{"Functions": {"getThreadState()": {"Returns": [["String", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "String getThreadState ()"}, "MonitoringInstrumentation()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "MonitoringInstrumentation ()"}, "callActivityOnDestroy(android.app.Activity)": {"Returns": [], "Parameters": [["Activity", "Activity no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void callActivityOnDestroy (Activity activity)"}, "waitForActivitiesToComplete()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ensures we've onStopped() all activities which were onStarted(). According to Activity's contract, the process is not killable between onStart and onStop. Breaking this contract (which finish() will if you let it) can cause bad behaviour (including a full restart of system_server). We give the app 2 seconds to stop all its activities, then we proceed.", "history": "", "FullName": "void waitForActivitiesToComplete ()"}, "callActivityOnStart(android.app.Activity)": {"Returns": [], "Parameters": [["Activity", "Activity no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void callActivityOnStart (Activity activity)"}, "onException(java.lang.Object, java.lang.Throwable)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["Object", "Object no parameter comment"], ["Throwable", "Throwable no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "boolean onException (Object obj, Throwable e)"}, "startActivitySync(android.content.Intent)": {"Returns": [["Activity", "no returns description in source"]], "Parameters": [["Intent", "Intent no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "Activity startActivitySync (Intent intent)"}, "callApplicationOnCreate(android.app.Application)": {"Returns": [], "Parameters": [["Application", "Application no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void callApplicationOnCreate (Application app)"}, "callActivityOnStop(android.app.Activity)": {"Returns": [], "Parameters": [["Activity", "Activity no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void callActivityOnStop (Activity activity)"}, "dumpThreadStateToOutputs(java.lang.String)": {"Returns": [], "Parameters": [["String", "String no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void dumpThreadStateToOutputs (String outputFileName)"}, "onStart()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This implementation of onStart() will guarantee that the Application's onCreate method has completed when it returns. Subclasses should call super.onStart() before executing any code that touches the application and it's state.", "history": "", "FullName": "void onStart ()"}, "onCreate(android.os.Bundle)": {"Returns": [], "Parameters": [["Bundle", "Bundle no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets up lifecycle monitoring, and argument registry. Subclasses must call up to onCreate(). This onCreate method does not call start() it is the subclasses responsibility to call start if it desires.", "history": "", "FullName": "void onCreate (Bundle arguments)"}, "callActivityOnRestart(android.app.Activity)": {"Returns": [], "Parameters": [["Activity", "Activity no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void callActivityOnRestart (Activity activity)"}, "callActivityOnResume(android.app.Activity)": {"Returns": [], "Parameters": [["Activity", "Activity no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void callActivityOnResume (Activity activity)"}, "specifyDexMakerCacheProperty()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void specifyDexMakerCacheProperty ()"}, "callActivityOnPause(android.app.Activity)": {"Returns": [], "Parameters": [["Activity", "Activity no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void callActivityOnPause (Activity activity)"}, "finish(int, android.os.Bundle)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["Bundle", "Bundle no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ensures all activities launched in this instrumentation are finished before the instrumentation exits. Subclasses who override this method should do their finish processing and then call super.finish to invoke this logic. Not waiting for all activities to finish() before exiting can cause device wide instability.", "history": "", "FullName": "void finish (int resultCode, Bundle results)"}, "onDestroy()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "void onDestroy ()"}}, "Inheritance": ["https:##developer#android#com@B_java#lang#Object_E@", "https:##developer#android#com@B_android#app#Instrumentation_E@", "android.support.test.internal.runner.hidden.ExposedInstrumentationApi"], "ClassName": "android.support.test.runner.MonitoringInstrumentation", "ClassDesc": "An instrumentation that enables several advanced features and makes some hard guarantees about the state of the application under instrumentation. A short list of these capabilities: Forces Application.onCreate() to happen before Instrumentation.onStart() runs (ensuring your code always runs in a sane state). Logs application death due to exceptions. Allows tracking of activity lifecycle states. Registers instrumentation arguments in an easy to access place. Ensures your activities are creating themselves in reasonable amounts of time. Provides facilities to dump current app threads to test outputs. Ensures all activities finish before instrumentation exits. This Instrumentation is *NOT* a test instrumentation (some of its subclasses are). It makes no assumptions about what the subclass wants to do."}