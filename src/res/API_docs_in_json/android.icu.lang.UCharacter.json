{"Functions": {"codePointAt(java.lang.CharSequence,int)": {"Returns": [["int", "the code point at the index"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the characters to check"], ["int", "int: the index of the first or only char forming the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointAt_E@. Returns the code point at index. This examines only the characters at index and index+1.", "history": "Added in API level 24", "FullName": "public static int codePointAt (CharSequence seq, int index)"}, "toUpperCase(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "uppercase version of the argument string"]], "Parameters": [["@B_java#lang#String_E@", "String: source string to be performed on"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the uppercase version of the argument string. Casing is dependent on the default locale and context-sensitive.", "history": "Added in API level 24", "FullName": "public static String toUpperCase (String str)"}, "getCharFromNameAlias(java.lang.String)": {"Returns": [["int", "code point or -1 if name is not found"]], "Parameters": [["@B_java#lang#String_E@", "String: Unicode name alias whose code point is to be returned"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find a Unicode character by its corrected name alias and return its code point value. All Unicode names are in uppercase. Note calling any methods related to code point names, e.g. get*Name*() incurs a one-time initialisation cost to construct the name tables.", "history": "Added in API level 24", "FullName": "public static int getCharFromNameAlias (String name)"}, "isHighSurrogate(char)": {"Returns": [["boolean", "true if ch is a high (lead) surrogate"]], "Parameters": [["char", "char: the char to check"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#isHighSurrogate_E@.", "history": "Added in API level 24", "FullName": "public static boolean isHighSurrogate (char ch)"}, "isUUppercase(int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int", "int: codepoint to be tested"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if a code point has the Uppercase Unicode property. Same as UCharacter.hasBinaryProperty(ch, UProperty.UPPERCASE). This is different from UCharacter.isUpperCase(ch)!", "history": "Added in API level 24", "FullName": "public static boolean isUUppercase (int ch)"}, "isDefined(int)": {"Returns": [["boolean", "true if this code point is defined in unicode"]], "Parameters": [["int", "int: code point to be determined if it is defined in the most current version of Unicode"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if a code point has a defined meaning in the up-to-date Unicode standard. E.g. supplementary code points though allocated space are not defined in Unicode yet. Up-to-date Unicode implementation of java.lang.Character.isDefined()", "history": "Added in API level 24", "FullName": "public static boolean isDefined (int ch)"}, "toUpperCase(java.util.Locale,java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "uppercase version of the argument string"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the uppercase version of the argument string. Casing is dependent on the argument locale and context-sensitive.", "history": "Added in API level 24", "FullName": "public static String toUpperCase (Locale locale, String str)"}, "getUnicodeVersion()": {"Returns": [["@B_android#icu#util#VersionInfo_E@", "the unicode version number used"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static VersionInfo getUnicodeVersion ()"}, "getNameIterator()": {"Returns": [["@B_android#icu#util#ValueIterator_E@", "an iterator"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns an iterator for character names, iterating over codepoints. This API only gets the iterator for the modern, most up-to-date Unicode names. For older 1.0 Unicode names use get1_0NameIterator() or for extended names use getExtendedNameIterator(). Example of use: The maximal range which the name iterator iterates is from UCharacter.MIN_VALUE to UCharacter.MAX_VALUE.", "history": "Added in API level 24", "FullName": "public static ValueIterator getNameIterator ()"}, "isLowerCase(int)": {"Returns": [["boolean", "true if code point is a lowercase character"]], "Parameters": [["int", "int: code point to determine if it is in lowercase"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point is a lowercase character. UnicodeData only contains case mappings for code points where they are one-to-one mappings; it also omits information about context-sensitive case mappings. For more information about Unicode case mapping please refer to the Up-to-date Unicode implementation of java.lang.Character.isLowerCase()", "history": "Added in API level 24", "FullName": "public static boolean isLowerCase (int ch)"}, "offsetByCodePoints(char[],int,int,int,int)": {"Returns": [["int", "the adjusted index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the start of the range to check"], ["int", "int: the length of the range to check"], ["int", "int: the index to adjust"], ["int", "int: the number of code points by which to offset the index"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to the @B_java#lang#Character#offsetByCodePoints_E@ method, for convenience. Adjusts the char index by a code point offset.", "history": "Added in API level 24", "FullName": "public static int offsetByCodePoints (char[] text, int start, int count, int index, int codePointOffset)"}, "hasBinaryProperty(int,int)": {"Returns": [["boolean", "true or false according to the binary Unicode property value for ch. Also false if property is out of bounds or if the Unicode version does not have data for the property at all, or not for this code point."]], "Parameters": [["int", "int: code point to test."], ["int", "int: selector constant from android.icu.lang.UProperty, identifies which binary property to check."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "_E@"], "Permissions": [], "Description": "Unicode, especially in version 3.2, defines many more properties than the original set in UnicodeData.txt. This API is intended to reflect Unicode properties as defined in the Unicode Character Database (UCD) and Unicode Technical Reports (UTR). For details about the properties see For names of Unicode properties see the UCD file PropertyAliases.txt. This API does not check the validity of the codepoint. Important: If ICU is built with UCD files from Unicode versions below 3.2, then properties marked with \"new\" are not or not fully available.", "history": "Added in API level 24", "FullName": "public static boolean hasBinaryProperty (int ch, int property)"}, "getDirection(int)": {"Returns": [["int", "direction constant from UCharacterDirection."]], "Parameters": [["int", "int: the code point to be determined its direction"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Result returned belongs to the interface", "history": "Added in API level 24", "FullName": "public static int getDirection (int ch)"}, "toString(int)": {"Returns": [["@B_java#lang#String_E@", "string representation of the code point, null if code point is not defined in unicode"]], "Parameters": [["int", "int: code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Converts argument code point and returns a String object representing the code point's value in UTF-16 format. The result is a string whose length is 1 for BMP code points, 2 for supplementary ones. Up-to-date Unicode implementation of java.lang.Character.toString().", "history": "Added in API level 24", "FullName": "public static String toString (int ch)"}, "getDirectionality(int)": {"Returns": [["byte", "the directionality of the code point"]], "Parameters": [["int", "int: the code point to check"]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter#getDirection_E@"], "Permissions": [], "Description": "Equivalent to the @B_java#lang#Character#getDirectionality_E@ method, for convenience. Returns a byte representing the directionality of the character. @B_java#lang#Character#getDirectionality_E@, this returns DIRECTIONALITY_LEFT_TO_RIGHT for undefined or out-of-bounds characters. @B_android#icu#lang#UCharacterDirection_E@ and its interface @B_android#icu#lang#UCharacterEnums#ECharacterDirection_E@ since the values are different from the ones defined by java.lang.Character.", "history": "Added in API level 24", "FullName": "public static byte getDirectionality (int cp)"}, "toChars(int, char[], int)": {"Returns": [["int", "the count of the number of chars written (1 or 2)"]], "Parameters": [["int", "int: the code point to convert"], ["char[]", "char: the destination array into which to put the char(s) representing the code point"], ["int", "int: the index at which to put the first (or only) char"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if cp is not a valid code point"]], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#toChars_E@. Writes the chars representing the code point into the destination at the given index.", "history": "added in API level 24", "FullName": "public static int toChars (int cp, char[] dst, int dstIndex)"}, "getCombiningClass(int)": {"Returns": [["int", "the combining class of the codepoint"]], "Parameters": [["int", "int: code point whose combining is to be retrieved"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static int getCombiningClass (int ch)"}, "forDigit(int, int)": {"Returns": [["char", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Provide the java.lang.Character forDigit API, for convenience.", "history": "added in API level 24", "FullName": "public static char forDigit (int digit, int radix)"}, "isSpaceChar(int)": {"Returns": [["boolean", "true if the specified code point is a space character"]], "Parameters": [["int", "int: code point to determine if it is a space"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point is a Unicode specified space character, i.e. if code point is in the category Zs, Zl and Zp. Up-to-date Unicode implementation of java.lang.Character.isSpaceChar().", "history": "Added in API level 24", "FullName": "public static boolean isSpaceChar (int ch)"}, "digit(int)": {"Returns": [["int", "the numeric value represented by the code point, or -1 if the code point is not a decimal digit or if its value is too large for a decimal radix"]], "Parameters": [["int", "int: the code point to query"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returnss the numeric value of a decimal digit code point. This is a convenience overload of digit(int, int) that provides a decimal radix. Semantic Change: In release 1.3.1 and prior, this treated numeric letters and other numbers as digits. This has been changed to conform to the java semantics.", "history": "Added in API level 24", "FullName": "public static int digit (int ch)"}, "toLowerCase(android.icu.util.ULocale,java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "lowercase version of the argument string"]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the lowercase version of the argument string. Casing is dependent on the argument locale and context-sensitive", "history": "Added in API level 24", "FullName": "public static String toLowerCase (ULocale locale, String str)"}, "digit(int,int)": {"Returns": [["int", "the numeric value represented by the code point in the specified radix, or -1 if the code point is not a decimal digit or if its value is too large for the radix"]], "Parameters": [["int", "int: the code point to query"], ["int", "int: the radix"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returnss the numeric value of a decimal digit code point. This method observes the semantics of java.lang.Character.digit(). Note that this will return positive values for code points for which isDigit returns false, just like java.lang.Character. Semantic Change: In release 1.3.1 and prior, this did not treat the European letters as having a digit value, and also treated numeric letters and other numbers as digits. This has been changed to conform to the java semantics. A code point is a valid digit if and only if: ch is a decimal digit or one of the european letters, and the value of ch is less than the specified radix.", "history": "Added in API level 24", "FullName": "public static int digit (int ch, int radix)"}, "getIntPropertyValue(int, int)": {"Returns": [["int", "numeric value that is directly the property value or, for enumerated properties, corresponds to the numeric value of the enumerated constant of the respective property value enumeration type (cast to enum type if necessary). Returns 0 or 1 (for false / true) for binary Unicode properties. Returns a bit-mask for mask properties. Returns 0 if 'type' is out of bounds or if the Unicode version does not have data for the property at all, or not for this code point."]], "Parameters": [["int", "int: code point to test."], ["int", "int: UProperty selector constant, identifies which binary property to check. Must be UProperty.BINARY_START <= type < UProperty.BINARY_LIMIT or UProperty.INT_START <= type < UProperty.INT_LIMIT or UProperty.MASK_START <= type < UProperty.MASK_LIMIT."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "@B_android#icu#lang#UCharacter#hasBinaryProperty_E@", "@B_android#icu#lang#UCharacter#getIntPropertyMinValue_E@", "@B_android#icu#lang#UCharacter#getIntPropertyMaxValue_E@", "@B_android#icu#lang#UCharacter#getUnicodeVersion_E@"], "Permissions": [], "Description": "Returns the property value for an Unicode property type of a code point. Also returns binary and mask property values. Unicode, especially in version 3.2, defines many more properties than the original set in UnicodeData.txt. The properties APIs are intended to reflect Unicode properties as defined in the Unicode Character Database (UCD) and Unicode Technical Reports (UTR). For details about the properties see http://www.unicode.org/. For names of Unicode properties see the UCD file PropertyAliases.txt.", "history": "added in API level 24", "FullName": "public static int getIntPropertyValue (int ch, int type)"}, "toTitleCase(android.icu.util.ULocale,java.lang.String,android.icu.text.BreakIterator)": {"Returns": [["@B_java#lang#String_E@", "titlecase version of the argument string"]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"], ["@B_android#icu#text#BreakIterator_E@", "BreakIterator: break iterator to determine the positions in which the character should be title cased."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the titlecase version of the argument string. Position for titlecasing is determined by the argument break iterator, hence the user can customize his break iterator for a specialized titlecasing. In this case only the forward iteration needs to be implemented. If the break iterator passed in is null, the default Unicode algorithm will be used to determine the titlecase positions. Only positions returned by the break iterator will be title cased, character in between the positions will all be in lower case. Casing is dependent on the argument locale and context-sensitive", "history": "Added in API level 24", "FullName": "public static String toTitleCase (ULocale locale, String str, BreakIterator titleIter)"}, "codePointCount(char[], int, int)": {"Returns": [["int", "the number of code points in the range"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the start of the range"], ["int", "int: the limit of the range"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to the @B_java#lang#Character#codePointCount_E@ method, for convenience. Counts the number of code points in the range of text.", "history": "added in API level 24", "FullName": "public static int codePointCount (char[] text, int start, int limit)"}, "getMirror(int)": {"Returns": [["int", "another code point that may serve as a mirror-image substitute, or ch itself if there is no such mapping or ch does not have the \"mirrored\" property"]], "Parameters": [["int", "int: code point whose mirror is to be retrieved"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is useful for text conversion to and from codepages with visual order, and for displays without glyph selection capabilities.", "history": "Added in API level 24", "FullName": "public static int getMirror (int ch)"}, "offsetByCodePoints(char[], int, int, int, int)": {"Returns": [["int", "the adjusted index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the start of the range to check"], ["int", "int: the length of the range to check"], ["int", "int: the index to adjust"], ["int", "int: the number of code points by which to offset the index"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to the @B_java#lang#Character#offsetByCodePoints_E@ method, for convenience. Adjusts the char index by a code point offset.", "history": "added in API level 24", "FullName": "public static int offsetByCodePoints (char[] text, int start, int count, int index, int codePointOffset)"}, "isJavaIdentifierPart(int)": {"Returns": [["boolean", "true if the code point can continue a java identifier."]], "Parameters": [["int", "int: the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compatibility override of Java method, delegates to java.lang.Character.isJavaIdentifierPart.", "history": "Added in API level 24", "FullName": "public static boolean isJavaIdentifierPart (int cp)"}, "toUpperCase(java.util.Locale, java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "uppercase version of the argument string"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the uppercase version of the argument string. Casing is dependent on the argument locale and context-sensitive.", "history": "added in API level 24", "FullName": "public static String toUpperCase (Locale locale, String str)"}, "isIdentifierIgnorable(int)": {"Returns": [["boolean", "true if the code point is ignorable"]], "Parameters": [["int", "int: code point to be determined if it can be ignored in a Unicode identifier."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point should be regarded as an ignorable character in a Java identifier. A character is Java-identifier-ignorable if it has the general category Cf Formatting Control, or it is a non-Java-whitespace ISO control: U+0000..U+0008, U+000E..U+001B, U+007F..U+009F. Up-to-date Unicode implementation of java.lang.Character.isIdentifierIgnorable(). See Note that Unicode just recommends to ignore Cf (format controls).", "history": "Added in API level 24", "FullName": "public static boolean isIdentifierIgnorable (int ch)"}, "isValidCodePoint(int)": {"Returns": [["boolean", "true if cp is a valid code point"]], "Parameters": [["int", "int: the code point to check"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to @B_java#lang#Character#isValidCodePoint_E@.", "history": "Added in API level 24", "FullName": "public static boolean isValidCodePoint (int cp)"}, "toUpperCase(int)": {"Returns": [["int", "uppercase code point"]], "Parameters": [["int", "int: code point whose uppercase is to be retrieved"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Converts the character argument to uppercase. If no uppercase is available, the character itself is returned. Up-to-date Unicode implementation of java.lang.Character.toUpperCase() This function only returns the simple, single-code point case mapping. Full case mappings should be used whenever possible because they produce better results by working on whole strings. They take into account the string context and the language and can map to a result string with a different length as appropriate. Full case mappings are applied by the case mapping functions that take String parameters rather than code points (int). See also the User Guide chapter on C/POSIX migration: http://www.icu-project.org/userguide/posix.html#case_mappings", "history": "Added in API level 24", "FullName": "public static int toUpperCase (int ch)"}, "isUpperCase(int)": {"Returns": [["boolean", "true if the code point is an uppercase character"]], "Parameters": [["int", "int: code point to determine if it is in uppercase"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point is an uppercase character. UnicodeData only contains case mappings for code point where they are one-to-one mappings; it also omits information about context-sensitive case mappings. For language specific case conversion behavior, use toUpperCase(locale, str). For example, the case conversion for dot-less i and dotted I in Turkish, or for final sigma in Greek. For more information about Unicode case mapping please refer to the Up-to-date Unicode implementation of java.lang.Character.isUpperCase().", "history": "Added in API level 24", "FullName": "public static boolean isUpperCase (int ch)"}, "foldCase(java.lang.String,boolean)": {"Returns": [["@B_java#lang#String_E@", "the case folding equivalent of the character, if any; otherwise the character itself."]], "Parameters": [["@B_java#lang#String_E@", "String: the String to be converted"], ["boolean", "boolean: Indicates whether the default mappings defined in CaseFolding.txt are to be used, otherwise the mappings for dotted I and dotless i marked with 'T' in CaseFolding.txt are included."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter#foldCase_E@"], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static String foldCase (String str, boolean defaultmapping)"}, "toTitleCase(android.icu.util.ULocale,java.lang.String,android.icu.text.BreakIterator,int)": {"Returns": [["@B_java#lang#String_E@", "titlecase version of the argument string"]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"], ["@B_android#icu#text#BreakIterator_E@", "BreakIterator: break iterator to determine the positions in which the character should be title cased."], ["int", "int: bit set to modify the titlecasing operation"]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter_E@"], "Permissions": [], "Description": "Returns the titlecase version of the argument string. Position for titlecasing is determined by the argument break iterator, hence the user can customize his break iterator for a specialized titlecasing. In this case only the forward iteration needs to be implemented. If the break iterator passed in is null, the default Unicode algorithm will be used to determine the titlecase positions. Only positions returned by the break iterator will be title cased, character in between the positions will all be in lower case. Casing is dependent on the argument locale and context-sensitive", "history": "Added in API level 24", "FullName": "public static String toTitleCase (ULocale locale, String str, BreakIterator titleIter, int options)"}, "codePointCount(char[],int,int)": {"Returns": [["int", "the number of code points in the range"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the start of the range"], ["int", "int: the limit of the range"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to the @B_java#lang#Character#codePointCount_E@ method, for convenience. Counts the number of code points in the range of text.", "history": "Added in API level 24", "FullName": "public static int codePointCount (char[] text, int start, int limit)"}, "getHanNumericValue(int)": {"Returns": [["int", "value if it is a Han 'numeric character,' otherwise return -1."]], "Parameters": [["int", "int: code point to query"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This returns the value of Han 'numeric' code points, including those for zero, ten, hundred, thousand, ten thousand, and hundred million. This includes both the standard and 'checkwriting' characters, the 'big circle' zero character, and the standard zero character. Note: The Unicode Standard has numeric values for more Han characters recognized by this method (see @B_android#icu#lang#UCharacter#getNumericValue_E@ and the UCD file DerivedNumericValues.txt), and a @B_android#icu#text#NumberFormat_E@ can be used with a Chinese @B_android#icu#text#NumberingSystem_E@.", "history": "Added in API level 24", "FullName": "public static int getHanNumericValue (int ch)"}, "isULowercase(int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int", "int: codepoint to be tested"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if a code point has the Lowercase Unicode property. Same as UCharacter.hasBinaryProperty(ch, UProperty.LOWERCASE). This is different from UCharacter.isLowerCase(ch)!", "history": "Added in API level 24", "FullName": "public static boolean isULowercase (int ch)"}, "toLowerCase(java.util.Locale,java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "lowercase version of the argument string"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the lowercase version of the argument string. Casing is dependent on the argument locale and context-sensitive", "history": "Added in API level 24", "FullName": "public static String toLowerCase (Locale locale, String str)"}, "isJavaIdentifierStart(int)": {"Returns": [["boolean", "true if the code point can start a java identifier."]], "Parameters": [["int", "int: the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compatibility override of Java method, delegates to java.lang.Character.isJavaIdentifierStart.", "history": "Added in API level 24", "FullName": "public static boolean isJavaIdentifierStart (int cp)"}, "getPropertyValueEnum(int, java.lang.CharSequence)": {"Returns": [["int", "a value integer. Note: UProperty.GENERAL_CATEGORY values are mask values produced by left-shifting 1 by UCharacter.getType(). This allows grouped categories such as [:L:] to be represented."]], "Parameters": [["int", "int: UProperty selector constant. UProperty.INT_START <= property < UProperty.INT_LIMIT or UProperty.BINARY_START <= property < UProperty.BINARY_LIMIT or UProperty.MASK_START < = property < UProperty.MASK_LIMIT. Only these properties can be enumerated."], ["@B_java#lang#CharSequence_E@", "CharSequence: the value name to be matched. The name is compared using \"loose matching\" as described in PropertyValueAliases.txt."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if property is not a valid UProperty selector or valueAlias is not a value of this property"]], "SeeAlso": ["@B_android#icu#lang#UProperty_E@"], "Permissions": [], "Description": "", "history": "added in API level 24", "FullName": "public static int getPropertyValueEnum (int property, CharSequence valueAlias)"}, "isSupplementary(int)": {"Returns": [["boolean", "true if code point is a supplementary character"]], "Parameters": [["int", "int: code point to be determined if it is in the supplementary plane"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static boolean isSupplementary (int ch)"}, "toCodePoint(char, char)": {"Returns": [["int", "the code point formed by the surrogate pair"]], "Parameters": [["char", "char: the high (lead) surrogate"], ["char", "char: the low (trail) surrogate"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#toCodePoint_E@. Returns the code point represented by the two surrogate code units. This does not check the surrogate pair for validity.", "history": "added in API level 24", "FullName": "public static int toCodePoint (char high, char low)"}, "getUnicodeNumericValue(int)": {"Returns": [["double", "numeric value of ch, or NO_NUMERIC_VALUE if none is defined."]], "Parameters": [["int", "int: Code point to get the numeric value for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "A \"double\" return type is necessary because some numeric values are fractions, negative, or too large for int. For characters without any numeric values in the Unicode Character Database, this function will return NO_NUMERIC_VALUE. Note: This is different from the Unicode Standard which specifies NaN as the default value. API Change: In release 2.2 and prior, this API has a return type int and returns -1 when the argument ch does not have a corresponding numeric value. This has been changed to synch with ICU4C This corresponds to the ICU4C function u_getNumericValue.", "history": "Added in API level 24", "FullName": "public static double getUnicodeNumericValue (int ch)"}, "toTitleCase(java.lang.String,android.icu.text.BreakIterator)": {"Returns": [["@B_java#lang#String_E@", "titlecase version of the argument string"]], "Parameters": [["@B_java#lang#String_E@", "String: source string to be performed on"], ["@B_android#icu#text#BreakIterator_E@", "BreakIterator: break iterator to determine the positions in which the character should be title cased."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the titlecase version of the argument string. Position for titlecasing is determined by the argument break iterator, hence the user can customize his break iterator for a specialized titlecasing. In this case only the forward iteration needs to be implemented. If the break iterator passed in is null, the default Unicode algorithm will be used to determine the titlecase positions. Only positions returned by the break iterator will be title cased, character in between the positions will all be in lower case. Casing is dependent on the default locale and context-sensitive", "history": "Added in API level 24", "FullName": "public static String toTitleCase (String str, BreakIterator breakiter)"}, "foldCase(int, boolean)": {"Returns": [["int", "the case folding equivalent of the character, if any; otherwise the character itself."]], "Parameters": [["int", "int: the character to be converted"], ["boolean", "boolean: Indicates whether the default mappings defined in CaseFolding.txt are to be used, otherwise the mappings for dotted I and dotless i marked with 'T' in CaseFolding.txt are included."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter#foldCase_E@"], "Permissions": [], "Description": "This function only returns the simple, single-code point case mapping. Full case mappings should be used whenever possible because they produce better results by working on whole strings. They can map to a result string with a different length as appropriate. Full case mappings are applied by the case mapping functions that take String parameters rather than code points (int). See also the User Guide chapter on C/POSIX migration: http://www.icu-project.org/userguide/posix.html#case_mappings", "history": "added in API level 24", "FullName": "public static int foldCase (int ch, boolean defaultmapping)"}, "getCodePoint(char, char)": {"Returns": [["int", "code point if surrogate characters are valid."]], "Parameters": [["char", "char: the lead char"], ["char", "char: the trail char"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown when the code units do not form a valid code point"]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 24", "FullName": "public static int getCodePoint (char lead, char trail)"}, "codePointAt(java.lang.CharSequence, int)": {"Returns": [["int", "the code point at the index"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the characters to check"], ["int", "int: the index of the first or only char forming the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointAt_E@. Returns the code point at index. This examines only the characters at index and index+1.", "history": "added in API level 24", "FullName": "public static int codePointAt (CharSequence seq, int index)"}, "isLetter(int)": {"Returns": [["boolean", "true if code point is a letter"]], "Parameters": [["int", "int: code point to determine if it is a letter"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point is a letter. Up-to-date Unicode implementation of java.lang.Character.isLetter()", "history": "Added in API level 24", "FullName": "public static boolean isLetter (int ch)"}, "toUpperCase(android.icu.util.ULocale,java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "uppercase version of the argument string"]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the uppercase version of the argument string. Casing is dependent on the argument locale and context-sensitive.", "history": "Added in API level 24", "FullName": "public static String toUpperCase (ULocale locale, String str)"}, "codePointBefore(char[],int,int)": {"Returns": [["int", "the code point before the index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the index after the last or only char forming the code point"], ["int", "int: the start of the valid text"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointBefore_E@. Return the code point before index. This examines only the characters at index-1 and index-2.", "history": "Added in API level 24", "FullName": "public static int codePointBefore (char[] text, int index, int limit)"}, "getPropertyValueName(int, int, int)": {"Returns": [["@B_java#lang#String_E@", "a name, or null if Unicode explicitly defines no name (\"n/a\") for a given property/value/nameChoice. If a given nameChoice throws an exception, then all larger values of nameChoice will throw an exception. If null is returned for a given nameChoice, then other nameChoice values may return non-null results."]], "Parameters": [["int", "int: UProperty selector constant. UProperty.INT_START <= property < UProperty.INT_LIMIT or UProperty.BINARY_START <= property < UProperty.BINARY_LIMIT or UProperty.MASK_START < = property < UProperty.MASK_LIMIT. If out of range, null is returned."], ["int", "int: selector for a value for the given property. In general, valid values range from 0 up to some maximum. There are a few exceptions: (1.) UProperty.BLOCK values begin at the non-zero value BASIC_LATIN.getID(). (2.) UProperty.CANONICAL_COMBINING_CLASS values are not contiguous and range from 0..240. (3.) UProperty.GENERAL_CATEGORY_MASK values are mask values produced by left-shifting 1 by UCharacter.getType(). This allows grouped categories such as [:L:] to be represented. Mask values are non-contiguous."], ["int", "int: UProperty.NameChoice selector for which name to get. All values have a long name. Most have a short name, but some do not. Unicode allows for additional names; if present these will be returned by UProperty.NameChoice.LONG + i, where i=1, 2,..."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown if property, value, or nameChoice are invalid."]], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "@B_android#icu#lang#UProperty#NameChoice_E@"], "Permissions": [], "Description": "", "history": "added in API level 24", "FullName": "public static String getPropertyValueName (int property, int value, int nameChoice)"}, "isUWhiteSpace(int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int", "int: codepoint to be tested"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if a code point has the White_Space Unicode property. Same as UCharacter.hasBinaryProperty(ch, UProperty.WHITE_SPACE). This is different from both UCharacter.isSpace(ch) and UCharacter.isWhitespace(ch)!", "history": "Added in API level 24", "FullName": "public static boolean isUWhiteSpace (int ch)"}, "isLegal(java.lang.String)": {"Returns": [["boolean", "true if and only if legal."]], "Parameters": [["@B_java#lang#String_E@", "String: containing code points to examin"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Out of bounds, less than 0 or greater than UCharacter.MAX_VALUE A surrogate value, 0xD800 to 0xDFFF Not-a-character, having the form 0x xxFFFF or 0x xxFFFE Note: legal does not mean that it is assigned in this version of Unicode.", "history": "Added in API level 24", "FullName": "public static boolean isLegal (String str)"}, "isWhitespace(int)": {"Returns": [["boolean", "true if the specified code point is a white space character"]], "Parameters": [["int", "int: code point to determine if it is a white space"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point is a white space character. A code point is considered to be an whitespace character if and only if it satisfies one of the following criteria: It is a Unicode Separator character (categories \"Z\" = \"Zs\" or \"Zl\" or \"Zp\"), but is not also a non-breaking space (\\u00A0 or \\u2007 or \\u202F). It is \\u0009, HORIZONTAL TABULATION. It is \\u000A, LINE FEED. It is \\u000B, VERTICAL TABULATION. It is \\u000C, FORM FEED. It is \\u000D, CARRIAGE RETURN. It is \\u001C, FILE SEPARATOR. It is \\u001D, GROUP SEPARATOR. It is \\u001E, RECORD SEPARATOR. It is \\u001F, UNIT SEPARATOR. This API tries to sync with the semantics of Java's java.lang.Character.isWhitespace(), but it may not return the exact same results because of the Unicode version difference. Note: Unicode 4.0.1 changed U+200B ZERO WIDTH SPACE from a Space Separator (Zs) to a Format Control (Cf). Since then, isWhitespace(0x200b) returns false. See http://www.unicode.org/versions/Unicode4.0.1/", "history": "Added in API level 24", "FullName": "public static boolean isWhitespace (int ch)"}, "toCodePoint(char,char)": {"Returns": [["int", "the code point formed by the surrogate pair"]], "Parameters": [["char", "char: the high (lead) surrogate"], ["char", "char: the low (trail) surrogate"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#toCodePoint_E@. Returns the code point represented by the two surrogate code units. This does not check the surrogate pair for validity.", "history": "Added in API level 24", "FullName": "public static int toCodePoint (char high, char low)"}, "getPropertyName(int, int)": {"Returns": [["@B_java#lang#String_E@", "a name, or null if Unicode explicitly defines no name (\"n/a\") for a given property/nameChoice. If a given nameChoice throws an exception, then all larger values of nameChoice will throw an exception. If null is returned for a given nameChoice, then other nameChoice values may return non-null results."]], "Parameters": [["int", "int: UProperty selector."], ["int", "int: UProperty.NameChoice selector for which name to get. All properties have a long name. Most have a short name, but some do not. Unicode allows for additional names; if present these will be returned by UProperty.NameChoice.LONG + i, where i=1, 2,..."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown if property or nameChoice are invalid."]], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "@B_android#icu#lang#UProperty#NameChoice_E@"], "Permissions": [], "Description": "", "history": "added in API level 24", "FullName": "public static String getPropertyName (int property, int nameChoice)"}, "isMirrored(int)": {"Returns": [["boolean", "true if the code point has the \"mirrored\" property"]], "Parameters": [["int", "int: code point whose mirror is to be determined"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines whether the code point has the \"mirrored\" property. This property is set for characters that are commonly used in Right-To-Left contexts and need to be displayed with a \"mirrored\" glyph.", "history": "Added in API level 24", "FullName": "public static boolean isMirrored (int ch)"}, "foldCase(int,boolean)": {"Returns": [["int", "the case folding equivalent of the character, if any; otherwise the character itself."]], "Parameters": [["int", "int: the character to be converted"], ["boolean", "boolean: Indicates whether the default mappings defined in CaseFolding.txt are to be used, otherwise the mappings for dotted I and dotless i marked with 'T' in CaseFolding.txt are included."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter#foldCase_E@"], "Permissions": [], "Description": "This function only returns the simple, single-code point case mapping. Full case mappings should be used whenever possible because they produce better results by working on whole strings. They can map to a result string with a different length as appropriate. Full case mappings are applied by the case mapping functions that take String parameters rather than code points (int). See also the User Guide chapter on C/POSIX migration: http://www.icu-project.org/userguide/posix.html#case_mappings", "history": "Added in API level 24", "FullName": "public static int foldCase (int ch, boolean defaultmapping)"}, "isDigit(int)": {"Returns": [["boolean", "true if this code point is a digit"]], "Parameters": [["int", "int: code point to query"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if a code point is a Java digit. This method observes the semantics of java.lang.Character.isDigit(). It returns true for decimal digits only. Semantic Change: In release 1.3.1 and prior, this treated numeric letters and other numbers as digits. This has been changed to conform to the java semantics.", "history": "Added in API level 24", "FullName": "public static boolean isDigit (int ch)"}, "isLetterOrDigit(int)": {"Returns": [["boolean", "true if code point is a letter or a digit"]], "Parameters": [["int", "int: code point to determine if it is a letter or a digit"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point is a letter or digit.", "history": "Added in API level 24", "FullName": "public static boolean isLetterOrDigit (int ch)"}, "getExtendedName(int)": {"Returns": [["@B_java#lang#String_E@", "a name for the argument codepoint"]], "Parameters": [["int", "int: the code point for which to get the name"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The names are returned in the following order. Most current Unicode name if there is any Unicode 1.0 name if there is any Extended name in the form of \"<codepoint_type-codepoint_hex_digits>\". E.g., <noncharacter-fffe> Note calling any methods related to code point names, e.g. get*Name*() incurs a one-time initialisation cost to construct the name tables.", "history": "Added in API level 24", "FullName": "public static String getExtendedName (int ch)"}, "codePointAt(char[],int)": {"Returns": [["int", "the code point at the index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the index of the first or only char forming the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointAt_E@. Returns the code point at index. This examines only the characters at index and index+1.", "history": "Added in API level 24", "FullName": "public static int codePointAt (char[] text, int index)"}, "codePointAt(char[], int)": {"Returns": [["int", "the code point at the index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the index of the first or only char forming the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointAt_E@. Returns the code point at index. This examines only the characters at index and index+1.", "history": "added in API level 24", "FullName": "public static int codePointAt (char[] text, int index)"}, "getBidiPairedBracket(int)": {"Returns": [["int", "the paired bracket code point, or c itself if there is no such mapping (Bidi_Paired_Bracket_Type=None)"]], "Parameters": [["int", "int: the code point to be mapped"]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "@B_android#icu#lang#UCharacter#getMirror_E@"], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static int getBidiPairedBracket (int c)"}, "getIntPropertyMinValue(int)": {"Returns": [["int", "Minimum value returned by UCharacter.getIntPropertyValue(int) for a Unicode property. 0 if the property selector 'type' is out of range."]], "Parameters": [["int", "int: UProperty selector constant, identifies which binary property to check. Must be UProperty.BINARY_START <= type < UProperty.BINARY_LIMIT or UProperty.INT_START <= type < UProperty.INT_LIMIT."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "@B_android#icu#lang#UCharacter#hasBinaryProperty_E@", "@B_android#icu#lang#UCharacter#getUnicodeVersion_E@", "@B_android#icu#lang#UCharacter#getIntPropertyMaxValue_E@", "@B_android#icu#lang#UCharacter#getIntPropertyValue_E@"], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static int getIntPropertyMinValue (int type)"}, "isBaseForm(int)": {"Returns": [["boolean", "true if the code point is of base form"]], "Parameters": [["int", "int: code point to be determined if it is of base form"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static boolean isBaseForm (int ch)"}, "getExtendedNameIterator()": {"Returns": [["@B_android#icu#util#ValueIterator_E@", "an iterator"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns an iterator for character names, iterating over codepoints. This API only gets the iterator for the extended names. For modern, most up-to-date Unicode names use getNameIterator() or for older 1.0 Unicode names use get1_0NameIterator(). Example of use: The maximal range which the name iterator iterates is from", "history": "Added in API level 24", "FullName": "public static ValueIterator getExtendedNameIterator ()"}, "getName(java.lang.String, java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "string of names"]], "Parameters": [["@B_java#lang#String_E@", "String: string to format"], ["@B_java#lang#String_E@", "String: string to go between names"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 24", "FullName": "public static String getName (String s, String separator)"}, "isPrintable(int)": {"Returns": [["boolean", "true if the code point is a printable character"]], "Parameters": [["int", "int: code point to be determined if it is printable"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static boolean isPrintable (int ch)"}, "isISOControl(int)": {"Returns": [["boolean", "true if code point is a ISO control character"]], "Parameters": [["int", "int: code point to determine if it is an ISO control character"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point is an ISO control character. A code point is considered to be an ISO control character if it is in the range \\u0000 through \\u001F or in the range \\u007F through \\u009F. Up-to-date Unicode implementation of java.lang.Character.isISOControl()", "history": "Added in API level 24", "FullName": "public static boolean isISOControl (int ch)"}, "getNameAlias(int)": {"Returns": [["@B_java#lang#String_E@", "Unicode name alias, or null"]], "Parameters": [["int", "int: the code point for which to get the name alias"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Note calling any methods related to code point names, e.g. get*Name*() incurs a one-time initialisation cost to construct the name tables.", "history": "Added in API level 24", "FullName": "public static String getNameAlias (int ch)"}, "isBMP(int)": {"Returns": [["boolean", "true if code point is not a supplementary character"]], "Parameters": [["int", "int: code point to be determined if it is not a supplementary character"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static boolean isBMP (int ch)"}, "isSurrogatePair(char, char)": {"Returns": [["boolean", "true if high, low form a surrogate pair"]], "Parameters": [["char", "char: the high (lead) char"], ["char", "char: the low (trail) char"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#isSurrogatePair_E@.", "history": "added in API level 24", "FullName": "public static boolean isSurrogatePair (char high, char low)"}, "getPropertyValueName(int,int,int)": {"Returns": [["@B_java#lang#String_E@", "a name, or null if Unicode explicitly defines no name (\"n/a\") for a given property/value/nameChoice. If a given nameChoice throws an exception, then all larger values of nameChoice will throw an exception. If null is returned for a given nameChoice, then other nameChoice values may return non-null results."]], "Parameters": [["int", "int: UProperty selector constant. UProperty.INT_START <= property < UProperty.INT_LIMIT or UProperty.BINARY_START <= property < UProperty.BINARY_LIMIT or UProperty.MASK_START < = property < UProperty.MASK_LIMIT. If out of range, null is returned."], ["int", "int: selector for a value for the given property. In general, valid values range from 0 up to some maximum. There are a few exceptions: (1.) UProperty.BLOCK values begin at the non-zero value BASIC_LATIN.getID(). (2.) UProperty.CANONICAL_COMBINING_CLASS values are not contiguous and range from 0..240. (3.) UProperty.GENERAL_CATEGORY_MASK values are mask values produced by left-shifting 1 by UCharacter.getType(). This allows grouped categories such as [:L:] to be represented. Mask values are non-contiguous."], ["int", "int: UProperty.NameChoice selector for which name to get. All values have a long name. Most have a short name, but some do not. Unicode allows for additional names; if present these will be returned by UProperty.NameChoice.LONG + i, where i=1, 2,..."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown if property, value, or nameChoice are invalid."]], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "@B_android#icu#lang#UProperty#NameChoice_E@"], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static String getPropertyValueName (int property, int value, int nameChoice)"}, "isSupplementaryCodePoint(int)": {"Returns": [["boolean", "true if cp is a supplementary code point"]], "Parameters": [["int", "int: the code point to check"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#isSupplementaryCodePoint_E@.", "history": "Added in API level 24", "FullName": "public static boolean isSupplementaryCodePoint (int cp)"}, "codePointBefore(java.lang.CharSequence, int)": {"Returns": [["int", "the code point before the index"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the characters to check"], ["int", "int: the index after the last or only char forming the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointBefore_E@. Return the code point before index. This examines only the characters at index-1 and index-2.", "history": "added in API level 24", "FullName": "public static int codePointBefore (CharSequence seq, int index)"}, "toLowerCase(java.util.Locale, java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "lowercase version of the argument string"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the lowercase version of the argument string. Casing is dependent on the argument locale and context-sensitive", "history": "added in API level 24", "FullName": "public static String toLowerCase (Locale locale, String str)"}, "foldCase(java.lang.String, int)": {"Returns": [["@B_java#lang#String_E@", "the case folding equivalent of the character, if any; otherwise the character itself."]], "Parameters": [["@B_java#lang#String_E@", "String: the String to be converted"], ["int", "int: A bit set for special processing. Currently the recognised options are FOLD_CASE_EXCLUDE_SPECIAL_I and FOLD_CASE_DEFAULT"]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter#foldCase_E@"], "Permissions": [], "Description": "", "history": "added in API level 24", "FullName": "public static String foldCase (String str, int options)"}, "codePointBefore(char[], int, int)": {"Returns": [["int", "the code point before the index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the index after the last or only char forming the code point"], ["int", "int: the start of the valid text"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointBefore_E@. Return the code point before index. This examines only the characters at index-1 and index-2.", "history": "added in API level 24", "FullName": "public static int codePointBefore (char[] text, int index, int limit)"}, "toLowerCase(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "lowercase version of the argument string"]], "Parameters": [["@B_java#lang#String_E@", "String: source string to be performed on"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the lowercase version of the argument string. Casing is dependent on the default locale and context-sensitive", "history": "Added in API level 24", "FullName": "public static String toLowerCase (String str)"}, "getIntPropertyValue(int,int)": {"Returns": [["int", "numeric value that is directly the property value or, for enumerated properties, corresponds to the numeric value of the enumerated constant of the respective property value type (@B_android#icu#lang#UCharacterEnums#ECharacterCategory_E@, @B_android#icu#lang#UCharacterEnums#ECharacterDirection_E@, @B_android#icu#lang#UCharacter#DecompositionType_E@, etc.). Returns 0 or 1 (for false / true) for binary Unicode properties. Returns a bit-mask for mask properties. Returns 0 if 'type' is out of bounds or if the Unicode version does not have data for the property at all, or not for this code point."]], "Parameters": [["int", "int: code point to test."], ["int", "int: UProperty selector constant, identifies which binary property to check. Must be UProperty.BINARY_START <= type < UProperty.BINARY_LIMIT or UProperty.INT_START <= type < UProperty.INT_LIMIT or UProperty.MASK_START <= type < UProperty.MASK_LIMIT."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "@B_android#icu#lang#UCharacter#hasBinaryProperty_E@", "@B_android#icu#lang#UCharacter#getIntPropertyMinValue_E@", "@B_android#icu#lang#UCharacter#getIntPropertyMaxValue_E@", "_E@", "@B_android#icu#lang#UCharacter#getUnicodeVersion_E@"], "Permissions": [], "Description": "Unicode, especially in version 3.2, defines many more properties than the original set in UnicodeData.txt. The properties APIs are intended to reflect Unicode properties as defined in the Unicode Character Database (UCD) and Unicode Technical Reports (UTR). For details about the properties see http://www.unicode.org/. For names of Unicode properties see the UCD file PropertyAliases.txt.", "history": "Added in API level 24", "FullName": "public static int getIntPropertyValue (int ch, int type)"}, "getAge(int)": {"Returns": [["@B_android#icu#util#VersionInfo_E@", "the Unicode version number"]], "Parameters": [["int", "int: The code point."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The \"age\" is the Unicode version when the code point was first designated (as a non-character or for Private Use) or assigned a character. This can be useful to avoid emitting code points to receiving processes that do not accept newer characters. The data is from the UCD file DerivedAge.txt.", "history": "Added in API level 24", "FullName": "public static VersionInfo getAge (int ch)"}, "getPropertyValueEnum(int,java.lang.CharSequence)": {"Returns": [["int", "a value integer. Note: UProperty.GENERAL_CATEGORY values are mask values produced by left-shifting 1 by UCharacter.getType(). This allows grouped categories such as [:L:] to be represented."]], "Parameters": [["int", "int: UProperty selector constant. UProperty.INT_START <= property < UProperty.INT_LIMIT or UProperty.BINARY_START <= property < UProperty.BINARY_LIMIT or UProperty.MASK_START < = property < UProperty.MASK_LIMIT. Only these properties can be enumerated."], ["@B_java#lang#CharSequence_E@", "CharSequence: the value name to be matched. The name is compared using \"loose matching\" as described in PropertyValueAliases.txt."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if property is not a valid UProperty selector or valueAlias is not a value of this property"]], "SeeAlso": ["@B_android#icu#lang#UProperty_E@"], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static int getPropertyValueEnum (int property, CharSequence valueAlias)"}, "codePointAt(char[], int, int)": {"Returns": [["int", "the code point at the index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the index of the first or only char forming the code point"], ["int", "int: the limit of the valid text"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointAt_E@. Returns the code point at index. This examines only the characters at index and index+1.", "history": "added in API level 24", "FullName": "public static int codePointAt (char[] text, int index, int limit)"}, "codePointBefore(char[],int)": {"Returns": [["int", "the code point before the index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the index after the last or only char forming the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointBefore_E@. Returns the code point before index. This examines only the characters at index-1 and index-2.", "history": "Added in API level 24", "FullName": "public static int codePointBefore (char[] text, int index)"}, "forDigit(int,int)": {"Returns": [["char", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Provide the java.lang.Character forDigit API, for convenience.", "history": "Added in API level 24", "FullName": "public static char forDigit (int digit, int radix)"}, "getCharFromExtendedName(java.lang.String)": {"Returns": [["int", "code point associated with the name or -1 if the name is not found."]], "Parameters": [["@B_java#lang#String_E@", "String: codepoint name"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find a Unicode character by either its name and return its code point value. All Unicode names are in uppercase. Extended names are all lowercase except for numbers and are contained within angle brackets. The names are searched in the following order Most current Unicode name if there is any Unicode 1.0 name if there is any Extended name in the form of \"<codepoint_type-codepoint_hex_digits>\". E.g. <noncharacter-FFFE> Note calling any methods related to code point names, e.g. get*Name*() incurs a one-time initialisation cost to construct the name tables.", "history": "Added in API level 24", "FullName": "public static int getCharFromExtendedName (String name)"}, "codePointBefore(char[], int)": {"Returns": [["int", "the code point before the index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the index after the last or only char forming the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointBefore_E@. Returns the code point before index. This examines only the characters at index-1 and index-2.", "history": "added in API level 24", "FullName": "public static int codePointBefore (char[] text, int index)"}, "getNumericValue(int)": {"Returns": [["int", "the numeric value of the code point, or -1 if it has no numeric value, or -2 if it has a numeric value that cannot be represented as a nonnegative integer"]], "Parameters": [["int", "int: the code point to query"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the numeric value of the code point as a nonnegative integer. If the code point does not have a numeric value, then -1 is returned. If the code point has a numeric value that cannot be represented as a nonnegative integer (for example, a fractional value), then -2 is returned.", "history": "Added in API level 24", "FullName": "public static int getNumericValue (int ch)"}, "getIntPropertyMaxValue(int)": {"Returns": [["int", "Maximum value returned by u_getIntPropertyValue for a Unicode property. <= 0 if the property selector 'type' is out of range."]], "Parameters": [["int", "int: UProperty selector constant, identifies which binary property to check. Must be UProperty.BINARY_START <= type < UProperty.BINARY_LIMIT or UProperty.INT_START <= type < UProperty.INT_LIMIT."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "@B_android#icu#lang#UCharacter#hasBinaryProperty_E@", "@B_android#icu#lang#UCharacter#getUnicodeVersion_E@", "@B_android#icu#lang#UCharacter#getIntPropertyMaxValue_E@", "@B_android#icu#lang#UCharacter#getIntPropertyValue_E@"], "Permissions": [], "Description": "UProperty.BIDI_CLASS: 0/18 (UCharacterDirection.LEFT_TO_RIGHT/UCharacterDirection.BOUNDARY_NEUTRAL) UProperty.SCRIPT: 0/45 (UScript.COMMON/UScript.TAGBANWA) UProperty.IDEOGRAPHIC: 0/1 (false/true) For undefined UProperty constant values, min/max values will be 0/-1.", "history": "Added in API level 24", "FullName": "public static int getIntPropertyMaxValue (int type)"}, "getType(int)": {"Returns": [["int", "category which is a value of UCharacterCategory"]], "Parameters": [["int", "int: code point whose type is to be determined"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a value indicating a code point's Unicode category. Up-to-date Unicode implementation of java.lang.Character.getType() except for the above mentioned code points that had their category changed. Return results are constants from the interface NOTE: the UCharacterCategory values are not compatible with those returned by java.lang.Character.getType. UCharacterCategory values match the ones used in ICU4C, while java.lang.Character type values, though similar, skip the value 17.", "history": "Added in API level 24", "FullName": "public static int getType (int ch)"}, "codePointCount(java.lang.CharSequence, int, int)": {"Returns": [["int", "the number of code points in the range"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the characters to check"], ["int", "int: the start of the range"], ["int", "int: the limit of the range"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to the @B_java#lang#Character#codePointCount_E@ method, for convenience. Counts the number of code points in the range of text.", "history": "added in API level 24", "FullName": "public static int codePointCount (CharSequence text, int start, int limit)"}, "foldCase(int, int)": {"Returns": [["int", "the case folding equivalent of the character, if any; otherwise the character itself."]], "Parameters": [["int", "int: the character to be converted"], ["int", "int: A bit set for special processing. Currently the recognised options are FOLD_CASE_EXCLUDE_SPECIAL_I and FOLD_CASE_DEFAULT"]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter#foldCase_E@"], "Permissions": [], "Description": "This function only returns the simple, single-code point case mapping. Full case mappings should be used whenever possible because they produce better results by working on whole strings. They can map to a result string with a different length as appropriate. Full case mappings are applied by the case mapping functions that take String parameters rather than code points (int). See also the User Guide chapter on C/POSIX migration: http://www.icu-project.org/userguide/posix.html#case_mappings", "history": "added in API level 24", "FullName": "public static int foldCase (int ch, int options)"}, "getPropertyName(int,int)": {"Returns": [["@B_java#lang#String_E@", "a name, or null if Unicode explicitly defines no name (\"n/a\") for a given property/nameChoice. If a given nameChoice throws an exception, then all larger values of nameChoice will throw an exception. If null is returned for a given nameChoice, then other nameChoice values may return non-null results."]], "Parameters": [["int", "int: UProperty selector."], ["int", "int: UProperty.NameChoice selector for which name to get. All properties have a long name. Most have a short name, but some do not. Unicode allows for additional names; if present these will be returned by UProperty.NameChoice.LONG + i, where i=1, 2,..."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown if property or nameChoice are invalid."]], "SeeAlso": ["@B_android#icu#lang#UProperty_E@", "@B_android#icu#lang#UProperty#NameChoice_E@"], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static String getPropertyName (int property, int nameChoice)"}, "isUAlphabetic(int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int", "int: codepoint to be tested"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if a code point has the Alphabetic Unicode property. Same as UCharacter.hasBinaryProperty(ch, UProperty.ALPHABETIC). Different from UCharacter.isLetter(ch)!", "history": "Added in API level 24", "FullName": "public static boolean isUAlphabetic (int ch)"}, "isLegal(int)": {"Returns": [["boolean", "true if and only if legal."]], "Parameters": [["int", "int: code point to determine if it is a legal code point by itself"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Out of bounds, less than 0 or greater than UCharacter.MAX_VALUE A surrogate value, 0xD800 to 0xDFFF Not-a-character, having the form 0x xxFFFF or 0x xxFFFE Note: legal does not mean that it is assigned in this version of Unicode.", "history": "Added in API level 24", "FullName": "public static boolean isLegal (int ch)"}, "getCodePoint(char)": {"Returns": [["int", "code point if argument is a valid character."]], "Parameters": [["char", "char: the BMP code point"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown when char16 is not a valid code point"]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static int getCodePoint (char char16)"}, "foldCase(java.lang.String,int)": {"Returns": [["@B_java#lang#String_E@", "the case folding equivalent of the character, if any; otherwise the character itself."]], "Parameters": [["@B_java#lang#String_E@", "String: the String to be converted"], ["int", "int: A bit set for special processing. Currently the recognised options are FOLD_CASE_EXCLUDE_SPECIAL_I and FOLD_CASE_DEFAULT"]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter#foldCase_E@"], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static String foldCase (String str, int options)"}, "codePointBefore(java.lang.CharSequence,int)": {"Returns": [["int", "the code point before the index"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the characters to check"], ["int", "int: the index after the last or only char forming the code point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointBefore_E@. Return the code point before index. This examines only the characters at index-1 and index-2.", "history": "Added in API level 24", "FullName": "public static int codePointBefore (CharSequence seq, int index)"}, "toLowerCase(int)": {"Returns": [["int", "the lowercase equivalent code point"]], "Parameters": [["int", "int: code point whose lowercase equivalent is to be retrieved"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The given code point is mapped to its lowercase equivalent; if the code point has no lowercase equivalent, the code point itself is returned. Up-to-date Unicode implementation of java.lang.Character.toLowerCase() This function only returns the simple, single-code point case mapping. Full case mappings should be used whenever possible because they produce better results by working on whole strings. They take into account the string context and the language and can map to a result string with a different length as appropriate. Full case mappings are applied by the case mapping functions that take String parameters rather than code points (int). See also the User Guide chapter on C/POSIX migration: http://www.icu-project.org/userguide/posix.html#case_mappings", "history": "Added in API level 24", "FullName": "public static int toLowerCase (int ch)"}, "hasBinaryProperty(int, int)": {"Returns": [["boolean", "true or false according to the binary Unicode property value for ch. Also false if property is out of bounds or if the Unicode version does not have data for the property at all, or not for this code point."]], "Parameters": [["int", "int: code point to test."], ["int", "int: selector constant from android.icu.lang.UProperty, identifies which binary property to check."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UProperty_E@"], "Permissions": [], "Description": "Check a binary Unicode property for a code point. Unicode, especially in version 3.2, defines many more properties than the original set in UnicodeData.txt. This API is intended to reflect Unicode properties as defined in the Unicode Character Database (UCD) and Unicode Technical Reports (UTR). For details about the properties see For names of Unicode properties see the UCD file PropertyAliases.txt. This API does not check the validity of the codepoint. Important: If ICU is built with UCD files from Unicode versions below 3.2, then properties marked with \"new\" are not or not fully available.", "history": "added in API level 24", "FullName": "public static boolean hasBinaryProperty (int ch, int property)"}, "getTypeIterator()": {"Returns": [["@B_android#icu#util#RangeValueIterator_E@", "an iterator"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns an iterator for character types, iterating over codepoints. Example of use:", "history": "Added in API level 24", "FullName": "public static RangeValueIterator getTypeIterator ()"}, "toChars(int,char[],int)": {"Returns": [["int", "the count of the number of chars written (1 or 2)"]], "Parameters": [["int", "int: the code point to convert"], ["char[]", "char: the destination array into which to put the char(s) representing the code point"], ["int", "int: the index at which to put the first (or only) char"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if cp is not a valid code point"]], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#toChars_E@. Writes the chars representing the code point into the destination at the given index.", "history": "Added in API level 24", "FullName": "public static int toChars (int cp, char[] dst, int dstIndex)"}, "toTitleCase(java.util.Locale,java.lang.String,android.icu.text.BreakIterator,int)": {"Returns": [["@B_java#lang#String_E@", "titlecase version of the argument string"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"], ["@B_android#icu#text#BreakIterator_E@", "BreakIterator: break iterator to determine the positions in which the character should be title cased."], ["int", "int: bit set to modify the titlecasing operation"]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter_E@"], "Permissions": [], "Description": "Returns the titlecase version of the argument string. Position for titlecasing is determined by the argument break iterator, hence the user can customize his break iterator for a specialized titlecasing. In this case only the forward iteration needs to be implemented. If the break iterator passed in is null, the default Unicode algorithm will be used to determine the titlecase positions. Only positions returned by the break iterator will be title cased, character in between the positions will all be in lower case. Casing is dependent on the argument locale and context-sensitive", "history": "Added in API level 24", "FullName": "public static String toTitleCase (Locale locale, String str, BreakIterator titleIter, int options)"}, "offsetByCodePoints(java.lang.CharSequence,int,int)": {"Returns": [["int", "the adjusted index"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the characters to check"], ["int", "int: the index to adjust"], ["int", "int: the number of code points by which to offset the index"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to the @B_java#lang#Character#offsetByCodePoints_E@ method, for convenience. Adjusts the char index by a code point offset.", "history": "Added in API level 24", "FullName": "public static int offsetByCodePoints (CharSequence text, int index, int codePointOffset)"}, "getPropertyEnum(java.lang.CharSequence)": {"Returns": [["int", "a UProperty enum."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the property name to be matched. The name is compared using \"loose matching\" as described in PropertyAliases.txt."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown if propertyAlias is not recognized."]], "SeeAlso": ["@B_android#icu#lang#UProperty_E@"], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static int getPropertyEnum (CharSequence propertyAlias)"}, "codePointAt(char[],int,int)": {"Returns": [["int", "the code point at the index"]], "Parameters": [["char[]", "char: the characters to check"], ["int", "int: the index of the first or only char forming the code point"], ["int", "int: the limit of the valid text"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#codePointAt_E@. Returns the code point at index. This examines only the characters at index and index+1.", "history": "Added in API level 24", "FullName": "public static int codePointAt (char[] text, int index, int limit)"}, "toTitleCase(int)": {"Returns": [["int", "titlecase code point"]], "Parameters": [["int", "int: code point whose title case is to be retrieved"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Converts the code point argument to titlecase. If no titlecase is available, the uppercase is returned. If no uppercase is available, the code point itself is returned. Up-to-date Unicode implementation of java.lang.Character.toTitleCase() This function only returns the simple, single-code point case mapping. Full case mappings should be used whenever possible because they produce better results by working on whole strings. They take into account the string context and the language and can map to a result string with a different length as appropriate. Full case mappings are applied by the case mapping functions that take String parameters rather than code points (int). See also the User Guide chapter on C/POSIX migration: http://www.icu-project.org/userguide/posix.html#case_mappings", "history": "Added in API level 24", "FullName": "public static int toTitleCase (int ch)"}, "toTitleCase(java.util.Locale,java.lang.String,android.icu.text.BreakIterator)": {"Returns": [["@B_java#lang#String_E@", "titlecase version of the argument string"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: which string is to be converted in"], ["@B_java#lang#String_E@", "String: source string to be performed on"], ["@B_android#icu#text#BreakIterator_E@", "BreakIterator: break iterator to determine the positions in which the character should be title cased."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the titlecase version of the argument string. Position for titlecasing is determined by the argument break iterator, hence the user can customize his break iterator for a specialized titlecasing. In this case only the forward iteration needs to be implemented. If the break iterator passed in is null, the default Unicode algorithm will be used to determine the titlecase positions. Only positions returned by the break iterator will be title cased, character in between the positions will all be in lower case. Casing is dependent on the argument locale and context-sensitive", "history": "Added in API level 24", "FullName": "public static String toTitleCase (Locale locale, String str, BreakIterator breakiter)"}, "isTitleCase(int)": {"Returns": [["boolean", "true if the specified code point is a titlecase character"]], "Parameters": [["int", "int: code point to determine if it is in title case"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point is a titlecase character. UnicodeData only contains case mappings for code points where they are one-to-one mappings; it also omits information about context-sensitive case mappings. For more information about Unicode case mapping please refer to the Up-to-date Unicode implementation of java.lang.Character.isTitleCase().", "history": "Added in API level 24", "FullName": "public static boolean isTitleCase (int ch)"}, "toChars(int)": {"Returns": [["char[]", "an array containing the char(s) representing the code point"]], "Parameters": [["int", "int: the code point to convert"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if cp is not a valid code point"]], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#toChars_E@. Returns a char array representing the code point.", "history": "Added in API level 24", "FullName": "public static char[] toChars (int cp)"}, "isLowSurrogate(char)": {"Returns": [["boolean", "true if ch is a low (trail) surrogate"]], "Parameters": [["char", "char: the char to check"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#isLowSurrogate_E@.", "history": "Added in API level 24", "FullName": "public static boolean isLowSurrogate (char ch)"}, "getCodePoint(char,char)": {"Returns": [["int", "code point if surrogate characters are valid."]], "Parameters": [["char", "char: the lead char"], ["char", "char: the trail char"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown when the code units do not form a valid code point"]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static int getCodePoint (char lead, char trail)"}, "isUnicodeIdentifierPart(int)": {"Returns": [["boolean", "true if code point is any character belonging a unicode identifier suffix after the first character"]], "Parameters": [["int", "int: code point to determine if is can be part of a Unicode identifier"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point may be any part of a Unicode identifier other than the starting character. A code point may be part of a Unicode identifier if and only if it is one of the following: Lu Uppercase letter Ll Lowercase letter Lt Titlecase letter Lm Modifier letter Lo Other letter Nl Letter number Pc Connecting punctuation character Nd decimal number Mc Spacing combining mark Mn Non-spacing mark Cf formatting code Up-to-date Unicode implementation of java.lang.Character.isUnicodeIdentifierPart(). See", "history": "Added in API level 24", "FullName": "public static boolean isUnicodeIdentifierPart (int ch)"}, "charCount(int)": {"Returns": [["int", "the number of chars needed to represent the code point"]], "Parameters": [["int", "int: the code point to check"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#charCount_E@. Returns the number of chars needed to represent the code point (1 or 2). This does not check the code point for validity.", "history": "Added in API level 24", "FullName": "public static int charCount (int cp)"}, "foldCase(java.lang.String, boolean)": {"Returns": [["@B_java#lang#String_E@", "the case folding equivalent of the character, if any; otherwise the character itself."]], "Parameters": [["@B_java#lang#String_E@", "String: the String to be converted"], ["boolean", "boolean: Indicates whether the default mappings defined in CaseFolding.txt are to be used, otherwise the mappings for dotted I and dotless i marked with 'T' in CaseFolding.txt are included."]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter#foldCase_E@"], "Permissions": [], "Description": "", "history": "added in API level 24", "FullName": "public static String foldCase (String str, boolean defaultmapping)"}, "digit(int, int)": {"Returns": [["int", "the numeric value represented by the code point in the specified radix, or -1 if the code point is not a decimal digit or if its value is too large for the radix"]], "Parameters": [["int", "int: the code point to query"], ["int", "int: the radix"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returnss the numeric value of a decimal digit code point. This method observes the semantics of java.lang.Character.digit(). Note that this will return positive values for code points for which isDigit returns false, just like java.lang.Character. Semantic Change: In release 1.3.1 and prior, this did not treat the European letters as having a digit value, and also treated numeric letters and other numbers as digits. This has been changed to conform to the java semantics. A code point is a valid digit if and only if: ch is a decimal digit or one of the european letters, and the value of ch is less than the specified radix.", "history": "added in API level 24", "FullName": "public static int digit (int ch, int radix)"}, "getName(int)": {"Returns": [["@B_java#lang#String_E@", "most current Unicode name"]], "Parameters": [["int", "int: the code point for which to get the name"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Note calling any methods related to code point names, e.g. get*Name*() incurs a one-time initialisation cost to construct the name tables.", "history": "Added in API level 24", "FullName": "public static String getName (int ch)"}, "isUnicodeIdentifierStart(int)": {"Returns": [["boolean", "true if code point is the first character belonging a unicode identifier"]], "Parameters": [["int", "int: code point to determine if it can start a Unicode identifier"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the specified code point is permissible as the first character in a Unicode identifier. A code point may start a Unicode identifier if it is of type either Lu Uppercase letter Ll Lowercase letter Lt Titlecase letter Lm Modifier letter Lo Other letter Nl Letter number Up-to-date Unicode implementation of java.lang.Character.isUnicodeIdentifierStart(). See", "history": "Added in API level 24", "FullName": "public static boolean isUnicodeIdentifierStart (int ch)"}, "getName(java.lang.String,java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "string of names"]], "Parameters": [["@B_java#lang#String_E@", "String: string to format"], ["@B_java#lang#String_E@", "String: string to go between names"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static String getName (String s, String separator)"}, "getCharFromName(java.lang.String)": {"Returns": [["int", "code point or -1 if name is not found"]], "Parameters": [["@B_java#lang#String_E@", "String: most current Unicode character name whose code point is to be returned"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finds a Unicode code point by its most current Unicode name and return its code point value. All Unicode names are in uppercase. Note calling any methods related to code point names, e.g. get*Name*() incurs a one-time initialisation cost to construct the name tables.", "history": "Added in API level 24", "FullName": "public static int getCharFromName (String name)"}, "codePointCount(java.lang.CharSequence,int,int)": {"Returns": [["int", "the number of code points in the range"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the characters to check"], ["int", "int: the start of the range"], ["int", "int: the limit of the range"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to the @B_java#lang#Character#codePointCount_E@ method, for convenience. Counts the number of code points in the range of text.", "history": "Added in API level 24", "FullName": "public static int codePointCount (CharSequence text, int start, int limit)"}, "isSurrogatePair(char,char)": {"Returns": [["boolean", "true if high, low form a surrogate pair"]], "Parameters": [["char", "char: the high (lead) char"], ["char", "char: the low (trail) char"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_java#lang#Character#isSurrogatePair_E@.", "history": "Added in API level 24", "FullName": "public static boolean isSurrogatePair (char high, char low)"}, "foldCase(int,int)": {"Returns": [["int", "the case folding equivalent of the character, if any; otherwise the character itself."]], "Parameters": [["int", "int: the character to be converted"], ["int", "int: A bit set for special processing. Currently the recognised options are FOLD_CASE_EXCLUDE_SPECIAL_I and FOLD_CASE_DEFAULT"]], "Throws": [], "SeeAlso": ["@B_android#icu#lang#UCharacter#foldCase_E@"], "Permissions": [], "Description": "This function only returns the simple, single-code point case mapping. Full case mappings should be used whenever possible because they produce better results by working on whole strings. They can map to a result string with a different length as appropriate. Full case mappings are applied by the case mapping functions that take String parameters rather than code points (int). See also the User Guide chapter on C/POSIX migration: http://www.icu-project.org/userguide/posix.html#case_mappings", "history": "Added in API level 24", "FullName": "public static int foldCase (int ch, int options)"}}, "Inheritance": [], "ClassName": "android.icu.lang.UCharacter", "ClassDesc": "@B_java#lang#Character_E@. Methods, fields, and other functionality specific to ICU are labeled 'The UCharacter class provides extensions to the @B_java#lang#Character_E@ class. These extensions provide support for more Unicode properties. Each ICU release supports the latest version of Unicode available at that time. For some time before Java 5 added support for supplementary Unicode code points, The ICU UCharacter class and many other ICU classes already supported them. Some UCharacter methods and constants were widened slightly differently than how the Character class methods and constants were widened later. In particular, @B_java#lang#Character#MAX_VALUE_E@ is still a char with the value U+FFFF, while the @B_android#icu#lang#UCharacter#MAX_VALUE_E@ is an int with the value U+10FFFF. Code points are represented in these API using ints. While it would be more convenient in Java to have a separate primitive datatype for them, ints suffice in the meantime. Aside from the additions for UTF-16 support, and the updated Unicode properties, the main differences between UCharacter and Character are: UCharacter is not designed to be a char wrapper and does not have APIs to which involves management of that single char. These include: char charValue(), int compareTo(java.lang.Character, java.lang.Character), etc. UCharacter does not include Character APIs that are deprecated, nor does it include the Java-specific character information, such as boolean isJavaIdentifierPart(char ch). Character maps characters 'A' - 'Z' and 'a' - 'z' to the numeric values '10' - '35'. UCharacter also does this in digit and getNumericValue, to adhere to the java semantics of these methods. New methods unicodeDigit, and getUnicodeNumericValue do not treat the above code points as having numeric values. This is a semantic change from ICU4J 1.3.1. In addition to Java compatibility functions, which calculate derived properties, this API provides low-level access to the Unicode Character Database. Unicode assigns each code point (not just assigned character) values for many properties. Most of them are simple boolean flags, or constants from a small enumerated list. For some properties, values are strings or other relatively more complex types. For more information see There are also functions that provide easy migration from C/POSIX functions like isblank(). Their use is generally discouraged because the C/POSIX standards do not define their semantics beyond the ASCII range, which means that different implementations exhibit very different behavior. Instead, Unicode properties should be used directly. There are also only a few, broad C/POSIX character classes, and they tend to be used for conflicting purposes. For example, the \"isalpha()\" class is sometimes used to determine word boundaries, while a more sophisticated approach would at least distinguish initial letters from continuation characters (the latter including combining marks). (In ICU, BreakIterator is the most sophisticated API for word boundaries.) Another example: There is no \"istitle()\" class for titlecase characters. ICU 3.4 and later provides API access for all twelve C/POSIX character classes. ICU implements them according to the Standard Recommendations in Annex C: Compatibility Properties of UTS #18 Unicode Regular Expressions (http://www.unicode.org/reports/tr18/#Compatibility_Properties). API access for C/POSIX character classes is as follows: The C/POSIX character classes are also available in UnicodeSet patterns, using patterns like [:graph:] or \\p{graph}. isUWhiteSpace=UCHAR_WHITE_SPACE: Unicode White_Space property; most of general categories \"Z\" (separators) + most whitespace ISO controls (including no-break spaces, but excluding IS1..IS4) isWhitespace: Java isWhitespace; Z + whitespace ISO controls but excluding no-break spaces isSpaceChar: just Z (including no-break spaces) This class is not subclassable."}