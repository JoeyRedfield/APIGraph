{"Functions": {"execute(java.lang.Runnable)": {"Returns": [], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: the runnable task"]], "Throws": [["@B_java#util#concurrent#RejectedExecutionException_E@", "if this task cannot be accepted for execution"], ["@B_java#lang#NullPointerException_E@", "if command is null"]], "SeeAlso": [], "Permissions": [], "Description": "Executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation.", "history": "Added in API level 1", "FullName": "public abstract void execute (Runnable command)"}}, "Inheritance": [], "ClassName": "java.util.concurrent.Executor", "ClassDesc": "An object that executes submitted @B_java#lang#Runnable_E@ tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new RunnableTask()).start() for each of a set of tasks, you might use: Executor interface does not strictly require that execution be asynchronous. In the simplest case, an executor can run the submitted task immediately in the caller's thread: Executor implementations impose some sort of limitation on how and when tasks are scheduled. The executor below serializes the submission of tasks to a second executor, illustrating a composite executor. Executor implementations provided in this package implement @B_java#util#concurrent#ExecutorService_E@, which is a more extensive interface. The @B_java#util#concurrent#ThreadPoolExecutor_E@ class provides an extensible thread pool implementation. The @B_java#util#concurrent#Executors_E@ class provides convenient factory methods for these Executors. Memory consistency effects: Actions in a thread prior to submitting a Runnable object to an Executor"}