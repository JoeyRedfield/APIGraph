{"Functions": {"getRemoteDevice(byte[])": {"Returns": [["@B_android#bluetooth#BluetoothDevice_E@", "no returns description in source"]], "Parameters": [["byte[]", "byte: Bluetooth MAC address (6 bytes)"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if address is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Get a @B_android#bluetooth#BluetoothDevice_E@ object for the given Bluetooth hardware address. Valid Bluetooth hardware addresses must be 6 bytes. This method expects the address in network byte order (MSB first). A @B_android#bluetooth#BluetoothDevice_E@ will always be returned for a valid hardware address, even if this adapter has never seen that device.", "history": "Added in API level 16", "FullName": "public BluetoothDevice getRemoteDevice (byte[] address)"}, "startLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback)": {"Returns": [["boolean", "true, if the scan was started successfully"]], "Parameters": [["@B_android#bluetooth#BluetoothAdapter#LeScanCallback_E@", "BluetoothAdapter.LeScanCallback: the callback LE scan results are delivered"]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "use @B_android#bluetooth#le#BluetoothLeScanner#startScan_E@ instead. Starts a scan for Bluetooth LE devices. Results of the scan are reported using the @B_android#bluetooth#BluetoothAdapter#LeScanCallback#onLeScan_E@ callback. Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@", "history": "Added in API level 18 Deprecated in API level 21", "FullName": "public boolean startLeScan (BluetoothAdapter.LeScanCallback callback)"}, "isLePeriodicAdvertisingSupported()": {"Returns": [["boolean", "true if chipset supports LE Periodic Advertising feature"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if LE Periodic Advertising feature is supported.", "history": "Added in API level 26", "FullName": "public boolean isLePeriodicAdvertisingSupported ()"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#Throwable_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 5", "FullName": "protected void finalize ()"}, "getLeMaximumAdvertisingDataLength()": {"Returns": [["int", "the maximum LE advertising data length."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the maximum LE advertising data length in bytes, if LE Extended Advertising feature is supported, 0 otherwise.", "history": "Added in API level 26", "FullName": "public int getLeMaximumAdvertisingDataLength ()"}, "getProfileConnectionState(int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Get the current connection state of a profile. This function can be used to check whether the local Bluetooth adapter is connected to any remote device for a specific profile. Profile can be one of @B_android#bluetooth#BluetoothProfile#HEADSET_E@, @B_android#bluetooth#BluetoothProfile#A2DP_E@. Return value can be one of @B_android#bluetooth#BluetoothProfile#STATE_DISCONNECTED_E@, @B_android#bluetooth#BluetoothProfile#STATE_CONNECTING_E@, @B_android#bluetooth#BluetoothProfile#STATE_CONNECTED_E@, @B_android#bluetooth#BluetoothProfile#STATE_DISCONNECTING_E@ Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 14", "FullName": "public int getProfileConnectionState (int profile)"}, "cancelDiscovery()": {"Returns": [["boolean", "true on success, false on error"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "Cancel the current device discovery process. Because discovery is a heavyweight procedure for the Bluetooth adapter, this method should always be called before attempting to connect to a remote device with @B_android#bluetooth#BluetoothSocket#connect_E@. Discovery is not managed by the Activity, but is run as a system service, so an application should always call cancel discovery even if it did not directly request a discovery, just to be sure. If Bluetooth state is not @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@, this API will return false. After turning on Bluetooth, wait for @B_android#bluetooth#BluetoothAdapter#ACTION_STATE_CHANGED_E@ with @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@ to get the updated value. Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@", "history": "Added in API level 5", "FullName": "public boolean cancelDiscovery ()"}, "getProfileProxy(android.content.Context,android.bluetooth.BluetoothProfile.ServiceListener,int)": {"Returns": [["boolean", "true on success, false on error"]], "Parameters": [["@B_android#content#Context_E@", "Context: Context of the application"], ["@B_android#bluetooth#BluetoothProfile#ServiceListener_E@", "BluetoothProfile.ServiceListener: The service Listener for connection callbacks."], ["int", "int: The Bluetooth profile; either @B_android#bluetooth#BluetoothProfile#HEADSET_E@, @B_android#bluetooth#BluetoothProfile#A2DP_E@, @B_android#bluetooth#BluetoothProfile#GATT_E@, @B_android#bluetooth#BluetoothProfile#HEARING_AID_E@ or @B_android#bluetooth#BluetoothProfile#GATT_SERVER_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the profile proxy object associated with the profile. Profile can be one of @B_android#bluetooth#BluetoothProfile#HEADSET_E@, @B_android#bluetooth#BluetoothProfile#A2DP_E@, @B_android#bluetooth#BluetoothProfile#GATT_E@, @B_android#bluetooth#BluetoothProfile#HEARING_AID_E@, or @B_android#bluetooth#BluetoothProfile#GATT_SERVER_E@. Clients must implement @B_android#bluetooth#BluetoothProfile#ServiceListener_E@ to get notified of the connection status and to get the proxy object.", "history": "Added in API level 11", "FullName": "public boolean getProfileProxy (Context context, BluetoothProfile.ServiceListener listener, int profile)"}, "setName(java.lang.String)": {"Returns": [["boolean", "true if the name was set, false otherwise"]], "Parameters": [["@B_java#lang#String_E@", "String: a valid Bluetooth name"]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "Set the friendly Bluetooth name of the local Bluetooth adapter. This name is visible to remote Bluetooth devices. Valid Bluetooth names are a maximum of 248 bytes using UTF-8 encoding, although many remote devices can only display the first 40 characters, and some may be limited to just 20. If Bluetooth state is not @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@, this API will return false. After turning on Bluetooth, wait for @B_android#bluetooth#BluetoothAdapter#ACTION_STATE_CHANGED_E@ with @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@ to get the updated value. Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@", "history": "Added in API level 5", "FullName": "public boolean setName (String name)"}, "isOffloadedScanBatchingSupported()": {"Returns": [["boolean", "true if chipset supports on-chip scan batching"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if offloaded scan batching is supported", "history": "Added in API level 21", "FullName": "public boolean isOffloadedScanBatchingSupported ()"}, "startLeScan(java.util.UUID[],android.bluetooth.BluetoothAdapter.LeScanCallback)": {"Returns": [["boolean", "true, if the scan was started successfully"]], "Parameters": [["@B_java#util#UUID_E@", "UUID: Array of services to look for"], ["@B_android#bluetooth#BluetoothAdapter#LeScanCallback_E@", "BluetoothAdapter.LeScanCallback: the callback LE scan results are delivered"]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "use @B_android#bluetooth#le#BluetoothLeScanner#startScan_E@ instead. Starts a scan for Bluetooth LE devices, looking for devices that advertise given services. Devices which advertise all specified services are reported using the @B_android#bluetooth#BluetoothAdapter#LeScanCallback#onLeScan_E@ callback. Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@", "history": "Added in API level 18 Deprecated in API level 21", "FullName": "public boolean startLeScan (UUID[] serviceUuids, BluetoothAdapter.LeScanCallback callback)"}, "enable()": {"Returns": [["boolean", "true to indicate adapter startup has begun, or false on immediate error"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "Turn on the local Bluetooth adapter\u2014do not use without explicit user action to turn on Bluetooth. This powers on the underlying Bluetooth hardware, and starts all Bluetooth system services. @B_android#bluetooth#BluetoothAdapter#ACTION_REQUEST_ENABLE_E@ Intent, which will raise a dialog that requests user permission to turn on Bluetooth. The @B_android#bluetooth#BluetoothAdapter#enable_E@ method is provided only for applications that include a user interface for changing system settings, such as a \"power manager\" app. This is an asynchronous call: it will return immediately, and clients should listen for @B_android#bluetooth#BluetoothAdapter#ACTION_STATE_CHANGED_E@ to be notified of subsequent adapter state changes. If this call returns true, then the adapter state will immediately transition from @B_android#bluetooth#BluetoothAdapter#STATE_OFF_E@ to @B_android#bluetooth#BluetoothAdapter#STATE_TURNING_ON_E@, and some time later transition to either @B_android#bluetooth#BluetoothAdapter#STATE_OFF_E@ or @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@. If this call returns false then there was an immediate problem that will prevent the adapter from being turned on - such as Airplane mode, or the adapter is already turned on. Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@", "history": "Added in API level 5", "FullName": "public boolean enable ()"}, "isLeExtendedAdvertisingSupported()": {"Returns": [["boolean", "true if chipset supports LE Extended Advertising feature"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if LE Extended Advertising feature is supported.", "history": "Added in API level 26", "FullName": "public boolean isLeExtendedAdvertisingSupported ()"}, "listenUsingL2capChannel()": {"Returns": [["@B_android#bluetooth#BluetoothServerSocket_E@", "an L2CAP CoC BluetoothServerSocket This value will never be null."]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", "on error, for example Bluetooth not available, or insufficient permissions, or unable to start this CoC"]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Create a secure L2CAP Connection-oriented Channel (CoC) @B_android#bluetooth#BluetoothServerSocket_E@ and assign a dynamic protocol/service multiplexer (PSM) value. This socket can be used to listen for incoming connections. The supported Bluetooth transport is LE only. A remote device connecting to this socket will be authenticated and communication on this socket will be encrypted. Use @B_android#bluetooth#BluetoothServerSocket#accept_E@ to retrieve incoming connections from a listening @B_android#bluetooth#BluetoothServerSocket_E@. The system will assign a dynamic PSM value. This PSM value can be read from the @B_android#bluetooth#BluetoothServerSocket#getPsm_E@ and this value will be released when this server socket is closed, Bluetooth is turned off, or the application exits unexpectedly. The mechanism of disclosing the assigned dynamic PSM value to the initiating peer is defined and performed by the application. Use @B_android#bluetooth#BluetoothDevice#createL2capChannel_E@ to connect to this server socket from another Android device that is given the PSM value. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 29", "FullName": "public BluetoothServerSocket listenUsingL2capChannel ()"}, "stopLeScan(android.bluetooth.BluetoothAdapter.LeScanCallback)": {"Returns": [], "Parameters": [["@B_android#bluetooth#BluetoothAdapter#LeScanCallback_E@", "BluetoothAdapter.LeScanCallback: used to identify which scan to stop must be the same handle used to start the scan"]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "Use @B_android#bluetooth#le#BluetoothLeScanner#stopScan_E@ instead. Stops an ongoing Bluetooth LE device scan. Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@", "history": "Added in API level 18 Deprecated in API level 21", "FullName": "public void stopLeScan (BluetoothAdapter.LeScanCallback callback)"}, "startDiscovery()": {"Returns": [["boolean", "true on success, false on error"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "Start the remote device discovery process. The discovery process usually involves an inquiry scan of about 12 seconds, followed by a page scan of each new device to retrieve its Bluetooth name. This is an asynchronous call, it will return immediately. Register for @B_android#bluetooth#BluetoothAdapter#ACTION_DISCOVERY_STARTED_E@ and @B_android#bluetooth#BluetoothAdapter#ACTION_DISCOVERY_FINISHED_E@ intents to determine exactly when the discovery starts and completes. Register for @B_android#bluetooth#BluetoothDevice#ACTION_FOUND_E@ to be notified as remote Bluetooth devices are found. Device discovery is a heavyweight procedure. New connections to remote Bluetooth devices should not be attempted while discovery is in progress, and existing connections will experience limited bandwidth and high latency. Use @B_android#bluetooth#BluetoothAdapter#cancelDiscovery_E@ to cancel an ongoing discovery. Discovery is not managed by the Activity, but is run as a system service, so an application should always call @B_android#bluetooth#BluetoothAdapter#cancelDiscovery_E@ even if it did not directly request a discovery, just to be sure. Device discovery will only find remote devices that are currently If Bluetooth state is not @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@, this API will return false. After turning on Bluetooth, wait for @B_android#bluetooth#BluetoothAdapter#ACTION_STATE_CHANGED_E@ with @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@ to get the updated value. Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@", "history": "Added in API level 5", "FullName": "public boolean startDiscovery ()"}, "getScanMode()": {"Returns": [["int", "scan mode Value is @B_android#bluetooth#BluetoothAdapter#SCAN_MODE_NONE_E@, @B_android#bluetooth#BluetoothAdapter#SCAN_MODE_CONNECTABLE_E@, or @B_android#bluetooth#BluetoothAdapter#SCAN_MODE_CONNECTABLE_DISCOVERABLE_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Get the current Bluetooth scan mode of the local Bluetooth adapter. The Bluetooth scan mode determines if the local adapter is connectable and/or discoverable from remote Bluetooth devices. Possible values are: @B_android#bluetooth#BluetoothAdapter#SCAN_MODE_NONE_E@, @B_android#bluetooth#BluetoothAdapter#SCAN_MODE_CONNECTABLE_E@, @B_android#bluetooth#BluetoothAdapter#SCAN_MODE_CONNECTABLE_DISCOVERABLE_E@. If Bluetooth state is not @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@, this API will return @B_android#bluetooth#BluetoothAdapter#SCAN_MODE_NONE_E@. After turning on Bluetooth, wait for @B_android#bluetooth#BluetoothAdapter#ACTION_STATE_CHANGED_E@ with @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@ to get the updated value. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public int getScanMode ()"}, "isDiscovering()": {"Returns": [["boolean", "true if discovering"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Return true if the local Bluetooth adapter is currently in the device discovery process. Device discovery is a heavyweight procedure. New connections to remote Bluetooth devices should not be attempted while discovery is in progress, and existing connections will experience limited bandwidth and high latency. Use @B_android#bluetooth#BluetoothAdapter#cancelDiscovery_E@ to cancel an ongoing discovery. Applications can also register for @B_android#bluetooth#BluetoothAdapter#ACTION_DISCOVERY_STARTED_E@ or @B_android#bluetooth#BluetoothAdapter#ACTION_DISCOVERY_FINISHED_E@ to be notified when discovery starts or completes. If Bluetooth state is not @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@, this API will return false. After turning on Bluetooth, wait for @B_android#bluetooth#BluetoothAdapter#ACTION_STATE_CHANGED_E@ with @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@ to get the updated value. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public boolean isDiscovering ()"}, "getName()": {"Returns": [["@B_java#lang#String_E@", "the Bluetooth name, or null on error"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Get the friendly Bluetooth name of the local Bluetooth adapter. This name is visible to remote Bluetooth devices. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public String getName ()"}, "isOffloadedFilteringSupported()": {"Returns": [["boolean", "true if chipset supports on-chip filtering"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if offloaded filters are supported", "history": "Added in API level 21", "FullName": "public boolean isOffloadedFilteringSupported ()"}, "getDefaultAdapter()": {"Returns": [["@B_android#bluetooth#BluetoothAdapter_E@", "the default local adapter, or null if Bluetooth is not supported on this hardware platform"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get a handle to the default local Bluetooth adapter. Currently Android only supports one Bluetooth adapter, but the API could be extended to support more. This will always return the default adapter.", "history": "Added in API level 5", "FullName": "public static BluetoothAdapter getDefaultAdapter ()"}, "closeProfileProxy(int,android.bluetooth.BluetoothProfile)": {"Returns": [], "Parameters": [["@B_android#bluetooth#BluetoothProfile_E@", "BluetoothProfile: Profile proxy object"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Close the connection of the profile proxy to the Service. Clients should call this when they are no longer using the proxy obtained from @B_android#bluetooth#BluetoothAdapter#getProfileProxy_E@. Profile can be one of @B_android#bluetooth#BluetoothProfile#HEADSET_E@ or @B_android#bluetooth#BluetoothProfile#A2DP_E@", "history": "Added in API level 11", "FullName": "public void closeProfileProxy (int profile, BluetoothProfile proxy)"}, "getRemoteDevice(java.lang.String)": {"Returns": [["@B_android#bluetooth#BluetoothDevice_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: valid Bluetooth MAC address"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if address is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Get a @B_android#bluetooth#BluetoothDevice_E@ object for the given Bluetooth hardware address. Valid Bluetooth hardware addresses must be upper case, in a format such as \"00:11:22:33:AA:BB\". The helper @B_android#bluetooth#BluetoothAdapter#checkBluetoothAddress_E@ is available to validate a Bluetooth address. A @B_android#bluetooth#BluetoothDevice_E@ will always be returned for a valid hardware address, even if this adapter has never seen that device.", "history": "Added in API level 5", "FullName": "public BluetoothDevice getRemoteDevice (String address)"}, "getState()": {"Returns": [["int", "current state of Bluetooth adapter Value is @B_android#bluetooth#BluetoothAdapter#STATE_OFF_E@, @B_android#bluetooth#BluetoothAdapter#STATE_TURNING_ON_E@, @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@, @B_android#bluetooth#BluetoothAdapter#STATE_TURNING_OFF_E@, android.bluetooth.BluetoothAdapter.STATE_BLE_TURNING_ON, android.bluetooth.BluetoothAdapter.STATE_BLE_ON, or android.bluetooth.BluetoothAdapter.STATE_BLE_TURNING_OFF"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Get the current state of the local Bluetooth adapter. Possible return values are @B_android#bluetooth#BluetoothAdapter#STATE_OFF_E@, @B_android#bluetooth#BluetoothAdapter#STATE_TURNING_ON_E@, @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@, @B_android#bluetooth#BluetoothAdapter#STATE_TURNING_OFF_E@. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public int getState ()"}, "checkBluetoothAddress(java.lang.String)": {"Returns": [["boolean", "true if the address is valid, false otherwise"]], "Parameters": [["@B_java#lang#String_E@", "String: Bluetooth address as string"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Validate a String Bluetooth address, such as \"00:43:A8:23:10:F0\" Alphabetic characters must be uppercase to be valid.", "history": "Added in API level 5", "FullName": "public static boolean checkBluetoothAddress (String address)"}, "isEnabled()": {"Returns": [["boolean", "true if the local adapter is turned on"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Return true if Bluetooth is currently enabled and ready for use. Equivalent to: getBluetoothState() == STATE_ON Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public boolean isEnabled ()"}, "getBluetoothLeScanner()": {"Returns": [["@B_android#bluetooth#le#BluetoothLeScanner_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a @B_android#bluetooth#le#BluetoothLeScanner_E@ object for Bluetooth LE scan operations.", "history": "Added in API level 21", "FullName": "public BluetoothLeScanner getBluetoothLeScanner ()"}, "isMultipleAdvertisementSupported()": {"Returns": [["boolean", "true if Multiple Advertisement feature is supported"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if the multi advertisement is supported by the chipset", "history": "Added in API level 21", "FullName": "public boolean isMultipleAdvertisementSupported ()"}, "listenUsingInsecureL2capChannel()": {"Returns": [["@B_android#bluetooth#BluetoothServerSocket_E@", "an L2CAP CoC BluetoothServerSocket This value will never be null."]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", "on error, for example Bluetooth not available, or insufficient permissions, or unable to start this CoC"]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Create an insecure L2CAP Connection-oriented Channel (CoC) @B_android#bluetooth#BluetoothServerSocket_E@ and assign a dynamic PSM value. This socket can be used to listen for incoming connections. The supported Bluetooth transport is LE only. The link key is not required to be authenticated, i.e the communication may be vulnerable to man-in-the-middle attacks. Use @B_android#bluetooth#BluetoothAdapter#listenUsingL2capChannel_E@, if an encrypted and authenticated communication channel is desired. Use @B_android#bluetooth#BluetoothServerSocket#accept_E@ to retrieve incoming connections from a listening @B_android#bluetooth#BluetoothServerSocket_E@. The system will assign a dynamic protocol/service multiplexer (PSM) value. This PSM value can be read from the @B_android#bluetooth#BluetoothServerSocket#getPsm_E@ and this value will be released when this server socket is closed, Bluetooth is turned off, or the application exits unexpectedly. The mechanism of disclosing the assigned dynamic PSM value to the initiating peer is defined and performed by the application. Use @B_android#bluetooth#BluetoothDevice#createInsecureL2capChannel_E@ to connect to this server socket from another Android device that is given the PSM value. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 29", "FullName": "public BluetoothServerSocket listenUsingInsecureL2capChannel ()"}, "getAddress()": {"Returns": [["@B_java#lang#String_E@", "Bluetooth hardware address as string"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Returns the hardware address of the local Bluetooth adapter. For example, \"00:11:22:AA:BB:CC\". Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public String getAddress ()"}, "isLe2MPhySupported()": {"Returns": [["boolean", "true if chipset supports LE 2M PHY feature"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if LE 2M PHY feature is supported.", "history": "Added in API level 26", "FullName": "public boolean isLe2MPhySupported ()"}, "listenUsingRfcommWithServiceRecord(java.lang.String,java.util.UUID)": {"Returns": [["@B_android#bluetooth#BluetoothServerSocket_E@", "a listening RFCOMM BluetoothServerSocket"]], "Parameters": [["@B_java#lang#String_E@", "String: service name for SDP record"], ["@B_java#util#UUID_E@", "UUID: uuid for SDP record"]], "Throws": [["@B_java#io#IOException_E@", "on error, for example Bluetooth not available, or insufficient permissions, or channel in use."]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Create a listening, secure RFCOMM Bluetooth socket with Service Record. A remote device connecting to this socket will be authenticated and communication on this socket will be encrypted. Use @B_android#bluetooth#BluetoothServerSocket#accept_E@ to retrieve incoming connections from a listening @B_android#bluetooth#BluetoothServerSocket_E@. The system will assign an unused RFCOMM channel to listen on. The system will also register a Service Discovery Protocol (SDP) record with the local SDP server containing the specified UUID, service name, and auto-assigned channel. Remote Bluetooth devices can use the same UUID to query our SDP server and discover which channel to connect to. This SDP record will be removed when this socket is closed, or if this application closes unexpectedly. Use @B_android#bluetooth#BluetoothDevice#createRfcommSocketToServiceRecord_E@ to connect to this socket from another device using the same @B_java#util#UUID_E@. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public BluetoothServerSocket listenUsingRfcommWithServiceRecord (String name, UUID uuid)"}, "isLeCodedPhySupported()": {"Returns": [["boolean", "true if chipset supports LE Coded PHY feature"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if LE Coded PHY feature is supported.", "history": "Added in API level 26", "FullName": "public boolean isLeCodedPhySupported ()"}, "getBluetoothLeAdvertiser()": {"Returns": [["@B_android#bluetooth#le#BluetoothLeAdvertiser_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a @B_android#bluetooth#le#BluetoothLeAdvertiser_E@ object for Bluetooth LE Advertising operations. Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not supported on this device. Use @B_android#bluetooth#BluetoothAdapter#isMultipleAdvertisementSupported_E@ to check whether LE Advertising is supported on this device before calling this method.", "history": "Added in API level 21", "FullName": "public BluetoothLeAdvertiser getBluetoothLeAdvertiser ()"}, "disable()": {"Returns": [["boolean", "true to indicate adapter shutdown has begun, or false on immediate error"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "Turn off the local Bluetooth adapter\u2014do not use without explicit user action to turn off Bluetooth. This gracefully shuts down all Bluetooth connections, stops Bluetooth system services, and powers down the underlying Bluetooth hardware. @B_android#bluetooth#BluetoothAdapter#disable_E@ method is provided only for applications that include a user interface for changing system settings, such as a \"power manager\" app. This is an asynchronous call: it will return immediately, and clients should listen for @B_android#bluetooth#BluetoothAdapter#ACTION_STATE_CHANGED_E@ to be notified of subsequent adapter state changes. If this call returns true, then the adapter state will immediately transition from @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@ to @B_android#bluetooth#BluetoothAdapter#STATE_TURNING_OFF_E@, and some time later transition to either @B_android#bluetooth#BluetoothAdapter#STATE_OFF_E@ or @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@. If this call returns false then there was an immediate problem that will prevent the adapter from being turned off - such as the adapter already being turned off. Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@", "history": "Added in API level 5", "FullName": "public boolean disable ()"}, "listenUsingInsecureRfcommWithServiceRecord(java.lang.String,java.util.UUID)": {"Returns": [["@B_android#bluetooth#BluetoothServerSocket_E@", "a listening RFCOMM BluetoothServerSocket"]], "Parameters": [["@B_java#lang#String_E@", "String: service name for SDP record"], ["@B_java#util#UUID_E@", "UUID: uuid for SDP record"]], "Throws": [["@B_java#io#IOException_E@", "on error, for example Bluetooth not available, or insufficient permissions, or channel in use."]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Create a listening, insecure RFCOMM Bluetooth socket with Service Record. The link key is not required to be authenticated, i.e the communication may be vulnerable to Man In the Middle attacks. For Bluetooth 2.1 devices, the link will be encrypted, as encryption is mandartory. For legacy devices (pre Bluetooth 2.1 devices) the link will not be encrypted. Use @B_android#bluetooth#BluetoothAdapter#listenUsingRfcommWithServiceRecord_E@, if an encrypted and authenticated communication channel is desired. Use @B_android#bluetooth#BluetoothServerSocket#accept_E@ to retrieve incoming connections from a listening @B_android#bluetooth#BluetoothServerSocket_E@. The system will assign an unused RFCOMM channel to listen on. The system will also register a Service Discovery Protocol (SDP) record with the local SDP server containing the specified UUID, service name, and auto-assigned channel. Remote Bluetooth devices can use the same UUID to query our SDP server and discover which channel to connect to. This SDP record will be removed when this socket is closed, or if this application closes unexpectedly. Use @B_android#bluetooth#BluetoothDevice#createRfcommSocketToServiceRecord_E@ to connect to this socket from another device using the same @B_java#util#UUID_E@. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 10", "FullName": "public BluetoothServerSocket listenUsingInsecureRfcommWithServiceRecord (String name, UUID uuid)"}, "getBondedDevices()": {"Returns": [["@B_java#util#Set_E@", "unmodifiable set of @B_android#bluetooth#BluetoothDevice_E@, or null on error"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Return the set of @B_android#bluetooth#BluetoothDevice_E@ objects that are bonded (paired) to the local adapter. If Bluetooth state is not @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@, this API will return an empty set. After turning on Bluetooth, wait for @B_android#bluetooth#BluetoothAdapter#ACTION_STATE_CHANGED_E@ with @B_android#bluetooth#BluetoothAdapter#STATE_ON_E@ to get the updated value. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public Set<BluetoothDevice> getBondedDevices ()"}}, "Inheritance": [], "ClassName": "android.bluetooth.BluetoothAdapter", "ClassDesc": "Represents the local device Bluetooth adapter. The @B_android#bluetooth#BluetoothAdapter_E@ lets you perform fundamental Bluetooth tasks, such as initiate device discovery, query a list of bonded (paired) devices, instantiate a @B_android#bluetooth#BluetoothDevice_E@ using a known MAC address, and create a @B_android#bluetooth#BluetoothServerSocket_E@ to listen for connection requests from other devices, and start a scan for Bluetooth LE devices. To get a @B_android#bluetooth#BluetoothAdapter_E@ representing the local Bluetooth adapter, call the @B_android#bluetooth#BluetoothManager#getAdapter_E@ function on @B_android#bluetooth#BluetoothManager_E@. On JELLY_BEAN_MR1 and below you will need to use the static @B_android#bluetooth#BluetoothAdapter#getDefaultAdapter_E@ method instead. Fundamentally, this is your starting point for all Bluetooth actions. Once you have the local adapter, you can get a set of @B_android#bluetooth#BluetoothDevice_E@ objects representing all paired devices with @B_android#bluetooth#BluetoothAdapter#getBondedDevices_E@; start device discovery with @B_android#bluetooth#BluetoothAdapter#startDiscovery_E@; or create a @B_android#bluetooth#BluetoothServerSocket_E@ to listen for incoming RFComm connection requests with @B_android#bluetooth#BluetoothAdapter#listenUsingRfcommWithServiceRecord_E@; listen for incoming L2CAP Connection-oriented Channels (CoC) connection requests with @B_android#bluetooth#BluetoothAdapter#listenUsingL2capChannel_E@; or start a scan for Bluetooth LE devices with @B_android#bluetooth#BluetoothAdapter#startLeScan_E@. This class is thread safe. @B_android#Manifest#permission#BLUETOOTH_E@ permission and some also require the @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@ permission."}