{"Functions": {"getMaxHdcpLevel()": {"Returns": [["int", "the maximum supported HDCP level Value is @B_android#media#MediaDrm#HDCP_LEVEL_UNKNOWN_E@, @B_android#media#MediaDrm#HDCP_NONE_E@, @B_android#media#MediaDrm#HDCP_V1_E@, @B_android#media#MediaDrm#HDCP_V2_E@, @B_android#media#MediaDrm#HDCP_V2_1_E@, @B_android#media#MediaDrm#HDCP_V2_2_E@, @B_android#media#MediaDrm#HDCP_V2_3_E@, or @B_android#media#MediaDrm#HDCP_NO_DIGITAL_OUTPUT_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the maximum supported HDCP level. The maximum HDCP level is a constant for a given device, it does not depend on downstream receivers that may be connected. If multiple HDCP-capable interfaces are present, it indicates the highest of the maximum HDCP levels of all interfaces.", "history": "Added in API level 28", "FullName": "public int getMaxHdcpLevel ()"}, "close()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Releases resources associated with the current session of MediaDrm. It is considered good practice to call this method when the @B_android#media#MediaDrm_E@ object is no longer needed in your application. After this method is called, @B_android#media#MediaDrm_E@ is no longer usable since it has lost all of its required resource. This method was added in API 28. In API versions 18 through 27, release() should be called instead. There is no need to do anything for API versions prior to 18.", "history": "Added in API level 28", "FullName": "public void close ()"}, "removeOfflineLicense(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: the id of the offline license to remove This value must never be null."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the keySetId does not refer to an offline license."]], "SeeAlso": [], "Permissions": [], "Description": "Normally offline licenses are released using a key request/response exchange using @B_android#media#MediaDrm#getKeyRequest_E@ where the key type is KEY_TYPE_RELEASE, followed by @B_android#media#MediaDrm#provideKeyResponse_E@. This allows the server to cryptographically confirm that the license has been removed and then adjust the count of offline licenses allocated to the device. In some exceptional situations it may be necessary to directly remove offline licenses without notifying the server, which may be performed using this method.", "history": "Added in API level 29", "FullName": "public void removeOfflineLicense (byte[] keySetId)"}, "MediaDrm(java.util.UUID)": {"Returns": [], "Parameters": [["@B_java#util#UUID_E@", "UUID: The UUID of the crypto scheme. This value must never be null."]], "Throws": [["@B_android#media#UnsupportedSchemeException_E@", "if the device does not support the specified scheme UUID"]], "SeeAlso": [], "Permissions": [], "Description": "Instantiate a MediaDrm object", "history": "Added in API level 18", "FullName": "public MediaDrm (UUID uuid)"}, "clearOnExpirationUpdateListener()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clear the @B_android#media#MediaDrm#OnExpirationUpdateListener_E@.", "history": "Added in API level 29", "FullName": "public void clearOnExpirationUpdateListener ()"}, "getOpenSessionCount()": {"Returns": [["int", "the number of open sessions."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of MediaDrm sessions that are currently opened simultaneously among all MediaDrm instances for the active DRM scheme.", "history": "Added in API level 28", "FullName": "public int getOpenSessionCount ()"}, "getConnectedHdcpLevel()": {"Returns": [["int", "the connected HDCP level Value is @B_android#media#MediaDrm#HDCP_LEVEL_UNKNOWN_E@, @B_android#media#MediaDrm#HDCP_NONE_E@, @B_android#media#MediaDrm#HDCP_V1_E@, @B_android#media#MediaDrm#HDCP_V2_E@, @B_android#media#MediaDrm#HDCP_V2_1_E@, @B_android#media#MediaDrm#HDCP_V2_2_E@, @B_android#media#MediaDrm#HDCP_V2_3_E@, or @B_android#media#MediaDrm#HDCP_NO_DIGITAL_OUTPUT_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the HDCP level negotiated with downstream receivers the device is connected to. If multiple HDCP-capable displays are simultaneously connected to separate interfaces, this method returns the lowest negotiated level of all interfaces. This method should only be used for informational purposes, not for enforcing compliance with HDCP requirements. Trusted enforcement of HDCP policies must be handled by the DRM system.", "history": "Added in API level 28", "FullName": "public int getConnectedHdcpLevel ()"}, "getMaxSessionCount()": {"Returns": [["int", "maximum sessions."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the maximum number of MediaDrm sessions that may be opened simultaneosly among all MediaDrm instances for the active DRM scheme. The maximum number of sessions is not affected by any sessions that may have already been opened.", "history": "Added in API level 28", "FullName": "public int getMaxSessionCount ()"}, "setPropertyByteArray(java.lang.String, byte[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment This value must never be null.Value is PROPERTY_DEVICE_UNIQUE_ID."], ["byte[]", "byte no parameter comment This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a MediaDrm byte array property value, given the property name string and new value for the property.", "history": "added in API level 18", "FullName": "public void setPropertyByteArray (String propertyName, byte[] value)"}, "getSecurityLevel(byte[])": {"Returns": [["int", "the security level of the session Value is @B_android#media#MediaDrm#SECURITY_LEVEL_UNKNOWN_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_SW_SECURE_CRYPTO_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_SW_SECURE_DECODE_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_HW_SECURE_CRYPTO_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_HW_SECURE_DECODE_E@, or @B_android#media#MediaDrm#SECURITY_LEVEL_HW_SECURE_ALL_E@"]], "Parameters": [["byte[]", "byte: the session to query. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the current security level of a session. A session has an initial security level determined by the robustness of the DRM system's implementation on the device. The security level may be changed at the time a session is opened using @B_android#media#MediaDrm#openSession_E@.", "history": "Added in API level 28", "FullName": "public int getSecurityLevel (byte[] sessionId)"}, "setOnEventListener(android.media.MediaDrm.OnEventListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaDrm#OnEventListener_E@", "MediaDrm.OnEventListener: the callback that will be run. Use null to stop receiving event callbacks. This value may be null."], ["@B_android#os#Handler_E@", "Handler: the handler on which the listener should be invoked, or null if the listener should be invoked on the calling thread's looper. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when an event occurs", "history": "Added in API level 29", "FullName": "public void setOnEventListener (MediaDrm.OnEventListener listener, Handler handler)"}, "getSecureStops()": {"Returns": [["@B_java#util#List_E@", "a list of all secure stops from secure persistent memory This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Secure stops are a way to enforce limits on the number of concurrent streams per subscriber across devices. They provide secure monitoring of the lifetime of content decryption keys in MediaDrm sessions. A secure stop is written to secure persistent memory when keys are loaded into a MediaDrm session. The secure stop state indicates that the keys are available for use. When playback completes and the keys are removed or the session is destroyed, the secure stop state is updated to indicate that keys are no longer usable. After playback, the app can query the secure stop and send it in a message to the license server confirming that the keys are no longer active. The license server returns a secure stop release response message to the app which then deletes the secure stop from persistent memory using @B_android#media#MediaDrm#releaseSecureStops_E@. Each secure stop has a unique ID that can be used to identify it during enumeration, access and removal.", "history": "Added in API level 18", "FullName": "public List<byte[]> getSecureStops ()"}, "restoreKeys(byte[], byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: the session ID for the DRM sessionThis value must never be null."], ["byte[]", "byte: identifies the saved key set to restore This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Restore persisted offline keys into a new session. keySetId identifies the keys to load, obtained from a prior call to @B_android#media#MediaDrm#provideKeyResponse_E@.", "history": "added in API level 18", "FullName": "public void restoreKeys (byte[] sessionId, byte[] keySetId)"}, "provideKeyResponse(byte[],byte[])": {"Returns": [["byte[]", "If the response is for an offline request, the keySetId for the offline keys will be returned. If the response is for a streaming or release request an empty byte array will be returned. This value may be null."]], "Parameters": [["byte[]", "byte: may be a sessionId or keySetId depending on the type of the response. Scope should be set to the sessionId when the response is for either streaming or offline key requests. Scope should be set to the keySetId when the response is for a release request. This value must never be null."], ["byte[]", "byte: the byte array response from the server This value must never be null."]], "Throws": [["@B_android#media#NotProvisionedException_E@", "if the response indicates that reprovisioning is required"], ["@B_android#media#DeniedByServerException_E@", "if the response indicates that the server rejected the request"]], "SeeAlso": [], "Permissions": [], "Description": "A key response is received from the license server by the app, then it is provided to the MediaDrm instance using provideKeyResponse. When the response is for an offline key request, a keySetId is returned that can be used to later restore the keys to a new session with the method @B_android#media#MediaDrm#restoreKeys_E@. When the response is for a streaming or release request, an empty byte array is returned.", "history": "Added in API level 18", "FullName": "public byte[] provideKeyResponse (byte[] scope, byte[] response)"}, "getOfflineLicenseState(byte[])": {"Returns": [["int", "the offline license state Value is @B_android#media#MediaDrm#OFFLINE_LICENSE_STATE_UNKNOWN_E@, @B_android#media#MediaDrm#OFFLINE_LICENSE_STATE_USABLE_E@, or @B_android#media#MediaDrm#OFFLINE_LICENSE_STATE_RELEASED_E@"]], "Parameters": [["byte[]", "byte: selects the offline license This value must never be null."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the keySetId does not refer to an offline license."]], "SeeAlso": [], "Permissions": [], "Description": "Request the state of an offline license. An offline license may be usable or inactive. The keys in a usable offline license are available for decryption. When the offline license state is inactive, the keys have been marked for release using @B_android#media#MediaDrm#getKeyRequest_E@ with KEY_TYPE_RELEASE but the key response has not been received. The keys in an inactive offline license are not usable for decryption.", "history": "Added in API level 29", "FullName": "public int getOfflineLicenseState (byte[] keySetId)"}, "isCryptoSchemeSupported(java.util.UUID)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#util#UUID_E@", "UUID: The UUID of the crypto scheme. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Query if the given scheme identified by its UUID is supported on this device.", "history": "Added in API level 18", "FullName": "public static boolean isCryptoSchemeSupported (UUID uuid)"}, "setOnSessionLostStateListener(android.media.MediaDrm.OnSessionLostStateListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaDrm#OnSessionLostStateListener_E@", "MediaDrm.OnSessionLostStateListener: the callback that will be run, or null to unregister the previously registered callback. This value may be null."], ["@B_android#os#Handler_E@", "Handler: the handler on which the listener should be invoked, or null if the listener should be invoked on the calling thread's looper. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when session state has been lost. This event can occur on devices that are not capable of retaining crypto session state across device suspend/resume cycles. When this event occurs, the session must be closed and a new session opened to resume operation.", "history": "Added in API level 29", "FullName": "public void setOnSessionLostStateListener (MediaDrm.OnSessionLostStateListener listener, Handler handler)"}, "getSecureStop(byte[])": {"Returns": [["byte[]", "the secure stop identified by ssid This value will never be null."]], "Parameters": [["byte[]", "byte: the ID of the secure stop to return This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Access a specific secure stop given its secure stop ID. Each secure stop has a unique ID.", "history": "Added in API level 22", "FullName": "public byte[] getSecureStop (byte[] ssid)"}, "getMetrics()": {"Returns": [["@B_android#os#PersistableBundle_E@", "a @B_android#os#PersistableBundle_E@ containing the set of attributes and values available for this instance of MediaDrm. The attributes are described in @B_android#media#MediaDrm#MetricsConstants_E@. Additional vendor-specific fields may also be present in the return value."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return Metrics data about the current MediaDrm instance.", "history": "Added in API level 28", "FullName": "public PersistableBundle getMetrics ()"}, "release()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "replaced by @B_android#media#MediaDrm#close_E@.", "history": "Added in API level 18 Deprecated in API level 28", "FullName": "public void release ()"}, "removeKeys(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: the session ID for the DRM session This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove the current keys from a session.", "history": "Added in API level 18", "FullName": "public void removeKeys (byte[] sessionId)"}, "setOnExpirationUpdateListener(android.media.MediaDrm.OnExpirationUpdateListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaDrm#OnExpirationUpdateListener_E@", "MediaDrm.OnExpirationUpdateListener: the callback that will be run, or null to unregister the previously registered callback. This value may be null."], ["@B_android#os#Handler_E@", "Handler: the handler on which the listener should be invoked, or null if the listener should be invoked on the calling thread's looper. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when a session expiration update occurs. The app's OnExpirationUpdateListener will be notified when the expiration time of the keys in the session have changed.", "history": "Added in API level 23", "FullName": "public void setOnExpirationUpdateListener (MediaDrm.OnExpirationUpdateListener listener, Handler handler)"}, "clearOnKeyStatusChangeListener()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clear the @B_android#media#MediaDrm#OnKeyStatusChangeListener_E@.", "history": "Added in API level 29", "FullName": "public void clearOnKeyStatusChangeListener ()"}, "setPropertyString(java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: This value must never be null."], ["@B_java#lang#String_E@", "String: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a MediaDrm String property value, given the property name string and new value for the property.", "history": "Added in API level 18", "FullName": "public void setPropertyString (String propertyName, String value)"}, "getPropertyString(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "This value will never be null."]], "Parameters": [["@B_java#lang#String_E@", "String: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Read a MediaDrm String property value, given the property name string. Standard fields names are: @B_android#media#MediaDrm#PROPERTY_VENDOR_E@, @B_android#media#MediaDrm#PROPERTY_VERSION_E@, @B_android#media#MediaDrm#PROPERTY_DESCRIPTION_E@, @B_android#media#MediaDrm#PROPERTY_ALGORITHMS_E@", "history": "Added in API level 18", "FullName": "public String getPropertyString (String propertyName)"}, "setOnKeyStatusChangeListener(java.util.concurrent.Executor,android.media.MediaDrm.OnKeyStatusChangeListener)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#Executor_E@", "Executor: the executor on which the listener should be invoked. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#media#MediaDrm#OnKeyStatusChangeListener_E@", "MediaDrm.OnKeyStatusChangeListener: the callback that will be run when key status changes. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#media#MediaDrm#setOnKeyStatusChangeListener_E@"], "Permissions": [], "Description": "Register a callback to be invoked when the state of keys in a session change.", "history": "Added in API level 29", "FullName": "public void setOnKeyStatusChangeListener (Executor executor, MediaDrm.OnKeyStatusChangeListener listener)"}, "getProvisionRequest()": {"Returns": [["@B_android#media#MediaDrm#ProvisionRequest_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "A provision request/response exchange occurs between the app and a provisioning server to retrieve a device certificate. If provisionining is required, the EVENT_PROVISION_REQUIRED event will be sent to the event handler. getProvisionRequest is used to obtain the opaque provision request byte array that should be delivered to the provisioning server. The provision request byte array is returned in ProvisionRequest.data. The recommended URL to deliver the provision request to is returned in ProvisionRequest.defaultUrl.", "history": "Added in API level 18", "FullName": "public MediaDrm.ProvisionRequest getProvisionRequest ()"}, "getPropertyByteArray(java.lang.String)": {"Returns": [["byte[]", "This value will never be null."]], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Read a MediaDrm byte array property value, given the property name string. Standard fields names are @B_android#media#MediaDrm#PROPERTY_DEVICE_UNIQUE_ID_E@", "history": "Added in API level 18", "FullName": "public byte[] getPropertyByteArray (String propertyName)"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#Throwable_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 18", "FullName": "protected void finalize ()"}, "clearOnSessionLostStateListener()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clear the @B_android#media#MediaDrm#OnSessionLostStateListener_E@.", "history": "Added in API level 29", "FullName": "public void clearOnSessionLostStateListener ()"}, "setOnSessionLostStateListener(java.util.concurrent.Executor,android.media.MediaDrm.OnSessionLostStateListener)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#Executor_E@", "Executor: the executor on which the listener should be invoked. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#media#MediaDrm#OnSessionLostStateListener_E@", "MediaDrm.OnSessionLostStateListener: the callback that will be run. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#media#MediaDrm#setOnSessionLostStateListener_E@"], "Permissions": [], "Description": "Register a callback to be invoked when session state has been lost.", "history": "Added in API level 29", "FullName": "public void setOnSessionLostStateListener (Executor executor, MediaDrm.OnSessionLostStateListener listener)"}, "getOfflineLicenseKeySetIds()": {"Returns": [["@B_java#util#List_E@", "a list of offline license keySetIds This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The keys in an offline license allow protected content to be played even if the device is not connected to a network. Offline licenses are stored on the device after a key request/response exchange when the key request KeyType is OFFLINE. Normally each app is responsible for keeping track of the keySetIds it has created. If an app loses the keySetId for any stored licenses that it created, however, it must be able to recover the stored keySetIds so those licenses can be removed when they expire or when the app is uninstalled. This method returns a list of the keySetIds for all offline licenses. The offline license keySetId may be used to query the status of an offline license with @B_android#media#MediaDrm#getOfflineLicenseState_E@ or remove it with @B_android#media#MediaDrm#removeOfflineLicense_E@.", "history": "Added in API level 29", "FullName": "public List<byte[]> getOfflineLicenseKeySetIds ()"}, "setOnExpirationUpdateListener(java.util.concurrent.Executor,android.media.MediaDrm.OnExpirationUpdateListener)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#Executor_E@", "Executor: the executor through which the listener should be invoked This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#media#MediaDrm#OnExpirationUpdateListener_E@", "MediaDrm.OnExpirationUpdateListener: the callback that will be run. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#media#MediaDrm#setOnExpirationUpdateListener_E@"], "Permissions": [], "Description": "Register a callback to be invoked when a session expiration update occurs.", "history": "Added in API level 29", "FullName": "public void setOnExpirationUpdateListener (Executor executor, MediaDrm.OnExpirationUpdateListener listener)"}, "releaseAllSecureStops()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove all secure stops using @B_android#media#MediaDrm#removeAllSecureStops_E@ instead. Remove all secure stops without requiring a secure stop release message from the license server.", "history": "Added in API level 22 Deprecated in API level 28", "FullName": "public void releaseAllSecureStops ()"}, "closeSession(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Close a session on the MediaDrm object that was previously opened with @B_android#media#MediaDrm#openSession_E@.", "history": "Added in API level 18", "FullName": "public void closeSession (byte[] sessionId)"}, "getKeyRequest(byte[],byte[],java.lang.String,int,java.util.HashMap<java.lang.String,java.lang.String>)": {"Returns": [["@B_android#media#MediaDrm#KeyRequest_E@", "no returns description in source"]], "Parameters": [["byte[]", "byte: may be a sessionId or a keySetId, depending on the specified keyType. When the keyType is KEY_TYPE_STREAMING or KEY_TYPE_OFFLINE, scope should be set to the sessionId the keys will be provided to. When the keyType is KEY_TYPE_RELEASE, scope should be set to the keySetId of the keys being released. Releasing keys from a device invalidates them for all sessions. This value must never be null."], ["byte[]", "byte: container-specific data, its meaning is interpreted based on the mime type provided in the mimeType parameter. It could contain, for example, the content ID, key ID or other data obtained from the content metadata that is required in generating the key request. May be null when keyType is KEY_TYPE_RELEASE or if the request is a renewal, i.e. not the first key request for the session. This value may be null."], ["@B_java#lang#String_E@", "String: identifies the mime type of the content. May be null if the keyType is KEY_TYPE_RELEASE or if the request is a renewal, i.e. not the first key request for the session. This value may be null."], ["int", "int: specifes the type of the request. The request may be to acquire keys for streaming or offline content, or to release previously acquired keys, which are identified by a keySetId. Value is @B_android#media#MediaDrm#KEY_TYPE_STREAMING_E@, @B_android#media#MediaDrm#KEY_TYPE_OFFLINE_E@, or @B_android#media#MediaDrm#KEY_TYPE_RELEASE_E@"], ["@B_java#util#HashMap_E@", "HashMap: are included in the key request message to allow a client application to provide additional message parameters to the server. This may be null if no additional parameters are to be sent. This value may be null."]], "Throws": [["@B_android#media#NotProvisionedException_E@", "if reprovisioning is needed, due to a problem with the certifcate"]], "SeeAlso": [], "Permissions": [], "Description": "A key request/response exchange occurs between the app and a license server to obtain or release keys used to decrypt encrypted content. getKeyRequest() is used to obtain an opaque key request byte array that is delivered to the license server. The opaque key request byte array is returned in KeyRequest.data. The recommended URL to deliver the key request to is returned in KeyRequest.defaultUrl. After the app has received the key request response from the server, it should deliver to the response to the MediaDrm instance using the method @B_android#media#MediaDrm#provideKeyResponse_E@.", "history": "Added in API level 18", "FullName": "public MediaDrm.KeyRequest getKeyRequest (byte[] scope, byte[] init, String mimeType, int keyType, HashMap<String, String> optionalParameters)"}, "getCryptoSession(byte[],java.lang.String,java.lang.String)": {"Returns": [["@B_android#media#MediaDrm#CryptoSession_E@", "no returns description in source"]], "Parameters": [["byte[]", "byte: the session ID for the session containing keys to be used for encrypt, decrypt, sign and/or verify This value must never be null."], ["@B_java#lang#String_E@", "String: the algorithm to use for encryption and decryption ciphers. The algorithm string conforms to JCA Standard Names for Cipher Transforms and is case insensitive. For example \"AES/CBC/NoPadding\". This value must never be null."], ["@B_java#lang#String_E@", "String: the algorithm to use for sign and verify The algorithm string conforms to JCA Standard Names for Mac Algorithms and is case insensitive. For example \"HmacSHA256\". The list of supported algorithms for a DRM plugin can be obtained using the method getPropertyString(String) with the property name \"algorithms\". This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Obtain a CryptoSession object which can be used to encrypt, decrypt, sign and verify messages or data using the session keys established for the session using methods @B_android#media#MediaDrm#getKeyRequest_E@ and @B_android#media#MediaDrm#provideKeyResponse_E@ using a session key server.", "history": "Added in API level 18", "FullName": "public MediaDrm.CryptoSession getCryptoSession (byte[] sessionId, String cipherAlgorithm, String macAlgorithm)"}, "setOnEventListener(java.util.concurrent.Executor,android.media.MediaDrm.OnEventListener)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#Executor_E@", "Executor: the executor through which the listener should be invoked This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#media#MediaDrm#OnEventListener_E@", "MediaDrm.OnEventListener: the callback that will be run. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#media#MediaDrm#setOnEventListener_E@"], "Permissions": [], "Description": "Register a callback to be invoked when an event occurs", "history": "Added in API level 29", "FullName": "public void setOnEventListener (Executor executor, MediaDrm.OnEventListener listener)"}, "setOnKeyStatusChangeListener(android.media.MediaDrm.OnKeyStatusChangeListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaDrm#OnKeyStatusChangeListener_E@", "MediaDrm.OnKeyStatusChangeListener: the callback that will be run when key status changes, or null to unregister the previously registered callback. This value may be null."], ["@B_android#os#Handler_E@", "Handler: the handler on which the listener should be invoked, or null if the listener should be invoked on the calling thread's looper. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the state of keys in a session change, e.g. when a license update occurs or when a license expires.", "history": "Added in API level 23", "FullName": "public void setOnKeyStatusChangeListener (MediaDrm.OnKeyStatusChangeListener listener, Handler handler)"}, "removeAllSecureStops()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove all secure stops without requiring a secure stop release message from the license server. This method was added in API 28. In API versions 18 through 27, @B_android#media#MediaDrm#releaseAllSecureStops_E@ should be called instead. There is no need to do anything for API versions prior to 18.", "history": "Added in API level 28", "FullName": "public void removeAllSecureStops ()"}, "isCryptoSchemeSupported(java.util.UUID,java.lang.String)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#util#UUID_E@", "UUID: The UUID of the crypto scheme. This value must never be null."], ["@B_java#lang#String_E@", "String: The MIME type of the media container, e.g. \"video/mp4\" or \"video/webm\" This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Query if the given scheme identified by its UUID is supported on this device, and whether the DRM plugin is able to handle the media container format specified by mimeType.", "history": "Added in API level 19", "FullName": "public static boolean isCryptoSchemeSupported (UUID uuid, String mimeType)"}, "restoreKeys(byte[],byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: the session ID for the DRM session This value must never be null."], ["byte[]", "byte: identifies the saved key set to restore This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Restore persisted offline keys into a new session. keySetId identifies the keys to load, obtained from a prior call to @B_android#media#MediaDrm#provideKeyResponse_E@.", "history": "Added in API level 18", "FullName": "public void restoreKeys (byte[] sessionId, byte[] keySetId)"}, "setPropertyByteArray(java.lang.String,byte[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: This value must never be null."], ["byte[]", "byte: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a MediaDrm byte array property value, given the property name string and new value for the property.", "history": "Added in API level 18", "FullName": "public void setPropertyByteArray (String propertyName, byte[] value)"}, "isCryptoSchemeSupported(java.util.UUID,java.lang.String,int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#util#UUID_E@", "UUID: The UUID of the crypto scheme. This value must never be null."], ["@B_java#lang#String_E@", "String: The MIME type of the media container, e.g. \"video/mp4\" or \"video/webm\" This value must never be null."], ["int", "int: the security level requested Value is @B_android#media#MediaDrm#SECURITY_LEVEL_UNKNOWN_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_SW_SECURE_CRYPTO_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_SW_SECURE_DECODE_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_HW_SECURE_CRYPTO_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_HW_SECURE_DECODE_E@, or @B_android#media#MediaDrm#SECURITY_LEVEL_HW_SECURE_ALL_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Query if the given scheme identified by its UUID is supported on this device, and whether the DRM plugin is able to handle the media container format specified by mimeType at the requested security level.", "history": "Added in API level 29", "FullName": "public static boolean isCryptoSchemeSupported (UUID uuid, String mimeType, int securityLevel)"}, "provideKeyResponse(byte[], byte[])": {"Returns": [["byte[]", "If the response is for an offline request, the keySetId for the offline keys will be returned. If the response is for a streaming or release request an empty byte array will be returned.This value may be null."]], "Parameters": [["byte[]", "byte: may be a sessionId or keySetId depending on the type of the response. Scope should be set to the sessionId when the response is for either streaming or offline key requests. Scope should be set to the keySetId when the response is for a release request.This value must never be null."], ["byte[]", "byte: the byte array response from the serverThis value must never be null."]], "Throws": [["@B_android#media#NotProvisionedException_E@", "if the response indicates that reprovisioning is required"], ["@B_android#media#DeniedByServerException_E@", "if the response indicates that the server rejected the request"]], "SeeAlso": [], "Permissions": [], "Description": "A key response is received from the license server by the app, then it is provided to the MediaDrm instance using provideKeyResponse. When the response is for an offline key request, a keySetId is returned that can be used to later restore the keys to a new session with the method @B_android#media#MediaDrm#restoreKeys_E@. When the response is for a streaming or release request, an empty byte array is returned.", "history": "added in API level 18", "FullName": "public byte[] provideKeyResponse (byte[] scope, byte[] response)"}, "removeSecureStop(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: the ID of the secure stop to remove This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove a specific secure stop without requiring a secure stop release message from the license server.", "history": "Added in API level 28", "FullName": "public void removeSecureStop (byte[] ssid)"}, "getSecureStopIds()": {"Returns": [["@B_java#util#List_E@", "a list of secure stop IDs This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a list of all secure stop IDs currently in persistent memory. The secure stop ID can be used to access or remove the corresponding secure stop.", "history": "Added in API level 28", "FullName": "public List<byte[]> getSecureStopIds ()"}, "openSession()": {"Returns": [["byte[]", "This value will never be null."]], "Parameters": [], "Throws": [["@B_android#media#NotProvisionedException_E@", "if provisioning is needed"], ["@B_android#media#ResourceBusyException_E@", "if required resources are in use"]], "SeeAlso": [], "Permissions": [], "Description": "Open a new session with the MediaDrm object. A session ID is returned. By default, sessions are opened at the native security level of the device.", "history": "Added in API level 18", "FullName": "public byte[] openSession ()"}, "provideProvisionResponse(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: the opaque provisioning response byte array to provide to the MediaDrm instance. This value must never be null."]], "Throws": [["@B_android#media#DeniedByServerException_E@", "if the response indicates that the server rejected the request"]], "SeeAlso": [], "Permissions": [], "Description": "After a provision response is received by the app, it is provided to the MediaDrm instance using this method.", "history": "Added in API level 18", "FullName": "public void provideProvisionResponse (byte[] response)"}, "queryKeyStatus(byte[])": {"Returns": [["@B_java#util#HashMap_E@", "This value will never be null."]], "Parameters": [["byte[]", "byte: the session ID for the DRM session This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request an informative description of the key status for the session. The status is in the form of {name, value} pairs. Since DRM license policies vary by vendor, the specific status field names are determined by each DRM vendor. Refer to your DRM provider documentation for definitions of the field names for a particular DRM plugin.", "history": "Added in API level 18", "FullName": "public HashMap<String, String> queryKeyStatus (byte[] sessionId)"}, "getMaxSecurityLevel()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a value that may be passed as a parameter to @B_android#media#MediaDrm#openSession_E@ requesting that the session be opened at the maximum security level of the device.", "history": "Added in API level 28", "FullName": "public static int getMaxSecurityLevel ()"}, "setOnEventListener(android.media.MediaDrm.OnEventListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaDrm#OnEventListener_E@", "MediaDrm.OnEventListener: the callback that will be run. Use null to stop receiving event callbacks. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#media#MediaDrm#setOnEventListener_E@"], "Permissions": [], "Description": "Register a callback to be invoked when an event occurs", "history": "Added in API level 18", "FullName": "public void setOnEventListener (MediaDrm.OnEventListener listener)"}, "openSession(int)": {"Returns": [["byte[]", "This value will never be null."]], "Parameters": [["int", "int: the new security level Value is @B_android#media#MediaDrm#SECURITY_LEVEL_UNKNOWN_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_SW_SECURE_CRYPTO_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_SW_SECURE_DECODE_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_HW_SECURE_CRYPTO_E@, @B_android#media#MediaDrm#SECURITY_LEVEL_HW_SECURE_DECODE_E@, or @B_android#media#MediaDrm#SECURITY_LEVEL_HW_SECURE_ALL_E@"]], "Throws": [["@B_android#media#NotProvisionedException_E@", "if provisioning is needed"], ["@B_android#media#ResourceBusyException_E@", "if required resources are in use"], ["@B_java#lang#IllegalArgumentException_E@", "if the requested security level is higher than the native level or lower than the lowest supported level or if the device does not support specifying the security level when opening a session"]], "SeeAlso": [], "Permissions": [], "Description": "Open a new session at a requested security level. The security level represents the robustness of the device's DRM implementation. By default, sessions are opened at the native security level of the device. Overriding the security level is necessary when the decrypted frames need to be manipulated, such as for image compositing. The security level parameter must be lower than the native level. Reducing the security level will typically limit the content to lower resolutions, as determined by the license policy. If the requested level is not supported, the next lower supported security level will be set. The level can be queried using @B_android#media#MediaDrm#getSecurityLevel_E@. A session ID is returned.", "history": "Added in API level 28", "FullName": "public byte[] openSession (int level)"}, "clearOnEventListener()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clear the @B_android#media#MediaDrm#OnEventListener_E@.", "history": "Added in API level 29", "FullName": "public void clearOnEventListener ()"}, "releaseSecureStops(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: the server response indicating which secure stops to release This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Process the secure stop server response message ssRelease. After authenticating the message, remove the secure stops identified in the response.", "history": "Added in API level 18", "FullName": "public void releaseSecureStops (byte[] ssRelease)"}}, "Inheritance": [], "ClassName": "android.media.MediaDrm", "ClassDesc": "MediaDrm can be used to obtain keys for decrypting protected media streams, in conjunction with @B_android#media#MediaCrypto_E@. The MediaDrm APIs are designed to support the ISO/IEC 23001-7: Common Encryption standard, but may also be used to implement other encryption schemes. Encrypted content is prepared using an encryption server and stored in a content library. The encrypted content is streamed or downloaded from the content library to client devices via content servers. Licenses to view the content are obtained from a License Server. Keys are requested from the license server using a key request. The key response is delivered to the client app, which provides the response to the MediaDrm API. A Provisioning server may be required to distribute device-unique credentials to the devices. Enforcing requirements related to the number of devices that may play content simultaneously can be performed either through key renewal or using the secure stop methods. The following sequence diagram shows the interactions between the objects involved while playing back encrypted content: The app first constructs @B_android#media#MediaExtractor_E@ and @B_android#media#MediaCodec_E@ objects. It accesses the DRM-scheme-identifying UUID, typically from metadata in the content, and uses this UUID to construct an instance of a MediaDrm object that is able to support the DRM scheme required by the content. Crypto schemes are assigned 16 byte UUIDs. The method @B_android#media#MediaDrm#isCryptoSchemeSupported_E@ can be used to query if a given scheme is supported on the device. The app calls @B_android#media#MediaDrm#openSession_E@ to generate a sessionId that will uniquely identify the session in subsequent interactions. The app next uses the MediaDrm object to obtain a key request message and send it to the license server, then provide the server's response to the MediaDrm object. Once the app has a sessionId, it can construct a MediaCrypto object from the UUID and sessionId. The MediaCrypto object is registered with the MediaCodec in the @B_android#media#MediaCodec#configure_E@ method to enable the codec to decrypt content. When the app has constructed @B_android#media#MediaExtractor_E@, @B_android#media#MediaCodec_E@ and @B_android#media#MediaCrypto_E@ objects, it proceeds to pull samples from the extractor and queue them into the decoder. For encrypted content, the samples returned from the extractor remain encrypted, they are only decrypted when the samples are delivered to the decoder. MediaDrm methods throw @B_android#media#MediaDrm#MediaDrmStateException_E@ when a method is called on a MediaDrm object that has had an unrecoverable failure in the DRM plugin or security hardware. @B_android#media#MediaDrm#MediaDrmStateException_E@ extends @B_java#lang#IllegalStateException_E@ with the addition of a developer-readable diagnostic information string associated with the exception. In the event of a mediaserver process crash or restart while a MediaDrm object is active, MediaDrm methods may throw @B_android#media#MediaDrmResetException_E@. To recover, the app must release the MediaDrm object, then create and initialize a new one. As @B_android#media#MediaDrmResetException_E@ and @B_android#media#MediaDrm#MediaDrmStateException_E@ both extend @B_java#lang#IllegalStateException_E@, they should be in an earlier catch() block than @B_java#lang#IllegalStateException_E@ if handled separately. Applications should register for informational events in order to be informed of key state updates during playback or streaming. Registration for these events is done via a call to @B_android#media#MediaDrm#setOnEventListener_E@. In order to receive the respective callback associated with this listener, applications are required to create MediaDrm objects on a thread with its own Looper running (main UI thread by default has a Looper running)."}