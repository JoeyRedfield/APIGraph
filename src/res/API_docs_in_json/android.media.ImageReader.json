{"Functions": {"discardFreeBuffers()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Discard any free buffers owned by this ImageReader. Generally, the ImageReader caches buffers for reuse once they have been allocated, for best performance. However, sometimes it may be important to release all the cached, unused buffers to save on memory. Calling this method will discard all free cached buffers. This does not include any buffers associated with Images acquired from the ImageReader, any filled buffers waiting to be acquired, and any buffers currently in use by the source rendering buffers into the ImageReader's Surface. The ImageReader continues to be usable after this call, but may need to reallocate buffers when more buffers are needed for rendering.", "history": "Added in API level 28", "FullName": "public void discardFreeBuffers ()"}, "getImageFormat()": {"Returns": [["int", "the expected format of an Image"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#graphics#ImageFormat_E@"], "Permissions": [], "Description": "The default @B_android#graphics#ImageFormat_E@ of @B_android#media#Image_E@. Some color formats may be overridden by the producer sending buffers to this ImageReader's Surface if the default color format allows. ImageReader guarantees that all @B_android#media#Image_E@ acquired from ImageReader (for example, with @B_android#media#ImageReader#acquireNextImage_E@) will have a \"compatible\" format to what was specified in @B_android#media#ImageReader#newInstance_E@. As of now, each format is only compatible to itself. The actual format of the images can be found using @B_android#media#Image#getFormat_E@.", "history": "Added in API level 19", "FullName": "public int getImageFormat ()"}, "newInstance(int,int,int,int)": {"Returns": [["@B_android#media#ImageReader_E@", "This value will never be null."]], "Parameters": [["int", "int: The default width in pixels of the Images that this reader will produce. Value is 1 or greater"], ["int", "int: The default height in pixels of the Images that this reader will produce. Value is 1 or greater"], ["int", "int: The format of the Image that this reader will produce. This must be one of the @B_android#graphics#ImageFormat_E@ or @B_android#graphics#PixelFormat_E@ constants. Note that not all formats are supported, like ImageFormat.NV21. Value is @B_android#graphics#ImageFormat#UNKNOWN_E@, @B_android#graphics#ImageFormat#RGB_565_E@, @B_android#graphics#ImageFormat#YV12_E@, @B_android#graphics#ImageFormat#Y8_E@, android.graphics.ImageFormat.Y16, @B_android#graphics#ImageFormat#NV16_E@, @B_android#graphics#ImageFormat#NV21_E@, @B_android#graphics#ImageFormat#YUY2_E@, @B_android#graphics#ImageFormat#JPEG_E@, @B_android#graphics#ImageFormat#DEPTH_JPEG_E@, @B_android#graphics#ImageFormat#YUV_420_888_E@, @B_android#graphics#ImageFormat#YUV_422_888_E@, @B_android#graphics#ImageFormat#YUV_444_888_E@, @B_android#graphics#ImageFormat#FLEX_RGB_888_E@, @B_android#graphics#ImageFormat#FLEX_RGBA_8888_E@, @B_android#graphics#ImageFormat#RAW_SENSOR_E@, @B_android#graphics#ImageFormat#RAW_PRIVATE_E@, @B_android#graphics#ImageFormat#RAW10_E@, @B_android#graphics#ImageFormat#RAW12_E@, @B_android#graphics#ImageFormat#DEPTH16_E@, @B_android#graphics#ImageFormat#DEPTH_POINT_CLOUD_E@, android.graphics.ImageFormat.RAW_DEPTH, @B_android#graphics#ImageFormat#PRIVATE_E@, or @B_android#graphics#ImageFormat#HEIC_E@"], ["int", "int: The maximum number of images the user will want to access simultaneously. This should be as small as possible to limit memory use. Once maxImages Images are obtained by the user, one of them has to be released before a new Image will become available for access through @B_android#media#ImageReader#acquireLatestImage_E@ or @B_android#media#ImageReader#acquireNextImage_E@. Must be greater than 0. Value is 1 or greater"]], "Throws": [], "SeeAlso": ["@B_android#media#Image_E@"], "Permissions": [], "Description": "Create a new reader for images of the desired size and format. The maxImages parameter determines the maximum number of @B_android#media#Image_E@ objects that can be be acquired from the ImageReader simultaneously. Requesting more buffers will use up more memory, so it is important to use only the minimum number necessary for the use case. The valid sizes and formats depend on the source of the image data. If the format is @B_android#graphics#ImageFormat#PRIVATE_E@, the created @B_android#media#ImageReader_E@ will produce images that are not directly accessible by the application. The application can still acquire images from this @B_android#media#ImageReader_E@, and send them to the @B_android#hardware#camera2#CameraDevice_E@ for reprocessing via @B_android#media#ImageWriter_E@ interface. However, the @B_android#media#Image#getPlanes_E@ will return an empty array for @B_android#graphics#ImageFormat#PRIVATE_E@ format images. The application can check if an existing reader's format by calling @B_android#media#ImageReader#getImageFormat_E@. @B_android#graphics#ImageFormat#PRIVATE_E@ format @B_android#media#ImageReader_E@ are more efficient to use when application access to image data is not necessary, compared to ImageReaders using other format such as @B_android#graphics#ImageFormat#YUV_420_888_E@.", "history": "Added in API level 19", "FullName": "public static ImageReader newInstance (int width, int height, int format, int maxImages)"}, "setOnImageAvailableListener(android.media.ImageReader.OnImageAvailableListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#ImageReader#OnImageAvailableListener_E@", "ImageReader.OnImageAvailableListener: The listener that will be run."], ["@B_android#os#Handler_E@", "Handler: The handler on which the listener should be invoked, or null if the listener should be invoked on the calling thread's looper."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "If no handler specified and the calling thread has no looper."]], "SeeAlso": [], "Permissions": [], "Description": "Register a listener to be invoked when a new image becomes available from the ImageReader.", "history": "Added in API level 19", "FullName": "public void setOnImageAvailableListener (ImageReader.OnImageAvailableListener listener, Handler handler)"}, "close()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Free up all the resources associated with this ImageReader. After calling this method, this ImageReader can not be used. Calling any methods on this ImageReader and Images previously provided by @B_android#media#ImageReader#acquireNextImage_E@ or @B_android#media#ImageReader#acquireLatestImage_E@ will result in an @B_java#lang#IllegalStateException_E@, and attempting to read from @B_java#nio#ByteBuffer_E@ returned by an earlier @B_android#media#Image#Plane#getBuffer_E@ call will have undefined behavior.", "history": "Added in API level 19", "FullName": "public void close ()"}, "newInstance(int,int,int,int,long)": {"Returns": [["@B_android#media#ImageReader_E@", "This value will never be null."]], "Parameters": [["int", "int: The default width in pixels of the Images that this reader will produce. Value is 1 or greater"], ["int", "int: The default height in pixels of the Images that this reader will produce. Value is 1 or greater"], ["int", "int: The format of the Image that this reader will produce. This must be one of the @B_android#graphics#ImageFormat_E@ or @B_android#graphics#PixelFormat_E@ constants. Note that not all formats are supported, like ImageFormat.NV21. Value is @B_android#graphics#ImageFormat#UNKNOWN_E@, @B_android#graphics#ImageFormat#RGB_565_E@, @B_android#graphics#ImageFormat#YV12_E@, @B_android#graphics#ImageFormat#Y8_E@, android.graphics.ImageFormat.Y16, @B_android#graphics#ImageFormat#NV16_E@, @B_android#graphics#ImageFormat#NV21_E@, @B_android#graphics#ImageFormat#YUY2_E@, @B_android#graphics#ImageFormat#JPEG_E@, @B_android#graphics#ImageFormat#DEPTH_JPEG_E@, @B_android#graphics#ImageFormat#YUV_420_888_E@, @B_android#graphics#ImageFormat#YUV_422_888_E@, @B_android#graphics#ImageFormat#YUV_444_888_E@, @B_android#graphics#ImageFormat#FLEX_RGB_888_E@, @B_android#graphics#ImageFormat#FLEX_RGBA_8888_E@, @B_android#graphics#ImageFormat#RAW_SENSOR_E@, @B_android#graphics#ImageFormat#RAW_PRIVATE_E@, @B_android#graphics#ImageFormat#RAW10_E@, @B_android#graphics#ImageFormat#RAW12_E@, @B_android#graphics#ImageFormat#DEPTH16_E@, @B_android#graphics#ImageFormat#DEPTH_POINT_CLOUD_E@, android.graphics.ImageFormat.RAW_DEPTH, @B_android#graphics#ImageFormat#PRIVATE_E@, or @B_android#graphics#ImageFormat#HEIC_E@"], ["int", "int: The maximum number of images the user will want to access simultaneously. This should be as small as possible to limit memory use. Once maxImages Images are obtained by the user, one of them has to be released before a new Image will become available for access through @B_android#media#ImageReader#acquireLatestImage_E@ or @B_android#media#ImageReader#acquireNextImage_E@. Must be greater than 0. Value is 1 or greater"], ["long", "long: The intended usage of the images produced by this ImageReader. See the usages on @B_android#hardware#HardwareBuffer_E@ for a list of valid usage bits. See also @B_android#hardware#HardwareBuffer#isSupported_E@ for checking if a combination is supported. If it's not supported this will throw an @B_java#lang#IllegalArgumentException_E@. Value is either 0 or a combination of @B_android#hardware#HardwareBuffer#USAGE_CPU_READ_RARELY_E@, @B_android#hardware#HardwareBuffer#USAGE_CPU_READ_OFTEN_E@, @B_android#hardware#HardwareBuffer#USAGE_CPU_WRITE_RARELY_E@, @B_android#hardware#HardwareBuffer#USAGE_CPU_WRITE_OFTEN_E@, @B_android#hardware#HardwareBuffer#USAGE_GPU_SAMPLED_IMAGE_E@, @B_android#hardware#HardwareBuffer#USAGE_GPU_COLOR_OUTPUT_E@, @B_android#hardware#HardwareBuffer#USAGE_PROTECTED_CONTENT_E@, @B_android#hardware#HardwareBuffer#USAGE_VIDEO_ENCODE_E@, @B_android#hardware#HardwareBuffer#USAGE_GPU_DATA_BUFFER_E@, @B_android#hardware#HardwareBuffer#USAGE_SENSOR_DIRECT_DATA_E@, @B_android#hardware#HardwareBuffer#USAGE_GPU_CUBE_MAP_E@, and @B_android#hardware#HardwareBuffer#USAGE_GPU_MIPMAP_COMPLETE_E@"]], "Throws": [], "SeeAlso": ["@B_android#media#Image_E@", "@B_android#hardware#HardwareBuffer_E@"], "Permissions": [], "Description": "Create a new reader for images of the desired size, format and consumer usage flag. The maxImages parameter determines the maximum number of @B_android#media#Image_E@ objects that can be be acquired from the ImageReader simultaneously. Requesting more buffers will use up more memory, so it is important to use only the minimum number necessary for the use case. The valid sizes and formats depend on the source of the image data. The format and usage flag combination describes how the buffer will be used by consumer end-points. For example, if the application intends to send the images to @B_android#media#MediaCodec_E@ or @B_android#media#MediaRecorder_E@ for hardware video encoding, the format and usage flag combination needs to be @B_android#graphics#ImageFormat#PRIVATE_E@ and @B_android#hardware#HardwareBuffer#USAGE_VIDEO_ENCODE_E@. When an @B_android#media#ImageReader_E@ object is created with a valid size and such format/usage flag combination, the application can send the @B_android#media#Image_E@ to an @B_android#media#ImageWriter_E@ that is created with the input @B_android#view#Surface_E@ provided by the @B_android#media#MediaCodec_E@ or @B_android#media#MediaRecorder_E@. If the format is @B_android#graphics#ImageFormat#PRIVATE_E@, the created @B_android#media#ImageReader_E@ will produce images that are not directly accessible by the application. The application can still acquire images from this @B_android#media#ImageReader_E@, and send them to the @B_android#hardware#camera2#CameraDevice_E@ for reprocessing, or to the @B_android#media#MediaCodec_E@ / @B_android#media#MediaRecorder_E@ for hardware video encoding via @B_android#media#ImageWriter_E@ interface. However, the @B_android#media#Image#getPlanes_E@ will return an empty array for @B_android#graphics#ImageFormat#PRIVATE_E@ format images. The application can check if an existing reader's format by calling @B_android#media#ImageReader#getImageFormat_E@. @B_android#graphics#ImageFormat#PRIVATE_E@ format @B_android#media#ImageReader_E@ are more efficient to use when application access to image data is not necessary, compared to ImageReaders using other format such as @B_android#graphics#ImageFormat#YUV_420_888_E@. Note that not all format and usage flag combinations are supported by the @B_android#media#ImageReader_E@. Below are the supported combinations by the @B_android#media#ImageReader_E@ (assuming the consumer end-points support the such image consumption, e.g., hardware video encoding). @B_java#lang#IllegalArgumentException_E@.", "history": "Added in API level 29", "FullName": "public static ImageReader newInstance (int width, int height, int format, int maxImages, long usage)"}, "newInstance(int, int, int, int)": {"Returns": [["@B_android#media#ImageReader_E@", "no returns description in source"]], "Parameters": [["int", "int: The default width in pixels of the Images that this reader will produce."], ["int", "int: The default height in pixels of the Images that this reader will produce."], ["int", "int: The format of the Image that this reader will produce. This must be one of the @B_android#graphics#ImageFormat_E@ or @B_android#graphics#PixelFormat_E@ constants. Note that not all formats are supported, like ImageFormat.NV21."], ["int", "int: The maximum number of images the user will want to access simultaneously. This should be as small as possible to limit memory use. Once maxImages Images are obtained by the user, one of them has to be released before a new Image will become available for access through @B_android#media#ImageReader#acquireLatestImage_E@ or @B_android#media#ImageReader#acquireNextImage_E@. Must be greater than 0."]], "Throws": [], "SeeAlso": ["@B_android#media#Image_E@"], "Permissions": [], "Description": "Create a new reader for images of the desired size and format. The maxImages parameter determines the maximum number of @B_android#media#Image_E@ objects that can be be acquired from the ImageReader simultaneously. Requesting more buffers will use up more memory, so it is important to use only the minimum number necessary for the use case. The valid sizes and formats depend on the source of the image data. If the format is @B_android#graphics#ImageFormat#PRIVATE_E@, the created @B_android#media#ImageReader_E@ will produce images that are not directly accessible by the application. The application can still acquire images from this @B_android#media#ImageReader_E@, and send them to the @B_android#hardware#camera2#CameraDevice_E@ for reprocessing via @B_android#media#ImageWriter_E@ interface. However, the @B_android#media#Image#getPlanes_E@ will return an empty array for @B_android#graphics#ImageFormat#PRIVATE_E@ format images. The application can check if an existing reader's format by calling @B_android#media#ImageReader#getImageFormat_E@. @B_android#graphics#ImageFormat#PRIVATE_E@ format @B_android#media#ImageReader_E@ are more efficient to use when application access to image data is not necessary, compared to ImageReaders using other format such as @B_android#graphics#ImageFormat#YUV_420_888_E@.", "history": "added in API level 19", "FullName": "public static ImageReader newInstance (int width, int height, int format, int maxImages)"}, "getMaxImages()": {"Returns": [["int", "Maximum number of images for this ImageReader."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#Image#close_E@"], "Permissions": [], "Description": "Maximum number of images that can be acquired from the ImageReader by any time (for example, with @B_android#media#ImageReader#acquireNextImage_E@). An image is considered acquired after it's returned by a function from ImageReader, and until the Image is @B_android#media#Image#close_E@ to release the image back to the ImageReader. Attempting to acquire more than maxImages concurrently will result in the acquire function throwing a @B_java#lang#IllegalStateException_E@. Furthermore, while the max number of images have been acquired by the ImageReader user, the producer enqueueing additional images may stall until at least one image has been released.", "history": "Added in API level 19", "FullName": "public int getMaxImages ()"}, "acquireLatestImage()": {"Returns": [["@B_android#media#Image_E@", "latest frame of image data, or null if no image data is available."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if too many images are currently acquired"]], "SeeAlso": [], "Permissions": [], "Description": "Acquire the latest @B_android#media#Image_E@ from the ImageReader's queue, dropping older @B_android#media#Image_E@. Returns null if no new image is available. This operation will acquire all the images possible from the ImageReader, but @B_android#media#ImageReader#close_E@ all images that aren't the latest. This function is recommended to use over @B_android#media#ImageReader#acquireNextImage_E@ for most use-cases, as it's more suited for real-time processing. Note that @B_android#media#ImageReader#getMaxImages_E@ should be at least 2 for @B_android#media#ImageReader#acquireLatestImage_E@ to be any different than @B_android#media#ImageReader#acquireNextImage_E@ - discarding all-but-the-newest @B_android#media#Image_E@ requires temporarily acquiring two @B_android#media#Image_E@ at once. Or more generally, calling @B_android#media#ImageReader#acquireLatestImage_E@ with less than two images of margin, that is (maxImages - currentAcquiredImages < 2) will not discard as expected. This operation will fail by throwing an @B_java#lang#IllegalStateException_E@ if maxImages have been acquired with @B_android#media#ImageReader#acquireLatestImage_E@ or @B_android#media#ImageReader#acquireNextImage_E@. In particular a sequence of @B_android#media#ImageReader#acquireLatestImage_E@ calls greater than @B_android#media#ImageReader#getMaxImages_E@ without calling @B_android#media#Image#close_E@ in-between will exhaust the underlying queue. At such a time, @B_java#lang#IllegalStateException_E@ will be thrown until more images are released with @B_android#media#Image#close_E@.", "history": "Added in API level 19", "FullName": "public Image acquireLatestImage ()"}, "getHeight()": {"Returns": [["int", "the expected height of an Image"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The default height of @B_android#media#Image_E@, in pixels. The height may be overridden by the producer sending buffers to this ImageReader's Surface. If so, the actual height of the images can be found using @B_android#media#Image#getHeight_E@.", "history": "Added in API level 19", "FullName": "public int getHeight ()"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#Throwable_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 19", "FullName": "protected void finalize ()"}, "getSurface()": {"Returns": [["@B_android#view#Surface_E@", "A @B_android#view#Surface_E@ to use for a drawing target for various APIs."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get a @B_android#view#Surface_E@ that can be used to produce @B_android#media#Image_E@ for this ImageReader. Until valid image data is rendered into this @B_android#view#Surface_E@, the @B_android#media#ImageReader#acquireNextImage_E@ method will return null. Only one source can be producing data into this Surface at the same time, although the same @B_android#view#Surface_E@ can be reused with a different API once the first source is disconnected from the @B_android#view#Surface_E@. Please note that holding on to the Surface object returned by this method is not enough to keep its parent ImageReader from being reclaimed. In that sense, a Surface acts like a @B_java#lang#ref#WeakReference_E@ to the ImageReader that provides it.", "history": "Added in API level 19", "FullName": "public Surface getSurface ()"}, "getWidth()": {"Returns": [["int", "the expected width of an Image"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The default width of @B_android#media#Image_E@, in pixels. The width may be overridden by the producer sending buffers to this ImageReader's Surface. If so, the actual width of the images can be found using @B_android#media#Image#getWidth_E@.", "history": "Added in API level 19", "FullName": "public int getWidth ()"}, "acquireNextImage()": {"Returns": [["@B_android#media#Image_E@", "a new frame of image data, or null if no image data is available."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if maxImages images are currently acquired"]], "SeeAlso": ["@B_android#media#ImageReader#acquireLatestImage_E@"], "Permissions": [], "Description": "Acquire the next Image from the ImageReader's queue. Returns null if no new image is available. @B_android#media#ImageReader#acquireLatestImage_E@ instead, as it will automatically release older images, and allow slower-running processing routines to catch up to the newest frame. Usage of @B_android#media#ImageReader#acquireNextImage_E@ is recommended for batch/background processing. Incorrectly using this function can cause images to appear with an ever-increasing delay, followed by a complete stall where no new images seem to appear. This operation will fail by throwing an @B_java#lang#IllegalStateException_E@ if maxImages have been acquired with @B_android#media#ImageReader#acquireNextImage_E@ or @B_android#media#ImageReader#acquireLatestImage_E@. In particular a sequence of @B_android#media#ImageReader#acquireNextImage_E@ or @B_android#media#ImageReader#acquireLatestImage_E@ calls greater than @B_android#media#ImageReader#getMaxImages_E@ without calling @B_android#media#Image#close_E@ in-between will exhaust the underlying queue. At such a time, @B_java#lang#IllegalStateException_E@ will be thrown until more images are released with @B_android#media#Image#close_E@.", "history": "Added in API level 19", "FullName": "public Image acquireNextImage ()"}}, "Inheritance": [], "ClassName": "android.media.ImageReader", "ClassDesc": "The ImageReader class allows direct application access to image data rendered into a @B_android#view#Surface_E@ Several Android media API classes accept Surface objects as targets to render to, including @B_android#media#MediaPlayer_E@, @B_android#media#MediaCodec_E@, @B_android#hardware#camera2#CameraDevice_E@, @B_android#media#ImageWriter_E@ and @B_android#renderscript#Allocation_E@. The image sizes and formats that can be used with each source vary, and should be checked in the documentation for the specific API. The image data is encapsulated in @B_android#media#Image_E@ objects, and multiple such objects can be accessed at the same time, up to the number specified by the maxImages constructor parameter. New images sent to an ImageReader through its @B_android#view#Surface_E@ are queued until accessed through the @B_android#media#ImageReader#acquireLatestImage_E@ or @B_android#media#ImageReader#acquireNextImage_E@ call. Due to memory limits, an image source will eventually stall or drop Images in trying to render to the Surface if the ImageReader does not obtain and release Images at a rate equal to the production rate."}