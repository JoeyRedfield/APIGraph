{"Functions": {"ActivityGroup()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public ActivityGroup ()"}, "onStop()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when you are no longer visible to the user. You will next receive either @B_android#app#Activity#onRestart_E@, @B_android#app#Activity#onDestroy_E@, or nothing, depending on later user activity. This is a good place to stop refreshing UI, running animations and other visual things. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1 Deprecated in API level 13", "FullName": "protected void onStop ()"}, "ActivityGroup(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public ActivityGroup (boolean singleActivityMode)"}, "onResume()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called after @B_android#app#Activity#onRestoreInstanceState_E@, @B_android#app#Activity#onRestart_E@, or @B_android#app#Activity#onPause_E@, for your activity to start interacting with the user. This is an indicator that the activity became active and ready to receive input. It is on top of an activity stack and visible to user. On platform versions prior to @B_android#os#Build#VERSION_CODES#Q_E@ this is also a good place to try to open exclusive-access devices or to get access to singleton resources. Starting with @B_android#os#Build#VERSION_CODES#Q_E@ there can be multiple resumed activities in the system simultaneously, so @B_android#app#Activity#onTopResumedActivityChanged_E@ should be used for that purpose instead. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1 Deprecated in API level 13", "FullName": "protected void onResume ()"}, "onDestroy()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform any final cleanup before an activity is destroyed. This can happen either because the activity is finishing (someone called @B_android#app#Activity#finish_E@ on it), or because the system is temporarily destroying this instance of the activity to save space. You can distinguish between these two scenarios with the @B_android#app#Activity#isFinishing_E@ method. Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either @B_android#app#Activity#onPause_E@ or @B_android#app#Activity#onSaveInstanceState_E@, not here. This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running. There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1 Deprecated in API level 13", "FullName": "protected void onDestroy ()"}, "getCurrentActivity()": {"Returns": [["@B_android#app#Activity_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1 Deprecated in API level 13", "FullName": "public Activity getCurrentActivity ()"}, "getLocalActivityManager()": {"Returns": [["@B_android#app#LocalActivityManager_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1 Deprecated in API level 13", "FullName": "public final LocalActivityManager getLocalActivityManager ()"}, "onCreate(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: If the activity is being re-initialized after previously being shut down then this Bundle contains the data it most recently supplied in @B_android#app#ActivityGroup#onSaveInstanceState_E@. Note: Otherwise it is null. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the activity is starting. This is where most initialization should go: calling @B_android#app#Activity#setContentView_E@ to inflate the activity's UI, using @B_android#app#Activity#findViewById_E@ to programmatically interact with widgets in the UI, calling @B_android#app#Activity#managedQuery_E@ to retrieve cursors for data being displayed, etc. You can call @B_android#app#Activity#finish_E@ from within this function, in which case onDestroy() will be immediately called after @B_android#app#Activity#onCreate_E@ without any of the rest of the activity lifecycle (@B_android#app#Activity#onStart_E@, @B_android#app#Activity#onResume_E@, @B_android#app#Activity#onPause_E@, etc) executing. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. This method must be called from the If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1 Deprecated in API level 13", "FullName": "protected void onCreate (Bundle savedInstanceState)"}, "onPause()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called as part of the activity lifecycle when the user no longer actively interacts with the activity, but it is still visible on screen. The counterpart to @B_android#app#Activity#onResume_E@. When activity B is launched in front of activity A, this callback will be invoked on A. B will not be created until A's @B_android#app#Activity#onPause_E@ returns, so be sure to not do anything lengthy here. This callback is mostly used for saving any persistent state the activity is editing, to present a \"edit in place\" model to the user and making sure nothing is lost if there are not enough resources to start the new activity without first killing this one. This is also a good place to stop things that consume a noticeable amount of CPU in order to make the switch to the next activity as fast as possible. On platform versions prior to @B_android#os#Build#VERSION_CODES#Q_E@ this is also a good place to try to close exclusive-access devices or to release access to singleton resources. Starting with @B_android#os#Build#VERSION_CODES#Q_E@ there can be multiple resumed activities in the system at the same time, so @B_android#app#Activity#onTopResumedActivityChanged_E@ should be used for that purpose instead. If an activity is launched on top, after receiving this call you will usually receive a following call to @B_android#app#Activity#onStop_E@ (after the next activity has been resumed and displayed above). However in some cases there will be a direct call back to @B_android#app#Activity#onResume_E@ without going through the stopped state. An activity can also rest in paused state in some cases when in multi-window mode, still visible to user. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1 Deprecated in API level 13", "FullName": "protected void onPause ()"}, "onSaveInstanceState(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: Bundle in which to place your saved state. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to retrieve per-instance state from an activity before being killed so that the state can be restored in @B_android#app#Activity#onCreate_E@ or @B_android#app#Activity#onRestoreInstanceState_E@ (the @B_android#os#Bundle_E@ populated by this method will be passed to both). This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via @B_android#app#Activity#onCreate_E@ or @B_android#app#Activity#onRestoreInstanceState_E@. Do not confuse this method with activity lifecycle callbacks such as @B_android#app#Activity#onPause_E@, which is always called when the user no longer actively interacts with an activity, or @B_android#app#Activity#onStop_E@ which is called when activity becomes invisible. One example of when @B_android#app#Activity#onPause_E@ and @B_android#app#Activity#onStop_E@ is called and not this method is when a user navigates back from activity B to activity A: there is no need to call @B_android#app#Activity#onSaveInstanceState_E@ on B because that particular instance will never be restored, so the system avoids calling it. An example when @B_android#app#Activity#onPause_E@ is called and not @B_android#app#Activity#onSaveInstanceState_E@ is when activity B is launched in front of activity A: the system may avoid calling @B_android#app#Activity#onSaveInstanceState_E@ on activity A if it isn't killed during the lifetime of B since the state of the user interface of A will stay intact. The default implementation takes care of most of the UI per-instance state for you by calling @B_android#view#View#onSaveInstanceState_E@ on each view in the hierarchy that has an id, and by saving the id of the currently focused view (all of which is restored by the default implementation of @B_android#app#Activity#onRestoreInstanceState_E@). If you override this method to save additional information not captured by each individual view, you will likely want to call through to the default implementation, otherwise be prepared to save all of the state of each view yourself. If called, this method will occur after @B_android#app#Activity#onStop_E@ for applications targeting platforms starting with @B_android#os#Build#VERSION_CODES#P_E@. For applications targeting earlier platform versions this method will occur before @B_android#app#Activity#onStop_E@ and there are no guarantees about whether it will occur before or after @B_android#app#Activity#onPause_E@.", "history": "Added in API level 1 Deprecated in API level 13", "FullName": "protected void onSaveInstanceState (Bundle outState)"}}, "Inheritance": ["@B_android#content#Context_E@", "@B_android#content#ContextWrapper_E@", "@B_android#view#ContextThemeWrapper_E@", "@B_android#app#Activity_E@"], "ClassName": "android.app.ActivityGroup", "ClassDesc": "Use the new @B_android#app#Fragment_E@ and @B_android#app#FragmentManager_E@ APIs instead; these are also available on older platforms through the Android compatibility package. A screen that contains and runs multiple embedded activities."}