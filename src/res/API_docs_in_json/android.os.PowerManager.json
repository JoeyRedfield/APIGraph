{"Functions": {"addThermalStatusListener(java.util.concurrent.Executor,android.os.PowerManager.OnThermalStatusChangedListener)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#Executor_E@", "Executor: @B_java#util#concurrent#Executor_E@ to handle listener callback. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#os#PowerManager#OnThermalStatusChangedListener_E@", "PowerManager.OnThermalStatusChangedListener: listener to be added. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function adds a listener for thermal status change.", "history": "Added in API level 29", "FullName": "public void addThermalStatusListener (Executor executor, PowerManager.OnThermalStatusChangedListener listener)"}, "removeThermalStatusListener(android.os.PowerManager.OnThermalStatusChangedListener)": {"Returns": [], "Parameters": [["@B_android#os#PowerManager#OnThermalStatusChangedListener_E@", "PowerManager.OnThermalStatusChangedListener: listener to be removed This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function removes a listener for thermal status change", "history": "Added in API level 29", "FullName": "public void removeThermalStatusListener (PowerManager.OnThermalStatusChangedListener listener)"}, "goToSleep(long)": {"Returns": [], "Parameters": [["long", "The time when the request to go to sleep was issued, in the @B_android#os#SystemClock#uptimeMillis_E@ time base. This timestamp is used to correctly order the go to sleep request with other power management functions. It should be set to the timestamp of the input event that caused the request to go to sleep."]], "Throws": [], "SeeAlso": ["@B_android#os#PowerManager#userActivity_E@", "@B_android#os#PowerManager#wakeUp_E@"], "Permissions": ["@B_android#Manifest#permission#DEVICE_POWER_E@"], "Description": "Forces the device to go to sleep. Overrides all the wake locks that are held. This is what happens when the power key is pressed to turn off the screen. Requires the @B_android#Manifest#permission#DEVICE_POWER_E@ permission.", "history": "Added in API level 1", "FullName": "public void goToSleep (long time)"}, "newWakeLock(int,java.lang.String)": {"Returns": [["@B_android#os#PowerManager#WakeLock_E@", "no returns description in source"]], "Parameters": [["int", "int: Combination of wake lock level and flag values defining the requested behavior of the WakeLock."], ["@B_java#lang#String_E@", "String: Your class name (or other tag) for debugging purposes."]], "Throws": [], "SeeAlso": ["@B_android#os#PowerManager#WakeLock#acquire_E@", "@B_android#os#PowerManager#WakeLock#release_E@", "@B_android#os#PowerManager_E@"], "Permissions": ["@B_android#Manifest#permission#WAKE_LOCK_E@"], "Description": "Creates a new wake lock with the specified level and flags. The levelAndFlags parameter specifies a wake lock level and optional flags combined using the logical OR operator. The wake lock levels are: @B_android#os#PowerManager#PARTIAL_WAKE_LOCK_E@, @B_android#os#PowerManager#FULL_WAKE_LOCK_E@, @B_android#os#PowerManager#SCREEN_DIM_WAKE_LOCK_E@ and @B_android#os#PowerManager#SCREEN_BRIGHT_WAKE_LOCK_E@. Exactly one wake lock level must be specified as part of the levelAndFlags parameter. The wake lock flags are: @B_android#os#PowerManager#ACQUIRE_CAUSES_WAKEUP_E@ and @B_android#os#PowerManager#ON_AFTER_RELEASE_E@. Multiple flags can be combined as part of the levelAndFlags parameters. Call @B_android#os#PowerManager#WakeLock#acquire_E@ on the object to acquire the wake lock, and @B_android#os#PowerManager#WakeLock#release_E@ when you are done. Although a wake lock can be created without special permissions, the @B_android#Manifest#permission#WAKE_LOCK_E@ permission is required to actually acquire or release the wake lock that is returned. If using this to keep the screen on, you should strongly consider using @B_android#view#WindowManager#LayoutParams#FLAG_KEEP_SCREEN_ON_E@ instead. This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. Recommended naming conventions for tags to make debugging easier: use a unique prefix delimited by a colon for your app/library (e.g. gmail:mytag) to make it easier to understand where the wake locks comes from. This namespace will also avoid collision for tags inside your app coming from different libraries which will make debugging easier. use constants (e.g. do not include timestamps in the tag) to make it easier for tools to aggregate similar wake locks. When collecting debugging data, the platform only monitors a finite number of tags, using constants will help tools to provide better debugging data. avoid using Class#getName() or similar method since this class name can be transformed by java optimizer and obfuscator tools. avoid wrapping the tag or a prefix to avoid collision with wake lock tags from the platform (e.g. *alarm*). never include personnally identifiable information for privacy reasons.", "history": "Added in API level 1", "FullName": "public PowerManager.WakeLock newWakeLock (int levelAndFlags, String tag)"}, "reboot(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: code to pass to the kernel (e.g., \"recovery\") to request special boot modes, or null."]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#REBOOT_E@"], "Description": "Reboot the device. Will not return if the reboot is successful. Requires the @B_android#Manifest#permission#REBOOT_E@ permission.", "history": "Added in API level 8", "FullName": "public void reboot (String reason)"}, "userActivity(long, boolean)": {"Returns": [], "Parameters": [["long", "The time of the user activity, in the @B_android#os#SystemClock#uptimeMillis_E@ time base. This timestamp is used to correctly order the user activity request with other power management functions. It should be set to the timestamp of the input event that caused the user activity."], ["boolean", "If true, does not cause the keyboard backlight to turn on because of this event. This is set when the power key is pressed. We want the device to stay on while the button is down, but we're about to turn off the screen so we don't want the keyboard backlight to turn on again. Otherwise the lights flash on and then off and it looks weird."]], "Throws": [], "SeeAlso": ["@B_android#os#PowerManager#wakeUp_E@", "@B_android#os#PowerManager#goToSleep_E@"], "Permissions": ["@B_android#Manifest#permission#DEVICE_POWER_E@"], "Description": "Notifies the power manager that user activity happened. Resets the auto-off timer and brightens the screen if the device is not asleep. This is what happens normally when a key or the touch screen is pressed or when some other user activity occurs. This method does not wake up the device if it has been put to sleep. Requires the @B_android#Manifest#permission#DEVICE_POWER_E@ permission.", "history": "Added in API level 1", "FullName": "public void userActivity (long when, boolean noChangeLights)"}, "isSustainedPerformanceModeSupported()": {"Returns": [["boolean", "Returns True if the device supports it, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#Window#setSustainedPerformanceMode_E@"], "Permissions": [], "Description": "This function checks if the device has implemented Sustained Performance Mode. This needs to be checked only once and is constant for a particular device/release. Sustained Performance Mode is intended to provide a consistent level of performance for prolonged amount of time. Applications should check if the device supports this mode, before using @B_android#view#Window#setSustainedPerformanceMode_E@.", "history": "Added in API level 24", "FullName": "public boolean isSustainedPerformanceModeSupported ()"}, "isIgnoringBatteryOptimizations(java.lang.String)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return whether the given application package name is on the device's power whitelist. Apps can be placed on the whitelist through the settings UI invoked by @B_android#provider#Settings#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS_E@.", "history": "Added in API level 23", "FullName": "public boolean isIgnoringBatteryOptimizations (String packageName)"}, "isWakeLockLevelSupported(int)": {"Returns": [["boolean", "True if the specified wake lock level is supported."]], "Parameters": [["int", "int: The wake lock level to check."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the specified wake lock level is supported.", "history": "Added in API level 21", "FullName": "public boolean isWakeLockLevelSupported (int level)"}, "isDeviceIdleMode()": {"Returns": [["boolean", "Returns true if currently in active device idle mode, else false. This is when idle mode restrictions are being actively applied; it will return false if the device is in a long-term idle mode but currently running a maintenance window where restrictions have been lifted."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the device is currently in idle mode. This happens when a device has been sitting unused and unmoving for a sufficiently long period of time, so that it decides to go into a lower power-use state. This may involve things like turning off network access to apps. You can monitor for changes to this state with @B_android#os#PowerManager#ACTION_DEVICE_IDLE_MODE_CHANGED_E@.", "history": "Added in API level 23", "FullName": "public boolean isDeviceIdleMode ()"}, "addThermalStatusListener(android.os.PowerManager.OnThermalStatusChangedListener)": {"Returns": [], "Parameters": [["@B_android#os#PowerManager#OnThermalStatusChangedListener_E@", "PowerManager.OnThermalStatusChangedListener: listener to be added, This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function adds a listener for thermal status change, listen call back will be enqueued tasks on the main thread", "history": "Added in API level 29", "FullName": "public void addThermalStatusListener (PowerManager.OnThermalStatusChangedListener listener)"}, "newWakeLock(int, java.lang.String)": {"Returns": [["@B_android#os#PowerManager#WakeLock_E@", "no returns description in source"]], "Parameters": [["int", "int: Combination of wake lock level and flag values defining the requested behavior of the WakeLock."], ["@B_java#lang#String_E@", "String: Your class name (or other tag) for debugging purposes."]], "Throws": [], "SeeAlso": ["@B_android#os#PowerManager#WakeLock#acquire_E@", "@B_android#os#PowerManager#WakeLock#release_E@", "@B_android#os#PowerManager_E@"], "Permissions": ["@B_android#Manifest#permission#WAKE_LOCK_E@"], "Description": "Creates a new wake lock with the specified level and flags. The levelAndFlags parameter specifies a wake lock level and optional flags combined using the logical OR operator. The wake lock levels are: @B_android#os#PowerManager#PARTIAL_WAKE_LOCK_E@, @B_android#os#PowerManager#FULL_WAKE_LOCK_E@, @B_android#os#PowerManager#SCREEN_DIM_WAKE_LOCK_E@ and @B_android#os#PowerManager#SCREEN_BRIGHT_WAKE_LOCK_E@. Exactly one wake lock level must be specified as part of the levelAndFlags parameter. The wake lock flags are: @B_android#os#PowerManager#ACQUIRE_CAUSES_WAKEUP_E@ and @B_android#os#PowerManager#ON_AFTER_RELEASE_E@. Multiple flags can be combined as part of the levelAndFlags parameters. Call @B_android#os#PowerManager#WakeLock#acquire_E@ on the object to acquire the wake lock, and @B_android#os#PowerManager#WakeLock#release_E@ when you are done. Although a wake lock can be created without special permissions, the @B_android#Manifest#permission#WAKE_LOCK_E@ permission is required to actually acquire or release the wake lock that is returned. If using this to keep the screen on, you should strongly consider using @B_android#view#WindowManager#LayoutParams#FLAG_KEEP_SCREEN_ON_E@ instead. This window flag will be correctly managed by the platform as the user moves between applications and doesn't require a special permission. Recommended naming conventions for tags to make debugging easier: use a unique prefix delimited by a colon for your app/library (e.g. gmail:mytag) to make it easier to understand where the wake locks comes from. This namespace will also avoid collision for tags inside your app coming from different libraries which will make debugging easier. use constants (e.g. do not include timestamps in the tag) to make it easier for tools to aggregate similar wake locks. When collecting debugging data, the platform only monitors a finite number of tags, using constants will help tools to provide better debugging data. avoid using Class#getName() or similar method since this class name can be transformed by java optimizer and obfuscator tools. avoid wrapping the tag or a prefix to avoid collision with wake lock tags from the platform (e.g. *alarm*). never include personnally identifiable information for privacy reasons.", "history": "added in API level 1", "FullName": "public PowerManager.WakeLock newWakeLock (int levelAndFlags, String tag)"}, "isInteractive()": {"Returns": [["boolean", "True if the device is in an interactive state."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Intent_E@"], "Permissions": [], "Description": "Returns true if the device is in an interactive state. When this method returns true, the device is awake and ready to interact with the user (although this is not a guarantee that the user is actively interacting with the device just this moment). The main screen is usually turned on while in this state. Certain features, such as the proximity sensor, may temporarily turn off the screen while still leaving the device in an interactive state. Note in particular that the device is still considered to be interactive while dreaming (since dreams can be interactive) but not when it is dozing or asleep. When this method returns false, the device is dozing or asleep and must be awoken before it will become ready to interact with the user again. The main screen is usually turned off while in this state. Certain features, such as \"ambient mode\" may cause the main screen to remain on (albeit in a low power state) to display system-provided content while the device dozes. The system will send a @B_android#content#Intent#ACTION_SCREEN_ON_E@ or @B_android#content#Intent#ACTION_SCREEN_OFF_E@ broadcast whenever the interactive state of the device changes. For historical reasons, the names of these broadcasts refer to the power state of the screen but they are actually sent in response to changes in the overall interactive state of the device, as described by this method. Services may use the non-interactive state as a hint to conserve power since the user is not present.", "history": "Added in API level 20", "FullName": "public boolean isInteractive ()"}, "getCurrentThermalStatus()": {"Returns": [["int", "thermal status as int, @B_android#os#PowerManager#THERMAL_STATUS_NONE_E@ if device in not under thermal throttling. Value is @B_android#os#PowerManager#THERMAL_STATUS_NONE_E@, @B_android#os#PowerManager#THERMAL_STATUS_LIGHT_E@, @B_android#os#PowerManager#THERMAL_STATUS_MODERATE_E@, @B_android#os#PowerManager#THERMAL_STATUS_SEVERE_E@, @B_android#os#PowerManager#THERMAL_STATUS_CRITICAL_E@, @B_android#os#PowerManager#THERMAL_STATUS_EMERGENCY_E@, or @B_android#os#PowerManager#THERMAL_STATUS_SHUTDOWN_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function returns the current thermal status of the device.", "history": "Added in API level 29", "FullName": "public int getCurrentThermalStatus ()"}, "isScreenOn()": {"Returns": [["boolean", "True if the device is in an interactive state."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#os#PowerManager#isInteractive_E@ instead. Returns true if the device is in an interactive state. For historical reasons, the name of this method refers to the power state of the screen but it actually describes the overall interactive state of the device. This method has been replaced by @B_android#os#PowerManager#isInteractive_E@. The value returned by this method only indicates whether the device is in an interactive state which may have nothing to do with the screen being on or off. To determine the actual state of the screen, use @B_android#view#Display#getState_E@.", "history": "Added in API level 7 Deprecated in API level 20", "FullName": "public boolean isScreenOn ()"}, "isPowerSaveMode()": {"Returns": [["boolean", "Returns true if currently in low power mode, else false."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the device is currently in power save mode. When in this mode, applications should reduce their functionality in order to conserve battery as much as possible. You can monitor for changes to this state with @B_android#os#PowerManager#ACTION_POWER_SAVE_MODE_CHANGED_E@.", "history": "Added in API level 21", "FullName": "public boolean isPowerSaveMode ()"}, "getLocationPowerSaveMode()": {"Returns": [["int", "Value is @B_android#os#PowerManager#LOCATION_MODE_NO_CHANGE_E@, @B_android#os#PowerManager#LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF_E@, @B_android#os#PowerManager#LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF_E@, @B_android#os#PowerManager#LOCATION_MODE_FOREGROUND_ONLY_E@, or @B_android#os#PowerManager#LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF_E@"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#os#PowerManager#isPowerSaveMode_E@", "@B_android#os#PowerManager_E@"], "Permissions": [], "Description": "Returns how location features should behave when battery saver is on. When battery saver is off, this will always return @B_android#os#PowerManager#LOCATION_MODE_NO_CHANGE_E@. This API is normally only useful for components that provide location features.", "history": "Added in API level 28", "FullName": "public int getLocationPowerSaveMode ()"}, "wakeUp(long)": {"Returns": [], "Parameters": [["long", "The time when the request to wake up was issued, in the @B_android#os#SystemClock#uptimeMillis_E@ time base. This timestamp is used to correctly order the wake up request with other power management functions. It should be set to the timestamp of the input event that caused the request to wake up."]], "Throws": [], "SeeAlso": ["@B_android#os#PowerManager#userActivity_E@", "@B_android#os#PowerManager#goToSleep_E@"], "Permissions": ["@B_android#Manifest#permission#DEVICE_POWER_E@"], "Description": "Forces the device to wake up from sleep. If the device is currently asleep, wakes it up, otherwise does nothing. This is what happens when the power key is pressed to turn on the screen. Requires the @B_android#Manifest#permission#DEVICE_POWER_E@ permission.", "history": "Added in API level 17", "FullName": "public void wakeUp (long time)"}}, "Inheritance": [], "ClassName": "android.os.PowerManager", "ClassDesc": "This class gives you control of the power state of the device. @B_android#os#PowerManager#WakeLock_E@s unless you really need them, use the minimum levels possible, and be sure to release them as soon as possible. The primary API you'll use is @B_android#os#PowerManager#newWakeLock_E@. This will create a @B_android#os#PowerManager#WakeLock_E@ object. You can then use methods on the wake lock object to control the power state of the device. In practice it's quite simple: The following wake lock levels are defined, with varying effects on system power. * In addition, you can add two more flags, which affect behavior of the screen only. Any application using a WakeLock must request the android.permission.WAKE_LOCK permission in an <uses-permission> element of the application's manifest."}