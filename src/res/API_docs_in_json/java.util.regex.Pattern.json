{"Functions": {"matches(java.lang.String,java.lang.CharSequence)": {"Returns": [["boolean", "whether or not the regular expression matches on the input"]], "Parameters": [["@B_java#lang#String_E@", "String: The expression to be compiled"], ["@B_java#lang#CharSequence_E@", "CharSequence: The character sequence to be matched"]], "Throws": [["@B_java#util#regex#PatternSyntaxException_E@", "If the expression's syntax is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Compiles the given regular expression and attempts to match the given input against it. An invocation of this convenience method of the form If a pattern is to be used multiple times, compiling it once and reusing it will be more efficient than invoking this method each time.", "history": "Added in API level 1", "FullName": "public static boolean matches (String regex, CharSequence input)"}, "matches(java.lang.String, java.lang.CharSequence)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: The expression to be compiled"], ["@B_java#lang#CharSequence_E@", "CharSequence: The character sequence to be matched"]], "Throws": [["@B_java#util#regex#PatternSyntaxException_E@", "If the expression's syntax is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Compiles the given regular expression and attempts to match the given input against it. An invocation of this convenience method of the form If a pattern is to be used multiple times, compiling it once and reusing it will be more efficient than invoking this method each time.", "history": "added in API level 1", "FullName": "public static boolean matches (String regex, CharSequence input)"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#Throwable_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Invoked when the garbage collector has detected that this instance is no longer reachable. The default implementation does nothing, but this method can be overridden to free resources. Note that objects that override finalize are significantly more expensive than objects that don't. Finalizers may be run a long time after the object is no longer reachable, depending on memory pressure, so it's a bad idea to rely on them for cleanup. Note also that finalizers are run on a single VM-wide finalizer thread, so doing blocking work in a finalizer is a bad idea. A finalizer is usually only necessary for a class that has a native peer and needs to call a native method to destroy that peer. Even then, it's better to provide an explicit close method (and implement @B_java#io#Closeable_E@), and insist that callers manually dispose of instances. This works well for something like files, but less well for something like a BigInteger where typical calling code would have to deal with lots of temporaries. Unfortunately, code that creates lots of temporaries is the worst kind of code from the point of view of the single finalizer thread. If you @B_java#lang#ref#ReferenceQueue_E@ and having your own thread process that queue. Unlike constructors, finalizers are not automatically chained. You are responsible for calling super.finalize() yourself. Uncaught exceptions thrown by finalizers are ignored and do not terminate the finalizer thread. See", "history": "Added in API level 1", "FullName": "protected void finalize ()"}, "compile(java.lang.String)": {"Returns": [["@B_java#util#regex#Pattern_E@", "the given regular expression compiled into a pattern"]], "Parameters": [["@B_java#lang#String_E@", "String: The expression to be compiled"]], "Throws": [["@B_java#util#regex#PatternSyntaxException_E@", "If the expression's syntax is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Compiles the given regular expression into a pattern.", "history": "Added in API level 1", "FullName": "public static Pattern compile (String regex)"}, "compile(java.lang.String,int)": {"Returns": [["@B_java#util#regex#Pattern_E@", "the given regular expression compiled into a pattern with the given flags"]], "Parameters": [["@B_java#lang#String_E@", "String: The expression to be compiled"], ["int", "int: Match flags, a bit mask that may include @B_java#util#regex#Pattern#CASE_INSENSITIVE_E@, @B_java#util#regex#Pattern#MULTILINE_E@, @B_java#util#regex#Pattern#DOTALL_E@, @B_java#util#regex#Pattern#UNICODE_CASE_E@, @B_java#util#regex#Pattern#CANON_EQ_E@, @B_java#util#regex#Pattern#UNIX_LINES_E@, @B_java#util#regex#Pattern#LITERAL_E@, @B_java#util#regex#Pattern#UNICODE_CHARACTER_CLASS_E@ and @B_java#util#regex#Pattern#COMMENTS_E@"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "If bit values other than those corresponding to the defined match flags are set in flags"], ["@B_java#util#regex#PatternSyntaxException_E@", "If the expression's syntax is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Compiles the given regular expression into a pattern with the given flags.", "history": "Added in API level 1", "FullName": "public static Pattern compile (String regex, int flags)"}, "compile(java.lang.String, int)": {"Returns": [["@B_java#util#regex#Pattern_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: The expression to be compiled"], ["int", "int: Match flags, a bit mask that may include @B_java#util#regex#Pattern#CASE_INSENSITIVE_E@, @B_java#util#regex#Pattern#MULTILINE_E@, @B_java#util#regex#Pattern#DOTALL_E@, @B_java#util#regex#Pattern#UNICODE_CASE_E@, @B_java#util#regex#Pattern#CANON_EQ_E@, @B_java#util#regex#Pattern#UNIX_LINES_E@, @B_java#util#regex#Pattern#LITERAL_E@, @B_java#util#regex#Pattern#UNICODE_CHARACTER_CLASS_E@ and @B_java#util#regex#Pattern#COMMENTS_E@"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "If bit values other than those corresponding to the defined match flags are set in flags"], ["@B_java#util#regex#PatternSyntaxException_E@", "If the expression's syntax is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Compiles the given regular expression into a pattern with the given flags.", "history": "added in API level 1", "FullName": "public static Pattern compile (String regex, int flags)"}, "asPredicate()": {"Returns": [["@B_java#util#function#Predicate_E@", "The predicate which can be used for matching on a string"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a predicate which can be used to match a string.", "history": "Added in API level 24", "FullName": "public Predicate<String> asPredicate ()"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "The string representation of this pattern"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the string representation of this pattern. This is the regular expression from which this pattern was compiled.", "history": "Added in API level 1", "FullName": "public String toString ()"}, "pattern()": {"Returns": [["@B_java#lang#String_E@", "The source of this pattern"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the regular expression from which this pattern was compiled.", "history": "Added in API level 1", "FullName": "public String pattern ()"}, "split(java.lang.CharSequence)": {"Returns": [["@B_java#lang#String_E@", "The array of strings computed by splitting the input around matches of this pattern"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The character sequence to be split"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Splits the given input sequence around matches of this pattern. This method works as if by invoking the two-argument @B_java#util#regex#Pattern#split_E@ method with the given input sequence and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array. The input", "history": "Added in API level 1", "FullName": "public String[] split (CharSequence input)"}, "split(java.lang.CharSequence, int)": {"Returns": [["@B_java#lang#String_E@", "The array of strings computed by splitting the input around matches of this pattern"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The character sequence to be split"], ["int", "int: The result threshold, as described above"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Splits the given input sequence around matches of this pattern. The array returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the array are in the order in which they occur in the input. If this pattern does not match any subsequence of the input then the resulting array has just one element, namely the input sequence in string form. The The input", "history": "added in API level 1", "FullName": "public String[] split (CharSequence input, int limit)"}, "split(java.lang.CharSequence,int)": {"Returns": [["@B_java#lang#String_E@", "The array of strings computed by splitting the input around matches of this pattern"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The character sequence to be split"], ["int", "int: The result threshold, as described above"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Splits the given input sequence around matches of this pattern. The array returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the array are in the order in which they occur in the input. If this pattern does not match any subsequence of the input then the resulting array has just one element, namely the input sequence in string form. When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however can only produce such an empty leading substring for apps running on or targeting API versions <= 28. The The input", "history": "Added in API level 1", "FullName": "public String[] split (CharSequence input, int limit)"}, "flags()": {"Returns": [["int", "The match flags specified when this pattern was compiled"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns this pattern's match flags.", "history": "Added in API level 1", "FullName": "public int flags ()"}, "quote(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "A literal string replacement"]], "Parameters": [["@B_java#lang#String_E@", "String: The string to be literalized"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a literal pattern String for the specified String. This method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern. Metacharacters or escape sequences in the input sequence will be given no special meaning.", "history": "Added in API level 1", "FullName": "public static String quote (String s)"}, "matcher(java.lang.CharSequence)": {"Returns": [["@B_java#util#regex#Matcher_E@", "A new matcher for this pattern"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The character sequence to be matched"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a matcher that will match the given input against this pattern.", "history": "Added in API level 1", "FullName": "public Matcher matcher (CharSequence input)"}, "splitAsStream(java.lang.CharSequence)": {"Returns": [["@B_java#util#stream#Stream_E@", "The stream of strings computed by splitting the input around matches of this pattern"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The character sequence to be split"]], "Throws": [], "SeeAlso": ["@B_java#util#regex#Pattern#split_E@"], "Permissions": [], "Description": "Creates a stream from the given input sequence around matches of this pattern. The stream returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the stream are in the order in which they occur in the input. Trailing empty strings will be discarded and not encountered in the stream. If this pattern does not match any subsequence of the input then the resulting stream has just one element, namely the input sequence in string form. When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the stream. A zero-width match at the beginning however never produces such empty leading substring. If the input sequence is mutable, it must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.", "history": "Added in API level 24", "FullName": "public Stream<String> splitAsStream (CharSequence input)"}}, "Inheritance": [], "ClassName": "java.util.regex.Pattern", "ClassDesc": "A compiled representation of a regular expression. A regular expression, specified as a string, must first be compiled into an instance of this class. The resulting pattern can then be used to create a @B_java#util#regex#Matcher_E@ object that can match arbitrary A typical invocation sequence is thus A @B_java#util#regex#Pattern#matches_E@ method is defined by this class as a convenience for when a regular expression is used just once. This method compiles an expression and matches an input sequence against it in a single invocation. The statement Instances of this class are immutable and are safe for use by multiple concurrent threads. Instances of the @B_java#util#regex#Matcher_E@ class are not safe for such use. The backslash character ( It is an error to use a backslash prior to any alphabetic character that does not denote an escaped construct; these are reserved for future extensions to the regular-expression language. A backslash may be used prior to a non-alphabetic character regardless of whether that character is part of an unescaped construct. Backslashes within string literals in Java source code are interpreted as required by Character classes may appear within other character classes, and may be composed by the union operator (implicit) and the intersection operator ( The precedence of character-class operators is as follows, from highest to lowest: Note that a different set of metacharacters are in effect inside a character class than outside a character class. For instance, the regular expression A A newline (line feed) character ( A carriage-return character followed immediately by a newline character ( A standalone carriage-return character ( A next-line character ( A line-separator character ( A paragraph-separator character ( If @B_java#util#regex#Pattern#UNIX_LINES_E@ mode is activated, then the only line terminators recognized are newline characters. The regular expression @B_java#util#regex#Pattern#DOTALL_E@ flag is specified. By default, the regular expressions @B_java#util#regex#Pattern#MULTILINE_E@ mode is activated then @B_java#util#regex#Pattern#MULTILINE_E@ mode Capturing groups are numbered by counting their opening parentheses from left to right. In the expression Group zero always stands for the entire expression. Capturing groups are so named because, during a match, each subsequence of the input sequence that matches such a group is saved. The captured subsequence may be used later in the expression, via a back reference, and may also be retrieved from the matcher once the match operation is complete. The constructs and APIs are available since API level 26. A capturing group can also be assigned a \"name\", a The uppercase letters The lowercase letters The digits A The captured input associated with a group is always the subsequence that the group most recently matched. If a group is evaluated a second time because of quantification then its previously-captured value, if any, will be retained if the second evaluation fails. Matching the string Groups beginning with This class is in conformance with Level 1 of A Unicode character can also be represented in a regular-expression by using its Unicode scripts, blocks, categories and binary properties are written with the Scripts, blocks, categories and binary properties can be used both inside and outside of a character class. Is, as in IsHiragana, or by using the script keyword (or its short form sc)as in script=Hiragana or sc=Hiragana. The script names supported by Pattern are the valid script names accepted and defined by @B_java#lang#Character#UnicodeScript#forName_E@. In, as in InMongolian, or by using the keyword block (or its short form blk) as in block=Mongolian or blk=Mongolian. The block names supported by Pattern are the valid block names accepted and defined by @B_java#lang#Character#UnicodeBlock#forName_E@. Is: Both \\p{L} and \\p{IsL} denote the category of Unicode letters. Same as scripts and blocks, categories can also be specified by using the keyword general_category (or its short form gc) as in general_category=Lu or gc=Lu. The supported categories are those of @B_java#lang#Character_E@ class. The category names are those defined in the Standard, both normative and informative. Is, as in IsAlphabetic. The supported binary properties by Pattern are Alphabetic Ideographic Letter Lowercase Uppercase Titlecase Punctuation Control White_Space Digit Hex_Digit Join_Control Noncharacter_Code_Point Assigned The following The Pattern engine performs traditional NFA-based matching with ordered alternation as occurs in Perl 5. Perl constructs not supported by this class: Predefined character classes (Unicode character) The backreference constructs, The named character construct, The conditional constructs The embedded code constructs The embedded comment syntax The preprocessing operations Constructs supported by this class but not by Perl: Character-class union and intersection as described Notable differences from Perl: In Perl, Perl uses the @B_java#util#regex#Matcher_E@ class: Repeated invocations of the @B_java#util#regex#Matcher#find_E@ method will resume where the last match left off, unless the matcher is reset. In Perl, embedded flags at the top level of an expression affect the whole expression. In this class, embedded flags always take effect at the point at which they appear, whether they are at the top level or within a group; in the latter case, flags are restored at the end of the group just as in Perl. For a more precise description of the behavior of regular expression constructs, please see"}