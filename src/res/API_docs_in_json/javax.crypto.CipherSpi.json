{"Functions": {"engineWrap(java.security.Key)": {"Returns": [["byte[]", "the wrapped key."]], "Parameters": [["@B_java#security#Key_E@", "Key: the key to be wrapped."]], "Throws": [["@B_javax#crypto#IllegalBlockSizeException_E@", "if this cipher is a block cipher, no padding has been requested, and the length of the encoding of the key to be wrapped is not a multiple of the block size."], ["@B_java#security#InvalidKeyException_E@", "if it is impossible or unsafe to wrap the key with this cipher (e.g., a hardware protected key is being passed to a software-only cipher)."], ["@B_java#lang#UnsupportedOperationException_E@", "if this method is not supported."]], "SeeAlso": [], "Permissions": [], "Description": "Wrap a key. This concrete method has been added to this previously-defined abstract class. (For backwards compatibility, it cannot be abstract.) It may be overridden by a provider to wrap a key. Such an override is expected to throw an IllegalBlockSizeException or InvalidKeyException (under the specified circumstances), if the given key cannot be wrapped. If this method is not overridden, it always throws an UnsupportedOperationException.", "history": "Added in API level 1", "FullName": "protected byte[] engineWrap (Key key)"}, "engineUpdateAAD(byte[],int,int)": {"Returns": [], "Parameters": [["byte[]", "byte: the buffer containing the AAD"], ["int", "int: the offset in src where the AAD input starts"], ["int", "int: the number of AAD bytes"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the update methods has already been called for the active encryption/decryption operation"], ["@B_java#lang#UnsupportedOperationException_E@", "if this method has not been overridden by an implementation"]], "SeeAlso": [], "Permissions": [], "Description": "Continues a multi-part update of the Additional Authentication Data (AAD), using a subset of the provided buffer. Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the update and doFinal methods).", "history": "Added in API level 19", "FullName": "protected void engineUpdateAAD (byte[] src, int offset, int len)"}, "engineDoFinal(byte[], int, int, byte[], int)": {"Returns": [["int", "the number of bytes stored in output"]], "Parameters": [["byte[]", "byte: the input buffer"], ["int", "int: the offset in input where the input starts"], ["int", "int: the input length"], ["byte[]", "byte: the buffer for the result"], ["int", "int: the offset in output where the result is stored"]], "Throws": [["@B_javax#crypto#IllegalBlockSizeException_E@", "if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided."], ["@B_javax#crypto#ShortBufferException_E@", "if the given output buffer is too small to hold the result"], ["@B_javax#crypto#BadPaddingException_E@", "if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes"], ["@B_javax#crypto#AEADBadTagException_E@", "if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"]], "SeeAlso": [], "Permissions": [], "Description": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer, starting at outputOffset inclusive. If the output buffer is too small to hold the result, a ShortBufferException is thrown. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to engineInit. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to engineInit) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.", "history": "added in API level 1", "FullName": "protected abstract int engineDoFinal (byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)"}, "engineUnwrap(byte[], java.lang.String, int)": {"Returns": [["@B_java#security#Key_E@", "the unwrapped key."]], "Parameters": [["byte[]", "byte: the key to be unwrapped."], ["@B_java#lang#String_E@", "String: the algorithm associated with the wrapped key."], ["int", "int: the type of the wrapped key. This is one of SECRET_KEY, PRIVATE_KEY, or PUBLIC_KEY."]], "Throws": [["@B_java#security#NoSuchAlgorithmException_E@", "if no installed providers can create keys of type wrappedKeyType for the wrappedKeyAlgorithm."], ["@B_java#security#InvalidKeyException_E@", "if wrappedKey does not represent a wrapped key of type wrappedKeyType for the wrappedKeyAlgorithm."], ["@B_java#lang#UnsupportedOperationException_E@", "if this method is not supported."]], "SeeAlso": [], "Permissions": [], "Description": "Unwrap a previously wrapped key. This concrete method has been added to this previously-defined abstract class. (For backwards compatibility, it cannot be abstract.) It may be overridden by a provider to unwrap a previously wrapped key. Such an override is expected to throw an InvalidKeyException if the given wrapped key cannot be unwrapped. If this method is not overridden, it always throws an UnsupportedOperationException.", "history": "added in API level 1", "FullName": "protected Key engineUnwrap (byte[] wrappedKey, String wrappedKeyAlgorithm, int wrappedKeyType)"}, "engineInit(int,java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom)": {"Returns": [], "Parameters": [["int", "int: the operation mode of this cipher (this is one of the following: ENCRYPT_MODE, DECRYPT_MODE, WRAP_MODE or UNWRAP_MODE)"], ["@B_java#security#Key_E@", "Key: the encryption key"], ["@B_java#security#spec#AlgorithmParameterSpec_E@", "AlgorithmParameterSpec: the algorithm parameters"], ["@B_java#security#SecureRandom_E@", "SecureRandom: the source of randomness"]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for initializing this cipher"], ["@B_java#security#InvalidAlgorithmParameterException_E@", "if the given algorithm parameters are inappropriate for this cipher, or if this cipher requires algorithm parameters and params is null."], ["@B_java#lang#UnsupportedOperationException_E@", "if opmode is WRAP_MODE or UNWRAP_MODE is not implemented by the cipher."]], "SeeAlso": [], "Permissions": [], "Description": "Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters and params is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidAlgorithmParameterException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using @B_javax#crypto#CipherSpi#engineGetParameters_E@ or @B_javax#crypto#CipherSpi#engineGetIV_E@ (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.", "history": "Added in API level 1", "FullName": "protected abstract void engineInit (int opmode, Key key, AlgorithmParameterSpec params, SecureRandom random)"}, "engineDoFinal(java.nio.ByteBuffer,java.nio.ByteBuffer)": {"Returns": [["int", "the number of bytes stored in output"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the input ByteBuffer"], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the output ByteByffer"]], "Throws": [["@B_javax#crypto#IllegalBlockSizeException_E@", "if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided."], ["@B_javax#crypto#ShortBufferException_E@", "if there is insufficient space in the output buffer"], ["@B_javax#crypto#BadPaddingException_E@", "if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes"], ["@B_javax#crypto#AEADBadTagException_E@", "if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"], ["@B_java#lang#NullPointerException_E@", "if either parameter is null"]], "SeeAlso": [], "Permissions": [], "Description": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. All input.remaining() bytes starting at input.position() are processed. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. The output buffer's position will have advanced by n, where n is the value returned by this method; the output buffer's limit will not have changed. If output.remaining() bytes are insufficient to hold the result, a ShortBufferException is thrown. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to engineInit. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to engineInit) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again. Subclasses should consider overriding this method if they can process ByteBuffers more efficiently than byte arrays.", "history": "Added in API level 1", "FullName": "protected int engineDoFinal (ByteBuffer input, ByteBuffer output)"}, "engineInit(int,java.security.Key,java.security.SecureRandom)": {"Returns": [], "Parameters": [["int", "int: the operation mode of this cipher (this is one of the following: ENCRYPT_MODE, DECRYPT_MODE, WRAP_MODE or UNWRAP_MODE)"], ["@B_java#security#Key_E@", "Key: the encryption key"], ["@B_java#security#SecureRandom_E@", "SecureRandom: the source of randomness"]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for initializing this cipher, or requires algorithm parameters that cannot be determined from the given key."], ["@B_java#lang#UnsupportedOperationException_E@", "if opmode is WRAP_MODE or UNWRAP_MODE is not implemented by the cipher."]], "SeeAlso": [], "Permissions": [], "Description": "Initializes this cipher with a key and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters that cannot be derived from the given key, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidKeyException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using @B_javax#crypto#CipherSpi#engineGetParameters_E@ or @B_javax#crypto#CipherSpi#engineGetIV_E@ (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.", "history": "Added in API level 1", "FullName": "protected abstract void engineInit (int opmode, Key key, SecureRandom random)"}, "engineUpdate(byte[], int, int)": {"Returns": [["byte[]", "the new buffer with the result, or null if the underlying cipher is a block cipher and the input data is too short to result in a new block."]], "Parameters": [["byte[]", "byte: the input buffer"], ["int", "int: the offset in input where the input starts"], ["int", "int: the input length"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, are processed, and the result is stored in a new buffer.", "history": "added in API level 1", "FullName": "protected abstract byte[] engineUpdate (byte[] input, int inputOffset, int inputLen)"}, "engineDoFinal(byte[],int,int)": {"Returns": [["byte[]", "the new buffer with the result"]], "Parameters": [["byte[]", "byte: the input buffer"], ["int", "int: the offset in input where the input starts"], ["int", "int: the input length"]], "Throws": [["@B_javax#crypto#IllegalBlockSizeException_E@", "if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided."], ["@B_javax#crypto#BadPaddingException_E@", "if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes"], ["@B_javax#crypto#AEADBadTagException_E@", "if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"]], "SeeAlso": [], "Permissions": [], "Description": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to engineInit. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to engineInit) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.", "history": "Added in API level 1", "FullName": "protected abstract byte[] engineDoFinal (byte[] input, int inputOffset, int inputLen)"}, "engineDoFinal(byte[], int, int)": {"Returns": [["byte[]", "the new buffer with the result"]], "Parameters": [["byte[]", "byte: the input buffer"], ["int", "int: the offset in input where the input starts"], ["int", "int: the input length"]], "Throws": [["@B_javax#crypto#IllegalBlockSizeException_E@", "if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided."], ["@B_javax#crypto#BadPaddingException_E@", "if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes"], ["@B_javax#crypto#AEADBadTagException_E@", "if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"]], "SeeAlso": [], "Permissions": [], "Description": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in a new buffer. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to engineInit. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to engineInit) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.", "history": "added in API level 1", "FullName": "protected abstract byte[] engineDoFinal (byte[] input, int inputOffset, int inputLen)"}, "engineGetIV()": {"Returns": [["byte[]", "the initialization vector in a new buffer, or null if the underlying algorithm does not use an IV, or if the IV has not yet been set."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the initialization vector (IV) in a new buffer. This is useful in the context of password-based encryption or decryption, where the IV is derived from a user-provided passphrase.", "history": "Added in API level 1", "FullName": "protected abstract byte[] engineGetIV ()"}, "engineUpdate(java.nio.ByteBuffer,java.nio.ByteBuffer)": {"Returns": [["int", "the number of bytes stored in output"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the input ByteBuffer"], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the output ByteByffer"]], "Throws": [["@B_javax#crypto#ShortBufferException_E@", "if there is insufficient space in the output buffer"], ["@B_java#lang#NullPointerException_E@", "if either parameter is null"]], "SeeAlso": [], "Permissions": [], "Description": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. All input.remaining() bytes starting at input.position() are processed. The result is stored in the output buffer. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed. The output buffer's position will have advanced by n, where n is the value returned by this method; the output buffer's limit will not have changed. If output.remaining() bytes are insufficient to hold the result, a ShortBufferException is thrown. Subclasses should consider overriding this method if they can process ByteBuffers more efficiently than byte arrays.", "history": "Added in API level 1", "FullName": "protected int engineUpdate (ByteBuffer input, ByteBuffer output)"}, "engineSetMode(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the cipher mode"]], "Throws": [["@B_java#security#NoSuchAlgorithmException_E@", "if the requested cipher mode does not exist"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the mode of this cipher.", "history": "Added in API level 1", "FullName": "protected abstract void engineSetMode (String mode)"}, "engineUpdate(byte[], int, int, byte[], int)": {"Returns": [["int", "the number of bytes stored in output"]], "Parameters": [["byte[]", "byte: the input buffer"], ["int", "int: the offset in input where the input starts"], ["int", "int: the input length"], ["byte[]", "byte: the buffer for the result"], ["int", "int: the offset in output where the result is stored"]], "Throws": [["@B_javax#crypto#ShortBufferException_E@", "if the given output buffer is too small to hold the result"]], "SeeAlso": [], "Permissions": [], "Description": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, are processed, and the result is stored in the output buffer, starting at outputOffset inclusive. If the output buffer is too small to hold the result, a ShortBufferException is thrown.", "history": "added in API level 1", "FullName": "protected abstract int engineUpdate (byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)"}, "engineUnwrap(byte[],java.lang.String,int)": {"Returns": [["@B_java#security#Key_E@", "the unwrapped key."]], "Parameters": [["byte[]", "byte: the key to be unwrapped."], ["@B_java#lang#String_E@", "String: the algorithm associated with the wrapped key."], ["int", "int: the type of the wrapped key. This is one of SECRET_KEY, PRIVATE_KEY, or PUBLIC_KEY."]], "Throws": [["@B_java#security#NoSuchAlgorithmException_E@", "if no installed providers can create keys of type wrappedKeyType for the wrappedKeyAlgorithm."], ["@B_java#security#InvalidKeyException_E@", "if wrappedKey does not represent a wrapped key of type wrappedKeyType for the wrappedKeyAlgorithm."], ["@B_java#lang#UnsupportedOperationException_E@", "if this method is not supported."]], "SeeAlso": [], "Permissions": [], "Description": "Unwrap a previously wrapped key. This concrete method has been added to this previously-defined abstract class. (For backwards compatibility, it cannot be abstract.) It may be overridden by a provider to unwrap a previously wrapped key. Such an override is expected to throw an InvalidKeyException if the given wrapped key cannot be unwrapped. If this method is not overridden, it always throws an UnsupportedOperationException.", "history": "Added in API level 1", "FullName": "protected Key engineUnwrap (byte[] wrappedKey, String wrappedKeyAlgorithm, int wrappedKeyType)"}, "engineDoFinal(byte[],int,int,byte[],int)": {"Returns": [["int", "the number of bytes stored in output"]], "Parameters": [["byte[]", "byte: the input buffer"], ["int", "int: the offset in input where the input starts"], ["int", "int: the input length"], ["byte[]", "byte: the buffer for the result"], ["int", "int: the offset in output where the result is stored"]], "Throws": [["@B_javax#crypto#IllegalBlockSizeException_E@", "if this cipher is a block cipher, no padding has been requested (only in encryption mode), and the total input length of the data processed by this cipher is not a multiple of block size; or if this encryption algorithm is unable to process the input data provided."], ["@B_javax#crypto#ShortBufferException_E@", "if the given output buffer is too small to hold the result"], ["@B_javax#crypto#BadPaddingException_E@", "if this cipher is in decryption mode, and (un)padding has been requested, but the decrypted data is not bounded by the appropriate padding bytes"], ["@B_javax#crypto#AEADBadTagException_E@", "if this cipher is decrypting in an AEAD mode (such as GCM/CCM), and the received authentication tag does not match the calculated value"]], "SeeAlso": [], "Permissions": [], "Description": "Encrypts or decrypts data in a single-part operation, or finishes a multiple-part operation. The data is encrypted or decrypted, depending on how this cipher was initialized. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, and any input bytes that may have been buffered during a previous update operation, are processed, with padding (if requested) being applied. If an AEAD mode such as GCM/CCM is being used, the authentication tag is appended in the case of encryption, or verified in the case of decryption. The result is stored in the output buffer, starting at outputOffset inclusive. If the output buffer is too small to hold the result, a ShortBufferException is thrown. Upon finishing, this method resets this cipher object to the state it was in when previously initialized via a call to engineInit. That is, the object is reset and available to encrypt or decrypt (depending on the operation mode that was specified in the call to engineInit) more data. Note: if any exception is thrown, this cipher object may need to be reset before it can be used again.", "history": "Added in API level 1", "FullName": "protected abstract int engineDoFinal (byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)"}, "engineUpdate(byte[],int,int)": {"Returns": [["byte[]", "the new buffer with the result, or null if the underlying cipher is a block cipher and the input data is too short to result in a new block."]], "Parameters": [["byte[]", "byte: the input buffer"], ["int", "int: the offset in input where the input starts"], ["int", "int: the input length"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, are processed, and the result is stored in a new buffer.", "history": "Added in API level 1", "FullName": "protected abstract byte[] engineUpdate (byte[] input, int inputOffset, int inputLen)"}, "engineGetOutputSize(int)": {"Returns": [["int", "the required output buffer size (in bytes)"]], "Parameters": [["int", "int: the input length (in bytes)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the length in bytes that an output buffer would need to be in order to hold the result of the next update or doFinal operation, given the input length inputLen (in bytes). This call takes into account any unprocessed (buffered) data from a previous update call, padding, and AEAD tagging. The actual output length of the next update or doFinal call may be smaller than the length returned by this method.", "history": "Added in API level 1", "FullName": "protected abstract int engineGetOutputSize (int inputLen)"}, "engineGetBlockSize()": {"Returns": [["int", "the block size (in bytes), or 0 if the underlying algorithm is not a block cipher"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the block size (in bytes).", "history": "Added in API level 1", "FullName": "protected abstract int engineGetBlockSize ()"}, "engineUpdate(byte[],int,int,byte[],int)": {"Returns": [["int", "the number of bytes stored in output"]], "Parameters": [["byte[]", "byte: the input buffer"], ["int", "int: the offset in input where the input starts"], ["int", "int: the input length"], ["byte[]", "byte: the buffer for the result"], ["int", "int: the offset in output where the result is stored"]], "Throws": [["@B_javax#crypto#ShortBufferException_E@", "if the given output buffer is too small to hold the result"]], "SeeAlso": [], "Permissions": [], "Description": "Continues a multiple-part encryption or decryption operation (depending on how this cipher was initialized), processing another data part. The first inputLen bytes in the input buffer, starting at inputOffset inclusive, are processed, and the result is stored in the output buffer, starting at outputOffset inclusive. If the output buffer is too small to hold the result, a ShortBufferException is thrown.", "history": "Added in API level 1", "FullName": "protected abstract int engineUpdate (byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset)"}, "engineGetKeySize(java.security.Key)": {"Returns": [["int", "the key size of the given key object."]], "Parameters": [["@B_java#security#Key_E@", "Key: the key object."]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if key is invalid."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the key size of the given key object in bits. This concrete method has been added to this previously-defined abstract class. It throws an UnsupportedOperationException if it is not overridden by the provider.", "history": "Added in API level 1", "FullName": "protected int engineGetKeySize (Key key)"}, "engineGetParameters()": {"Returns": [["@B_java#security#AlgorithmParameters_E@", "the parameters used with this cipher, or null if this cipher does not use any parameters."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the parameters used with this cipher. The returned parameters may be the same that were used to initialize this cipher, or may contain a combination of default and random parameter values used by the underlying cipher implementation if this cipher requires algorithm parameters but was not initialized with any.", "history": "Added in API level 1", "FullName": "protected abstract AlgorithmParameters engineGetParameters ()"}, "engineInit(int,java.security.Key,java.security.AlgorithmParameters,java.security.SecureRandom)": {"Returns": [], "Parameters": [["int", "int: the operation mode of this cipher (this is one of the following: ENCRYPT_MODE, DECRYPT_MODE, WRAP_MODE or UNWRAP_MODE)"], ["@B_java#security#Key_E@", "Key: the encryption key"], ["@B_java#security#AlgorithmParameters_E@", "AlgorithmParameters: the algorithm parameters"], ["@B_java#security#SecureRandom_E@", "SecureRandom: the source of randomness"]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for initializing this cipher"], ["@B_java#security#InvalidAlgorithmParameterException_E@", "if the given algorithm parameters are inappropriate for this cipher, or if this cipher requires algorithm parameters and params is null."], ["@B_java#lang#UnsupportedOperationException_E@", "if opmode is WRAP_MODE or UNWRAP_MODE is not implemented by the cipher."]], "SeeAlso": [], "Permissions": [], "Description": "Initializes this cipher with a key, a set of algorithm parameters, and a source of randomness. The cipher is initialized for one of the following four operations: encryption, decryption, key wrapping or key unwrapping, depending on the value of opmode. If this cipher requires any algorithm parameters and params is null, the underlying cipher implementation is supposed to generate the required parameters itself (using provider-specific default or random values) if it is being initialized for encryption or key wrapping, and raise an InvalidAlgorithmParameterException if it is being initialized for decryption or key unwrapping. The generated parameters can be retrieved using @B_javax#crypto#CipherSpi#engineGetParameters_E@ or @B_javax#crypto#CipherSpi#engineGetIV_E@ (if the parameter is an IV). If this cipher requires algorithm parameters that cannot be derived from the input parameters, and there are no reasonable provider-specific default values, initialization will necessarily fail. If this cipher (including its underlying feedback or padding scheme) requires any random bytes (e.g., for parameter generation), it will get them from random. Note that when a Cipher object is initialized, it loses all previously-acquired state. In other words, initializing a Cipher is equivalent to creating a new instance of that Cipher and initializing it.", "history": "Added in API level 1", "FullName": "protected abstract void engineInit (int opmode, Key key, AlgorithmParameters params, SecureRandom random)"}, "engineUpdateAAD(byte[], int, int)": {"Returns": [], "Parameters": [["byte[]", "byte: the buffer containing the AAD"], ["int", "int: the offset in src where the AAD input starts"], ["int", "int: the number of AAD bytes"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the update methods has already been called for the active encryption/decryption operation"], ["@B_java#lang#UnsupportedOperationException_E@", "if this method has not been overridden by an implementation"]], "SeeAlso": [], "Permissions": [], "Description": "Continues a multi-part update of the Additional Authentication Data (AAD), using a subset of the provided buffer. Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the update and doFinal methods).", "history": "added in API level 19", "FullName": "protected void engineUpdateAAD (byte[] src, int offset, int len)"}, "CipherSpi()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public CipherSpi ()"}, "engineSetPadding(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the padding mechanism"]], "Throws": [["@B_javax#crypto#NoSuchPaddingException_E@", "if the requested padding mechanism does not exist"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the padding mechanism of this cipher.", "history": "Added in API level 1", "FullName": "protected abstract void engineSetPadding (String padding)"}, "engineUpdateAAD(java.nio.ByteBuffer)": {"Returns": [], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the buffer containing the AAD"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this cipher is in a wrong state (e.g., has not been initialized), does not accept AAD, or if operating in either GCM or CCM mode and one of the update methods has already been called for the active encryption/decryption operation"], ["@B_java#lang#UnsupportedOperationException_E@", "if this method has not been overridden by an implementation"]], "SeeAlso": [], "Permissions": [], "Description": "Continues a multi-part update of the Additional Authentication Data (AAD). Calls to this method provide AAD to the cipher when operating in modes such as AEAD (GCM/CCM). If this cipher is operating in either GCM or CCM mode, all AAD must be supplied before beginning operations on the ciphertext (via the update and doFinal methods). All src.remaining() bytes starting at src.position() are processed. Upon return, the input buffer's position will be equal to its limit; its limit will not have changed.", "history": "Added in API level 19", "FullName": "protected void engineUpdateAAD (ByteBuffer src)"}}, "Inheritance": [], "ClassName": "javax.crypto.CipherSpi", "ClassDesc": "This class defines the Cipher class. All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular cipher algorithm. In order to create an instance of Cipher, which encapsulates an instance of this CipherSpi class, an application calls one of the @B_javax#crypto#Cipher#getInstance_E@ factory methods of the @B_javax#crypto#Cipher_E@ engine class and specifies the requested A A transformation is of the form: \"\" (in the latter case, provider-specific default values for the mode and padding scheme are used). For example, the following is a valid transformation: A provider may supply a separate class for each combination of getInstance methods of Cipher, which invoke the @B_javax#crypto#CipherSpi#engineSetMode_E@ and @B_javax#crypto#CipherSpi#engineSetPadding_E@ methods of the provider's subclass of CipherSpi. A Cipher property in a provider master class may have one of the following formats: For example, a provider may supply a subclass of CipherSpi that implements Cipher properties in its master class: Another provider may implement a class for each of the above modes (i.e., one class for CipherSpi. That provider would have the following Cipher properties in its master class: The getInstance factory method of the Cipher engine class follows these rules in order to instantiate a provider's implementation of CipherSpi for a transformation of the form \"The getInstance factory method of the Cipher engine class follows these rules in order to instantiate a provider's implementation of CipherSpi for a transformation of the form \""}