{"Functions": {"getUpper()": {"Returns": [["T", "a non-null T reference"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the upper endpoint.", "history": "Added in API level 21", "FullName": "public T getUpper ()"}, "extend(T,T)": {"Returns": [["@B_android#util#Range_E@", "the extension of this range and the other range."]], "Parameters": [["T", "T: a non-null T reference"], ["T", "T: a non-null T reference"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if lower or upper was null"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the smallest range that includes this range and the inclusive range specified by [lower, upper]. See @B_android#util#Range#extend_E@ for more details.", "history": "Added in API level 21", "FullName": "public Range<T> extend (T lower, T upper)"}, "Range(T, T)": {"Returns": [], "Parameters": [["T", "T: The lower endpoint (inclusive)"], ["T", "T: The upper endpoint (inclusive)"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if lower or upper is null"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new immutable range. The endpoints are [lower, upper]; that is the range is bounded. lower must be @B_java#lang#Comparable#compareTo_E@ to upper.", "history": "added in API level 21", "FullName": "public Range (T lower, T upper)"}, "getLower()": {"Returns": [["T", "a non-null T reference"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the lower endpoint.", "history": "Added in API level 21", "FullName": "public T getLower ()"}, "extend(T, T)": {"Returns": [["@B_android#util#Range_E@", "the extension of this range and the other range."]], "Parameters": [["T", "T: a non-null T reference"], ["T", "T: a non-null T reference"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if lower or upper was null"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the smallest range that includes this range and the inclusive range specified by [lower, upper]. See @B_android#util#Range#extend_E@ for more details.", "history": "added in API level 21", "FullName": "public Range<T> extend (T lower, T upper)"}, "Range(T,T)": {"Returns": [], "Parameters": [["T", "T: The lower endpoint (inclusive)"], ["T", "T: The upper endpoint (inclusive)"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if lower or upper is null"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new immutable range. The endpoints are [lower, upper]; that is the range is bounded. lower must be @B_java#lang#Comparable#compareTo_E@ to upper.", "history": "Added in API level 21", "FullName": "public Range (T lower, T upper)"}, "intersect(android.util.Range<T>)": {"Returns": [["@B_android#util#Range_E@", "the intersection of this range and the other range."]], "Parameters": [["@B_android#util#Range_E@", "Range: a non-null Range<T> reference"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if range was null"], ["@B_java#lang#IllegalArgumentException_E@", "if the ranges are disjoint."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the intersection of this range and another range. E.g. if a < b < c < d, the intersection of [a, c] and [b, d] ranges is [b, c]. As the endpoints are object references, there is no guarantee which specific endpoint reference is used from the input ranges: E.g. if a == a' < b < c, the intersection of [a, b] and [a', c] ranges could be either [a, b] or ['a, b], where [a, b] could be either the exact input range, or a newly created range with the same endpoints.", "history": "Added in API level 21", "FullName": "public Range<T> intersect (Range<T> range)"}, "contains(T)": {"Returns": [["boolean", "true if the value is within this inclusive range, false otherwise"]], "Parameters": [["T", "T: a non-null T reference"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if value was null"]], "SeeAlso": [], "Permissions": [], "Description": "Checks if the value is within the bounds of this range. A value is considered to be within this range if it's >= the lower endpoint <= the upper endpoint (using the @B_java#lang#Comparable_E@ interface.)", "history": "Added in API level 21", "FullName": "public boolean contains (T value)"}, "create(T,T)": {"Returns": [["@B_android#util#Range_E@", "no returns description in source"]], "Parameters": [["T", "T: The lower endpoint (inclusive)"], ["T", "T: The upper endpoint (inclusive)"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if lower or upper is null"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new immutable range, with the argument types inferred. The endpoints are [lower, upper]; that is the range is bounded. lower must be @B_java#lang#Comparable#compareTo_E@ to upper.", "history": "Added in API level 21", "FullName": "public static Range<T> create (T lower, T upper)"}, "contains(android.util.Range<T>)": {"Returns": [["boolean", "true if the range is within this inclusive range, false otherwise"]], "Parameters": [["@B_android#util#Range_E@", "Range: a non-null T reference"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if range was null"]], "SeeAlso": [], "Permissions": [], "Description": "Checks if another range is within the bounds of this range. A range is considered to be within this range if both of its endpoints are within this range.", "history": "Added in API level 21", "FullName": "public boolean contains (Range<T> range)"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "string representation of the range"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the range as a string representation \"[lower, upper]\".", "history": "Added in API level 21", "FullName": "public String toString ()"}, "intersect(T,T)": {"Returns": [["@B_android#util#Range_E@", "the intersection of this range and the other range"]], "Parameters": [["T", "T: a non-null T reference"], ["T", "T: a non-null T reference"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if lower or upper was null"], ["@B_java#lang#IllegalArgumentException_E@", "if the ranges are disjoint."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the intersection of this range and the inclusive range specified by [lower, upper]. See @B_android#util#Range#intersect_E@ for more details.", "history": "Added in API level 21", "FullName": "public Range<T> intersect (T lower, T upper)"}, "extend(android.util.Range<T>)": {"Returns": [["@B_android#util#Range_E@", "the extension of this range and the other range."]], "Parameters": [["@B_android#util#Range_E@", "Range: a non-null Range<T> reference"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if range was null"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the smallest range that includes this range and another range. E.g. if a < b < c < d, the extension of [a, c] and [b, d] ranges is [a, d]. As the endpoints are object references, there is no guarantee which specific endpoint reference is used from the input ranges: E.g. if a == a' < b < c, the extension of [a, b] and [a', c] ranges could be either [a, c] or ['a, c], where ['a, c] could be either the exact input range, or a newly created range with the same endpoints.", "history": "Added in API level 21", "FullName": "public Range<T> extend (Range<T> range)"}, "create(T, T)": {"Returns": [["@B_android#util#Range_E@", "no returns description in source"]], "Parameters": [["T", "T: The lower endpoint (inclusive)"], ["T", "T: The upper endpoint (inclusive)"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if lower or upper is null"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new immutable range, with the argument types inferred. The endpoints are [lower, upper]; that is the range is bounded. lower must be @B_java#lang#Comparable#compareTo_E@ to upper.", "history": "added in API level 21", "FullName": "public static Range<T> create (T lower, T upper)"}, "clamp(T)": {"Returns": [["T", "value clamped to this range."]], "Parameters": [["T", "T: a non-null T reference"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clamps value to this range. If the value is within this range, it is returned. Otherwise, if it is < than the lower endpoint, the lower endpoint is returned, else the upper endpoint is returned. Comparisons are performed using the @B_java#lang#Comparable_E@ interface.", "history": "Added in API level 21", "FullName": "public T clamp (T value)"}, "extend(T)": {"Returns": [["@B_android#util#Range_E@", "the extension of this range and the value."]], "Parameters": [["T", "T: a non-null T reference"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if value was null"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the smallest range that includes this range and the value. See @B_android#util#Range#extend_E@ for more details, as this method is equivalent to extend(Range.create(value, value)).", "history": "Added in API level 21", "FullName": "public Range<T> extend (T value)"}, "intersect(T, T)": {"Returns": [["@B_android#util#Range_E@", "the intersection of this range and the other range"]], "Parameters": [["T", "T: a non-null T reference"], ["T", "T: a non-null T reference"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if lower or upper was null"], ["@B_java#lang#IllegalArgumentException_E@", "if the ranges are disjoint."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the intersection of this range and the inclusive range specified by [lower, upper]. See @B_android#util#Range#intersect_E@ for more details.", "history": "added in API level 21", "FullName": "public Range<T> intersect (T lower, T upper)"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if the ranges are equal, false otherwise"]], "Parameters": [["@B_java#lang#Object_E@", "Object: the reference object with which to compare."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compare two ranges for equality. A range is considered equal if and only if both the lower and upper endpoints are also equal.", "history": "Added in API level 21", "FullName": "public boolean equals (Object obj)"}, "hashCode()": {"Returns": [["int", "a hash code value for this object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by @B_java#util#HashMap_E@. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the @B_java#lang#Object#equals_E@ method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java\u2122 programming language.)", "history": "Added in API level 21", "FullName": "public int hashCode ()"}}, "Inheritance": [], "ClassName": "@B_java#lang#Comparable_E@", "ClassDesc": "Immutable class for describing the range of two numeric values. A range (or \"interval\") defines the inclusive boundaries around a contiguous span of values of some @B_java#lang#Comparable_E@ type; for example, \"integers from 1 to 100 inclusive.\" All ranges are bounded, and the left side of the range is always <= the right side of the range. Although the implementation itself is immutable, there is no restriction that objects stored must also be immutable. If mutable objects are stored here, then the range effectively becomes mutable."}