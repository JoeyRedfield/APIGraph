{"Functions": {"read()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Reads a single byte from this stream and returns it as an integer in the range from 0 to 255. Returns -1 if the end of the stream has been reached. Blocks until one byte has been read, the end of the source stream is detected or an exception is thrown.", "history": "Added in API level 1", "FullName": "public int read ()"}, "close()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Closes this stream. Concrete implementations of this class should free any resources during close. This implementation does nothing.", "history": "Added in API level 1", "FullName": "public void close ()"}, "IdentityInputStream(org.apache.http.io.SessionInputBuffer)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public IdentityInputStream (SessionInputBuffer in)"}, "available()": {"Returns": [["", "the estimated number of bytes available"]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Returns an estimated number of bytes that can be read or skipped without blocking for more input. Note that this method provides such a weak guarantee that it is not very useful in practice. Firstly, the guarantee is \"without blocking for more input\" rather than \"without blocking\": a read may still block waiting for I/O to complete \u2014 the guarantee is merely that it won't have to wait indefinitely for data to be written. The result of this method should not be used as a license to do I/O on a thread that shouldn't be blocked. Secondly, the result is a conservative estimate and may be significantly smaller than the actual number of bytes available. In particular, an implementation that always returns 0 would be correct. In general, callers should only use this method if they'd be satisfied with treating the result as a boolean yes or no answer to the question \"is there definitely data ready?\". Thirdly, the fact that a given number of bytes is \"available\" does not guarantee that a read or skip will actually read or skip that many bytes: they may read or skip fewer. It is particularly important to realize that you @B_java#io#ByteArrayOutputStream_E@ and convert that to a byte array. Alternatively, if you're reading from a file, @B_java#io#File#length_E@ returns the current length of the file (though assuming the file's length can't change may be incorrect, reading a file is inherently racy). The default implementation of this method in InputStream always returns 0. Subclasses should override this method if they are able to indicate the number of bytes available.", "history": "Added in API level 1", "FullName": "public int available ()"}, "read(byte[], int, int)": {"Returns": [], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Reads up to byteCount bytes from this stream and stores them in the byte array buffer starting at byteOffset. Returns the number of bytes actually read or -1 if the end of the stream has been reached.", "history": "Added in API level 1", "FullName": "public int read (byte[] b, int off, int len)"}}, "Inheritance": ["@B_java#io#InputStream_E@"], "ClassName": "org.apache.http.impl.io.IdentityInputStream", "ClassDesc": "Please use @B_java#net#URL#openConnection_E@ instead. Please visit A stream for reading from a @B_org#apache#http#io#SessionInputBuffer_E@."}