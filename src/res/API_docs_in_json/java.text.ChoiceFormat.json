{"Functions": {"nextDouble(double)": {"Returns": [["double", "the least double value greather than d"]], "Parameters": [["double", "double: the reference value"]], "Throws": [], "SeeAlso": ["@B_java#text#ChoiceFormat#previousDouble_E@"], "Permissions": [], "Description": "Finds the least double greater than d. If NaN, returns same value. Used to make half-open intervals.", "history": "Added in API level 1", "FullName": "public static final double nextDouble (double d)"}, "setChoices(double[],java.lang.String[])": {"Returns": [], "Parameters": [["double[]", "double: contains the top value that you want parsed with that format, and should be in ascending sorted order. When formatting X, the choice will be the i, where limit[i] \u2264 X < limit[i+1]. If the limit array is not in ascending order, the results of formatting will be incorrect."], ["@B_java#lang#String_E@", "String: are the formats you want to use for each limit. They can be either Format objects or Strings. When formatting with object Y, if the object is a NumberFormat, then ((NumberFormat) Y).format(X) is called. Otherwise Y.toString() is called."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the choices to be used in formatting.", "history": "Added in API level 1", "FullName": "public void setChoices (double[] limits, String[] formats)"}, "setChoices(double[], java.lang.String[])": {"Returns": [], "Parameters": [["double[]", "double: contains the top value that you want parsed with that format, and should be in ascending sorted order. When formatting X, the choice will be the i, where limit[i] \u2264 X < limit[i+1]. If the limit array is not in ascending order, the results of formatting will be incorrect."], ["@B_java#lang#String_E@", "String: are the formats you want to use for each limit. They can be either Format objects or Strings. When formatting with object Y, if the object is a NumberFormat, then ((NumberFormat) Y).format(X) is called. Otherwise Y.toString() is called."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the choices to be used in formatting.", "history": "added in API level 1", "FullName": "public void setChoices (double[] limits, String[] formats)"}, "format(double,java.lang.StringBuffer,java.text.FieldPosition)": {"Returns": [["@B_java#lang#StringBuffer_E@", "the formatted StringBuffer"]], "Parameters": [["double", "double: number to be formatted and substituted."], ["@B_java#lang#StringBuffer_E@", "StringBuffer: where text is appended."], ["@B_java#text#FieldPosition_E@", "FieldPosition: ignore no useful status is returned."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns pattern with formatted double.", "history": "Added in API level 1", "FullName": "public StringBuffer format (double number, StringBuffer toAppendTo, FieldPosition status)"}, "format(long,java.lang.StringBuffer,java.text.FieldPosition)": {"Returns": [["@B_java#lang#StringBuffer_E@", "the formatted StringBuffer"]], "Parameters": [["long", "long: the long number to format"], ["@B_java#lang#StringBuffer_E@", "StringBuffer: the StringBuffer to which the formatted text is to be appended"], ["@B_java#text#FieldPosition_E@", "FieldPosition: the field position"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Specialization of format. This method really calls format(double, StringBuffer, FieldPosition) thus the range of longs that are supported is only equal to the range that can be stored by double. This will never be a practical limitation.", "history": "Added in API level 1", "FullName": "public StringBuffer format (long number, StringBuffer toAppendTo, FieldPosition status)"}, "previousDouble(double)": {"Returns": [["double", "the greatest double value less than d"]], "Parameters": [["double", "double: the reference value"]], "Throws": [], "SeeAlso": ["@B_java#text#ChoiceFormat#nextDouble_E@"], "Permissions": [], "Description": "Finds the greatest double less than d. If NaN, returns same value.", "history": "Added in API level 1", "FullName": "public static final double previousDouble (double d)"}, "getLimits()": {"Returns": [["double[]", "a copy of the double[] array supplied to the constructor or the most recent call to @B_java#text#ChoiceFormat#setChoices_E@."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public double[] getLimits ()"}, "nextDouble(double, boolean)": {"Returns": [["double", "the least or greater double value"]], "Parameters": [["double", "double: the reference value"], ["boolean", "boolean: true if the least double is desired; false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finds the least double greater than d (if positive is true), or the greatest double less than d (if positive is false). If NaN, returns same value. Does not affect floating-point flags, provided these member functions do not: Double.longBitsToDouble(long) Double.doubleToLongBits(double) Double.isNaN(double)", "history": "added in API level 1", "FullName": "public static double nextDouble (double d, boolean positive)"}, "parse(java.lang.String, java.text.ParsePosition)": {"Returns": [["@B_java#lang#Number_E@", "A Number representing the value of the number parsed."]], "Parameters": [["@B_java#lang#String_E@", "String: the source text."], ["@B_java#text#ParsePosition_E@", "ParsePosition: an input-output parameter. On input, the status.index field indicates the first character of the source text that should be parsed. On exit, if no error occurred, status.index is set to the first unparsed character in the source text. On exit, if an error did occur, status.index is unchanged and status.errorIndex is set to the first index of the character that caused the parse to fail."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Parses a Number from the input text.", "history": "added in API level 1", "FullName": "public Number parse (String text, ParsePosition status)"}, "nextDouble(double,boolean)": {"Returns": [["double", "the least or greater double value"]], "Parameters": [["double", "double: the reference value"], ["boolean", "boolean: true if the least double is desired; false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finds the least double greater than d (if positive is true), or the greatest double less than d (if positive is false). If NaN, returns same value. Does not affect floating-point flags, provided these member functions do not: Double.longBitsToDouble(long) Double.doubleToLongBits(double) Double.isNaN(double)", "history": "Added in API level 1", "FullName": "public static double nextDouble (double d, boolean positive)"}, "ChoiceFormat(double[],java.lang.String[])": {"Returns": [], "Parameters": [["double[]", "double: limits in ascending order"], ["@B_java#lang#String_E@", "String: corresponding format strings"]], "Throws": [], "SeeAlso": ["@B_java#text#ChoiceFormat#setChoices_E@"], "Permissions": [], "Description": "Constructs with the limits and the corresponding formats.", "history": "Added in API level 1", "FullName": "public ChoiceFormat (double[] limits, String[] formats)"}, "getFormats()": {"Returns": [["@B_java#lang#Object_E@", "a copy of the String[] array supplied to the constructor or the most recent call to @B_java#text#ChoiceFormat#setChoices_E@."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public Object[] getFormats ()"}, "ChoiceFormat(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the new pattern string"]], "Throws": [], "SeeAlso": ["@B_java#text#ChoiceFormat#applyPattern_E@"], "Permissions": [], "Description": "Constructs with limits and corresponding formats based on the pattern.", "history": "Added in API level 1", "FullName": "public ChoiceFormat (String newPattern)"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if this object is the same as the obj argument; false otherwise."]], "Parameters": [["@B_java#lang#Object_E@", "Object: the reference object with which to compare."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equality comparision between two", "history": "Added in API level 1", "FullName": "public boolean equals (Object obj)"}, "ChoiceFormat(double[], java.lang.String[])": {"Returns": [], "Parameters": [["double[]", "double: limits in ascending order"], ["@B_java#lang#String_E@", "String: corresponding format strings"]], "Throws": [], "SeeAlso": ["@B_java#text#ChoiceFormat#setChoices_E@"], "Permissions": [], "Description": "Constructs with the limits and the corresponding formats.", "history": "added in API level 1", "FullName": "public ChoiceFormat (double[] limits, String[] formats)"}, "toPattern()": {"Returns": [["@B_java#lang#String_E@", "the pattern string"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the pattern.", "history": "Added in API level 1", "FullName": "public String toPattern ()"}, "parse(java.lang.String,java.text.ParsePosition)": {"Returns": [["@B_java#lang#Number_E@", "A Number representing the value of the number parsed."]], "Parameters": [["@B_java#lang#String_E@", "String: the source text."], ["@B_java#text#ParsePosition_E@", "ParsePosition: an input-output parameter. On input, the status.index field indicates the first character of the source text that should be parsed. On exit, if no error occurred, status.index is set to the first unparsed character in the source text. On exit, if an error did occur, status.index is unchanged and status.errorIndex is set to the first index of the character that caused the parse to fail."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Parses a Number from the input text.", "history": "Added in API level 1", "FullName": "public Number parse (String text, ParsePosition status)"}, "clone()": {"Returns": [["@B_java#lang#Object_E@", "a clone of this instance."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Overrides Cloneable", "history": "Added in API level 1", "FullName": "public Object clone ()"}, "applyPattern(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: See the class description."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the pattern.", "history": "Added in API level 1", "FullName": "public void applyPattern (String newPattern)"}, "hashCode()": {"Returns": [["int", "a hash code value for this object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Generates a hash code for the message format object.", "history": "Added in API level 1", "FullName": "public int hashCode ()"}}, "Inheritance": ["@B_java#text#Format_E@", "@B_java#text#NumberFormat_E@"], "ClassName": "java.text.ChoiceFormat", "ClassDesc": "A ChoiceFormat allows you to attach a format to a range of numbers. It is generally used in a MessageFormat for handling plurals. The choice is specified with an ascending list of doubles, where each item specifies a half-open interval up to the next item: \\u221E as equivalent to infinity(INF). ChoiceFormat differs from the other Format classes in that you create a ChoiceFormat object with a constructor (not with a getInstance style factory method). The factory methods aren't necessary because ChoiceFormat doesn't require any complex setup for a given locale. In fact, ChoiceFormat doesn't implement any locale specific behavior. When creating a ChoiceFormat, you must specify an array of formats and an array of limits. The length of these arrays must be the same. For example, limits = {1,2,3,4,5,6,7} formats = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"} limits = {0, 1, ChoiceFormat.nextDouble(1)} formats = {\"no files\", \"one file\", \"many files\"} (nextDouble can be used to get the next higher double, to make the half-open interval.) Here is a simple example that shows formatting and parsing: Specifying a pattern for ChoiceFormat objects is fairly straightforward. For example: Choice formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally."}