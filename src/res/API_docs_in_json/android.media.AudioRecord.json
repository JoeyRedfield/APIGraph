{"Functions": {"setRecordPositionUpdateListener(android.media.AudioRecord.OnRecordPositionUpdateListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#os#Handler_E@", "Handler: the Handler that will receive the event notification messages."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the listener the AudioRecord notifies when a previously set marker is reached or for each periodic record head position update. Use this method to receive AudioRecord events in the Handler associated with another thread than the one in which you created the AudioRecord instance.", "history": "Added in API level 3", "FullName": "public void setRecordPositionUpdateListener (AudioRecord.OnRecordPositionUpdateListener listener, Handler handler)"}, "getActiveRecordingConfiguration()": {"Returns": [["@B_android#media#AudioRecordingConfiguration_E@", "a valid @B_android#media#AudioRecordingConfiguration_E@ if this recorder is active or null otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#AudioRecordingConfiguration_E@"], "Permissions": [], "Description": "Returns the current active audio recording for this audio recorder.", "history": "Added in API level 29", "FullName": "public AudioRecordingConfiguration getActiveRecordingConfiguration ()"}, "startRecording(android.media.MediaSyncEvent)": {"Returns": [], "Parameters": [["@B_android#media#MediaSyncEvent_E@", "MediaSyncEvent: event that triggers the capture."]], "Throws": [["", "java.lang.IllegalStateException"], ["@B_java#lang#IllegalStateException_E@", ""]], "SeeAlso": ["@B_android#media#MediaSyncEvent_E@"], "Permissions": [], "Description": "Starts recording from the AudioRecord instance when the specified synchronization event occurs on the specified audio session.", "history": "Added in API level 16", "FullName": "public void startRecording (MediaSyncEvent syncEvent)"}, "removeOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener)": {"Returns": [], "Parameters": [["@B_android#media#AudioRouting#OnRoutingChangedListener_E@", "AudioRouting.OnRoutingChangedListener: The previously added @B_android#media#AudioRouting#OnRoutingChangedListener_E@ interface to remove."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes an @B_android#media#AudioRouting#OnRoutingChangedListener_E@ which has been previously added to receive rerouting notifications.", "history": "Added in API level 24", "FullName": "public void removeOnRoutingChangedListener (AudioRouting.OnRoutingChangedListener listener)"}, "startRecording()": {"Returns": [], "Parameters": [], "Throws": [["", "java.lang.IllegalStateException"], ["@B_java#lang#IllegalStateException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Starts recording from the AudioRecord instance.", "history": "Added in API level 3", "FullName": "public void startRecording ()"}, "getBufferSizeInFrames()": {"Returns": [["int", "current size in frames of the AudioRecord buffer."]], "Parameters": [], "Throws": [["", "java.lang.IllegalStateException"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the frame count of the native AudioRecord buffer. This is greater than or equal to the bufferSizeInBytes converted to frame units specified in the AudioRecord constructor or Builder. The native frame count may be enlarged to accommodate the requirements of the source on creation or if the AudioRecord is subsequently rerouted.", "history": "Added in API level 23", "FullName": "public int getBufferSizeInFrames ()"}, "setPositionNotificationPeriod(int)": {"Returns": [["int", "error code or success, see @B_android#media#AudioRecord#SUCCESS_E@, @B_android#media#AudioRecord#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["int", "int: update period expressed in frames"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the period at which the listener is called, if set with @B_android#media#AudioRecord#setRecordPositionUpdateListener_E@ or @B_android#media#AudioRecord#setRecordPositionUpdateListener_E@. It is possible for notifications to be lost if the period is too small.", "history": "Added in API level 3", "FullName": "public int setPositionNotificationPeriod (int periodInFrames)"}, "getMinBufferSize(int,int,int)": {"Returns": [["int", "@B_android#media#AudioRecord#ERROR_BAD_VALUE_E@ if the recording parameters are not supported by the hardware, or an invalid parameter was passed, or @B_android#media#AudioRecord#ERROR_E@ if the implementation was unable to query the hardware for its input properties, or the minimum buffer size expressed in bytes."]], "Parameters": [["int", "int: the sample rate expressed in Hertz. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ is not permitted."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_IN_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_IN_STEREO_E@"], ["int", "int: the format in which the audio data is represented. See @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@."]], "Throws": [], "SeeAlso": ["@B_android#media#AudioRecord#AudioRecord_E@"], "Permissions": [], "Description": "Returns the minimum buffer size required for the successful creation of an AudioRecord object, in byte units. Note that this size doesn't guarantee a smooth recording under load, and higher values should be chosen according to the expected frequency at which the AudioRecord instance will be polled for new data. See @B_android#media#AudioRecord#AudioRecord_E@ for more information on valid configuration values.", "history": "Added in API level 3", "FullName": "public static int getMinBufferSize (int sampleRateInHz, int channelConfig, int audioFormat)"}, "getAudioSource()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#MediaRecorder#AudioSource_E@"], "Permissions": [], "Description": "Returns the audio recording source.", "history": "Added in API level 3", "FullName": "public int getAudioSource ()"}, "getActiveMicrophones()": {"Returns": [["@B_java#util#List_E@", "a lists of @B_android#media#MicrophoneInfo_E@ representing the active microphones."]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", "if an error occurs"]], "SeeAlso": [], "Permissions": [], "Description": "Returns a lists of @B_android#media#MicrophoneInfo_E@ representing the active microphones. By querying channel mapping for each active microphone, developer can know how the microphone is used by each channels or a capture stream. Note that the information about the active microphones may change during a recording. See @B_android#media#AudioManager#registerAudioDeviceCallback_E@ to be notified of changes in the audio devices, querying the active microphones then will return the latest information.", "history": "Added in API level 28", "FullName": "public List<MicrophoneInfo> getActiveMicrophones ()"}, "getRoutedDevice()": {"Returns": [["@B_android#media#AudioDeviceInfo_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns an @B_android#media#AudioDeviceInfo_E@ identifying the current routing of this AudioRecord. Note: The query is only valid if the AudioRecord is currently recording. If it is not, getRoutedDevice() will return null.", "history": "Added in API level 23", "FullName": "public AudioDeviceInfo getRoutedDevice ()"}, "read(java.nio.ByteBuffer,int,int)": {"Returns": [["int", "zero or the positive number of bytes that were read, or one of the following error codes. The number of bytes will not exceed sizeInBytes and will be truncated to be a multiple of the frame size. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the direct buffer to which the recorded audio data is written. Data is written to audioBuffer.position(). This value must never be null."], ["int", "int: the number of requested bytes. It is recommended but not enforced that the number of bytes requested be a multiple of the frame size (sample size in bytes multiplied by the channel count)."], ["int", "int: one of @B_android#media#AudioRecord#READ_BLOCKING_E@, @B_android#media#AudioRecord#READ_NON_BLOCKING_E@. With @B_android#media#AudioRecord#READ_BLOCKING_E@, the read will block until all the requested data is read. With @B_android#media#AudioRecord#READ_NON_BLOCKING_E@, the read will return immediately after reading as much audio data as possible without blocking. Value is @B_android#media#AudioRecord#READ_BLOCKING_E@, or @B_android#media#AudioRecord#READ_NON_BLOCKING_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a direct buffer. If this buffer is not a direct buffer, this method will always return 0. Note that the value returned by @B_java#nio#Buffer#position_E@ on this buffer is unchanged after a call to this method. The representation of the data in the buffer will depend on the format specified in the AudioRecord constructor, and will be native endian.", "history": "Added in API level 23", "FullName": "public int read (ByteBuffer audioBuffer, int sizeInBytes, int readMode)"}, "stop()": {"Returns": [], "Parameters": [], "Throws": [["", "java.lang.IllegalStateException"], ["@B_java#lang#IllegalStateException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Stops recording.", "history": "Added in API level 3", "FullName": "public void stop ()"}, "getTimestamp(android.media.AudioTimestamp,int)": {"Returns": [["int", "@B_android#media#AudioRecord#SUCCESS_E@ if a timestamp is available, or @B_android#media#AudioRecord#ERROR_INVALID_OPERATION_E@ if a timestamp not available."]], "Parameters": [["@B_android#media#AudioTimestamp_E@", "AudioTimestamp: a caller provided non-null AudioTimestamp instance, which is updated with the AudioRecord frame delivery information upon success. This value must never be null."], ["int", "int: one of @B_android#media#AudioTimestamp#TIMEBASE_BOOTTIME_E@ or @B_android#media#AudioTimestamp#TIMEBASE_MONOTONIC_E@, used to select the clock for the AudioTimestamp time. Value is @B_android#media#AudioTimestamp#TIMEBASE_MONOTONIC_E@, or @B_android#media#AudioTimestamp#TIMEBASE_BOOTTIME_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Poll for an @B_android#media#AudioTimestamp_E@ on demand. The AudioTimestamp reflects the frame delivery information at the earliest point available in the capture pipeline. Calling @B_android#media#AudioRecord#startRecording_E@ following a @B_android#media#AudioRecord#stop_E@ will reset the frame count to 0.", "history": "Added in API level 24", "FullName": "public int getTimestamp (AudioTimestamp outTimestamp, int timebase)"}, "read(short[], int, int, int)": {"Returns": [["int", "zero or the positive number of shorts that were read, or one of the following error codes. The number of shorts will be a multiple of the channel count not to exceed sizeInShorts. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["short[]", "short: the array to which the recorded audio data is written.This value must never be null."], ["int", "int: index in audioData from which the data is written expressed in shorts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of requested shorts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioRecord#READ_BLOCKING_E@, @B_android#media#AudioRecord#READ_NON_BLOCKING_E@. With @B_android#media#AudioRecord#READ_BLOCKING_E@, the read will block until all the requested data is read. With @B_android#media#AudioRecord#READ_NON_BLOCKING_E@, the read will return immediately after reading as much audio data as possible without blocking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a short array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ to correspond to the data in the array.", "history": "added in API level 23", "FullName": "public int read (short[] audioData, int offsetInShorts, int sizeInShorts, int readMode)"}, "read(byte[], int, int, int)": {"Returns": [["int", "zero or the positive number of bytes that were read, or one of the following error codes. The number of bytes will be a multiple of the frame size in bytes not to exceed sizeInBytes. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["byte[]", "byte: the array to which the recorded audio data is written.This value must never be null."], ["int", "int: index in audioData to which the data is written expressed in bytes. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of requested bytes. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioRecord#READ_BLOCKING_E@, @B_android#media#AudioRecord#READ_NON_BLOCKING_E@. With @B_android#media#AudioRecord#READ_BLOCKING_E@, the read will block until all the requested data is read. With @B_android#media#AudioRecord#READ_NON_BLOCKING_E@, the read will return immediately after reading as much audio data as possible without blocking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a byte array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@ to correspond to the data in the array. The format can be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, but this is deprecated.", "history": "added in API level 23", "FullName": "public int read (byte[] audioData, int offsetInBytes, int sizeInBytes, int readMode)"}, "getState()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#AudioRecord_E@"], "Permissions": [], "Description": "Returns the state of the AudioRecord instance. This is useful after the AudioRecord instance has been created to check if it was initialized properly. This ensures that the appropriate hardware resources have been acquired.", "history": "Added in API level 3", "FullName": "public int getState ()"}, "read(short[], int, int)": {"Returns": [["int", "zero or the positive number of shorts that were read, or one of the following error codes. The number of shorts will be a multiple of the channel count not to exceed sizeInShorts. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["short[]", "short: the array to which the recorded audio data is written.This value must never be null."], ["int", "int: index in audioData to which the data is written expressed in shorts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of requested shorts. Must not be negative, or cause the data access to go out of bounds of the array."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a short array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ to correspond to the data in the array.", "history": "added in API level 3", "FullName": "public int read (short[] audioData, int offsetInShorts, int sizeInShorts)"}, "read(float[],int,int,int)": {"Returns": [["int", "zero or the positive number of floats that were read, or one of the following error codes. The number of floats will be a multiple of the channel count not to exceed sizeInFloats. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["float[]", "float: the array to which the recorded audio data is written. This value must never be null."], ["int", "int: index in audioData from which the data is written. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of requested floats. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioRecord#READ_BLOCKING_E@, @B_android#media#AudioRecord#READ_NON_BLOCKING_E@. With @B_android#media#AudioRecord#READ_BLOCKING_E@, the read will block until all the requested data is read. With @B_android#media#AudioRecord#READ_NON_BLOCKING_E@, the read will return immediately after reading as much audio data as possible without blocking. Value is @B_android#media#AudioRecord#READ_BLOCKING_E@, or @B_android#media#AudioRecord#READ_NON_BLOCKING_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a float array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@ to correspond to the data in the array.", "history": "Added in API level 23", "FullName": "public int read (float[] audioData, int offsetInFloats, int sizeInFloats, int readMode)"}, "read(byte[],int,int,int)": {"Returns": [["int", "zero or the positive number of bytes that were read, or one of the following error codes. The number of bytes will be a multiple of the frame size in bytes not to exceed sizeInBytes. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["byte[]", "byte: the array to which the recorded audio data is written. This value must never be null."], ["int", "int: index in audioData to which the data is written expressed in bytes. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of requested bytes. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioRecord#READ_BLOCKING_E@, @B_android#media#AudioRecord#READ_NON_BLOCKING_E@. With @B_android#media#AudioRecord#READ_BLOCKING_E@, the read will block until all the requested data is read. With @B_android#media#AudioRecord#READ_NON_BLOCKING_E@, the read will return immediately after reading as much audio data as possible without blocking. Value is @B_android#media#AudioRecord#READ_BLOCKING_E@, or @B_android#media#AudioRecord#READ_NON_BLOCKING_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a byte array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@ to correspond to the data in the array. The format can be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, but this is deprecated.", "history": "Added in API level 23", "FullName": "public int read (byte[] audioData, int offsetInBytes, int sizeInBytes, int readMode)"}, "getAudioFormat()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured audio data encoding. See @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@.", "history": "Added in API level 3", "FullName": "public int getAudioFormat ()"}, "setRecordPositionUpdateListener(android.media.AudioRecord.OnRecordPositionUpdateListener)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the listener the AudioRecord notifies when a previously set marker is reached or for each periodic record head position update.", "history": "Added in API level 3", "FullName": "public void setRecordPositionUpdateListener (AudioRecord.OnRecordPositionUpdateListener listener)"}, "release()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Releases the native AudioRecord resources. The object can no longer be used and the reference should be set to null after a call to release()", "history": "Added in API level 3", "FullName": "public void release ()"}, "getAudioSessionId()": {"Returns": [["int", "the ID of the audio session this AudioRecord belongs to."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the audio session ID.", "history": "Added in API level 16", "FullName": "public int getAudioSessionId ()"}, "AudioRecord(int,int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: the recording source. See @B_android#media#MediaRecorder#AudioSource_E@ for the recording source definitions."], ["int", "int: the sample rate expressed in Hertz. 44100Hz is currently the only rate that is guaranteed to work on all devices, but other rates such as 22050, 16000, and 11025 may work on some devices. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ means to use a route-dependent value which is usually the sample rate of the source. @B_android#media#AudioRecord#getSampleRate_E@ can be used to retrieve the actual sample rate chosen."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_IN_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_IN_STEREO_E@. @B_android#media#AudioFormat#CHANNEL_IN_MONO_E@ is guaranteed to work on all devices."], ["int", "int: the format in which the audio data is to be returned. See @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@."], ["int", "int: the total size (in bytes) of the buffer where audio data is written to during the recording. New audio data can be read from this buffer in smaller chunks than this size. See @B_android#media#AudioRecord#getMinBufferSize_E@ to determine the minimum required buffer size for the successful creation of an AudioRecord instance. Using values smaller than getMinBufferSize() will result in an initialization failure."]], "Throws": [["", "java.lang.IllegalArgumentException"], ["@B_java#lang#IllegalArgumentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Class constructor. Though some invalid parameters will result in an @B_java#lang#IllegalArgumentException_E@ exception, other errors do not. Thus you should call @B_android#media#AudioRecord#getState_E@ immediately after construction to confirm that the object is usable.", "history": "Added in API level 3", "FullName": "public AudioRecord (int audioSource, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes)"}, "getPreferredDevice()": {"Returns": [["@B_android#media#AudioDeviceInfo_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the selected input specified by @B_android#media#AudioRecord#setPreferredDevice_E@. Note that this is not guarenteed to correspond to the actual device being used for recording.", "history": "Added in API level 23", "FullName": "public AudioDeviceInfo getPreferredDevice ()"}, "getMetrics()": {"Returns": [["@B_android#os#PersistableBundle_E@", "a @B_android#os#PersistableBundle_E@ containing the set of attributes and values available for the media being handled by this instance of AudioRecord The attributes are descibed in @B_android#media#AudioRecord#MetricsConstants_E@. Additional vendor-specific fields may also be present in the return value."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return Metrics data about the current AudioTrack instance.", "history": "Added in API level 28", "FullName": "public PersistableBundle getMetrics ()"}, "getFormat()": {"Returns": [["@B_android#media#AudioFormat_E@", "an @B_android#media#AudioFormat_E@ containing the AudioRecord parameters at the time of configuration. This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured AudioRecord format.", "history": "Added in API level 23", "FullName": "public AudioFormat getFormat ()"}, "read(java.nio.ByteBuffer, int, int)": {"Returns": [["int", "zero or the positive number of bytes that were read, or one of the following error codes. The number of bytes will not exceed sizeInBytes and will be truncated to be a multiple of the frame size. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the direct buffer to which the recorded audio data is written. Data is written to audioBuffer.position().This value must never be null."], ["int", "int: the number of requested bytes. It is recommended but not enforced that the number of bytes requested be a multiple of the frame size (sample size in bytes multiplied by the channel count)."], ["int", "int: one of @B_android#media#AudioRecord#READ_BLOCKING_E@, @B_android#media#AudioRecord#READ_NON_BLOCKING_E@. With @B_android#media#AudioRecord#READ_BLOCKING_E@, the read will block until all the requested data is read. With @B_android#media#AudioRecord#READ_NON_BLOCKING_E@, the read will return immediately after reading as much audio data as possible without blocking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a direct buffer. If this buffer is not a direct buffer, this method will always return 0. Note that the value returned by @B_java#nio#Buffer#position_E@ on this buffer is unchanged after a call to this method. The representation of the data in the buffer will depend on the format specified in the AudioRecord constructor, and will be native endian.", "history": "added in API level 23", "FullName": "public int read (ByteBuffer audioBuffer, int sizeInBytes, int readMode)"}, "read(short[],int,int,int)": {"Returns": [["int", "zero or the positive number of shorts that were read, or one of the following error codes. The number of shorts will be a multiple of the channel count not to exceed sizeInShorts. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["short[]", "short: the array to which the recorded audio data is written. This value must never be null."], ["int", "int: index in audioData from which the data is written expressed in shorts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of requested shorts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioRecord#READ_BLOCKING_E@, @B_android#media#AudioRecord#READ_NON_BLOCKING_E@. With @B_android#media#AudioRecord#READ_BLOCKING_E@, the read will block until all the requested data is read. With @B_android#media#AudioRecord#READ_NON_BLOCKING_E@, the read will return immediately after reading as much audio data as possible without blocking. Value is @B_android#media#AudioRecord#READ_BLOCKING_E@, or @B_android#media#AudioRecord#READ_NON_BLOCKING_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a short array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ to correspond to the data in the array.", "history": "Added in API level 23", "FullName": "public int read (short[] audioData, int offsetInShorts, int sizeInShorts, int readMode)"}, "setPreferredMicrophoneFieldDimension(float)": {"Returns": [["boolean", "true if sucessful."]], "Parameters": [["float", "float: the desired field dimension of microphone capture. Range is from -1 (wide angle), though 0 (no zoom) to 1 (maximum zoom). Value is between -1.0 and 1.0 inclusive"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Specifies the zoom factor (i.e. the field dimension) for the selected microphone (for processing). The selected microphone is determined by the use-case for the stream.", "history": "Added in API level 29", "FullName": "public boolean setPreferredMicrophoneFieldDimension (float zoom)"}, "getSampleRate()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured audio sink sample rate in Hz. The sink sample rate never changes after construction. If the constructor had a specific sample rate, then the sink sample rate is that value. If the constructor had @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@, then the sink sample rate is a route-dependent default value based on the source [sic].", "history": "Added in API level 3", "FullName": "public int getSampleRate ()"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 3", "FullName": "protected void finalize ()"}, "read(short[],int,int)": {"Returns": [["int", "zero or the positive number of shorts that were read, or one of the following error codes. The number of shorts will be a multiple of the channel count not to exceed sizeInShorts. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["short[]", "short: the array to which the recorded audio data is written. This value must never be null."], ["int", "int: index in audioData to which the data is written expressed in shorts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of requested shorts. Must not be negative, or cause the data access to go out of bounds of the array."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a short array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ to correspond to the data in the array.", "history": "Added in API level 3", "FullName": "public int read (short[] audioData, int offsetInShorts, int sizeInShorts)"}, "read(byte[],int,int)": {"Returns": [["int", "zero or the positive number of bytes that were read, or one of the following error codes. The number of bytes will not exceed sizeInBytes. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["byte[]", "byte: the array to which the recorded audio data is written. This value must never be null."], ["int", "int: index in audioData from which the data is written expressed in bytes."], ["int", "int: the number of requested bytes."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a byte array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@ to correspond to the data in the array.", "history": "Added in API level 3", "FullName": "public int read (byte[] audioData, int offsetInBytes, int sizeInBytes)"}, "read(float[], int, int, int)": {"Returns": [["int", "zero or the positive number of floats that were read, or one of the following error codes. The number of floats will be a multiple of the channel count not to exceed sizeInFloats. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["float[]", "float: the array to which the recorded audio data is written.This value must never be null."], ["int", "int: index in audioData from which the data is written. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of requested floats. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioRecord#READ_BLOCKING_E@, @B_android#media#AudioRecord#READ_NON_BLOCKING_E@. With @B_android#media#AudioRecord#READ_BLOCKING_E@, the read will block until all the requested data is read. With @B_android#media#AudioRecord#READ_NON_BLOCKING_E@, the read will return immediately after reading as much audio data as possible without blocking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a float array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@ to correspond to the data in the array.", "history": "added in API level 23", "FullName": "public int read (float[] audioData, int offsetInFloats, int sizeInFloats, int readMode)"}, "AudioRecord(int, int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: the recording source. See @B_android#media#MediaRecorder#AudioSource_E@ for the recording source definitions."], ["int", "int: the sample rate expressed in Hertz. 44100Hz is currently the only rate that is guaranteed to work on all devices, but other rates such as 22050, 16000, and 11025 may work on some devices. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ means to use a route-dependent value which is usually the sample rate of the source. @B_android#media#AudioRecord#getSampleRate_E@ can be used to retrieve the actual sample rate chosen."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_IN_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_IN_STEREO_E@. @B_android#media#AudioFormat#CHANNEL_IN_MONO_E@ is guaranteed to work on all devices."], ["int", "int: the format in which the audio data is to be returned. See @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@."], ["int", "int: the total size (in bytes) of the buffer where audio data is written to during the recording. New audio data can be read from this buffer in smaller chunks than this size. See @B_android#media#AudioRecord#getMinBufferSize_E@ to determine the minimum required buffer size for the successful creation of an AudioRecord instance. Using values smaller than getMinBufferSize() will result in an initialization failure."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Class constructor. Though some invalid parameters will result in an @B_java#lang#IllegalArgumentException_E@ exception, other errors do not. Thus you should call @B_android#media#AudioRecord#getState_E@ immediately after construction to confirm that the object is usable.", "history": "added in API level 3", "FullName": "public AudioRecord (int audioSource, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes)"}, "getMinBufferSize(int, int, int)": {"Returns": [["int", "@B_android#media#AudioRecord#ERROR_BAD_VALUE_E@ if the recording parameters are not supported by the hardware, or an invalid parameter was passed, or @B_android#media#AudioRecord#ERROR_E@ if the implementation was unable to query the hardware for its input properties, or the minimum buffer size expressed in bytes."]], "Parameters": [["int", "int: the sample rate expressed in Hertz. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ is not permitted."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_IN_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_IN_STEREO_E@"], ["int", "int: the format in which the audio data is represented. See @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@."]], "Throws": [], "SeeAlso": ["@B_android#media#AudioRecord#AudioRecord_E@"], "Permissions": [], "Description": "Returns the minimum buffer size required for the successful creation of an AudioRecord object, in byte units. Note that this size doesn't guarantee a smooth recording under load, and higher values should be chosen according to the expected frequency at which the AudioRecord instance will be polled for new data. See @B_android#media#AudioRecord#AudioRecord_E@ for more information on valid configuration values.", "history": "added in API level 3", "FullName": "public static int getMinBufferSize (int sampleRateInHz, int channelConfig, int audioFormat)"}, "getNotificationMarkerPosition()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the notification marker position expressed in frames.", "history": "Added in API level 3", "FullName": "public int getNotificationMarkerPosition ()"}, "setNotificationMarkerPosition(int)": {"Returns": [["int", "error code or success, see @B_android#media#AudioRecord#SUCCESS_E@, @B_android#media#AudioRecord#ERROR_BAD_VALUE_E@, @B_android#media#AudioRecord#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["int", "int: marker position expressed in frames"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the marker position at which the listener is called, if set with @B_android#media#AudioRecord#setRecordPositionUpdateListener_E@ or @B_android#media#AudioRecord#setRecordPositionUpdateListener_E@.", "history": "Added in API level 3", "FullName": "public int setNotificationMarkerPosition (int markerInFrames)"}, "addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#AudioRouting#OnRoutingChangedListener_E@", "AudioRouting.OnRoutingChangedListener: The @B_android#media#AudioRouting#OnRoutingChangedListener_E@ interface to receive notifications of rerouting events."], ["@B_android#os#Handler_E@", "Handler: Specifies the @B_android#os#Handler_E@ object for the thread on which to execute the callback. If null, the @B_android#os#Handler_E@ associated with the main @B_android#os#Looper_E@ will be used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds an @B_android#media#AudioRouting#OnRoutingChangedListener_E@ to receive notifications of routing changes on this AudioRecord.", "history": "Added in API level 24", "FullName": "public void addOnRoutingChangedListener (AudioRouting.OnRoutingChangedListener listener, Handler handler)"}, "getRecordingState()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#AudioRecord_E@"], "Permissions": [], "Description": "Returns the recording state of the AudioRecord instance.", "history": "Added in API level 3", "FullName": "public int getRecordingState ()"}, "read(byte[], int, int)": {"Returns": [["int", "zero or the positive number of bytes that were read, or one of the following error codes. The number of bytes will not exceed sizeInBytes. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["byte[]", "byte: the array to which the recorded audio data is written.This value must never be null."], ["int", "int: index in audioData from which the data is written expressed in bytes."], ["int", "int: the number of requested bytes."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a byte array. The format specified in the AudioRecord constructor should be @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@ to correspond to the data in the array.", "history": "added in API level 3", "FullName": "public int read (byte[] audioData, int offsetInBytes, int sizeInBytes)"}, "setPreferredMicrophoneDirection(int)": {"Returns": [["boolean", "true if sucessful."]], "Parameters": [["int", "int: Value is @B_android#media#MicrophoneDirection#MIC_DIRECTION_UNSPECIFIED_E@, @B_android#media#MicrophoneDirection#MIC_DIRECTION_TOWARDS_USER_E@, @B_android#media#MicrophoneDirection#MIC_DIRECTION_AWAY_FROM_USER_E@, or @B_android#media#MicrophoneDirection#MIC_DIRECTION_EXTERNAL_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Specifies the logical microphone (for processing). Applications can use this to specify which side of the device to optimize capture from. Typically used in conjunction with the camera capturing video.", "history": "Added in API level 29", "FullName": "public boolean setPreferredMicrophoneDirection (int direction)"}, "removeOnRoutingChangedListener(android.media.AudioRecord.OnRoutingChangedListener)": {"Returns": [], "Parameters": [["@B_android#media#AudioRecord#OnRoutingChangedListener_E@", "AudioRecord.OnRoutingChangedListener: The previously added @B_android#media#AudioRecord#OnRoutingChangedListener_E@ interface to remove."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "users should switch to the general purpose @B_android#media#AudioRouting#OnRoutingChangedListener_E@ class instead. Removes an @B_android#media#AudioRecord#OnRoutingChangedListener_E@ which has been previously added to receive rerouting notifications.", "history": "Added in API level 23 Deprecated in API level 24", "FullName": "public void removeOnRoutingChangedListener (AudioRecord.OnRoutingChangedListener listener)"}, "getPositionNotificationPeriod()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the notification update period expressed in frames.", "history": "Added in API level 3", "FullName": "public int getPositionNotificationPeriod ()"}, "registerAudioRecordingCallback(java.util.concurrent.Executor,android.media.AudioManager.AudioRecordingCallback)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#Executor_E@", "Executor: @B_java#util#concurrent#Executor_E@ to handle the callbacks. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#media#AudioManager#AudioRecordingCallback_E@", "AudioManager.AudioRecordingCallback: non-null callback to register This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be notified of audio capture changes via a @B_android#media#AudioManager#AudioRecordingCallback_E@. A callback is received when the capture path configuration changes (pre-processing, format, sampling rate...) or capture is silenced/unsilenced by the system.", "history": "Added in API level 29", "FullName": "public void registerAudioRecordingCallback (Executor executor, AudioManager.AudioRecordingCallback cb)"}, "getChannelConfiguration()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured channel position mask. See @B_android#media#AudioFormat#CHANNEL_IN_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_IN_STEREO_E@. This method may return @B_android#media#AudioFormat#CHANNEL_INVALID_E@ if a channel index mask is used. Consider @B_android#media#AudioRecord#getFormat_E@ instead, to obtain an @B_android#media#AudioFormat_E@, which contains both the channel position mask and the channel index mask.", "history": "Added in API level 3", "FullName": "public int getChannelConfiguration ()"}, "setPreferredDevice(android.media.AudioDeviceInfo)": {"Returns": [["boolean", "true if successful, false if the specified @B_android#media#AudioDeviceInfo_E@ is non-null and does not correspond to a valid audio input device."]], "Parameters": [["@B_android#media#AudioDeviceInfo_E@", "AudioDeviceInfo: The @B_android#media#AudioDeviceInfo_E@ specifying the audio source. If deviceInfo is null, default routing is restored."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Specifies an audio device (via an @B_android#media#AudioDeviceInfo_E@ object) to route the input to this AudioRecord.", "history": "Added in API level 23", "FullName": "public boolean setPreferredDevice (AudioDeviceInfo deviceInfo)"}, "read(java.nio.ByteBuffer, int)": {"Returns": [["int", "zero or the positive number of bytes that were read, or one of the following error codes. The number of bytes will not exceed sizeInBytes and will be truncated to be a multiple of the frame size. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the direct buffer to which the recorded audio data is written. Data is written to audioBuffer.position().This value must never be null."], ["int", "int: the number of requested bytes. It is recommended but not enforced that the number of bytes requested be a multiple of the frame size (sample size in bytes multiplied by the channel count)."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a direct buffer. If this buffer is not a direct buffer, this method will always return 0. Note that the value returned by @B_java#nio#Buffer#position_E@ on this buffer is unchanged after a call to this method. The representation of the data in the buffer will depend on the format specified in the AudioRecord constructor, and will be native endian.", "history": "added in API level 3", "FullName": "public int read (ByteBuffer audioBuffer, int sizeInBytes)"}, "getTimestamp(android.media.AudioTimestamp, int)": {"Returns": [["int", "@B_android#media#AudioRecord#SUCCESS_E@ if a timestamp is available, or @B_android#media#AudioRecord#ERROR_INVALID_OPERATION_E@ if a timestamp not available."]], "Parameters": [["@B_android#media#AudioTimestamp_E@", "AudioTimestamp: a caller provided non-null AudioTimestamp instance, which is updated with the AudioRecord frame delivery information upon success."], ["int", "int: one of @B_android#media#AudioTimestamp#TIMEBASE_BOOTTIME_E@ or @B_android#media#AudioTimestamp#TIMEBASE_MONOTONIC_E@, used to select the clock for the AudioTimestamp time."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Poll for an @B_android#media#AudioTimestamp_E@ on demand. The AudioTimestamp reflects the frame delivery information at the earliest point available in the capture pipeline. Calling @B_android#media#AudioRecord#startRecording_E@ following a @B_android#media#AudioRecord#stop_E@ will reset the frame count to 0.", "history": "added in API level 24", "FullName": "public int getTimestamp (AudioTimestamp outTimestamp, int timebase)"}, "getChannelCount()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured number of channels.", "history": "Added in API level 3", "FullName": "public int getChannelCount ()"}, "addOnRoutingChangedListener(android.media.AudioRecord.OnRoutingChangedListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#AudioRecord#OnRoutingChangedListener_E@", "AudioRecord.OnRoutingChangedListener: The @B_android#media#AudioRecord#OnRoutingChangedListener_E@ interface to receive notifications of rerouting events."], ["@B_android#os#Handler_E@", "Handler: Specifies the @B_android#os#Handler_E@ object for the thread on which to execute the callback. If null, the @B_android#os#Handler_E@ associated with the main @B_android#os#Looper_E@ will be used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "users should switch to the general purpose @B_android#media#AudioRouting#OnRoutingChangedListener_E@ class instead. Adds an @B_android#media#AudioRecord#OnRoutingChangedListener_E@ to receive notifications of routing changes on this AudioRecord.", "history": "Added in API level 23 Deprecated in API level 24", "FullName": "public void addOnRoutingChangedListener (AudioRecord.OnRoutingChangedListener listener, Handler handler)"}, "read(java.nio.ByteBuffer,int)": {"Returns": [["int", "zero or the positive number of bytes that were read, or one of the following error codes. The number of bytes will not exceed sizeInBytes and will be truncated to be a multiple of the frame size. ERROR_INVALID_OPERATION if the object isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the object is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next read() ERROR in case of other error"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the direct buffer to which the recorded audio data is written. Data is written to audioBuffer.position(). This value must never be null."], ["int", "int: the number of requested bytes. It is recommended but not enforced that the number of bytes requested be a multiple of the frame size (sample size in bytes multiplied by the channel count)."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reads audio data from the audio hardware for recording into a direct buffer. If this buffer is not a direct buffer, this method will always return 0. Note that the value returned by @B_java#nio#Buffer#position_E@ on this buffer is unchanged after a call to this method. The representation of the data in the buffer will depend on the format specified in the AudioRecord constructor, and will be native endian.", "history": "Added in API level 3", "FullName": "public int read (ByteBuffer audioBuffer, int sizeInBytes)"}, "unregisterAudioRecordingCallback(android.media.AudioManager.AudioRecordingCallback)": {"Returns": [], "Parameters": [["@B_android#media#AudioManager#AudioRecordingCallback_E@", "AudioManager.AudioRecordingCallback: non-null callback to unregister This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Unregister an audio recording callback previously registered with @B_android#media#AudioRecord#registerAudioRecordingCallback_E@.", "history": "Added in API level 29", "FullName": "public void unregisterAudioRecordingCallback (AudioManager.AudioRecordingCallback cb)"}}, "Inheritance": [], "ClassName": "android.media.AudioRecord", "ClassDesc": "The AudioRecord class manages the audio resources for Java applications to record audio from the audio input hardware of the platform. This is achieved by \"pulling\" (reading) the data from the AudioRecord object. The application is responsible for polling the AudioRecord object in time using one of the following three methods: @B_android#media#AudioRecord#read_E@, @B_android#media#AudioRecord#read_E@ or @B_android#media#AudioRecord#read_E@. The choice of which method to use will be based on the audio data storage format that is the most convenient for the user of AudioRecord. Upon creation, an AudioRecord object initializes its associated audio buffer that it will fill with the new audio data. The size of this buffer, specified during the construction, determines how long an AudioRecord can record before \"over-running\" data that has not been read yet. Data should be read from the audio hardware in chunks of sizes inferior to the total recording buffer size."}