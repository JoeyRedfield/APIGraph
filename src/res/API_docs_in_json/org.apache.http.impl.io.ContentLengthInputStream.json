{"Functions": {"read(byte[])": {"Returns": [["", "The number of bytes read into the buffer."]], "Parameters": [["byte[]", "The byte array to put the new data in."]], "Throws": [["@B_java#io#IOException_E@", "If an IO problem occurs"]], "SeeAlso": ["@B_java#io#InputStream#read_E@"], "Permissions": [], "Description": "Read more bytes from the stream.", "history": "Added in API level 1", "FullName": "public int read (byte[] b)"}, "read(byte[], int, int)": {"Returns": [["", "The number of bytes read, or -1 if the end of content has been reached."]], "Parameters": [["byte[]", "The byte array to fill."], ["int", "Start filling at this position."], ["int", "The number of bytes to attempt to read."]], "Throws": [["@B_java#io#IOException_E@", "Should an error occur on the wrapped stream."]], "SeeAlso": [], "Permissions": [], "Description": "Does standard @B_java#io#InputStream#read_E@ behavior, but also notifies the watcher when the contents have been consumed.", "history": "Added in API level 1", "FullName": "public int read (byte[] b, int off, int len)"}, "close()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", "If an IO problem occurs."]], "SeeAlso": [], "Permissions": [], "Description": "Reads until the end of the known length of content. Does not close the underlying socket input, but instead leaves it primed to parse the next response.", "history": "Added in API level 1", "FullName": "public void close ()"}, "read()": {"Returns": [["", "The next byte or -1 if the end of stream has been reached."]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", "If an IO problem occurs"]], "SeeAlso": ["@B_java#io#InputStream#read_E@"], "Permissions": [], "Description": "Read the next byte from the stream", "history": "Added in API level 1", "FullName": "public int read ()"}, "skip(long)": {"Returns": [["", "The actual number of bytes skipped. <= 0 if no bytes are skipped."]], "Parameters": [["long", "The number of bytes to skip."]], "Throws": [["@B_java#io#IOException_E@", "If an error occurs while skipping bytes."]], "SeeAlso": ["@B_java#io#InputStream#skip_E@"], "Permissions": [], "Description": "Skips and discards a number of bytes from the input stream.", "history": "Added in API level 1", "FullName": "public long skip (long n)"}, "ContentLengthInputStream(org.apache.http.io.SessionInputBuffer, long)": {"Returns": [], "Parameters": [["@B_org#apache#http#io#SessionInputBuffer_E@", "The session input buffer to wrap"], ["long", "The maximum number of bytes that can be read from the stream. Subsequent read operations will return -1."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a new length limited stream", "history": "Added in API level 1", "FullName": "public ContentLengthInputStream (SessionInputBuffer in, long contentLength)"}}, "Inheritance": ["@B_java#io#InputStream_E@"], "ClassName": "org.apache.http.impl.io.ContentLengthInputStream", "ClassDesc": "Please use @B_java#net#URL#openConnection_E@ instead. Please visit Stream that cuts off after a specified number of bytes. Note that this class NEVER closes the underlying stream, even when close gets called. Instead, it will read until the \"end\" of its chunking on close, which allows for the seamless execution of subsequent HTTP 1.1 requests, while not requiring the client to remember to read the entire contents of the response. Implementation note: Choices abound. One approach would pass through the @B_java#io#InputStream#mark_E@ and @B_java#io#InputStream#reset_E@ calls to the underlying stream. That's tricky, though, because you then have to start duplicating the work of keeping track of how much a reset rewinds. Further, you have to watch out for the \"readLimit\", and since the semantics for the readLimit leave room for differing implementations, you might get into a lot of trouble. Alternatively, you could make this class extend @B_java#io#BufferedInputStream_E@ and then use the protected members of that class to avoid duplicated effort. That solution has the side effect of adding yet another possible layer of buffering. Then, there is the simple choice, which this takes - simply don't support @B_java#io#InputStream#mark_E@ and @B_java#io#InputStream#reset_E@. That choice has the added benefit of keeping this class very simple."}