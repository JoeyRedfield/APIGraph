{"Functions": {"getEmptyInstance()": {"Returns": [["@B_android#icu#text#DateTimePatternGenerator_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create empty generator, to be constructed with addPattern(...) etc.", "history": "Added in API level 24", "FullName": "public static DateTimePatternGenerator getEmptyInstance ()"}, "getSkeleton(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "skeleton, such as \"MMMdd\""]], "Parameters": [["@B_java#lang#String_E@", "String: Input pattern, such as \"dd/MMM\""]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Utility to return a unique skeleton from a given pattern. For example, both \"MMM-dd\" and \"dd/MMM\" produce the skeleton \"MMMdd\".", "history": "Added in API level 24", "FullName": "public String getSkeleton (String pattern)"}, "getBaseSkeleton(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "skeleton, such as \"MMMdd\""]], "Parameters": [["@B_java#lang#String_E@", "String: Input pattern, such as \"dd/MMM\""]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Utility to return a unique base skeleton from a given pattern. This is the same as the skeleton, except that differences in length are minimized so as to only preserve the difference between string and numeric form. So for example, both \"MMM-dd\" and \"d/MMM\" produce the skeleton \"MMMd\" (notice the single d).", "history": "Added in API level 24", "FullName": "public String getBaseSkeleton (String pattern)"}, "setDateTimeFormat(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: message format pattern, where {1} will be replaced by the date pattern and {0} will be replaced by the time pattern."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The date time format is a message format pattern used to compose date and time patterns. The default value is \"{1} {0}\", where {1} will be replaced by the date pattern and {0} will be replaced by the time pattern. This is used when the input skeleton contains both date and time fields, but there is not a close match among the added patterns. For example, suppose that this object was created by adding \"dd-MMM\" and \"hh:mm\", and its datetimeFormat is the default \"{1} {0}\". Then if the input skeleton is \"MMMdhmm\", there is not an exact match, so the input skeleton is broken up into two components \"MMMd\" and \"hmm\". There are close matches for those two skeletons, so the result is put together with this pattern, resulting in \"d-MMM h:mm\".", "history": "Added in API level 24", "FullName": "public void setDateTimeFormat (String dateTimeFormat)"}, "setAppendItemFormat(int,java.lang.String)": {"Returns": [], "Parameters": [["int", "int: such as ERA"], ["@B_java#lang#String_E@", "String: pattern, such as \"{0}, {1}\""]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "An AppendItem format is a pattern used to append a field if there is no good match. For example, suppose that the input skeleton is \"GyyyyMMMd\", and there is no matching pattern internally, but there is a pattern matching \"yyyyMMMd\", say \"d-MM-yyyy\". Then that pattern is used, plus the G. The way these two are conjoined is by using the AppendItemFormat for G (era). So if that value is, say \"{0}, {1}\" then the final resulting pattern is \"d-MM-yyyy, G\". There are actually three available variables: {0} is the pattern so far, {1} is the element we are adding, and {2} is the name of the element. This reflects the way that the CLDR data is organized.", "history": "Added in API level 24", "FullName": "public void setAppendItemFormat (int field, String value)"}, "replaceFieldTypes(java.lang.String,java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "pattern adjusted to match the skeleton fields widths and subtypes."]], "Parameters": [["@B_java#lang#String_E@", "String: input pattern"], ["@B_java#lang#String_E@", "String: For the pattern to match to."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adjusts the field types (width and subtype) of a pattern to match what is in a skeleton. That is, if you supply a pattern like \"d-M H:m\", and a skeleton of \"MMMMddhhmm\", then the input pattern is adjusted to be \"dd-MMMM hh:mm\". This is used internally to get the best match for the input skeleton, but can also be used externally. Example code:", "history": "Added in API level 24", "FullName": "public String replaceFieldTypes (String pattern, String skeleton)"}, "setAppendItemFormat(int, java.lang.String)": {"Returns": [], "Parameters": [["int", "int: such as ERA"], ["@B_java#lang#String_E@", "String: pattern, such as \"{0}, {1}\""]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "An AppendItem format is a pattern used to append a field if there is no good match. For example, suppose that the input skeleton is \"GyyyyMMMd\", and there is no matching pattern internally, but there is a pattern matching \"yyyyMMMd\", say \"d-MM-yyyy\". Then that pattern is used, plus the G. The way these two are conjoined is by using the AppendItemFormat for G (era). So if that value is, say \"{0}, {1}\" then the final resulting pattern is \"d-MM-yyyy, G\". There are actually three available variables: {0} is the pattern so far, {1} is the element we are adding, and {2} is the name of the element. This reflects the way that the CLDR data is organized.", "history": "added in API level 24", "FullName": "public void setAppendItemFormat (int field, String value)"}, "setAppendItemName(int,java.lang.String)": {"Returns": [], "Parameters": [["int", "int: Index of the append item names."], ["@B_java#lang#String_E@", "String: The value to set the item to."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the names of fields, eg \"era\" in English for ERA. These are only used if the corresponding AppendItemFormat is used, and if it contains a {2} variable. This reflects the way that the CLDR data is organized.", "history": "Added in API level 24", "FullName": "public void setAppendItemName (int field, String value)"}, "replaceFieldTypes(java.lang.String,java.lang.String,int)": {"Returns": [["@B_java#lang#String_E@", "pattern adjusted to match the skeleton fields widths and subtypes."]], "Parameters": [["@B_java#lang#String_E@", "String: input pattern"], ["@B_java#lang#String_E@", "String: For the pattern to match to."], ["int", "int: MATCH_xxx options for forcing the length of specified fields in the returned pattern to match those in the skeleton (when this would not happen otherwise). For default behavior, use MATCH_NO_OPTIONS."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adjusts the field types (width and subtype) of a pattern to match what is in a skeleton. That is, if you supply a pattern like \"d-M H:m\", and a skeleton of \"MMMMddhhmm\", then the input pattern is adjusted to be \"dd-MMMM hh:mm\". This is used internally to get the best match for the input skeleton, but can also be used externally.", "history": "Added in API level 24", "FullName": "public String replaceFieldTypes (String pattern, String skeleton, int options)"}, "getInstance()": {"Returns": [["@B_android#icu#text#DateTimePatternGenerator_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#icu#util#ULocale#Category_E@"], "Permissions": [], "Description": "Construct a flexible generator according to data for the default FORMAT locale.", "history": "Added in API level 24", "FullName": "public static DateTimePatternGenerator getInstance ()"}, "addPattern(java.lang.String,boolean,android.icu.text.DateTimePatternGenerator.PatternInfo)": {"Returns": [["@B_android#icu#text#DateTimePatternGenerator_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: Pattern to add."], ["boolean", "boolean: When existing values are to be overridden use true, otherwise use false."], ["@B_android#icu#text#DateTimePatternGenerator#PatternInfo_E@", "DateTimePatternGenerator.PatternInfo: Returned information."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a pattern to the generator. If the pattern has the same skeleton as an existing pattern, and the override parameter is set, then the previous value is overridden. Otherwise, the previous value is retained. In either case, the conflicting information is returned in PatternInfo. Note that single-field patterns (like \"MMM\") are automatically added, and don't need to be added explicitly! * Example code:", "history": "Added in API level 24", "FullName": "public DateTimePatternGenerator addPattern (String pattern, boolean override, DateTimePatternGenerator.PatternInfo returnInfo)"}, "getSkeletons(java.util.Map<java.lang.String,java.lang.String>)": {"Returns": [["@B_java#util#Map_E@", "the input Map containing the values."]], "Parameters": [["@B_java#util#Map_E@", "Map: an output Map in which to place the mapping from skeleton to pattern. If you want to see the internal order being used, supply a LinkedHashMap. If the input value is null, then a LinkedHashMap is allocated. Issue: an alternate API would be to just return a list of the skeletons, and then have a separate routine to get from skeleton to pattern."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a list of all the skeletons (in canonical form) from this class, and the patterns that they map to.", "history": "Added in API level 24", "FullName": "public Map<String, String> getSkeletons (Map<String, String> result)"}, "isFrozen()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines whether the object has been frozen or not.", "history": "Added in API level 24", "FullName": "public boolean isFrozen ()"}, "getBaseSkeletons(java.util.Set<java.lang.String>)": {"Returns": [["@B_java#util#Set_E@", "no returns description in source"]], "Parameters": [["@B_java#util#Set_E@", "Set no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a list of all the base skeletons (in canonical form) from this class", "history": "Added in API level 24", "FullName": "public Set<String> getBaseSkeletons (Set<String> result)"}, "getDateTimeFormat()": {"Returns": [["@B_java#lang#String_E@", "pattern"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Getter corresponding to setDateTimeFormat.", "history": "Added in API level 24", "FullName": "public String getDateTimeFormat ()"}, "clone()": {"Returns": [["@B_java#lang#Object_E@", "A copy of this DateTimePatternGenerator object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a copy of this DateTimePatternGenerator object.", "history": "Added in API level 24", "FullName": "public Object clone ()"}, "cloneAsThawed()": {"Returns": [["@B_android#icu#text#DateTimePatternGenerator_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Provides for the clone operation. Any clone is initially unfrozen.", "history": "Added in API level 24", "FullName": "public DateTimePatternGenerator cloneAsThawed ()"}, "getInstance(android.icu.util.ULocale)": {"Returns": [["@B_android#icu#text#DateTimePatternGenerator_E@", "no returns description in source"]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: The locale to pass."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Construct a flexible generator according to data for a given locale.", "history": "Added in API level 24", "FullName": "public static DateTimePatternGenerator getInstance (ULocale uLocale)"}, "getBestPattern(java.lang.String,int)": {"Returns": [["@B_java#lang#String_E@", "Best pattern matching the input skeleton (and options)."]], "Parameters": [["@B_java#lang#String_E@", "String: The skeleton is a pattern containing only the variable fields. For example, \"MMMdd\" and \"mmhh\" are skeletons."], ["int", "int: MATCH_xxx options for forcing the length of specified fields in the returned pattern to match those in the skeleton (when this would not happen otherwise). For default behavior, use MATCH_NO_OPTIONS."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the best pattern matching the input skeleton. It is guaranteed to have all of the fields in the skeleton.", "history": "Added in API level 24", "FullName": "public String getBestPattern (String skeleton, int options)"}, "setDecimal(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The decimal to set to."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The decimal value is used in formatting fractions of seconds. If the skeleton contains fractional seconds, then this is used with the fractional seconds. For example, suppose that the input pattern is \"hhmmssSSSS\", and the best matching pattern internally is \"H:mm:ss\", and the decimal string is \",\". Then the resulting pattern is modified to be \"H:mm:ss,SSSS\"", "history": "Added in API level 24", "FullName": "public void setDecimal (String decimal)"}, "freeze()": {"Returns": [["@B_android#icu#text#DateTimePatternGenerator_E@", "the object itself."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Freezes the object.", "history": "Added in API level 24", "FullName": "public DateTimePatternGenerator freeze ()"}, "getAppendItemName(int)": {"Returns": [["@B_java#lang#String_E@", "name for field"]], "Parameters": [["int", "int: The index to get the append item name."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Getter corresponding to setAppendItemName. Values below 0 or at or above TYPE_LIMIT are illegal arguments. Note: The more general method for getting date/time field display names is getFieldDisplayName.", "history": "Added in API level 24", "FullName": "public String getAppendItemName (int field)"}, "setAppendItemName(int, java.lang.String)": {"Returns": [], "Parameters": [["int", "int: Index of the append item names."], ["@B_java#lang#String_E@", "String: The value to set the item to."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the names of fields, eg \"era\" in English for ERA. These are only used if the corresponding AppendItemFormat is used, and if it contains a {2} variable. This reflects the way that the CLDR data is organized.", "history": "added in API level 24", "FullName": "public void setAppendItemName (int field, String value)"}, "getDecimal()": {"Returns": [["@B_java#lang#String_E@", "string corresponding to the decimal point"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Getter corresponding to setDecimal.", "history": "Added in API level 24", "FullName": "public String getDecimal ()"}, "getBestPattern(java.lang.String, int)": {"Returns": [["@B_java#lang#String_E@", "Best pattern matching the input skeleton (and options)."]], "Parameters": [["@B_java#lang#String_E@", "String: The skeleton is a pattern containing only the variable fields. For example, \"MMMdd\" and \"mmhh\" are skeletons."], ["int", "int: MATCH_xxx options for forcing the length of specified fields in the returned pattern to match those in the skeleton (when this would not happen otherwise). For default behavior, use MATCH_NO_OPTIONS."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the best pattern matching the input skeleton. It is guaranteed to have all of the fields in the skeleton.", "history": "added in API level 24", "FullName": "public String getBestPattern (String skeleton, int options)"}, "getBestPattern(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "Best pattern matching the input skeleton."]], "Parameters": [["@B_java#lang#String_E@", "String: The skeleton is a pattern containing only the variable fields. For example, \"MMMdd\" and \"mmhh\" are skeletons."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the best pattern matching the input skeleton. It is guaranteed to have all of the fields in the skeleton. Example code:", "history": "Added in API level 24", "FullName": "public String getBestPattern (String skeleton)"}, "getAppendItemFormat(int)": {"Returns": [["@B_java#lang#String_E@", "append pattern for field"]], "Parameters": [["int", "int: The index to retrieve the append item formats."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Getter corresponding to setAppendItemFormats. Values below 0 or at or above TYPE_LIMIT are illegal arguments.", "history": "Added in API level 24", "FullName": "public String getAppendItemFormat (int field)"}, "DateTimePatternGenerator()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Only for use by subclasses", "history": "Added in API level 24", "FullName": "protected DateTimePatternGenerator ()"}, "getInstance(java.util.Locale)": {"Returns": [["@B_android#icu#text#DateTimePatternGenerator_E@", "no returns description in source"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: The @B_java#util#Locale_E@ to pass."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Construct a flexible generator according to data for a given locale.", "history": "Added in API level 24", "FullName": "public static DateTimePatternGenerator getInstance (Locale locale)"}}, "Inheritance": [], "ClassName": "android.icu.text.DateTimePatternGenerator", "ClassDesc": "This class provides flexible generation of date format patterns, like \"yy-MM-dd\". The user can build up the generator by adding successive patterns. Once that is done, a query can be made using a \"skeleton\", which is a pattern which just includes the desired fields and lengths. The generator will return the \"best fit\" pattern corresponding to that skeleton. The main method people will use is getBestPattern(String skeleton), since normally this class is pre-built with data from a particular locale. However, generators can be built directly from other data as well."}