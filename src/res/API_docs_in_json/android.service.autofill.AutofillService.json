{"Functions": {"getFillEventHistory()": {"Returns": [["@B_android#service#autofill#FillEventHistory_E@", "The history or null if there are no events."]], "Parameters": [], "Throws": [["@B_java#lang#RuntimeException_E@", "if the event history could not be retrieved."]], "SeeAlso": [], "Permissions": [], "Description": "Gets the events that happened after the last @B_android#service#autofill#AutofillService#onFillRequest_E@ call. This method is typically used to keep track of previous user actions to optimize further requests. For example, the service might return email addresses in alphabetical order by default, but change that order based on the address the user picked on previous requests. The history is not persisted over reboots, and it's cleared every time the service replies to a @B_android#service#autofill#AutofillService#onFillRequest_E@ by calling @B_android#service#autofill#FillCallback#onSuccess_E@ or @B_android#service#autofill#FillCallback#onFailure_E@ (if the service doesn't call any of these methods, the history will clear out after some pre-defined time). Hence, the service should call @B_android#service#autofill#AutofillService#getFillEventHistory_E@ before finishing the @B_android#service#autofill#FillCallback_E@.", "history": "Added in API level 26", "FullName": "public final FillEventHistory getFillEventHistory ()"}, "onCreate()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system when the service is first created. Do not call this method directly. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 26", "FullName": "public void onCreate ()"}, "onSaveRequest(android.service.autofill.SaveRequest,android.service.autofill.SaveCallback)": {"Returns": [], "Parameters": [["@B_android#service#autofill#SaveRequest_E@", "SaveRequest: the @B_android#service#autofill#SaveRequest_E@ to handle. See @B_android#service#autofill#FillResponse_E@ for examples of multiple-sections requests. This value must never be null."], ["@B_android#service#autofill#SaveCallback_E@", "SaveCallback: object used to notify the result of the request. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the user requests the service to save the contents of a screen. If the service could not handle the request right away\u2014for example, because it must launch an activity asking the user to authenticate first or because the network is down\u2014the service could keep the @B_android#service#autofill#SaveRequest_E@ and reuse it later, but the service @B_android#service#autofill#SaveCallback#onSuccess_E@ or @B_android#service#autofill#SaveCallback#onSuccess_E@ right away. @B_android#app#assist#AssistStructure#ViewNode#getAutofillValue_E@; if it calls @B_android#app#assist#AssistStructure#ViewNode#getText_E@ or other methods, there is no guarantee such method will return the most recent value of the field.", "history": "Added in API level 26", "FullName": "public abstract void onSaveRequest (SaveRequest request, SaveCallback callback)"}, "onDisconnected()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the Android system disconnects from the service. At this point this service may no longer be an active @B_android#service#autofill#AutofillService_E@. It should not make calls on @B_android#view#autofill#AutofillManager_E@ that requires the caller to be the current service.", "history": "Added in API level 26", "FullName": "public void onDisconnected ()"}, "AutofillService()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 26", "FullName": "public AutofillService ()"}, "onFillRequest(android.service.autofill.FillRequest,android.os.CancellationSignal,android.service.autofill.FillCallback)": {"Returns": [], "Parameters": [["@B_android#service#autofill#FillRequest_E@", "FillRequest: the @B_android#service#autofill#FillRequest_E@ to handle. See @B_android#service#autofill#FillResponse_E@ for examples of multiple-sections requests. This value must never be null."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: signal for observing cancellation requests. The system will use this to notify you that the fill result is no longer needed and you should stop handling this fill request in order to save resources. This value must never be null."], ["@B_android#service#autofill#FillCallback_E@", "FillCallback: object used to notify the result of the request. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the Android system do decide if a screen can be autofilled by the service. Service must call one of the @B_android#service#autofill#FillCallback_E@ methods (like @B_android#service#autofill#FillCallback#onSuccess_E@ or @B_android#service#autofill#FillCallback#onFailure_E@) to notify the result of the request.", "history": "Added in API level 26", "FullName": "public abstract void onFillRequest (FillRequest request, CancellationSignal cancellationSignal, FillCallback callback)"}, "onConnected()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the Android system connects to service. You should generally do initialization here rather than in @B_android#service#autofill#AutofillService#onCreate_E@.", "history": "Added in API level 26", "FullName": "public void onConnected ()"}, "onBind(android.content.Intent)": {"Returns": [["@B_android#os#IBinder_E@", "Return an IBinder through which clients can call on to the service."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent that was used to bind to this service, as given to @B_android#content#Context#bindService_E@. Note that any extras that were included with the Intent at that point will not be seen here."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the communication channel to the service. May return null if clients can not bind to the service. The returned @B_android#os#IBinder_E@ is usually for a complex interface that has been Note that unlike other application components, calls on to the IBinder interface returned here may not happen on the main thread of the process. More information about the main thread can be found in", "history": "Added in API level 26", "FullName": "public final IBinder onBind (Intent intent)"}}, "Inheritance": ["@B_android#content#Context_E@", "@B_android#content#ContextWrapper_E@", "@B_android#app#Service_E@"], "ClassName": "android.service.autofill.AutofillService", "ClassDesc": "An AutofillService is a service used to automatically fill the contents of the screen on behalf of a given user - for more information about autofill, read An AutofillService is only bound to the Android System for autofill purposes if: The basic autofill process is defined by the workflow below: This workflow was designed to minimize the time the Android System is bound to the service; for each call, it: binds to service, waits for the reply, and unbinds right away. Furthermore, those calls are considered stateless: if the service needs to keep state between calls, it must do its own state management (keeping in mind that the service's process might be killed by the Android System when unbound; for example, if the device is running low in memory). Typically, the @B_android#service#autofill#AutofillService#onFillRequest_E@ will: For example, for a login screen with username and password views where the user only has one account in the service, the response could be: But if the user had 2 accounts instead, the response could be: If the service does not find any autofillable view in the view structure, it should pass null to @B_android#service#autofill#FillCallback#onSuccess_E@; if the service encountered an error processing the request, it should call @B_android#service#autofill#FillCallback#onFailure_E@. For performance reasons, it's paramount that the service calls either @B_android#service#autofill#FillCallback#onSuccess_E@ or @B_android#service#autofill#FillCallback#onFailure_E@ for each @B_android#service#autofill#AutofillService#onFillRequest_E@ received - if it doesn't, the request will eventually time out and be discarded by the Android System. If the service is also interested on saving the data filled by the user, it must set a @B_android#service#autofill#SaveInfo_E@ object in the @B_android#service#autofill#FillResponse_E@. See @B_android#service#autofill#SaveInfo_E@ for more details and examples. The service can provide an extra degree of security by requiring the user to authenticate before an app can be autofilled. The authentication is typically required in 2 scenarios: To unlock the user data (for example, using a master password or fingerprint authentication) - see @B_android#service#autofill#FillResponse#Builder#setAuthentication_E@. To unlock a specific dataset (for example, by providing a CVC for a credit card) - see @B_android#service#autofill#Dataset#Builder#setAuthentication_E@. When using authentication, it is recommended to encrypt only the sensitive data and leave labels unencrypted, so they can be used on presentation views. For example, if the user has a home and a work address, the Home and Work labels should be stored unencrypted (since they don't have any sensitive data) while the address data per se could be stored in an encrypted storage. Then when the user chooses the Home dataset, the platform starts the authentication flow, and the service can decrypt the sensitive data. The authentication mechanism can also be used in scenarios where the service needs multiple steps to determine the datasets that can fill a screen. For example, when autofilling a financial app where the user has accounts for multiple banks, the workflow could be: Another example of multiple-steps dataset selection is when the service stores the user credentials in \"vaults\": the first response would contain fake datasets with the vault names, and the subsequent response would contain the app credentials stored in that vault. The autofillable views in a screen should be grouped in logical groups called \"partitions\". Typical partitions are: Credentials (username/email address, password). Address (street, city, state, zip code, etc). Payment info (credit card number, expiration date, and verification code). For security reasons, when a screen has more than one partition, it's paramount that the contents of a dataset do not spawn multiple partitions, specially when one of the partitions contains data that is not specific to the application being autofilled. For example, a dataset should not contain fields for username, password, and credit card information. The reason for this rule is that a malicious app could draft a view structure where the credit card fields are not visible, so when the user selects a dataset from the username UI, the credit card info is released to the application without the user knowledge. Similarly, it's recommended to always protect a dataset that contains sensitive information by requiring dataset authentication (see @B_android#service#autofill#Dataset#Builder#setAuthentication_E@), and to include info about the \"primary\" field of the partition in the custom presentation for \"secondary\" fields\u2014that would prevent a malicious app from getting the \"primary\" fields without the user realizing they're being released (for example, a malicious app could have fields for a credit card number, verification code, and expiration date crafted in a way that just the latter is visible; by explicitly indicating the expiration date is related to a given credit card number, the service would be providing a visual clue for the users to check what would be released upon selecting that field). When the service detects that a screen has multiple partitions, it should return a @B_android#service#autofill#FillResponse_E@ with just the datasets for the partition that originated the request (i.e., the partition that has the @B_android#app#assist#AssistStructure#ViewNode_E@ whose @B_android#app#assist#AssistStructure#ViewNode#isFocused_E@ returns true); then if the user selects a field from a different partition, the Android System will make another @B_android#service#autofill#AutofillService#onFillRequest_E@ call for that partition, and so on. Notice that when the user autofill a partition with the data provided by the service and the user did not change these fields, the autofilled value is sent back to the service in the subsequent calls (and can be obtained by calling @B_android#app#assist#AssistStructure#ViewNode#getAutofillValue_E@). This is useful in the cases where the service must create datasets for a partition based on the choice made in a previous partition. For example, the 1st response for a screen that have credentials and address partitions could be: Then if the user selected flanders, the service would get a new @B_android#service#autofill#AutofillService#onFillRequest_E@ call, with the values of the fields id1 and id2 prepopulated, so the service could then fetch the address for the Flanders account and return the following @B_android#service#autofill#FillResponse_E@ for the address partition: When the service returns multiple @B_android#service#autofill#FillResponse_E@, the last one overrides the previous; that's why the @B_android#service#autofill#SaveInfo_E@ in the 2nd request above has the info for both partitions. When autofilling app-specific data (like username and password), the service must verify the authenticity of the request by obtaining all signing certificates of the app being autofilled, and only fulfilling the request when they match the values that were obtained when the data was first saved \u2014 such verification is necessary to avoid phishing attempts by apps that were sideloaded in the device with the same package name of another app. Here's an example on how to achieve that by hashing the signing certificates: If the service did not store the signing certificates data the first time the data was saved \u2014 for example, because the data was created by a previous version of the app that did not use the Autofill Framework \u2014 the service should warn the user that the authenticity of the app cannot be confirmed (see an example on how to show such warning in the If the service find views that cannot be autofilled (for example, a text field representing the response to a Captcha challenge), it should mark those views as ignored by calling @B_android#service#autofill#FillResponse#Builder#setIgnoredIds_E@ so the system does not trigger a new @B_android#service#autofill#AutofillService#onFillRequest_E@ when these views are focused. When handling autofill requests that represent web pages (typically view structures whose root's @B_android#app#assist#AssistStructure#ViewNode#getClassName_E@ is a @B_android#webkit#WebView_E@), the service should take the following steps to verify if the structure can be autofilled with the data associated with the app requesting it: Here's an example on how to get the canonical domain using If the association between the web domain and app package cannot be verified through the steps above, but the service thinks that it is appropriate to fill persisted credentials that are stored for the web domain, the service should warn the user about the potential data leakage first, and ask for the user to confirm. For example, the service could: This same procedure could also be used when the autofillable data is contained inside an IFRAME, in which case the WebView generates a new autofill context when a node inside the IFRAME is focused, with the root node containing the IFRAME's src attribute on @B_android#app#assist#AssistStructure#ViewNode#getWebDomain_E@. A typical and legitimate use case for this scenario is a financial app that allows the user to login on different bank accounts. For example, a financial app my_financial_app could use a WebView that loads contents from banklogin.my_financial_app.com, which contains an IFRAME node whose src attribute is login.some_bank.com. When fulfilling that request, the service could add an @B_android#service#autofill#Dataset#Builder#setAuthentication_E@ whose presentation displays \"Username for some_bank.com\" and \"Password for some_bank.com\". Then when the user taps one of these options, the service shows the disclaimer dialog explaining that selecting that option would release the login.some_bank.com credentials to the my_financial_app; if the user agrees, then the service returns an unlocked dataset with the some_bank.com credentials. It's tricky to handle save for autofill in these situations, because the autofill service must wait until the user enters both fields before the autofill save UI can be shown. But it can be done by following the steps below: For example, in an app that uses 2 steps for the username and password fields, the workflow would be: The @B_android#service#autofill#AutofillService#onFillRequest_E@ method is called without the user content. The Android system strips some properties of the @B_android#app#assist#AssistStructure#ViewNode_E@ passed to this call, but not all of them. For example, the data provided in the @B_android#view#ViewStructure#HtmlInfo_E@ objects set by @B_android#webkit#WebView_E@ is never stripped out. Because this data could contain PII (Personally Identifiable Information, such as username or email address), the service should only use it locally (i.e., in the app's process) for heuristics purposes, but it should not be sent to external servers. @B_android#service#autofill#AutofillService#getFillEventHistory_E@ to get metrics representing the user actions, and then use these metrics to improve its heuristics. Prior to Android @B_android#os#Build#VERSION_CODES#P_E@, the metrics covered just the scenarios where the service knew how to autofill an activity, but Android @B_android#os#Build#VERSION_CODES#P_E@ introduced a new mechanism called field classification, which allows the service to dinamically classify the meaning of fields based on the existing user data known by the service. Typically, field classification can be used to detect fields that can be autofilled with user data that is not associated with a specific app\u2014such as email and physical address. Once the service identifies that a such field was manually filled by the user, the service could use this signal to improve its heuristics on subsequent requests (for example, by infering which resource ids are associated with known fields). The field classification workflow involves 4 steps: The field classification is an expensive operation and should be used carefully, otherwise it can reach its rate limit and get blocked by the Android System. Ideally, it should be used just in cases where the service could not determine how an activity can be autofilled, but it has a strong suspicious that it could. For example, if an activity has four or more fields and one of them is a list, chances are that these are address fields (like address, city, state, and zip code). Apps that use standard Android widgets support autofill out-of-the-box and need to do very little to improve their user experience (annotating autofillable views and providing autofill hints). However, some apps (typically browsers) do their own rendering and the rendered content may contain semantic structure that needs to be surfaced to the autofill framework. The platform exposes APIs to achieve this, however it could take some time until these apps implement autofill support. To enable autofill for such apps the platform provides a compatibility mode in which the platform would fall back to the accessibility APIs to generate the state reported to autofill services and fill data. This mode needs to be explicitly requested for a given package up to a specified max version code allowing clean migration path when the target app begins to support autofill natively. Note that enabling compatibility may degrade performance for the target package and should be used with caution. The platform supports whitelisting which packages can be targeted in compatibility mode to ensure this mode is used only when needed and as long as needed. You can request compatibility mode for packages of interest in the meta-data resource associated with your service. Below is a sample service declaration: In the XML file you can specify one or more packages for which to enable compatibility mode. Below is a sample meta-data declaration: Notice that compatibility mode has limitations such as: No manual autofill requests. Hence, the @B_android#service#autofill#FillRequest_E@ @B_android#service#autofill#FillRequest#getFlags_E@ never have the @B_android#service#autofill#FillRequest#FLAG_MANUAL_REQUEST_E@ flag. The value of password fields are most likely masked\u2014for example, **** instead of 1234. Hence, you must be careful when using these values to avoid updating the user data with invalid input. For example, when you parse the @B_android#service#autofill#FillRequest_E@ and detect a password field, you could check if its @B_android#app#assist#AssistStructure#ViewNode#getInputType_E@ has password flags and if so, don't add it to the @B_android#service#autofill#SaveInfo_E@ object. The autofill context is not always @B_android#view#autofill#AutofillManager#commit_E@ when an HTML form is submitted. Hence, you must use other mechanisms to trigger save, such as setting the @B_android#service#autofill#SaveInfo#FLAG_SAVE_ON_ALL_VIEWS_INVISIBLE_E@ flag on @B_android#service#autofill#SaveInfo#Builder#setFlags_E@ or using @B_android#service#autofill#SaveInfo#Builder#setTriggerId_E@. Browsers often provide their own autofill management system. When both the browser and the platform render an autofill dialog at the same time, the result can be confusing to the user. Such browsers typically offer an option for users to disable autofill, so your service should also allow users to disable compatiblity mode for specific apps. That way, it is up to the user to decide which autofill mechanism\u2014the browser's or the platform's\u2014should be used."}