{"Functions": {"prepareDrm(java.util.UUID)": {"Returns": [], "Parameters": [["@B_java#util#UUID_E@", "UUID: The UUID of the crypto scheme. If not known beforehand, it can be retrieved from the source through getDrmInfo or registering a onDrmInfoListener. This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if called before prepare(), or the DRM was prepared already"], ["@B_android#media#UnsupportedSchemeException_E@", "if the crypto scheme is not supported"], ["@B_android#media#ResourceBusyException_E@", "if required DRM resources are in use"], ["@B_android#media#MediaPlayer#ProvisioningNetworkErrorException_E@", "if provisioning is required but failed due to a network error"], ["@B_android#media#MediaPlayer#ProvisioningServerErrorException_E@", "if provisioning is required but failed due to the request denied by the provisioning server"]], "SeeAlso": [], "Permissions": [], "Description": "Prepares the DRM for the current source If OnDrmConfigHelper is registered, it will be called during preparation to allow configuration of the DRM properties before opening the DRM session. Note that the callback is called synchronously in the thread that called prepareDrm. It should be used only for a series of getDrmPropertyString and setDrmPropertyString calls and refrain from any lengthy operation. If the device has not been provisioned before, this call also provisions the device which involves accessing the provisioning server and can take a variable time to complete depending on the network connectivity. If OnDrmPreparedListener is registered, prepareDrm() runs in non-blocking mode by launching the provisioning in the background and returning. The listener will be called when provisioning and preparation has finished. If a OnDrmPreparedListener is not registered, prepareDrm() waits till provisioning and preparation has finished, i.e., runs in blocking mode. If OnDrmPreparedListener is registered, it is called to indicate the DRM session being ready. The application should not make any assumption about its call sequence (e.g., before or after prepareDrm returns), or the thread context that will execute the listener (unless the listener is registered with a handler thread).", "history": "Added in API level 26", "FullName": "public void prepareDrm (UUID uuid)"}, "getVideoWidth()": {"Returns": [["int", "the width of the video, or 0 if there is no video, no display surface was set, or the width has not been determined yet. The OnVideoSizeChangedListener can be registered via @B_android#media#MediaPlayer#setOnVideoSizeChangedListener_E@ to provide a notification when the width is available."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the width of the video.", "history": "Added in API level 1", "FullName": "public int getVideoWidth ()"}, "create(android.content.Context, int)": {"Returns": [["@B_android#media#MediaPlayer_E@", "a MediaPlayer object, or null if creation failed"]], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use"], ["int", "int: the raw resource id (R.raw.<something>) for the resource to use as the datasource"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method to create a MediaPlayer for a given resource id. On success, @B_android#media#MediaPlayer#prepare_E@ will already have been called and must not be called again. When done with the MediaPlayer, you should call @B_android#media#MediaPlayer#release_E@, to free the resources. If not released, too many MediaPlayer instances will result in an exception. Note that since @B_android#media#MediaPlayer#prepare_E@ is called automatically in this method, you cannot change the audio session ID (see @B_android#media#MediaPlayer#setAudioSessionId_E@) or audio attributes (see @B_android#media#MediaPlayer#setAudioAttributes_E@ of the new MediaPlayer.", "history": "added in API level 1", "FullName": "public static MediaPlayer create (Context context, int resid)"}, "getDrmPropertyString(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "This value will never be null."]], "Parameters": [["@B_java#lang#String_E@", "String: the property name Standard fields names are: @B_android#media#MediaDrm#PROPERTY_VENDOR_E@, @B_android#media#MediaDrm#PROPERTY_VERSION_E@, @B_android#media#MediaDrm#PROPERTY_DESCRIPTION_E@, @B_android#media#MediaDrm#PROPERTY_ALGORITHMS_E@ This value must never be null. Value is @B_android#media#MediaDrm#PROPERTY_VENDOR_E@, @B_android#media#MediaDrm#PROPERTY_VERSION_E@, @B_android#media#MediaDrm#PROPERTY_DESCRIPTION_E@, or @B_android#media#MediaDrm#PROPERTY_ALGORITHMS_E@"]], "Throws": [["@B_android#media#MediaPlayer#NoDrmSchemeException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Read a DRM engine plugin String property value, given the property name string.", "history": "Added in API level 26", "FullName": "public String getDrmPropertyString (String propertyName)"}, "start()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"]], "SeeAlso": [], "Permissions": [], "Description": "Starts or resumes playback. If playback had previously been paused, playback will continue from where it was paused. If playback had been stopped, or never started before, playback will start at the beginning.", "history": "Added in API level 1", "FullName": "public void start ()"}, "create(android.content.Context,android.net.Uri)": {"Returns": [["@B_android#media#MediaPlayer_E@", "a MediaPlayer object, or null if creation failed"]], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use"], ["@B_android#net#Uri_E@", "Uri: the Uri from which to get the datasource"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method to create a MediaPlayer for a given Uri. On success, @B_android#media#MediaPlayer#prepare_E@ will already have been called and must not be called again. When done with the MediaPlayer, you should call @B_android#media#MediaPlayer#release_E@, to free the resources. If not released, too many MediaPlayer instances will result in an exception. Note that since @B_android#media#MediaPlayer#prepare_E@ is called automatically in this method, you cannot change the audio session ID (see @B_android#media#MediaPlayer#setAudioSessionId_E@) or audio attributes (see @B_android#media#MediaPlayer#setAudioAttributes_E@ of the new MediaPlayer.", "history": "Added in API level 1", "FullName": "public static MediaPlayer create (Context context, Uri uri)"}, "create(android.content.Context, android.net.Uri)": {"Returns": [["@B_android#media#MediaPlayer_E@", "a MediaPlayer object, or null if creation failed"]], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use"], ["@B_android#net#Uri_E@", "Uri: the Uri from which to get the datasource"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method to create a MediaPlayer for a given Uri. On success, @B_android#media#MediaPlayer#prepare_E@ will already have been called and must not be called again. When done with the MediaPlayer, you should call @B_android#media#MediaPlayer#release_E@, to free the resources. If not released, too many MediaPlayer instances will result in an exception. Note that since @B_android#media#MediaPlayer#prepare_E@ is called automatically in this method, you cannot change the audio session ID (see @B_android#media#MediaPlayer#setAudioSessionId_E@) or audio attributes (see @B_android#media#MediaPlayer#setAudioAttributes_E@ of the new MediaPlayer.", "history": "added in API level 1", "FullName": "public static MediaPlayer create (Context context, Uri uri)"}, "baseRegisterPlayer()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call from derived class when instantiation / initialization is successful", "history": "", "FullName": "protected void baseRegisterPlayer ()"}, "stop()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Stops playback after playback has been started or paused.", "history": "Added in API level 1", "FullName": "public void stop ()"}, "pause()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Pauses playback. Call start() to resume.", "history": "Added in API level 1", "FullName": "public void pause ()"}, "setVideoScalingMode(int)": {"Returns": [], "Parameters": [["int", "int: target video scaling mode. Must be one of the supported video scaling modes; otherwise, IllegalArgumentException will be thrown."]], "Throws": [], "SeeAlso": ["@B_android#media#MediaPlayer_E@"], "Permissions": [], "Description": "Sets video scaling mode. To make the target video scaling mode effective during playback, this method must be called after data source is set. If not called, the default video scaling mode is @B_android#media#MediaPlayer#VIDEO_SCALING_MODE_SCALE_TO_FIT_E@. The supported video scaling modes are: @B_android#media#MediaPlayer#VIDEO_SCALING_MODE_SCALE_TO_FIT_E@ @B_android#media#MediaPlayer#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING_E@", "history": "Added in API level 16", "FullName": "public void setVideoScalingMode (int mode)"}, "setSurface(android.view.Surface)": {"Returns": [], "Parameters": [["@B_android#view#Surface_E@", "Surface: The @B_android#view#Surface_E@ to be used for the video portion of the media."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized or has been released."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the @B_android#view#Surface_E@ to be used as the sink for the video portion of the media. This is similar to @B_android#media#MediaPlayer#setDisplay_E@, but does not support @B_android#media#MediaPlayer#setScreenOnWhilePlaying_E@. Setting a Surface will un-set any Surface or SurfaceHolder that was previously set. A null surface will result in only the audio track being played. If the Surface sends frames to a @B_android#graphics#SurfaceTexture_E@, the timestamps returned from @B_android#graphics#SurfaceTexture#getTimestamp_E@ will have an unspecified zero point. These timestamps cannot be directly compared between different media sources, different instances of the same media source, or multiple runs of the same program. The timestamp is normally monotonically increasing and is unaffected by time-of-day adjustments, but it is reset when the position is set.", "history": "Added in API level 14", "FullName": "public void setSurface (Surface surface)"}, "isLooping()": {"Returns": [["boolean", "true if the MediaPlayer is currently looping, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Checks whether the MediaPlayer is looping or non-looping.", "history": "Added in API level 3", "FullName": "public boolean isLooping ()"}, "isPlaying()": {"Returns": [["boolean", "true if currently playing, false otherwise"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized or has been released."]], "SeeAlso": [], "Permissions": [], "Description": "Checks whether the MediaPlayer is playing.", "history": "Added in API level 1", "FullName": "public boolean isPlaying ()"}, "setDataSource(java.io.FileDescriptor,long,long)": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: the FileDescriptor for the file you want to play"], ["long", "long: the offset into the file where the data to be played starts, in bytes"], ["long", "long: the length in bytes of the data to be played"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#lang#IllegalArgumentException_E@", "if fd is not a valid FileDescriptor"], ["@B_java#io#IOException_E@", "if fd can not be read"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the data source (FileDescriptor) to use. The FileDescriptor must be seekable (N.B. a LocalSocket is not seekable). It is the caller's responsibility to close the file descriptor. It is safe to do so as soon as this call returns.", "history": "Added in API level 1", "FullName": "public void setDataSource (FileDescriptor fd, long offset, long length)"}, "create(android.content.Context,int,android.media.AudioAttributes,int)": {"Returns": [["@B_android#media#MediaPlayer_E@", "a MediaPlayer object, or null if creation failed"]], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use"], ["int", "int: the raw resource id (R.raw.<something>) for the resource to use as the datasource"], ["@B_android#media#AudioAttributes_E@", "AudioAttributes: the @B_android#media#AudioAttributes_E@ to be used by the media player."], ["int", "int: the audio session ID to be used by the media player, see @B_android#media#AudioManager#generateAudioSessionId_E@ to obtain a new session."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same factory method as @B_android#media#MediaPlayer#create_E@ but that lets you specify the audio attributes and session ID to be used by the new MediaPlayer instance.", "history": "Added in API level 21", "FullName": "public static MediaPlayer create (Context context, int resid, AudioAttributes audioAttributes, int audioSessionId)"}, "release()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Releases resources associated with this MediaPlayer object. It is considered good practice to call this method when you're done using the MediaPlayer. In particular, whenever an Activity of an application is paused (its onPause() method is called), or stopped (its onStop() method is called), this method should be invoked to release the MediaPlayer object, unless the application has a special need to keep the object around. In addition to unnecessary resources (such as memory and instances of codecs) being held, failure to call this method immediately if a MediaPlayer object is no longer needed may also lead to continuous battery consumption for mobile devices, and playback failure for other applications if no multiple instances of the same codec are supported on a device. Even if multiple instances of the same codec are supported, some performance degradation may be expected when unnecessary multiple instances are used at the same time.", "history": "Added in API level 1", "FullName": "public void release ()"}, "clearOnSubtitleDataListener()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clears the listener previously set with @B_android#media#MediaPlayer#setOnSubtitleDataListener_E@ or @B_android#media#MediaPlayer#setOnSubtitleDataListener_E@.", "history": "Added in API level 28", "FullName": "public void clearOnSubtitleDataListener ()"}, "restoreKeys(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: identifies the saved key set to restore This value must never be null."]], "Throws": [["@B_android#media#MediaPlayer#NoDrmSchemeException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Restore persisted offline keys into a new session. keySetId identifies the keys to load, obtained from a prior call to @B_android#media#MediaPlayer#provideKeyResponse_E@.", "history": "Added in API level 26", "FullName": "public void restoreKeys (byte[] keySetId)"}, "getMetrics()": {"Returns": [["@B_android#os#PersistableBundle_E@", "a @B_android#os#PersistableBundle_E@ containing the set of attributes and values available for the media being handled by this instance of MediaPlayer The attributes are descibed in @B_android#media#MediaPlayer#MetricsConstants_E@. Additional vendor-specific fields may also be present in the return value."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return Metrics data about the current player.", "history": "Added in API level 26", "FullName": "public PersistableBundle getMetrics ()"}, "setOnErrorListener(android.media.MediaPlayer.OnErrorListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnErrorListener_E@", "MediaPlayer.OnErrorListener: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when an error has happened during an asynchronous operation.", "history": "Added in API level 1", "FullName": "public void setOnErrorListener (MediaPlayer.OnErrorListener listener)"}, "deselectTrack(int)": {"Returns": [], "Parameters": [["int", "int: the index of the track to be deselected. The valid range of the index is 0..total number of tracks - 1. The total number of tracks as well as the type of each individual track can be found by calling @B_android#media#MediaPlayer#getTrackInfo_E@ method."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if called in an invalid state."]], "SeeAlso": ["@B_android#media#MediaPlayer#getTrackInfo_E@"], "Permissions": [], "Description": "Deselect a track. Currently, the track must be a timed text track and no audio or video tracks can be deselected. If the timed text track identified by index has not been selected before, it throws an exception.", "history": "Added in API level 16", "FullName": "public void deselectTrack (int index)"}, "getPlaybackParams()": {"Returns": [["@B_android#media#PlaybackParams_E@", "the playback params. This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Gets the playback params, containing the current playback rate.", "history": "Added in API level 23", "FullName": "public PlaybackParams getPlaybackParams ()"}, "setOnMediaTimeDiscontinuityListener(android.media.MediaPlayer.OnMediaTimeDiscontinuityListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnMediaTimeDiscontinuityListener_E@", "MediaPlayer.OnMediaTimeDiscontinuityListener: the listener called after a discontinuity This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the listener to be invoked when a media time discontinuity is encountered. The listener will be called on the same thread as the one in which the MediaPlayer was created.", "history": "Added in API level 28", "FullName": "public void setOnMediaTimeDiscontinuityListener (MediaPlayer.OnMediaTimeDiscontinuityListener listener)"}, "getTrackInfo()": {"Returns": [["@B_android#media#MediaPlayer#TrackInfo_E@", "Array of track info. The total number of tracks is the array length. Must be called again if an external timed text source has been added after any of the addTimedTextSource methods are called."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state."]], "SeeAlso": [], "Permissions": [], "Description": "Returns an array of track information.", "history": "Added in API level 16", "FullName": "public TrackInfo[] getTrackInfo ()"}, "setDataSource(java.io.FileDescriptor, long, long)": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: the FileDescriptor for the file you want to play"], ["long", "long: the offset into the file where the data to be played starts, in bytes"], ["long", "long: the length in bytes of the data to be played"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#lang#IllegalArgumentException_E@", "if fd is not a valid FileDescriptor"], ["@B_java#io#IOException_E@", "if fd can not be read"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the data source (FileDescriptor) to use. The FileDescriptor must be seekable (N.B. a LocalSocket is not seekable). It is the caller's responsibility to close the file descriptor. It is safe to do so as soon as this call returns.", "history": "added in API level 1", "FullName": "public void setDataSource (FileDescriptor fd, long offset, long length)"}, "getAudioSessionId()": {"Returns": [["int", "the audio session ID. Note that the audio session ID is 0 only if a problem occured when the MediaPlayer was contructed."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the audio session ID.", "history": "Added in API level 9", "FullName": "public int getAudioSessionId ()"}, "prepareAsync()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"]], "SeeAlso": [], "Permissions": [], "Description": "Prepares the player for playback, asynchronously. After setting the datasource and the display surface, you need to either call prepare() or prepareAsync(). For streams, you should call prepareAsync(), which returns immediately, rather than blocking until enough data has been buffered.", "history": "Added in API level 1", "FullName": "public void prepareAsync ()"}, "setWakeMode(android.content.Context, int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use"], ["int", "int: the power/wake mode to set"]], "Throws": [], "SeeAlso": ["@B_android#os#PowerManager_E@"], "Permissions": ["@B_android#Manifest#permission#WAKE_LOCK_E@"], "Description": "Set the low-level power management behavior for this MediaPlayer. This can be used when the MediaPlayer is not playing through a SurfaceHolder set with @B_android#media#MediaPlayer#setDisplay_E@ and thus can use the high-level @B_android#media#MediaPlayer#setScreenOnWhilePlaying_E@ feature. This function has the MediaPlayer access the low-level power manager service to control the device's power usage while playing is occurring. The parameter is a combination of @B_android#os#PowerManager_E@ wake flags. Use of this method requires @B_android#Manifest#permission#WAKE_LOCK_E@ permission. By default, no attempt is made to keep the device awake during playback.", "history": "added in API level 1", "FullName": "public void setWakeMode (Context context, int mode)"}, "getTimestamp()": {"Returns": [["@B_android#media#MediaTimestamp_E@", "a MediaTimestamp object if a timestamp is available, or null if no timestamp is available, e.g. because the media player has not been initialized."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#MediaTimestamp_E@"], "Permissions": [], "Description": "Get current playback position as a @B_android#media#MediaTimestamp_E@. The MediaTimestamp represents how the media time correlates to the system time in a linear fashion using an anchor and a clock rate. During regular playback, the media time moves fairly constantly (though the anchor frame may be rebased to a current system time, the linear correlation stays steady). Therefore, this method does not need to be called often. To help users get current playback position, this method always anchors the timestamp to the current @B_java#lang#System#nanoTime_E@, so @B_android#media#MediaTimestamp#getAnchorMediaTimeUs_E@ can be used as current playback position.", "history": "Added in API level 23", "FullName": "public MediaTimestamp getTimestamp ()"}, "setLooping(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: whether to loop or not"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the player to be looping or non-looping.", "history": "Added in API level 1", "FullName": "public void setLooping (boolean looping)"}, "getKeyRequest(byte[],byte[],java.lang.String,int,java.util.Map<java.lang.String,java.lang.String>)": {"Returns": [["@B_android#media#MediaDrm#KeyRequest_E@", "no returns description in source"]], "Parameters": [["byte[]", "byte: is the key-set identifier of the offline keys being released when keyType is @B_android#media#MediaDrm#KEY_TYPE_RELEASE_E@. It should be set to null for other key requests, when keyType is @B_android#media#MediaDrm#KEY_TYPE_STREAMING_E@ or @B_android#media#MediaDrm#KEY_TYPE_OFFLINE_E@. This value may be null."], ["byte[]", "byte: is the container-specific initialization data when the keyType is @B_android#media#MediaDrm#KEY_TYPE_STREAMING_E@ or @B_android#media#MediaDrm#KEY_TYPE_OFFLINE_E@. Its meaning is interpreted based on the mime type provided in the mimeType parameter. It could contain, for example, the content ID, key ID or other data obtained from the content metadata that is required in generating the key request. When the keyType is @B_android#media#MediaDrm#KEY_TYPE_RELEASE_E@, it should be set to null. This value may be null."], ["@B_java#lang#String_E@", "String: identifies the mime type of the content This value may be null."], ["int", "int: specifies the type of the request. The request may be to acquire keys for streaming, @B_android#media#MediaDrm#KEY_TYPE_STREAMING_E@, or for offline content @B_android#media#MediaDrm#KEY_TYPE_OFFLINE_E@, or to release previously acquired keys (@B_android#media#MediaDrm#KEY_TYPE_RELEASE_E@), which are identified by a keySetId. Value is @B_android#media#MediaDrm#KEY_TYPE_STREAMING_E@, @B_android#media#MediaDrm#KEY_TYPE_OFFLINE_E@, or @B_android#media#MediaDrm#KEY_TYPE_RELEASE_E@"], ["@B_java#util#Map_E@", "Map: are included in the key request message to allow a client application to provide additional message parameters to the server. This may be null if no additional parameters are to be sent. This value may be null."]], "Throws": [["@B_android#media#MediaPlayer#NoDrmSchemeException_E@", "if there is no active DRM session"]], "SeeAlso": [], "Permissions": [], "Description": "A key request/response exchange occurs between the app and a license server to obtain or release keys used to decrypt encrypted content. getKeyRequest() is used to obtain an opaque key request byte array that is delivered to the license server. The opaque key request byte array is returned in KeyRequest.data. The recommended URL to deliver the key request to is returned in KeyRequest.defaultUrl. After the app has received the key request response from the server, it should deliver to the response to the DRM engine plugin using the method @B_android#media#MediaPlayer#provideKeyResponse_E@.", "history": "Added in API level 26", "FullName": "public MediaDrm.KeyRequest getKeyRequest (byte[] keySetId, byte[] initData, String mimeType, int keyType, Map<String, String> optionalParameters)"}, "reset()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Resets the MediaPlayer to its uninitialized state. After calling this method, you will have to initialize it again by setting the data source and calling prepare().", "history": "Added in API level 1", "FullName": "public void reset ()"}, "selectTrack(int)": {"Returns": [], "Parameters": [["int", "int: the index of the track to be selected. The valid range of the index is 0..total number of track - 1. The total number of tracks as well as the type of each individual track can be found by calling @B_android#media#MediaPlayer#getTrackInfo_E@ method."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if called in an invalid state."]], "SeeAlso": ["@B_android#media#MediaPlayer#getTrackInfo_E@"], "Permissions": [], "Description": "Selects a track. If a MediaPlayer is in invalid state, it throws an IllegalStateException exception. If a MediaPlayer is in Started state, the selected track is presented immediately. If a MediaPlayer is not in Started state, it just marks the track to be played. In any valid state, if it is called multiple times on the same type of track (ie. Video, Audio, Timed Text), the most recent one will be chosen. The first audio and video tracks are selected by default if available, even though this method is not called. However, no timed text track will be selected until this function is called. Currently, only timed text, subtitle or audio tracks can be selected via this method. In addition, the support for selecting an audio track at runtime is pretty limited in that an audio track can only be selected in the Prepared state.", "history": "Added in API level 16", "FullName": "public void selectTrack (int index)"}, "setNextMediaPlayer(android.media.MediaPlayer)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer_E@", "MediaPlayer: the player to start after this one completes playback."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the MediaPlayer to start when this MediaPlayer finishes playback (i.e. reaches the end of the stream). The media framework will attempt to transition from this player to the next as seamlessly as possible. The next player can be set at any time before completion, but shall be after setDataSource has been called successfully. The next player must be prepared by the app, and the application should not call start() on it. The next MediaPlayer must be different from 'this'. An exception will be thrown if next == this. The application may call setNextMediaPlayer(null) to indicate no next player should be started at the end of playback. If the current player is looping, it will keep looping and the next player will not be started.", "history": "Added in API level 16", "FullName": "public void setNextMediaPlayer (MediaPlayer next)"}, "setWakeMode(android.content.Context,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use"], ["int", "int: the power/wake mode to set"]], "Throws": [], "SeeAlso": ["@B_android#os#PowerManager_E@"], "Permissions": ["@B_android#Manifest#permission#WAKE_LOCK_E@"], "Description": "Set the low-level power management behavior for this MediaPlayer. This can be used when the MediaPlayer is not playing through a SurfaceHolder set with @B_android#media#MediaPlayer#setDisplay_E@ and thus can use the high-level @B_android#media#MediaPlayer#setScreenOnWhilePlaying_E@ feature. This function has the MediaPlayer access the low-level power manager service to control the device's power usage while playing is occurring. The parameter is a combination of @B_android#os#PowerManager_E@ wake flags. Use of this method requires @B_android#Manifest#permission#WAKE_LOCK_E@ permission. By default, no attempt is made to keep the device awake during playback.", "history": "Added in API level 1", "FullName": "public void setWakeMode (Context context, int mode)"}, "getRoutedDevice()": {"Returns": [["@B_android#media#AudioDeviceInfo_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns an @B_android#media#AudioDeviceInfo_E@ identifying the current routing of this MediaPlayer Note: The query is only valid if the MediaPlayer is currently playing. If the player is not playing, the returned device can be null or correspond to previously selected device when the player was last active.", "history": "Added in API level 28", "FullName": "public AudioDeviceInfo getRoutedDevice ()"}, "getStartDelayMs()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "protected int getStartDelayMs ()"}, "getPreferredDevice()": {"Returns": [["@B_android#media#AudioDeviceInfo_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the selected output specified by @B_android#media#MediaPlayer#setPreferredDevice_E@. Note that this is not guaranteed to correspond to the actual device being used for playback.", "history": "Added in API level 28", "FullName": "public AudioDeviceInfo getPreferredDevice ()"}, "setOnBufferingUpdateListener(android.media.MediaPlayer.OnBufferingUpdateListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnBufferingUpdateListener_E@", "MediaPlayer.OnBufferingUpdateListener: the callback that will be run."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the status of a network stream's buffer has changed.", "history": "Added in API level 1", "FullName": "public void setOnBufferingUpdateListener (MediaPlayer.OnBufferingUpdateListener listener)"}, "releaseDrm()": {"Returns": [], "Parameters": [], "Throws": [["@B_android#media#MediaPlayer#NoDrmSchemeException_E@", "if there is no active DRM session to release"]], "SeeAlso": [], "Permissions": [], "Description": "Releases the DRM session The player has to have an active DRM session and be in stopped, or prepared state before this call is made. A reset() call will release the DRM session implicitly.", "history": "Added in API level 26", "FullName": "public void releaseDrm ()"}, "createVolumeShaper(android.media.VolumeShaper.Configuration)": {"Returns": [["@B_android#media#VolumeShaper_E@", "This value will never be null."]], "Parameters": [["@B_android#media#VolumeShaper#Configuration_E@", "VolumeShaper.Configuration: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a @B_android#media#VolumeShaper_E@ object that can be used modify the volume envelope of the player or track.", "history": "Added in API level 26", "FullName": "public VolumeShaper createVolumeShaper (VolumeShaper.Configuration configuration)"}, "setOnTimedTextListener(android.media.MediaPlayer.OnTimedTextListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnTimedTextListener_E@", "MediaPlayer.OnTimedTextListener: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when a timed text is available for display.", "history": "Added in API level 16", "FullName": "public void setOnTimedTextListener (MediaPlayer.OnTimedTextListener listener)"}, "setDisplay(android.view.SurfaceHolder)": {"Returns": [], "Parameters": [["@B_android#view#SurfaceHolder_E@", "SurfaceHolder: the SurfaceHolder to use for video display"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized or has been released."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the @B_android#view#SurfaceHolder_E@ to use for displaying the video portion of the media. Either a surface holder or surface must be set if a display or video sink is needed. Not calling this method or @B_android#media#MediaPlayer#setSurface_E@ when playing back a video will result in only the audio track being played. A null surface holder or surface will result in only the audio track being played.", "history": "Added in API level 1", "FullName": "public void setDisplay (SurfaceHolder sh)"}, "setDataSource(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the path of the file, or the http/rtsp URL of the stream you want to play"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#io#IOException_E@", ""], ["@B_java#lang#IllegalArgumentException_E@", ""], ["@B_java#lang#SecurityException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Sets the data source (file-path or http/rtsp URL) to use. When path refers to a local file, the file may actually be opened by a process other than the calling application. This implies that the pathname should be an absolute path (as any other process runs with unspecified current working directory), and that the pathname should reference a world-readable file. As an alternative, the application could first open the file for reading, and then use the file descriptor form @B_android#media#MediaPlayer#setDataSource_E@.", "history": "Added in API level 1", "FullName": "public void setDataSource (String path)"}, "setOnDrmPreparedListener(android.media.MediaPlayer.OnDrmPreparedListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnDrmPreparedListener_E@", "MediaPlayer.OnDrmPreparedListener: the callback that will be run"], ["@B_android#os#Handler_E@", "Handler: the Handler that will receive the callback"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the DRM object is prepared.", "history": "Added in API level 26", "FullName": "public void setOnDrmPreparedListener (MediaPlayer.OnDrmPreparedListener listener, Handler handler)"}, "setDataSource(android.content.Context,android.net.Uri,java.util.Map<java.lang.String,java.lang.String>,java.util.List<java.net.HttpCookie>)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use when resolving the Uri This value must never be null."], ["@B_android#net#Uri_E@", "Uri: the Content URI of the data you want to play This value must never be null."], ["@B_java#util#Map_E@", "Map: the headers to be sent together with the request for the data The headers must not include cookies. Instead, use the cookies param. This value may be null."], ["@B_java#util#List_E@", "List: the cookies to be sent together with the request This value may be null."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if cookies are provided and the installed handler is not a CookieManager"], ["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#lang#NullPointerException_E@", "if context or uri is null"], ["@B_java#io#IOException_E@", "if uri has a file scheme and an I/O error occurs"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the data source as a content Uri. To provide cookies for the subsequent HTTP requests, you can install your own default cookie handler and use other variants of setDataSource APIs instead. Alternatively, you can use this API to pass the cookies as a list of HttpCookie. If the app has not installed a CookieHandler already, this API creates a CookieManager and populates its CookieStore with the provided cookies. If the app has installed its own handler already, this API requires the handler to be of CookieManager type such that the API can update the manager\u2019s CookieStore.", "history": "Added in API level 26", "FullName": "public void setDataSource (Context context, Uri uri, Map<String, String> headers, List<HttpCookie> cookies)"}, "provideKeyResponse(byte[], byte[])": {"Returns": [["byte[]", "no returns description in source"]], "Parameters": [["byte[]", "byte: When the response is for a release request, keySetId identifies the saved key associated with the release request (i.e., the same keySetId passed to the earlier {@ link # getKeyRequest} call. It MUST be null when the response is for either streaming or offline key requests."], ["byte[]", "byte: the byte array response from the serverThis value must never be null."]], "Throws": [["@B_android#media#MediaPlayer#NoDrmSchemeException_E@", "if there is no active DRM session"], ["@B_android#media#DeniedByServerException_E@", "if the response indicates that the server rejected the request"]], "SeeAlso": [], "Permissions": [], "Description": "A key response is received from the license server by the app, then it is provided to the DRM engine plugin using provideKeyResponse. When the response is for an offline key request, a key-set identifier is returned that can be used to later restore the keys to a new session with the method {@ link # restoreKeys}. When the response is for a streaming or release request, null is returned.", "history": "added in API level 26", "FullName": "public byte[] provideKeyResponse (byte[] keySetId, byte[] response)"}, "setScreenOnWhilePlaying(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Supply true to keep the screen on, false to allow it to turn off."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Control whether we should use the attached SurfaceHolder to keep the screen on while video playback is occurring. This is the preferred method over @B_android#media#MediaPlayer#setWakeMode_E@ where possible, since it doesn't require that the application have permission for low-level wake lock access.", "history": "Added in API level 1", "FullName": "public void setScreenOnWhilePlaying (boolean screenOn)"}, "setOnPreparedListener(android.media.MediaPlayer.OnPreparedListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnPreparedListener_E@", "MediaPlayer.OnPreparedListener: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the media source is ready for playback.", "history": "Added in API level 1", "FullName": "public void setOnPreparedListener (MediaPlayer.OnPreparedListener listener)"}, "removeOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener)": {"Returns": [], "Parameters": [["@B_android#media#AudioRouting#OnRoutingChangedListener_E@", "AudioRouting.OnRoutingChangedListener: The previously added @B_android#media#AudioRouting#OnRoutingChangedListener_E@ interface to remove."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes an @B_android#media#AudioRouting#OnRoutingChangedListener_E@ which has been previously added to receive rerouting notifications.", "history": "Added in API level 28", "FullName": "public void removeOnRoutingChangedListener (AudioRouting.OnRoutingChangedListener listener)"}, "create(android.content.Context,android.net.Uri,android.view.SurfaceHolder,android.media.AudioAttributes,int)": {"Returns": [["@B_android#media#MediaPlayer_E@", "a MediaPlayer object, or null if creation failed"]], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use"], ["@B_android#net#Uri_E@", "Uri: the Uri from which to get the datasource"], ["@B_android#view#SurfaceHolder_E@", "SurfaceHolder: the SurfaceHolder to use for displaying the video, may be null."], ["@B_android#media#AudioAttributes_E@", "AudioAttributes: the @B_android#media#AudioAttributes_E@ to be used by the media player."], ["int", "int: the audio session ID to be used by the media player, see @B_android#media#AudioManager#generateAudioSessionId_E@ to obtain a new session."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same factory method as @B_android#media#MediaPlayer#create_E@ but that lets you specify the audio attributes and session ID to be used by the new MediaPlayer instance.", "history": "Added in API level 21", "FullName": "public static MediaPlayer create (Context context, Uri uri, SurfaceHolder holder, AudioAttributes audioAttributes, int audioSessionId)"}, "setOnCompletionListener(android.media.MediaPlayer.OnCompletionListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnCompletionListener_E@", "MediaPlayer.OnCompletionListener: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the end of a media source has been reached during playback.", "history": "Added in API level 1", "FullName": "public void setOnCompletionListener (MediaPlayer.OnCompletionListener listener)"}, "addTimedTextSource(java.io.FileDescriptor,long,long,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: the FileDescriptor for the file you want to play"], ["long", "long: the offset into the file where the data to be played starts, in bytes"], ["long", "long: the length in bytes of the data to be played"], ["@B_java#lang#String_E@", "String: The mime type of the file. Must be one of the mime types listed above."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the mimeType is not supported."], ["@B_java#lang#IllegalStateException_E@", "if called in an invalid state."]], "SeeAlso": [], "Permissions": [], "Description": "Adds an external timed text file (FileDescriptor). It is the caller's responsibility to close the file descriptor. It is safe to do so as soon as this call returns. Currently supported format is SubRip. Note that a single external timed text source may contain multiple tracks in it. One can find the total number of available tracks using @B_android#media#MediaPlayer#getTrackInfo_E@ to see what additional tracks become available after this method call.", "history": "Added in API level 16", "FullName": "public void addTimedTextSource (FileDescriptor fd, long offset, long length, String mime)"}, "prepare()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Prepares the player for playback, synchronously. After setting the datasource and the display surface, you need to either call prepare() or prepareAsync(). For files, it is OK to call prepare(), which blocks until MediaPlayer is ready for playback.", "history": "Added in API level 1", "FullName": "public void prepare ()"}, "setOnSubtitleDataListener(android.media.MediaPlayer.OnSubtitleDataListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnSubtitleDataListener_E@", "MediaPlayer.OnSubtitleDataListener: the listener called when new data is available This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the listener to be invoked when a subtitle track has new data available. The subtitle data comes from a subtitle track previously selected with @B_android#media#MediaPlayer#selectTrack_E@. Use @B_android#media#MediaPlayer#getTrackInfo_E@ to determine which tracks are subtitles (of type @B_android#media#MediaPlayer#TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE_E@), Subtitle track encodings can be determined by @B_android#media#MediaPlayer#TrackInfo#getFormat_E@). See @B_android#media#SubtitleData_E@ for an example of querying subtitle encoding. The listener will be called on the same thread as the one in which the MediaPlayer was created.", "history": "Added in API level 28", "FullName": "public void setOnSubtitleDataListener (MediaPlayer.OnSubtitleDataListener listener)"}, "setPlaybackParams(android.media.PlaybackParams)": {"Returns": [], "Parameters": [["@B_android#media#PlaybackParams_E@", "PlaybackParams: the playback params. This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized or has been released."], ["@B_java#lang#IllegalArgumentException_E@", "if params is not supported."]], "SeeAlso": [], "Permissions": [], "Description": "Sets playback rate using @B_android#media#PlaybackParams_E@. The object sets its internal PlaybackParams to the input, except that the object remembers previous speed when input speed is zero. This allows the object to resume at previous speed when start() is called. Calling it before the object is prepared does not change the object state. After the object is prepared, calling it with zero speed is equivalent to calling pause(). After the object is prepared, calling it with non-zero speed is equivalent to calling start().", "history": "Added in API level 23", "FullName": "public void setPlaybackParams (PlaybackParams params)"}, "setOnSeekCompleteListener(android.media.MediaPlayer.OnSeekCompleteListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnSeekCompleteListener_E@", "MediaPlayer.OnSeekCompleteListener: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when a seek operation has been completed.", "history": "Added in API level 1", "FullName": "public void setOnSeekCompleteListener (MediaPlayer.OnSeekCompleteListener listener)"}, "setAudioStreamType(int)": {"Returns": [], "Parameters": [["int", "int: the audio stream type"]], "Throws": [], "SeeAlso": ["@B_android#media#AudioManager_E@"], "Permissions": [], "Description": "use @B_android#media#MediaPlayer#setAudioAttributes_E@ Sets the audio stream type for this MediaPlayer. See @B_android#media#AudioManager_E@ for a list of stream types. Must call this method before prepare() or prepareAsync() in order for the target stream type to become effective thereafter.", "history": "Added in API level 1 Deprecated in API level 26", "FullName": "public void setAudioStreamType (int streamtype)"}, "getDrmInfo()": {"Returns": [["@B_android#media#MediaPlayer#DrmInfo_E@", "no returns description in source"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if called before prepare()"]], "SeeAlso": [], "Permissions": [], "Description": "Retrieves the DRM Info associated with the current source", "history": "Added in API level 26", "FullName": "public MediaPlayer.DrmInfo getDrmInfo ()"}, "setDrmPropertyString(java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the property name This value must never be null. Value is @B_android#media#MediaDrm#PROPERTY_VENDOR_E@, @B_android#media#MediaDrm#PROPERTY_VERSION_E@, @B_android#media#MediaDrm#PROPERTY_DESCRIPTION_E@, or @B_android#media#MediaDrm#PROPERTY_ALGORITHMS_E@"], ["@B_java#lang#String_E@", "String: the property value Standard fields names are: @B_android#media#MediaDrm#PROPERTY_VENDOR_E@, @B_android#media#MediaDrm#PROPERTY_VERSION_E@, @B_android#media#MediaDrm#PROPERTY_DESCRIPTION_E@, @B_android#media#MediaDrm#PROPERTY_ALGORITHMS_E@ This value must never be null."]], "Throws": [["@B_android#media#MediaPlayer#NoDrmSchemeException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Set a DRM engine plugin String property value.", "history": "Added in API level 26", "FullName": "public void setDrmPropertyString (String propertyName, String value)"}, "addTimedTextSource(android.content.Context,android.net.Uri,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use when resolving the Uri"], ["@B_android#net#Uri_E@", "Uri: the Content URI of the data you want to play"], ["@B_java#lang#String_E@", "String: The mime type of the file. Must be one of the mime types listed above."]], "Throws": [["@B_java#io#IOException_E@", "if the file cannot be accessed or is corrupted."], ["@B_java#lang#IllegalArgumentException_E@", "if the mimeType is not supported."], ["@B_java#lang#IllegalStateException_E@", "if called in an invalid state."]], "SeeAlso": [], "Permissions": [], "Description": "Adds an external timed text source file (Uri). Currently supported format is SubRip with the file extension .srt, case insensitive. Note that a single external timed text source may contain multiple tracks in it. One can find the total number of available tracks using @B_android#media#MediaPlayer#getTrackInfo_E@ to see what additional tracks become available after this method call.", "history": "Added in API level 16", "FullName": "public void addTimedTextSource (Context context, Uri uri, String mimeType)"}, "provideKeyResponse(byte[],byte[])": {"Returns": [["byte[]", "no returns description in source"]], "Parameters": [["byte[]", "byte: When the response is for a release request, keySetId identifies the saved key associated with the release request (i.e., the same keySetId passed to the earlier {@ link # getKeyRequest} call. It MUST be null when the response is for either streaming or offline key requests."], ["byte[]", "byte: the byte array response from the server"]], "Throws": [["@B_android#media#MediaPlayer#NoDrmSchemeException_E@", "if there is no active DRM session"], ["@B_android#media#DeniedByServerException_E@", "if the response indicates that the server rejected the request"]], "SeeAlso": [], "Permissions": [], "Description": "A key response is received from the license server by the app, then it is provided to the DRM engine plugin using provideKeyResponse. When the response is for an offline key request, a key-set identifier is returned that can be used to later restore the keys to a new session with the method {@ link # restoreKeys}. When the response is for a streaming or release request, null is returned.", "history": "Added in API level 26", "FullName": "public byte[] provideKeyResponse (byte[] keySetId, byte[] response)"}, "create(android.content.Context,int)": {"Returns": [["@B_android#media#MediaPlayer_E@", "a MediaPlayer object, or null if creation failed"]], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use"], ["int", "int: the raw resource id (R.raw.<something>) for the resource to use as the datasource"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method to create a MediaPlayer for a given resource id. On success, @B_android#media#MediaPlayer#prepare_E@ will already have been called and must not be called again. When done with the MediaPlayer, you should call @B_android#media#MediaPlayer#release_E@, to free the resources. If not released, too many MediaPlayer instances will result in an exception. Note that since @B_android#media#MediaPlayer#prepare_E@ is called automatically in this method, you cannot change the audio session ID (see @B_android#media#MediaPlayer#setAudioSessionId_E@) or audio attributes (see @B_android#media#MediaPlayer#setAudioAttributes_E@ of the new MediaPlayer.", "history": "Added in API level 1", "FullName": "public static MediaPlayer create (Context context, int resid)"}, "setOnDrmInfoListener(android.media.MediaPlayer.OnDrmInfoListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnDrmInfoListener_E@", "MediaPlayer.OnDrmInfoListener: the callback that will be run"], ["@B_android#os#Handler_E@", "Handler no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the DRM info is known.", "history": "Added in API level 26", "FullName": "public void setOnDrmInfoListener (MediaPlayer.OnDrmInfoListener listener, Handler handler)"}, "getCurrentPosition()": {"Returns": [["int", "the current position in milliseconds"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the current playback position.", "history": "Added in API level 1", "FullName": "public int getCurrentPosition ()"}, "getSelectedTrack(int)": {"Returns": [["int", "index of the audio, video, or subtitle track currently selected for playback; a negative integer is returned when there is no selected track for trackType or when trackType is not one of audio, video, or subtitle."]], "Parameters": [["int", "int: should be one of @B_android#media#MediaPlayer#TrackInfo#MEDIA_TRACK_TYPE_VIDEO_E@, @B_android#media#MediaPlayer#TrackInfo#MEDIA_TRACK_TYPE_AUDIO_E@, or @B_android#media#MediaPlayer#TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE_E@"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if called after @B_android#media#MediaPlayer#release_E@"]], "SeeAlso": ["@B_android#media#MediaPlayer#getTrackInfo_E@", "@B_android#media#MediaPlayer#selectTrack_E@", "@B_android#media#MediaPlayer#deselectTrack_E@"], "Permissions": [], "Description": "Returns the index of the audio, video, or subtitle track currently selected for playback, The return value is an index into the array returned by @B_android#media#MediaPlayer#getTrackInfo_E@, and can be used in calls to @B_android#media#MediaPlayer#selectTrack_E@ or @B_android#media#MediaPlayer#deselectTrack_E@.", "history": "Added in API level 21", "FullName": "public int getSelectedTrack (int trackType)"}, "setDataSource(android.media.MediaDataSource)": {"Returns": [], "Parameters": [["@B_android#media#MediaDataSource_E@", "MediaDataSource: the MediaDataSource for the media you want to play"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#lang#IllegalArgumentException_E@", "if dataSource is not a valid MediaDataSource"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the data source (MediaDataSource) to use.", "history": "Added in API level 23", "FullName": "public void setDataSource (MediaDataSource dataSource)"}, "setDataSource(android.content.Context,android.net.Uri)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use when resolving the Uri This value must never be null."], ["@B_android#net#Uri_E@", "Uri: the Content URI of the data you want to play This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#io#IOException_E@", ""], ["@B_java#lang#IllegalArgumentException_E@", ""], ["@B_java#lang#SecurityException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Sets the data source as a content Uri.", "history": "Added in API level 1", "FullName": "public void setDataSource (Context context, Uri uri)"}, "clearOnMediaTimeDiscontinuityListener()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clears the listener previously set with @B_android#media#MediaPlayer#setOnMediaTimeDiscontinuityListener_E@ or @B_android#media#MediaPlayer#setOnMediaTimeDiscontinuityListener_E@", "history": "Added in API level 28", "FullName": "public void clearOnMediaTimeDiscontinuityListener ()"}, "attachAuxEffect(int)": {"Returns": [], "Parameters": [["int", "int: system wide unique id of the effect to attach"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Attaches an auxiliary effect to the player. A typical auxiliary effect is a reverberation effect which can be applied on any sound source that directs a certain amount of its energy to this effect. This amount is defined by setAuxEffectSendLevel(). See @B_android#media#MediaPlayer#setAuxEffectSendLevel_E@. After creating an auxiliary effect (e.g. @B_android#media#audiofx#EnvironmentalReverb_E@), retrieve its ID with @B_android#media#audiofx#AudioEffect#getId_E@ and use it when calling this method to attach the player to the effect. To detach the effect from the player, call this method with a null effect id. This method must be called after one of the overloaded setDataSource methods.", "history": "Added in API level 9", "FullName": "public void attachAuxEffect (int effectId)"}, "setVolume(float, float)": {"Returns": [], "Parameters": [["float", "float: left volume scalar"], ["float", "float: right volume scalar"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the volume on this player. This API is recommended for balancing the output of audio streams within an application. Unless you are writing an application to control user settings, this API should be used in preference to @B_android#media#AudioManager#setStreamVolume_E@ which sets the volume of ALL streams of a particular type. Note that the passed volume values are raw scalars in range 0.0 to 1.0. UI controls should be scaled logarithmically.", "history": "added in API level 1", "FullName": "public void setVolume (float leftVolume, float rightVolume)"}, "setOnMediaTimeDiscontinuityListener(android.media.MediaPlayer.OnMediaTimeDiscontinuityListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnMediaTimeDiscontinuityListener_E@", "MediaPlayer.OnMediaTimeDiscontinuityListener: the listener called after a discontinuity This value must never be null."], ["@B_android#os#Handler_E@", "Handler: the @B_android#os#Handler_E@ that receives the listener events This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the listener to be invoked when a media time discontinuity is encountered.", "history": "Added in API level 28", "FullName": "public void setOnMediaTimeDiscontinuityListener (MediaPlayer.OnMediaTimeDiscontinuityListener listener, Handler handler)"}, "setAuxEffectSendLevel(float)": {"Returns": [], "Parameters": [["float", "float: send level scalar"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the send level of the player to the attached auxiliary effect. See @B_android#media#MediaPlayer#attachAuxEffect_E@. The level value range is 0 to 1.0. By default the send level is 0, so even if an effect is attached to the player this method must be called for the effect to be applied. Note that the passed level value is a raw scalar. UI controls should be scaled logarithmically: the gain applied by audio framework ranges from -72dB to 0dB, so an appropriate conversion from linear UI input x to level is: x == 0 -> level = 0 0 < x <= R -> level = 10^(72*(x-R)/20/R)", "history": "Added in API level 9", "FullName": "public void setAuxEffectSendLevel (float level)"}, "setOnInfoListener(android.media.MediaPlayer.OnInfoListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnInfoListener_E@", "MediaPlayer.OnInfoListener: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when an info/warning is available.", "history": "Added in API level 3", "FullName": "public void setOnInfoListener (MediaPlayer.OnInfoListener listener)"}, "setDataSource(android.content.res.AssetFileDescriptor)": {"Returns": [], "Parameters": [["@B_android#content#res#AssetFileDescriptor_E@", "AssetFileDescriptor: the AssetFileDescriptor for the file you want to play This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#lang#IllegalArgumentException_E@", "if afd is not a valid AssetFileDescriptor"], ["@B_java#io#IOException_E@", "if afd can not be read"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the data source (AssetFileDescriptor) to use. It is the caller's responsibility to close the file descriptor. It is safe to do so as soon as this call returns.", "history": "Added in API level 24", "FullName": "public void setDataSource (AssetFileDescriptor afd)"}, "setVolume(float,float)": {"Returns": [], "Parameters": [["float", "float: left volume scalar"], ["float", "float: right volume scalar"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the volume on this player. This API is recommended for balancing the output of audio streams within an application. Unless you are writing an application to control user settings, this API should be used in preference to @B_android#media#AudioManager#setStreamVolume_E@ which sets the volume of ALL streams of a particular type. Note that the passed volume values are raw scalars in range 0.0 to 1.0. UI controls should be scaled logarithmically.", "history": "Added in API level 1", "FullName": "public void setVolume (float leftVolume, float rightVolume)"}, "MediaPlayer()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default constructor. Consider using one of the create() methods for synchronously instantiating a MediaPlayer from a Uri or resource. When done with the MediaPlayer, you should call @B_android#media#MediaPlayer#release_E@, to free the resources. If not released, too many MediaPlayer instances may result in an exception.", "history": "Added in API level 1", "FullName": "public MediaPlayer ()"}, "setAudioAttributes(android.media.AudioAttributes)": {"Returns": [], "Parameters": [["@B_android#media#AudioAttributes_E@", "AudioAttributes: a non-null set of audio attributes"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Sets the audio attributes for this MediaPlayer. See @B_android#media#AudioAttributes_E@ for how to build and configure an instance of this class. You must call this method before @B_android#media#MediaPlayer#prepare_E@ or @B_android#media#MediaPlayer#prepareAsync_E@ in order for the audio attributes to become effective thereafter.", "history": "Added in API level 21", "FullName": "public void setAudioAttributes (AudioAttributes attributes)"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 1", "FullName": "protected void finalize ()"}, "getDuration()": {"Returns": [["int", "the duration in milliseconds, if no duration is available (for example, if streaming live content), -1 is returned."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the duration of the file.", "history": "Added in API level 1", "FullName": "public int getDuration ()"}, "setOnDrmPreparedListener(android.media.MediaPlayer.OnDrmPreparedListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnDrmPreparedListener_E@", "MediaPlayer.OnDrmPreparedListener: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the DRM object is prepared.", "history": "Added in API level 26", "FullName": "public void setOnDrmPreparedListener (MediaPlayer.OnDrmPreparedListener listener)"}, "setDataSource(java.io.FileDescriptor)": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: the FileDescriptor for the file you want to play"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#lang#IllegalArgumentException_E@", "if fd is not a valid FileDescriptor"], ["@B_java#io#IOException_E@", "if fd can not be read"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the data source (FileDescriptor) to use. It is the caller's responsibility to close the file descriptor. It is safe to do so as soon as this call returns.", "history": "Added in API level 1", "FullName": "public void setDataSource (FileDescriptor fd)"}, "setOnDrmInfoListener(android.media.MediaPlayer.OnDrmInfoListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnDrmInfoListener_E@", "MediaPlayer.OnDrmInfoListener: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the DRM info is known.", "history": "Added in API level 26", "FullName": "public void setOnDrmInfoListener (MediaPlayer.OnDrmInfoListener listener)"}, "seekTo(long, int)": {"Returns": [], "Parameters": [["long", "long: the offset in milliseconds from the start to seek to. When seeking to the given time position, there is no guarantee that the data source has a frame located at the position. When this happens, a frame nearby will be rendered. If msec is negative, time position zero will be used. If msec is larger than duration, duration will be used."], ["int", "int: the mode indicating where exactly to seek to. Use @B_android#media#MediaPlayer#SEEK_PREVIOUS_SYNC_E@ if one wants to seek to a sync frame that has a timestamp earlier than or the same as msec. Use @B_android#media#MediaPlayer#SEEK_NEXT_SYNC_E@ if one wants to seek to a sync frame that has a timestamp later than or the same as msec. Use @B_android#media#MediaPlayer#SEEK_CLOSEST_SYNC_E@ if one wants to seek to a sync frame that has a timestamp closest to or the same as msec. Use @B_android#media#MediaPlayer#SEEK_CLOSEST_E@ if one wants to seek to a frame that may or may not be a sync frame but is closest to or the same as msec. @B_android#media#MediaPlayer#SEEK_CLOSEST_E@ often has larger performance overhead compared to the other options if there is no sync frame located at msec."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized"], ["@B_java#lang#IllegalArgumentException_E@", "if the mode is invalid."]], "SeeAlso": [], "Permissions": [], "Description": "Moves the media to specified time position by considering the given mode. When seekTo is finished, the user will be notified via OnSeekComplete supplied by the user. There is at most one active seekTo processed at any time. If there is a to-be-completed seekTo, new seekTo requests will be queued in such a way that only the last request is kept. When current seekTo is completed, the queued request will be processed if that request is different from just-finished seekTo operation, i.e., the requested position or mode is different.", "history": "added in API level 26", "FullName": "public void seekTo (long msec, int mode)"}, "getSyncParams()": {"Returns": [["@B_android#media#SyncParams_E@", "the A/V sync params This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Gets the A/V sync mode.", "history": "Added in API level 23", "FullName": "public SyncParams getSyncParams ()"}, "setSyncParams(android.media.SyncParams)": {"Returns": [], "Parameters": [["@B_android#media#SyncParams_E@", "SyncParams: the A/V sync params to apply This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized."], ["@B_java#lang#IllegalArgumentException_E@", "if params are not supported."]], "SeeAlso": [], "Permissions": [], "Description": "Sets A/V sync mode.", "history": "Added in API level 23", "FullName": "public void setSyncParams (SyncParams params)"}, "getVideoHeight()": {"Returns": [["int", "the height of the video, or 0 if there is no video, no display surface was set, or the height has not been determined yet. The OnVideoSizeChangedListener can be registered via @B_android#media#MediaPlayer#setOnVideoSizeChangedListener_E@ to provide a notification when the height is available."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the height of the video.", "history": "Added in API level 1", "FullName": "public int getVideoHeight ()"}, "seekTo(int)": {"Returns": [], "Parameters": [["int", "int: the offset in milliseconds from the start to seek to"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized"]], "SeeAlso": [], "Permissions": [], "Description": "Seeks to specified time position. Same as @B_android#media#MediaPlayer#seekTo_E@ with mode = SEEK_PREVIOUS_SYNC.", "history": "Added in API level 1", "FullName": "public void seekTo (int msec)"}, "setOnSubtitleDataListener(android.media.MediaPlayer.OnSubtitleDataListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnSubtitleDataListener_E@", "MediaPlayer.OnSubtitleDataListener: the listener called when new data is available This value must never be null."], ["@B_android#os#Handler_E@", "Handler: the @B_android#os#Handler_E@ that receives the listener events This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the listener to be invoked when a subtitle track has new data available. The subtitle data comes from a subtitle track previously selected with @B_android#media#MediaPlayer#selectTrack_E@. Use @B_android#media#MediaPlayer#getTrackInfo_E@ to determine which tracks are subtitles (of type @B_android#media#MediaPlayer#TrackInfo#MEDIA_TRACK_TYPE_SUBTITLE_E@), Subtitle track encodings can be determined by @B_android#media#MediaPlayer#TrackInfo#getFormat_E@). See @B_android#media#SubtitleData_E@ for an example of querying subtitle encoding.", "history": "Added in API level 28", "FullName": "public void setOnSubtitleDataListener (MediaPlayer.OnSubtitleDataListener listener, Handler handler)"}, "seekTo(long,int)": {"Returns": [], "Parameters": [["long", "long: the offset in milliseconds from the start to seek to. When seeking to the given time position, there is no guarantee that the data source has a frame located at the position. When this happens, a frame nearby will be rendered. If msec is negative, time position zero will be used. If msec is larger than duration, duration will be used."], ["int", "int: the mode indicating where exactly to seek to. Use @B_android#media#MediaPlayer#SEEK_PREVIOUS_SYNC_E@ if one wants to seek to a sync frame that has a timestamp earlier than or the same as msec. Use @B_android#media#MediaPlayer#SEEK_NEXT_SYNC_E@ if one wants to seek to a sync frame that has a timestamp later than or the same as msec. Use @B_android#media#MediaPlayer#SEEK_CLOSEST_SYNC_E@ if one wants to seek to a sync frame that has a timestamp closest to or the same as msec. Use @B_android#media#MediaPlayer#SEEK_CLOSEST_E@ if one wants to seek to a frame that may or may not be a sync frame but is closest to or the same as msec. @B_android#media#MediaPlayer#SEEK_CLOSEST_E@ often has larger performance overhead compared to the other options if there is no sync frame located at msec. Value is @B_android#media#MediaPlayer#SEEK_PREVIOUS_SYNC_E@, @B_android#media#MediaPlayer#SEEK_NEXT_SYNC_E@, @B_android#media#MediaPlayer#SEEK_CLOSEST_SYNC_E@, or @B_android#media#MediaPlayer#SEEK_CLOSEST_E@"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized"], ["@B_java#lang#IllegalArgumentException_E@", "if the mode is invalid."]], "SeeAlso": [], "Permissions": [], "Description": "Moves the media to specified time position by considering the given mode. When seekTo is finished, the user will be notified via OnSeekComplete supplied by the user. There is at most one active seekTo processed at any time. If there is a to-be-completed seekTo, new seekTo requests will be queued in such a way that only the last request is kept. When current seekTo is completed, the queued request will be processed if that request is different from just-finished seekTo operation, i.e., the requested position or mode is different.", "history": "Added in API level 26", "FullName": "public void seekTo (long msec, int mode)"}, "addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#AudioRouting#OnRoutingChangedListener_E@", "AudioRouting.OnRoutingChangedListener: The @B_android#media#AudioRouting#OnRoutingChangedListener_E@ interface to receive notifications of rerouting events."], ["@B_android#os#Handler_E@", "Handler: Specifies the @B_android#os#Handler_E@ object for the thread on which to execute the callback. If null, the handler on the main looper will be used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds an @B_android#media#AudioRouting#OnRoutingChangedListener_E@ to receive notifications of routing changes on this MediaPlayer.", "history": "Added in API level 28", "FullName": "public void addOnRoutingChangedListener (AudioRouting.OnRoutingChangedListener listener, Handler handler)"}, "setOnTimedMetaDataAvailableListener(android.media.MediaPlayer.OnTimedMetaDataAvailableListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnTimedMetaDataAvailableListener_E@", "MediaPlayer.OnTimedMetaDataAvailableListener: the callback that will be run"]], "Throws": [], "SeeAlso": ["@B_android#media#MediaPlayer#selectTrack_E@", "@B_android#media#MediaPlayer#OnTimedMetaDataAvailableListener_E@", "@B_android#media#TimedMetaData_E@"], "Permissions": [], "Description": "Register a callback to be invoked when a selected track has timed metadata available. Currently only HTTP live streaming data URI's embedded with timed ID3 tags generates @B_android#media#TimedMetaData_E@.", "history": "Added in API level 23", "FullName": "public void setOnTimedMetaDataAvailableListener (MediaPlayer.OnTimedMetaDataAvailableListener listener)"}, "create(android.content.Context,android.net.Uri,android.view.SurfaceHolder)": {"Returns": [["@B_android#media#MediaPlayer_E@", "a MediaPlayer object, or null if creation failed"]], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use"], ["@B_android#net#Uri_E@", "Uri: the Uri from which to get the datasource"], ["@B_android#view#SurfaceHolder_E@", "SurfaceHolder: the SurfaceHolder to use for displaying the video"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method to create a MediaPlayer for a given Uri. On success, @B_android#media#MediaPlayer#prepare_E@ will already have been called and must not be called again. When done with the MediaPlayer, you should call @B_android#media#MediaPlayer#release_E@, to free the resources. If not released, too many MediaPlayer instances will result in an exception. Note that since @B_android#media#MediaPlayer#prepare_E@ is called automatically in this method, you cannot change the audio session ID (see @B_android#media#MediaPlayer#setAudioSessionId_E@) or audio attributes (see @B_android#media#MediaPlayer#setAudioAttributes_E@ of the new MediaPlayer.", "history": "Added in API level 1", "FullName": "public static MediaPlayer create (Context context, Uri uri, SurfaceHolder holder)"}, "setAudioSessionId(int)": {"Returns": [], "Parameters": [["int", "int: the audio session ID. The audio session ID is a system wide unique identifier for the audio stream played by this MediaPlayer instance. The primary use of the audio session ID is to associate audio effects to a particular instance of MediaPlayer: if an audio session ID is provided when creating an audio effect, this effect will be applied only to the audio content of media players within the same audio session and not to the output mix. When created, a MediaPlayer instance automatically generates its own audio session ID. However, it is possible to force this player to be part of an already existing audio session by calling this method. This method must be called before one of the overloaded setDataSource methods."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#lang#IllegalArgumentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Sets the audio session ID.", "history": "Added in API level 9", "FullName": "public void setAudioSessionId (int sessionId)"}, "setPreferredDevice(android.media.AudioDeviceInfo)": {"Returns": [["boolean", "true if succesful, false if the specified @B_android#media#AudioDeviceInfo_E@ is non-null and does not correspond to a valid audio device."]], "Parameters": [["@B_android#media#AudioDeviceInfo_E@", "AudioDeviceInfo: The @B_android#media#AudioDeviceInfo_E@ specifying the audio sink or source. If deviceInfo is null, default routing is restored."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Specifies an audio device (via an @B_android#media#AudioDeviceInfo_E@ object) to route the output from this MediaPlayer.", "history": "Added in API level 28", "FullName": "public boolean setPreferredDevice (AudioDeviceInfo deviceInfo)"}, "setOnVideoSizeChangedListener(android.media.MediaPlayer.OnVideoSizeChangedListener)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnVideoSizeChangedListener_E@", "MediaPlayer.OnVideoSizeChangedListener: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the video size is known or updated.", "history": "Added in API level 3", "FullName": "public void setOnVideoSizeChangedListener (MediaPlayer.OnVideoSizeChangedListener listener)"}, "addTimedTextSource(java.io.FileDescriptor,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: the FileDescriptor for the file you want to play"], ["@B_java#lang#String_E@", "String: The mime type of the file. Must be one of the mime types listed above."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the mimeType is not supported."], ["@B_java#lang#IllegalStateException_E@", "if called in an invalid state."]], "SeeAlso": [], "Permissions": [], "Description": "Adds an external timed text source file (FileDescriptor). It is the caller's responsibility to close the file descriptor. It is safe to do so as soon as this call returns. Currently supported format is SubRip. Note that a single external timed text source may contain multiple tracks in it. One can find the total number of available tracks using @B_android#media#MediaPlayer#getTrackInfo_E@ to see what additional tracks become available after this method call.", "history": "Added in API level 16", "FullName": "public void addTimedTextSource (FileDescriptor fd, String mimeType)"}, "setOnDrmConfigHelper(android.media.MediaPlayer.OnDrmConfigHelper)": {"Returns": [], "Parameters": [["@B_android#media#MediaPlayer#OnDrmConfigHelper_E@", "MediaPlayer.OnDrmConfigHelper: the callback that will be run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked for configuration of the DRM object before the session is created. The callback will be invoked synchronously during the execution of @B_android#media#MediaPlayer#prepareDrm_E@.", "history": "Added in API level 26", "FullName": "public void setOnDrmConfigHelper (MediaPlayer.OnDrmConfigHelper listener)"}, "addTimedTextSource(java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The file path of external timed text source file."], ["@B_java#lang#String_E@", "String: The mime type of the file. Must be one of the mime types listed above."]], "Throws": [["@B_java#io#IOException_E@", "if the file cannot be accessed or is corrupted."], ["@B_java#lang#IllegalArgumentException_E@", "if the mimeType is not supported."], ["@B_java#lang#IllegalStateException_E@", "if called in an invalid state."]], "SeeAlso": [], "Permissions": [], "Description": "Adds an external timed text source file. Currently supported format is SubRip with the file extension .srt, case insensitive. Note that a single external timed text source may contain multiple tracks in it. One can find the total number of available tracks using @B_android#media#MediaPlayer#getTrackInfo_E@ to see what additional tracks become available after this method call.", "history": "Added in API level 16", "FullName": "public void addTimedTextSource (String path, String mimeType)"}, "setDataSource(android.content.Context,android.net.Uri,java.util.Map<java.lang.String,java.lang.String>)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to use when resolving the Uri This value must never be null."], ["@B_android#net#Uri_E@", "Uri: the Content URI of the data you want to play This value must never be null."], ["@B_java#util#Map_E@", "Map: the headers to be sent together with the request for the data This value may be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if it is called in an invalid state"], ["@B_java#io#IOException_E@", ""], ["@B_java#lang#IllegalArgumentException_E@", ""], ["@B_java#lang#SecurityException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Sets the data source as a content Uri.", "history": "Added in API level 14", "FullName": "public void setDataSource (Context context, Uri uri, Map<String, String> headers)"}}, "Inheritance": [], "ClassName": "android.media.MediaPlayer", "ClassDesc": "MediaPlayer class can be used to control playback of audio/video files and streams. An example on how to use the methods in this class can be found in @B_android#widget#VideoView_E@. Topics covered here are: Playback control of audio/video files and streams is managed as a state machine. The following diagram shows the life cycle and the states of a MediaPlayer object driven by the supported playback control operations. The ovals represent the states a MediaPlayer object may reside in. The arcs represent the playback control operations that drive the object state transition. There are two types of arcs. The arcs with a single arrow head represent synchronous method calls, while those with a double arrow head represent asynchronous method calls. From this state diagram, one can see that a MediaPlayer object has the following states: When a MediaPlayer object is just created using new or after @B_android#media#MediaPlayer#reset_E@ is called, it is in the Idle state; and after @B_android#media#MediaPlayer#release_E@ is called, it is in the End state. Between these two states is the life cycle of the MediaPlayer object. There is a subtle but important difference between a newly constructed MediaPlayer object and the MediaPlayer object after @B_android#media#MediaPlayer#reset_E@ is called. It is a programming error to invoke methods such as @B_android#media#MediaPlayer#getCurrentPosition_E@, @B_android#media#MediaPlayer#getDuration_E@, @B_android#media#MediaPlayer#getVideoHeight_E@, @B_android#media#MediaPlayer#getVideoWidth_E@, @B_android#media#MediaPlayer#setAudioAttributes_E@, @B_android#media#MediaPlayer#setLooping_E@, @B_android#media#MediaPlayer#setVolume_E@, @B_android#media#MediaPlayer#pause_E@, @B_android#media#MediaPlayer#start_E@, @B_android#media#MediaPlayer#stop_E@, @B_android#media#MediaPlayer#seekTo_E@, @B_android#media#MediaPlayer#prepare_E@ or @B_android#media#MediaPlayer#prepareAsync_E@ in the Idle state for both cases. If any of these methods is called right after a MediaPlayer object is constructed, the user supplied callback method OnErrorListener.onError() won't be called by the internal player engine and the object state remains unchanged; but if these methods are called right after @B_android#media#MediaPlayer#reset_E@, the user supplied callback method OnErrorListener.onError() will be invoked by the internal player engine and the object will be transfered to the Error state. It is also recommended that once a MediaPlayer object is no longer being used, call @B_android#media#MediaPlayer#release_E@ immediately so that resources used by the internal player engine associated with the MediaPlayer object can be released immediately. Resource may include singleton resources such as hardware acceleration components and failure to call @B_android#media#MediaPlayer#release_E@ may cause subsequent instances of MediaPlayer objects to fallback to software implementations or fail altogether. Once the MediaPlayer object is in the End state, it can no longer be used and there is no way to bring it back to any other state. Furthermore, the MediaPlayer objects created using new is in the Idle state, while those created with one of the overloaded convenient create methods are NOT in the Idle state. In fact, the objects are in the Prepared state if the creation using create method is successful. In general, some playback control operation may fail due to various reasons, such as unsupported audio/video format, poorly interleaved audio/video, resolution too high, streaming timeout, and the like. Thus, error reporting and recovery is an important concern under these circumstances. Sometimes, due to programming errors, invoking a playback control operation in an invalid state may also occur. Under all these error conditions, the internal player engine invokes a user supplied OnErrorListener.onError() method if an OnErrorListener has been registered beforehand via @B_android#media#MediaPlayer#setOnErrorListener_E@. It is important to note that once an error occurs, the MediaPlayer object enters the Error state (except as noted above), even if an error listener has not been registered by the application. In order to reuse a MediaPlayer object that is in the Error state and recover from the error, @B_android#media#MediaPlayer#reset_E@ can be called to restore the object to its Idle state. It is good programming practice to have your application register a OnErrorListener to look out for error notifications from the internal player engine. IllegalStateException is thrown to prevent programming errors such as calling @B_android#media#MediaPlayer#prepare_E@, @B_android#media#MediaPlayer#prepareAsync_E@, or one of the overloaded setDataSource methods in an invalid state. Calling @B_android#media#MediaPlayer#setDataSource_E@, or @B_android#media#MediaPlayer#setDataSource_E@, or @B_android#media#MediaPlayer#setDataSource_E@, or @B_android#media#MediaPlayer#setDataSource_E@, or @B_android#media#MediaPlayer#setDataSource_E@ transfers a MediaPlayer object in the Idle state to the Initialized state. An IllegalStateException is thrown if setDataSource() is called in any other state. It is good programming practice to always look out for IllegalArgumentException and IOException that may be thrown from the overloaded setDataSource methods. A MediaPlayer object must first enter the Prepared state before playback can be started. There are two ways (synchronous vs. asynchronous) that the Prepared state can be reached: either a call to @B_android#media#MediaPlayer#prepare_E@ (synchronous) which transfers the object to the Prepared state once the method call returns, or a call to @B_android#media#MediaPlayer#prepareAsync_E@ (asynchronous) which first transfers the object to the Preparing state after the call returns (which occurs almost right away) while the internal player engine continues working on the rest of preparation work until the preparation work completes. When the preparation completes or when @B_android#media#MediaPlayer#prepare_E@ call returns, the internal player engine then calls a user supplied callback method, onPrepared() of the OnPreparedListener interface, if an OnPreparedListener is registered beforehand via @B_android#media#MediaPlayer#setOnPreparedListener_E@. It is important to note that the Preparing state is a transient state, and the behavior of calling any method with side effect while a MediaPlayer object is in the Preparing state is undefined. An IllegalStateException is thrown if @B_android#media#MediaPlayer#prepare_E@ or @B_android#media#MediaPlayer#prepareAsync_E@ is called in any other state. While in the Prepared state, properties such as audio/sound volume, screenOnWhilePlaying, looping can be adjusted by invoking the corresponding set methods. To start the playback, @B_android#media#MediaPlayer#start_E@ must be called. After @B_android#media#MediaPlayer#start_E@ returns successfully, the MediaPlayer object is in the Started state. @B_android#media#MediaPlayer#isPlaying_E@ can be called to test whether the MediaPlayer object is in the Started state. While in the Started state, the internal player engine calls a user supplied OnBufferingUpdateListener.onBufferingUpdate() callback method if a OnBufferingUpdateListener has been registered beforehand via @B_android#media#MediaPlayer#setOnBufferingUpdateListener_E@. This callback allows applications to keep track of the buffering status while streaming audio/video. Calling @B_android#media#MediaPlayer#start_E@ has not effect on a MediaPlayer object that is already in the Started state. Playback can be paused and stopped, and the current playback position can be adjusted. Playback can be paused via @B_android#media#MediaPlayer#pause_E@. When the call to @B_android#media#MediaPlayer#pause_E@ returns, the MediaPlayer object enters the Paused state. Note that the transition from the Started state to the Paused state and vice versa happens asynchronously in the player engine. It may take some time before the state is updated in calls to @B_android#media#MediaPlayer#isPlaying_E@, and it can be a number of seconds in the case of streamed content. Calling @B_android#media#MediaPlayer#start_E@ to resume playback for a paused MediaPlayer object, and the resumed playback position is the same as where it was paused. When the call to @B_android#media#MediaPlayer#start_E@ returns, the paused MediaPlayer object goes back to the Started state. Calling @B_android#media#MediaPlayer#pause_E@ has no effect on a MediaPlayer object that is already in the Paused state. Calling @B_android#media#MediaPlayer#stop_E@ stops playback and causes a MediaPlayer in the Started, Paused, Prepared or PlaybackCompleted state to enter the Stopped state. Once in the Stopped state, playback cannot be started until @B_android#media#MediaPlayer#prepare_E@ or @B_android#media#MediaPlayer#prepareAsync_E@ are called to set the MediaPlayer object to the Prepared state again. Calling @B_android#media#MediaPlayer#stop_E@ has no effect on a MediaPlayer object that is already in the Stopped state. The playback position can be adjusted with a call to @B_android#media#MediaPlayer#seekTo_E@. Although the asynchronuous @B_android#media#MediaPlayer#seekTo_E@ call returns right away, the actual seek operation may take a while to finish, especially for audio/video being streamed. When the actual seek operation completes, the internal player engine calls a user supplied OnSeekComplete.onSeekComplete() if an OnSeekCompleteListener has been registered beforehand via @B_android#media#MediaPlayer#setOnSeekCompleteListener_E@. Please note that @B_android#media#MediaPlayer#seekTo_E@ can also be called in the other states, such as Prepared, Paused and PlaybackCompleted state. When @B_android#media#MediaPlayer#seekTo_E@ is called in those states, one video frame will be displayed if the stream has video and the requested position is valid. Furthermore, the actual current playback position can be retrieved with a call to @B_android#media#MediaPlayer#getCurrentPosition_E@, which is helpful for applications such as a Music player that need to keep track of the playback progress. When the playback reaches the end of stream, the playback completes. If the looping mode was being set to @B_android#media#MediaPlayer#setLooping_E@, the MediaPlayer object shall remain in the Started state. If the looping mode was set to @B_android#media#MediaPlayer#setOnCompletionListener_E@. The invoke of the callback signals that the object is now in the PlaybackCompleted state. While in the PlaybackCompleted state, calling @B_android#media#MediaPlayer#start_E@ can restart the playback from the beginning of the audio/video source. One may need to declare a corresponding WAKE_LOCK permission @B_android#R#styleable#AndroidManifestUsesPermission_E@ element. This class requires the @B_android#Manifest#permission#INTERNET_E@ permission when used with network-based content. Applications may want to register for informational and error events in order to be informed of some internal state update and possible runtime errors during playback or streaming. Registration for these events is done by properly setting the appropriate listeners (via calls to @B_android#media#MediaPlayer#setOnPreparedListener_E@setOnPreparedListener, @B_android#media#MediaPlayer#setOnVideoSizeChangedListener_E@setOnVideoSizeChangedListener, @B_android#media#MediaPlayer#setOnSeekCompleteListener_E@setOnSeekCompleteListener, @B_android#media#MediaPlayer#setOnCompletionListener_E@setOnCompletionListener, @B_android#media#MediaPlayer#setOnBufferingUpdateListener_E@setOnBufferingUpdateListener, @B_android#media#MediaPlayer#setOnInfoListener_E@setOnInfoListener, @B_android#media#MediaPlayer#setOnErrorListener_E@setOnErrorListener, etc). In order to receive the respective callback associated with these listeners, applications are required to create MediaPlayer objects on a thread with its own Looper running (main UI thread by default has a Looper running)."}