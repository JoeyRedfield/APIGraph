{"Functions": {"connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback,int)": {"Returns": [["@B_android#bluetooth#BluetoothGatt_E@", "no returns description in source"]], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["boolean", "boolean: Whether to directly connect to the remote device (false) or to automatically connect as soon as the remote device becomes available (true)."], ["@B_android#bluetooth#BluetoothGattCallback_E@", "BluetoothGattCallback: GATT callback handler that will receive asynchronous callbacks."], ["int", "int: preferred transport for GATT connections to remote dual-mode devices @B_android#bluetooth#BluetoothDevice#TRANSPORT_AUTO_E@ or @B_android#bluetooth#BluetoothDevice#TRANSPORT_BREDR_E@ or @B_android#bluetooth#BluetoothDevice#TRANSPORT_LE_E@"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if callback is null"]], "SeeAlso": [], "Permissions": [], "Description": "Connect to GATT Server hosted by this device. Caller acts as GATT client. The callback is used to deliver results to Caller, such as connection status as well as any further GATT client operations. The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client operations.", "history": "Added in API level 23", "FullName": "public BluetoothGatt connectGatt (Context context, boolean autoConnect, BluetoothGattCallback callback, int transport)"}, "connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback,int,int,android.os.Handler)": {"Returns": [["@B_android#bluetooth#BluetoothGatt_E@", "no returns description in source"]], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["boolean", "boolean: Whether to directly connect to the remote device (false) or to automatically connect as soon as the remote device becomes available (true)."], ["@B_android#bluetooth#BluetoothGattCallback_E@", "BluetoothGattCallback: GATT callback handler that will receive asynchronous callbacks."], ["int", "int: preferred transport for GATT connections to remote dual-mode devices @B_android#bluetooth#BluetoothDevice#TRANSPORT_AUTO_E@ or @B_android#bluetooth#BluetoothDevice#TRANSPORT_BREDR_E@ or @B_android#bluetooth#BluetoothDevice#TRANSPORT_LE_E@"], ["int", "int: preferred PHY for connections to remote LE device. Bitwise OR of any of @B_android#bluetooth#BluetoothDevice#PHY_LE_1M_MASK_E@, @B_android#bluetooth#BluetoothDevice#PHY_LE_2M_MASK_E@, an d@B_android#bluetooth#BluetoothDevice#PHY_LE_CODED_MASK_E@. This option does not take effect if autoConnect is set to true."], ["@B_android#os#Handler_E@", "Handler: The handler to use for the callback. If null, callbacks will happen on an un-specified background thread."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if callback is null"]], "SeeAlso": [], "Permissions": [], "Description": "Connect to GATT Server hosted by this device. Caller acts as GATT client. The callback is used to deliver results to Caller, such as connection status as well as any further GATT client operations. The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client operations.", "history": "Added in API level 26", "FullName": "public BluetoothGatt connectGatt (Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy, Handler handler)"}, "createL2capChannel(int)": {"Returns": [["@B_android#bluetooth#BluetoothSocket_E@", "a CoC #BluetoothSocket ready for an outgoing connection This value will never be null."]], "Parameters": [["int", "int: dynamic PSM value from remote device"]], "Throws": [["@B_java#io#IOException_E@", "on error, for example Bluetooth not available, or insufficient permissions"]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Create a Bluetooth L2CAP Connection-oriented Channel (CoC) @B_android#bluetooth#BluetoothSocket_E@ that can be used to start a secure outgoing connection to the remote device with the same dynamic protocol/service multiplexer (PSM) value. The supported Bluetooth transport is LE only. This is designed to be used with @B_android#bluetooth#BluetoothAdapter#listenUsingL2capChannel_E@ for peer-peer Bluetooth applications. Use @B_android#bluetooth#BluetoothSocket#connect_E@ to initiate the outgoing connection. Application using this API is responsible for obtaining PSM value from remote device. The remote device will be authenticated and communication on this socket will be encrypted. Use this socket if an authenticated socket link is possible. Authentication refers to the authentication of the link key to prevent man-in-the-middle type of attacks. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 29", "FullName": "public BluetoothSocket createL2capChannel (int psm)"}, "describeContents()": {"Returns": [["int", "a bitmask indicating the set of special object types marshaled by this Parcelable object instance. Value is either 0 or @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Describe the kinds of special objects contained in this Parcelable instance's marshaled representation. For example, if the object will include a file descriptor in the output of @B_android#os#Parcelable#writeToParcel_E@, the return value of this method must include the @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@ bit.", "history": "Added in API level 5", "FullName": "public int describeContents ()"}, "getAddress()": {"Returns": [["@B_java#lang#String_E@", "Bluetooth hardware address as string"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the hardware address of this BluetoothDevice. For example, \"00:11:22:AA:BB:CC\".", "history": "Added in API level 5", "FullName": "public String getAddress ()"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if this object is the same as the obj argument; false otherwise."]], "Parameters": [["@B_java#lang#Object_E@", "Object: the reference object with which to compare."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether some other object is \"equal to\" this one. The equals method implements an equivalence relation on non-null object references: It is x, x.equals(x) should return true. It is x and y, x.equals(y) should return true if and only if y.equals(x) returns true. It is x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. It is x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. For any non-null reference value x, x.equals(null) should return false. The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true). Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.", "history": "Added in API level 5", "FullName": "public boolean equals (Object o)"}, "getUuids()": {"Returns": [["@B_android#os#ParcelUuid_E@", "the supported features (UUIDs) of the remote device, or null on error"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Returns the supported features (UUIDs) of the remote device. This method does not start a service discovery procedure to retrieve the UUIDs from the remote device. Instead, the local cached copy of the service UUIDs are returned. Use @B_android#bluetooth#BluetoothDevice#fetchUuidsWithSdp_E@ if fresh UUIDs are desired. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 15", "FullName": "public ParcelUuid[] getUuids ()"}, "createInsecureRfcommSocketToServiceRecord(java.util.UUID)": {"Returns": [["@B_android#bluetooth#BluetoothSocket_E@", "a RFCOMM BluetoothServerSocket ready for an outgoing connection"]], "Parameters": [["@B_java#util#UUID_E@", "UUID: service record uuid to lookup RFCOMM channel"]], "Throws": [["@B_java#io#IOException_E@", "on error, for example Bluetooth not available, or insufficient permissions"]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Create an RFCOMM @B_android#bluetooth#BluetoothSocket_E@ socket ready to start an insecure outgoing connection to this remote device using SDP lookup of uuid. The communication channel will not have an authenticated link key i.e it will be subject to man-in-the-middle attacks. For Bluetooth 2.1 devices, the link key will be encrypted, as encryption is mandatory. For legacy devices (pre Bluetooth 2.1 devices) the link key will be not be encrypted. Use @B_android#bluetooth#BluetoothDevice#createRfcommSocketToServiceRecord_E@ if an encrypted and authenticated communication channel is desired. This is designed to be used with @B_android#bluetooth#BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord_E@ for peer-peer Bluetooth applications. Use @B_android#bluetooth#BluetoothSocket#connect_E@ to initiate the outgoing connection. This will also perform an SDP lookup of the given uuid to determine which channel to connect to. The remote device will be authenticated and communication on this socket will be encrypted. Hint: If you are connecting to a Bluetooth serial board then try using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB. However if you are connecting to an Android peer then please generate your own unique UUID. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 10", "FullName": "public BluetoothSocket createInsecureRfcommSocketToServiceRecord (UUID uuid)"}, "fetchUuidsWithSdp()": {"Returns": [["boolean", "False if the sanity check fails, True if the process of initiating an ACL connection to the remote device was started."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Perform a service discovery on the remote device to get the UUIDs supported. This API is asynchronous and @B_android#bluetooth#BluetoothDevice#ACTION_UUID_E@ intent is sent, with the UUIDs supported by the remote end. If there is an error in getting the SDP records or if the process takes a long time, @B_android#bluetooth#BluetoothDevice#ACTION_UUID_E@ intent is sent with the UUIDs that is currently present in the cache. Clients should use the @B_android#bluetooth#BluetoothDevice#getUuids_E@ to get UUIDs if service discovery is not to be performed. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 15", "FullName": "public boolean fetchUuidsWithSdp ()"}, "setPairingConfirmation(boolean)": {"Returns": [["boolean", "true confirmation has been sent out false for error"]], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_PRIVILEGED_E@"], "Description": "Confirm passkey for @B_android#bluetooth#BluetoothDevice#PAIRING_VARIANT_PASSKEY_CONFIRMATION_E@ pairing. Requires @B_android#Manifest#permission#BLUETOOTH_PRIVILEGED_E@", "history": "Added in API level 19", "FullName": "public boolean setPairingConfirmation (boolean confirm)"}, "setPin(byte[])": {"Returns": [["boolean", "true pin has been set false for error"]], "Parameters": [["byte[]", "byte no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "Set the pin during pairing when the pairing method is @B_android#bluetooth#BluetoothDevice#PAIRING_VARIANT_PIN_E@ Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@.", "history": "Added in API level 19", "FullName": "public boolean setPin (byte[] pin)"}, "getName()": {"Returns": [["@B_java#lang#String_E@", "the Bluetooth name, or null if there was a problem."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Get the friendly Bluetooth name of the remote device. The local adapter will automatically retrieve remote names when performing a device scan, and will cache them. This method just returns the name for this device from the cache. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public String getName ()"}, "hashCode()": {"Returns": [["int", "a hash code value for this object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by @B_java#util#HashMap_E@. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the @B_java#lang#Object#equals_E@ method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java\u2122 programming language.)", "history": "Added in API level 5", "FullName": "public int hashCode ()"}, "getBondState()": {"Returns": [["int", "the bond state"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Get the bond state of the remote device. Possible values for the bond state are: @B_android#bluetooth#BluetoothDevice#BOND_NONE_E@, @B_android#bluetooth#BluetoothDevice#BOND_BONDING_E@, @B_android#bluetooth#BluetoothDevice#BOND_BONDED_E@. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public int getBondState ()"}, "createBond()": {"Returns": [["boolean", "false on immediate error, true if bonding will begin"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_ADMIN_E@"], "Description": "Start the bonding (pairing) process with the remote device. This is an asynchronous call, it will return immediately. Register for @B_android#bluetooth#BluetoothDevice#ACTION_BOND_STATE_CHANGED_E@ intents to be notified when the bonding process completes, and its result. Android system services will handle the necessary user interactions to confirm and complete the bonding process. Requires @B_android#Manifest#permission#BLUETOOTH_ADMIN_E@", "history": "Added in API level 19", "FullName": "public boolean createBond ()"}, "writeToParcel(android.os.Parcel, int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "added in API level 5", "FullName": "public void writeToParcel (Parcel out, int flags)"}, "connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback)": {"Returns": [["@B_android#bluetooth#BluetoothGatt_E@", "no returns description in source"]], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["boolean", "boolean: Whether to directly connect to the remote device (false) or to automatically connect as soon as the remote device becomes available (true)."], ["@B_android#bluetooth#BluetoothGattCallback_E@", "BluetoothGattCallback: GATT callback handler that will receive asynchronous callbacks."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if callback is null"]], "SeeAlso": [], "Permissions": [], "Description": "Connect to GATT Server hosted by this device. Caller acts as GATT client. The callback is used to deliver results to Caller, such as connection status as well as any further GATT client operations. The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client operations.", "history": "Added in API level 18", "FullName": "public BluetoothGatt connectGatt (Context context, boolean autoConnect, BluetoothGattCallback callback)"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "string representation of this BluetoothDevice"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of this BluetoothDevice. Currently this is the Bluetooth hardware address, for example \"00:11:22:AA:BB:CC\". However, you should always use @B_android#bluetooth#BluetoothDevice#getAddress_E@ if you explicitly require the Bluetooth hardware address in case the @B_android#bluetooth#BluetoothDevice#toString_E@ representation changes in the future.", "history": "Added in API level 5", "FullName": "public String toString ()"}, "getBluetoothClass()": {"Returns": [["@B_android#bluetooth#BluetoothClass_E@", "Bluetooth class object, or null on error"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Get the Bluetooth class of the remote device. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public BluetoothClass getBluetoothClass ()"}, "createRfcommSocketToServiceRecord(java.util.UUID)": {"Returns": [["@B_android#bluetooth#BluetoothSocket_E@", "a RFCOMM BluetoothServerSocket ready for an outgoing connection"]], "Parameters": [["@B_java#util#UUID_E@", "UUID: service record uuid to lookup RFCOMM channel"]], "Throws": [["@B_java#io#IOException_E@", "on error, for example Bluetooth not available, or insufficient permissions"]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Create an RFCOMM @B_android#bluetooth#BluetoothSocket_E@ ready to start a secure outgoing connection to this remote device using SDP lookup of uuid. This is designed to be used with @B_android#bluetooth#BluetoothAdapter#listenUsingRfcommWithServiceRecord_E@ for peer-peer Bluetooth applications. Use @B_android#bluetooth#BluetoothSocket#connect_E@ to initiate the outgoing connection. This will also perform an SDP lookup of the given uuid to determine which channel to connect to. The remote device will be authenticated and communication on this socket will be encrypted. Use this socket only if an authenticated socket link is possible. Authentication refers to the authentication of the link key to prevent man-in-the-middle type of attacks. For example, for Bluetooth 2.1 devices, if any of the devices does not have an input and output capability or just has the ability to display a numeric key, a secure socket connection is not possible. In such a case, use @B_android#bluetooth#BluetoothDevice#createInsecureRfcommSocketToServiceRecord_E@. For more details, refer to the Security Model section 5.2 (vol 3) of Bluetooth Core Specification version 2.1 + EDR. Hint: If you are connecting to a Bluetooth serial board then try using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB. However if you are connecting to an Android peer then please generate your own unique UUID. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 5", "FullName": "public BluetoothSocket createRfcommSocketToServiceRecord (UUID uuid)"}, "getType()": {"Returns": [["int", "the device type @B_android#bluetooth#BluetoothDevice#DEVICE_TYPE_CLASSIC_E@, @B_android#bluetooth#BluetoothDevice#DEVICE_TYPE_LE_E@ @B_android#bluetooth#BluetoothDevice#DEVICE_TYPE_DUAL_E@. @B_android#bluetooth#BluetoothDevice#DEVICE_TYPE_UNKNOWN_E@ if it's not available"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Get the Bluetooth device type of the remote device. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 18", "FullName": "public int getType ()"}, "createInsecureL2capChannel(int)": {"Returns": [["@B_android#bluetooth#BluetoothSocket_E@", "a CoC #BluetoothSocket ready for an outgoing connection This value will never be null."]], "Parameters": [["int", "int: dynamic PSM value from remote device"]], "Throws": [["@B_java#io#IOException_E@", "on error, for example Bluetooth not available, or insufficient permissions"]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#BLUETOOTH_E@"], "Description": "Create a Bluetooth L2CAP Connection-oriented Channel (CoC) @B_android#bluetooth#BluetoothSocket_E@ that can be used to start a secure outgoing connection to the remote device with the same dynamic protocol/service multiplexer (PSM) value. The supported Bluetooth transport is LE only. This is designed to be used with @B_android#bluetooth#BluetoothAdapter#listenUsingInsecureL2capChannel_E@ for peer-peer Bluetooth applications. Use @B_android#bluetooth#BluetoothSocket#connect_E@ to initiate the outgoing connection. Application using this API is responsible for obtaining PSM value from remote device. The communication channel may not have an authenticated link key, i.e. it may be subject to man-in-the-middle attacks. Use @B_android#bluetooth#BluetoothDevice#createL2capChannel_E@ if an encrypted and authenticated communication channel is possible. Requires @B_android#Manifest#permission#BLUETOOTH_E@", "history": "Added in API level 29", "FullName": "public BluetoothSocket createInsecureL2capChannel (int psm)"}, "writeToParcel(android.os.Parcel,int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@. Value is either 0 or a combination of @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "Added in API level 5", "FullName": "public void writeToParcel (Parcel out, int flags)"}, "connectGatt(android.content.Context,boolean,android.bluetooth.BluetoothGattCallback,int,int)": {"Returns": [["@B_android#bluetooth#BluetoothGatt_E@", "no returns description in source"]], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["boolean", "boolean: Whether to directly connect to the remote device (false) or to automatically connect as soon as the remote device becomes available (true)."], ["@B_android#bluetooth#BluetoothGattCallback_E@", "BluetoothGattCallback: GATT callback handler that will receive asynchronous callbacks."], ["int", "int: preferred transport for GATT connections to remote dual-mode devices @B_android#bluetooth#BluetoothDevice#TRANSPORT_AUTO_E@ or @B_android#bluetooth#BluetoothDevice#TRANSPORT_BREDR_E@ or @B_android#bluetooth#BluetoothDevice#TRANSPORT_LE_E@"], ["int", "int: preferred PHY for connections to remote LE device. Bitwise OR of any of @B_android#bluetooth#BluetoothDevice#PHY_LE_1M_MASK_E@, @B_android#bluetooth#BluetoothDevice#PHY_LE_2M_MASK_E@, and @B_android#bluetooth#BluetoothDevice#PHY_LE_CODED_MASK_E@. This option does not take effect if autoConnect is set to true."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if callback is null"]], "SeeAlso": [], "Permissions": [], "Description": "Connect to GATT Server hosted by this device. Caller acts as GATT client. The callback is used to deliver results to Caller, such as connection status as well as any further GATT client operations. The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct GATT client operations.", "history": "Added in API level 26", "FullName": "public BluetoothGatt connectGatt (Context context, boolean autoConnect, BluetoothGattCallback callback, int transport, int phy)"}}, "Inheritance": [], "ClassName": "android.bluetooth.BluetoothDevice", "ClassDesc": "Represents a remote Bluetooth device. A @B_android#bluetooth#BluetoothDevice_E@ lets you create a connection with the respective device or query information about it, such as the name, address, class, and bonding state. This class is really just a thin wrapper for a Bluetooth hardware address. Objects of this class are immutable. Operations on this class are performed on the remote Bluetooth hardware address, using the @B_android#bluetooth#BluetoothAdapter_E@ that was used to create this @B_android#bluetooth#BluetoothDevice_E@. To get a @B_android#bluetooth#BluetoothDevice_E@, use @B_android#bluetooth#BluetoothAdapter#getRemoteDevice_E@ to create one representing a device of a known MAC address (which you can get through device discovery with @B_android#bluetooth#BluetoothAdapter_E@) or get one from the set of bonded devices returned by @B_android#bluetooth#BluetoothAdapter#getBondedDevices_E@. You can then open a @B_android#bluetooth#BluetoothSocket_E@ for communication with the remote device, using @B_android#bluetooth#BluetoothDevice#createRfcommSocketToServiceRecord_E@ over Bluetooth BR/EDR or using @B_android#bluetooth#BluetoothDevice#createL2capChannel_E@ over Bluetooth LE. @B_android#Manifest#permission#BLUETOOTH_E@ permission."}