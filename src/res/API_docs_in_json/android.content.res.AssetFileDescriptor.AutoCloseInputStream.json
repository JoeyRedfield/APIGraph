{"Functions": {"available()": {"Returns": [["int", "an estimate of the number of remaining bytes that can be read (or skipped over) from this input stream without blocking."]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Returns an estimate of the number of remaining bytes that can be read (or skipped over) from this input stream without blocking by the next invocation of a method for this input stream. Returns 0 when the file position is beyond EOF. The next invocation might be the same thread or another thread. A single read or skip of this many bytes will not block, but may read or skip fewer bytes. In some cases, a non-blocking read (or skip) may appear to be blocked when it is merely slow, for example when reading large files over slow networks.", "history": "Added in API level 3", "FullName": "public int available ()"}, "read(byte[])": {"Returns": [["int", "the total number of bytes read into the buffer, or -1 if there is no more data because the end of the file has been reached."]], "Parameters": [["byte[]", "byte: the buffer into which the data is read."]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Reads up to b.length bytes of data from this input stream into an array of bytes. This method blocks until some input is available.", "history": "Added in API level 3", "FullName": "public int read (byte[] buffer)"}, "reset()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Repositions this stream to the position at the time the mark method was last called on this input stream. The general contract of reset is: If the method markSupported returns true, then: If the method mark has not been called since the stream was created, or the number of bytes read from the stream since mark was last called is larger than the argument to mark at that last call, then an IOException might be thrown. If such an IOException is not thrown, then the stream is reset to a state such that all the bytes read since the most recent call to mark (or since the start of the file, if mark has not been called) will be resupplied to subsequent callers of the read method, followed by any bytes that otherwise would have been the next input data as of the time of the call to reset. If the method markSupported returns false, then: The call to reset may throw an IOException. If an IOException is not thrown, then the stream is reset to a fixed state that depends on the particular type of the input stream and how it was created. The bytes that will be supplied to subsequent callers of the read method depend on the particular type of the input stream. The method reset for class InputStream does nothing except throw an IOException.", "history": "Added in API level 3", "FullName": "public void reset ()"}, "read(byte[],int,int)": {"Returns": [["int", "the total number of bytes read into the buffer, or -1 if there is no more data because the end of the file has been reached."]], "Parameters": [["byte[]", "byte: the buffer into which the data is read."], ["int", "int: the start offset in the destination array b"], ["int", "int: the maximum number of bytes read."]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Reads up to len bytes of data from this input stream into an array of bytes. If len is not zero, the method blocks until some input is available; otherwise, no bytes are read and 0 is returned.", "history": "Added in API level 3", "FullName": "public int read (byte[] buffer, int offset, int count)"}, "read(byte[], int, int)": {"Returns": [["int", "the total number of bytes read into the buffer, or -1 if there is no more data because the end of the file has been reached."]], "Parameters": [["byte[]", "byte: the buffer into which the data is read."], ["int", "int: the start offset in the destination array b"], ["int", "int: the maximum number of bytes read."]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Reads up to len bytes of data from this input stream into an array of bytes. If len is not zero, the method blocks until some input is available; otherwise, no bytes are read and 0 is returned.", "history": "added in API level 3", "FullName": "public int read (byte[] buffer, int offset, int count)"}, "markSupported()": {"Returns": [["boolean", "true if this stream instance supports the mark and reset methods; false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tests if this input stream supports the mark and reset methods. Whether or not mark and reset are supported is an invariant property of a particular input stream instance. The markSupported method of InputStream returns false.", "history": "Added in API level 3", "FullName": "public boolean markSupported ()"}, "read()": {"Returns": [["int", "the next byte of data, or -1 if the end of the file is reached."]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Reads a byte of data from this input stream. This method blocks if no input is yet available.", "history": "Added in API level 3", "FullName": "public int read ()"}, "skip(long)": {"Returns": [["long", "the actual number of bytes skipped."]], "Parameters": [["long", "long: the number of bytes to be skipped."]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Skips over and discards n bytes of data from the input stream. The skip method may, for a variety of reasons, end up skipping over some smaller number of bytes, possibly 0. If n is negative, the method will try to skip backwards. In case the backing file does not support backward skip at its current position, an IOException is thrown. The actual number of bytes skipped is returned. If it skips forwards, it returns a positive value. If it skips backwards, it returns a negative value. This method may skip more bytes than what are remaining in the backing file. This produces no exception and the number of bytes skipped may include some number of bytes that were beyond the EOF of the backing file. Attempting to read from the stream after skipping past the end will result in -1 indicating the end of the file.", "history": "Added in API level 3", "FullName": "public long skip (long count)"}, "AssetFileDescriptor.AutoCloseInputStream(android.content.res.AssetFileDescriptor)": {"Returns": [], "Parameters": [["@B_android#content#res#AssetFileDescriptor_E@", "AssetFileDescriptor no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 3", "FullName": "public AssetFileDescriptor.AutoCloseInputStream (AssetFileDescriptor fd)"}, "mark(int)": {"Returns": [], "Parameters": [["int", "int: the maximum limit of bytes that can be read before the mark position becomes invalid."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Marks the current position in this input stream. A subsequent call to the reset method repositions this stream at the last marked position so that subsequent reads re-read the same bytes. The readlimit arguments tells this input stream to allow that many bytes to be read before the mark position gets invalidated. The general contract of mark is that, if the method markSupported returns true, the stream somehow remembers all the bytes read after the call to mark and stands ready to supply those same bytes again if and whenever the method reset is called. However, the stream is not required to remember any data at all if more than readlimit bytes are read from the stream before reset is called. Marking a closed stream should not have any effect on the stream. The mark method of InputStream does nothing.", "history": "Added in API level 3", "FullName": "public void mark (int readlimit)"}}, "Inheritance": ["@B_java#io#InputStream_E@", "@B_java#io#FileInputStream_E@", "@B_android#os#ParcelFileDescriptor#AutoCloseInputStream_E@"], "ClassName": "android.content.res.AssetFileDescriptor.AutoCloseInputStream", "ClassDesc": "An InputStream you can create on a ParcelFileDescriptor, which will take care of calling @B_android#os#ParcelFileDescriptor#close_E@ for you when the stream is closed."}