{"Functions": {"isReleasable()": {"Returns": [["boolean", "true if blocking is unnecessary"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if blocking is unnecessary.", "history": "Added in API level 21", "FullName": "public abstract boolean isReleasable ()"}, "block()": {"Returns": [["boolean", "true if no additional blocking is necessary (i.e., if isReleasable would return true)"]], "Parameters": [], "Throws": [["@B_java#lang#InterruptedException_E@", "if interrupted while waiting (the method is not required to do so, but is allowed to)"]], "SeeAlso": [], "Permissions": [], "Description": "Possibly blocks the current thread, for example waiting for a lock or condition.", "history": "Added in API level 21", "FullName": "public abstract boolean block ()"}}, "Inheritance": [], "ClassName": "java.util.concurrent.ForkJoinPool.ManagedBlocker", "ClassDesc": "Interface for extending managed parallelism for tasks running in @B_java#util#concurrent#ForkJoinPool_E@s. A ManagedBlocker provides two methods. Method @B_java#util#concurrent#ForkJoinPool#ManagedBlocker#isReleasable_E@ must return true if blocking is not necessary. Method @B_java#util#concurrent#ForkJoinPool#ManagedBlocker#block_E@ blocks the current thread if necessary (perhaps internally invoking isReleasable before actually blocking). These actions are performed by any thread invoking @B_java#util#concurrent#ForkJoinPool#managedBlock_E@. The unusual methods in this API accommodate synchronizers that may, but don't usually, block for long periods. Similarly, they allow more efficient internal handling of cases in which additional workers may be, but usually are not, needed to ensure sufficient parallelism. Toward this end, implementations of method isReleasable must be amenable to repeated invocation. For example, here is a ManagedBlocker based on a ReentrantLock: Here is a class that possibly blocks waiting for an item on a given queue:"}