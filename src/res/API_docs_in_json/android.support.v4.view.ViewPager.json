{"Functions": {"executeKeyEvent(android.view.KeyEvent)": {"Returns": [["boolean", "Return true if the event was handled, else false."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to execute."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.", "history": "added in version 22.0.0", "FullName": "boolean executeKeyEvent (KeyEvent event)"}, "getOffscreenPageLimit()": {"Returns": [["int", "How many pages will be kept offscreen on either side"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v4#view#ViewPager#setOffscreenPageLimit_E@"], "Permissions": [], "Description": "Returns the number of pages that will be retained to either side of the current page in the view hierarchy in an idle state. Defaults to 1.", "history": "added in version 22.0.0", "FullName": "int getOffscreenPageLimit ()"}, "draw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: The Canvas to which the View is rendered."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Manually render this view (and all of its children) to the given Canvas. The view must have already done a full layout before this function is called. When implementing a view, implement @B_android#view#View#onDraw_E@ instead of overriding this method. If you do need to override this method, call the superclass version.", "history": "", "FullName": "void draw (Canvas canvas)"}, "computeScroll()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary. This will typically be done if the child is animating a scroll using a @B_android#widget#Scroller_E@ object.", "history": "", "FullName": "void computeScroll ()"}, "getCurrentItem()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "int getCurrentItem ()"}, "onSizeChanged(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: Current width of this view."], ["int", "int: Current height of this view."], ["int", "int: Old width of this view."], ["int", "int: Old height of this view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0.", "history": "", "FullName": "void onSizeChanged (int w, int h, int oldw, int oldh)"}, "canScrollHorizontally(int)": {"Returns": [["boolean", "Whether this ViewPager can be scrolled in the specified direction. It will always return false if the specified direction is 0."]], "Parameters": [["int", "int: Negative to check scrolling left, positive to check scrolling right."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if this ViewPager can be scrolled horizontally in a certain direction.", "history": "", "FullName": "boolean canScrollHorizontally (int direction)"}, "dispatchKeyEvent(android.view.KeyEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a key event to the next view on the focus path. This path runs from the top of the view tree down to the currently focused view. If this view has focus, it will dispatch to itself. Otherwise it will dispatch the next node down the focus path. This method also fires any key listeners.", "history": "", "FullName": "boolean dispatchKeyEvent (KeyEvent event)"}, "onPageScrolled(int, float, int)": {"Returns": [], "Parameters": [["int", "int: Position index of the first page currently being displayed. Page position+1 will be visible if positionOffset is nonzero."], ["float", "float: Value from [0, 1) indicating the offset from the page at position."], ["int", "int: Value in pixels indicating the offset from position."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method will be invoked when the current page is scrolled, either as part of a programmatically initiated smooth scroll or a user initiated touch scroll. If you override this method you must call through to the superclass implementation (e.g. super.onPageScrolled(position, offset, offsetPixels)) before onPageScrolled returns.", "history": "added in version 22.0.0", "FullName": "void onPageScrolled (int position, float offset, int offsetPixels)"}, "setAdapter(android.support.v4.view.PagerAdapter)": {"Returns": [], "Parameters": [["@B_android#support#v4#view#PagerAdapter_E@", "PagerAdapter: Adapter to use"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a PagerAdapter that will supply views for this pager as needed.", "history": "added in version 22.0.0", "FullName": "void setAdapter (PagerAdapter adapter)"}, "getAdapter()": {"Returns": [["@B_android#support#v4#view#PagerAdapter_E@", "The currently registered PagerAdapter"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the current adapter supplying pages.", "history": "added in version 22.0.0", "FullName": "PagerAdapter getAdapter ()"}, "isFakeDragging()": {"Returns": [["boolean", "true if currently in a fake drag, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v4#view#ViewPager#beginFakeDrag_E@", "@B_android#support#v4#view#ViewPager#fakeDragBy_E@", "@B_android#support#v4#view#ViewPager#endFakeDrag_E@"], "Permissions": [], "Description": "Returns true if a fake drag is in progress.", "history": "added in version 22.0.0", "FullName": "boolean isFakeDragging ()"}, "onInterceptTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true to steal motion events from the children and have them dispatched to this ViewGroup through onTouchEvent(). The current target will receive an ACTION_CANCEL event, and no further messages will be delivered here."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event being dispatched down the hierarchy."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to intercept all touch screen motion events. This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point. Using this function takes some care, as it has a fairly complicated interaction with @B_android#view#View#onTouchEvent_E@, and using it requires implementing that method as well as this one in the correct way. Events will be received in the following order:", "history": "", "FullName": "boolean onInterceptTouchEvent (MotionEvent ev)"}, "getPageMargin()": {"Returns": [["int", "The size of the margin in pixels"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the margin between pages.", "history": "added in version 22.0.0", "FullName": "int getPageMargin ()"}, "onMeasure(int, int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "", "FullName": "void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "onDetachedFromWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is detached from a window. At this point it no longer has a surface for drawing.", "history": "", "FullName": "void onDetachedFromWindow ()"}, "beginFakeDrag()": {"Returns": [["boolean", "true if the fake drag began successfully, false if it could not be started."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v4#view#ViewPager#fakeDragBy_E@", "@B_android#support#v4#view#ViewPager#endFakeDrag_E@"], "Permissions": [], "Description": "Start a fake drag of the pager. A fake drag can be useful if you want to synchronize the motion of the ViewPager with the touch scrolling of another view, while still letting the ViewPager control the snapping motion and fling behavior. (e.g. parallax-scrolling tabs.) Call @B_android#support#v4#view#ViewPager#fakeDragBy_E@ to simulate the actual drag motion. Call @B_android#support#v4#view#ViewPager#endFakeDrag_E@ to complete the fake drag and fling as necessary. During a fake drag the ViewPager will ignore all touch events. If a real drag is already in progress, this method will return false.", "history": "added in version 22.0.0", "FullName": "boolean beginFakeDrag ()"}, "ViewPager(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "ViewPager (Context context)"}, "arrowScroll(int)": {"Returns": [["boolean", "Whether the scrolling was handled successfully."]], "Parameters": [["int", "int: The direction corresponding to the arrow key that was pressed. It should be either @B_android#view#View#FOCUS_LEFT_E@ or @B_android#view#View#FOCUS_RIGHT_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handle scrolling in response to a left or right arrow click.", "history": "added in version 22.0.0", "FullName": "boolean arrowScroll (int direction)"}, "verifyDrawable(android.graphics.drawable.Drawable)": {"Returns": [["boolean", "boolean If true than the Drawable is being displayed in the view; else false and it is not allowed to animate."]], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: The Drawable to verify. Return true if it is one you are displaying, else return the result of calling through to the super class."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying. This allows animations for those drawables to be scheduled. Be sure to call through to the super class when overriding this function.", "history": "", "FullName": "boolean verifyDrawable (Drawable who)"}, "setCurrentItem(int, boolean)": {"Returns": [], "Parameters": [["int", "int: Item index to select"], ["boolean", "boolean: True to smoothly scroll to the new item, false to transition immediately"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the currently selected page.", "history": "added in version 22.0.0", "FullName": "void setCurrentItem (int item, boolean smoothScroll)"}, "setOffscreenPageLimit(int)": {"Returns": [], "Parameters": [["int", "int: How many pages will be kept offscreen in an idle state."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the number of pages that should be retained to either side of the current page in the view hierarchy in an idle state. Pages beyond this limit will be recreated from the adapter when needed. This is offered as an optimization. If you know in advance the number of pages you will need to support or have lazy-loading mechanisms in place on your pages, tweaking this setting can have benefits in perceived smoothness of paging animations and interaction. If you have a small number of pages (3-4) that you can keep active all at once, less time will be spent in layout for newly created view subtrees as the user pages back and forth. You should keep this limit low, especially if your pages have complex layouts. This setting defaults to 1.", "history": "added in version 22.0.0", "FullName": "void setOffscreenPageLimit (int limit)"}, "onRestoreInstanceState(android.os.Parcelable)": {"Returns": [], "Parameters": [["@B_android#os#Parcelable_E@", "Parcelable: The frozen state that had previously been returned by @B_android#support#v4#view#ViewPager#onSaveInstanceState_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to re-apply a representation of its internal state that had previously been generated by @B_android#view#View#onSaveInstanceState_E@. This function will never be called with a null state.", "history": "added in version 22.0.0", "FullName": "void onRestoreInstanceState (Parcelable state)"}, "drawableStateChanged()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown. If the View has a StateListAnimator, it will also be called to run necessary state change animations. Be sure to call through to the superclass when overriding this function.", "history": "", "FullName": "void drawableStateChanged ()"}, "onSaveInstanceState()": {"Returns": [["@B_android#os#Parcelable_E@", "Returns a Parcelable object containing the view's current dynamic state, or null if there is nothing interesting to save."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view.", "history": "added in version 22.0.0", "FullName": "Parcelable onSaveInstanceState ()"}, "onLayout(boolean, int, int, int, int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "added in version 22.0.0", "FullName": "void onLayout (boolean changed, int l, int t, int r, int b)"}, "getChildDrawingOrder(int, int)": {"Returns": [["int", "The index of the child to draw this iteration."]], "Parameters": [["int", "int no parameter comment"], ["int", "int: The current iteration."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the index of the child to draw for this iteration. Override this if you want to change the drawing order of children. By default, it returns i. NOTE: In order for this method to be called, you must enable child ordering first by calling @B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@.", "history": "", "FullName": "int getChildDrawingOrder (int childCount, int i)"}, "onAttachedToWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before @B_android#view#View#onDraw_E@, however it may be called any time before the first onDraw -- including before or after @B_android#view#View#onMeasure_E@.", "history": "", "FullName": "void onAttachedToWindow ()"}, "onTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle touch screen motion events. If this method is used to detect click actions, it is recommended that the actions be performed by implementing and calling @B_android#view#View#performClick_E@. This will ensure consistent system behavior, including: obeying click sound preferences dispatching OnClickListener calls handling @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_CLICK_E@ when accessibility features are enabled", "history": "", "FullName": "boolean onTouchEvent (MotionEvent ev)"}, "setPageMarginDrawable(int)": {"Returns": [], "Parameters": [["int", "int: Resource ID of a drawable to display between pages"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a drawable that will be used to fill the margin between pages.", "history": "added in version 22.0.0", "FullName": "void setPageMarginDrawable (int resId)"}, "setCurrentItem(int)": {"Returns": [], "Parameters": [["int", "int: Item index to select"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the currently selected page. If the ViewPager has already been through its first layout with its current adapter there will be a smooth animated transition between the current item and the specified item.", "history": "added in version 22.0.0", "FullName": "void setCurrentItem (int item)"}, "removeView(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "@B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "", "FullName": "void removeView (View view)"}, "generateLayoutParams(android.util.AttributeSet)": {"Returns": [["@B_android#view#ViewGroup#LayoutParams_E@", "an instance of @B_android#view#ViewGroup#LayoutParams_E@ or one of its descendants"]], "Parameters": [["@B_android#util#AttributeSet_E@", "AttributeSet: the attributes to build the layout parameters from"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a new set of layout parameters based on the supplied attributes set.", "history": "", "FullName": "ViewGroup.LayoutParams generateLayoutParams (AttributeSet attrs)"}, "generateDefaultLayoutParams()": {"Returns": [["@B_android#view#ViewGroup#LayoutParams_E@", "a set of default layout parameters or null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a set of default layout parameters. These parameters are requested when the View passed to @B_android#view#ViewGroup#addView_E@ has no layout parameters already set. If null is returned, an exception is thrown from addView.", "history": "", "FullName": "ViewGroup.LayoutParams generateDefaultLayoutParams ()"}, "endFakeDrag()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v4#view#ViewPager#beginFakeDrag_E@", "@B_android#support#v4#view#ViewPager#fakeDragBy_E@"], "Permissions": [], "Description": "End a fake drag of the pager.", "history": "added in version 22.0.0", "FullName": "void endFakeDrag ()"}, "clearOnPageChangeListeners()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove all listeners that are notified of any changes in scroll state or position.", "history": "added in version 22.2.0", "FullName": "void clearOnPageChangeListeners ()"}, "fakeDragBy(float)": {"Returns": [], "Parameters": [["float", "float: Offset in pixels to drag by."]], "Throws": [], "SeeAlso": ["@B_android#support#v4#view#ViewPager#beginFakeDrag_E@", "@B_android#support#v4#view#ViewPager#endFakeDrag_E@"], "Permissions": [], "Description": "Fake drag by an offset in pixels. You must have called @B_android#support#v4#view#ViewPager#beginFakeDrag_E@ first.", "history": "added in version 22.0.0", "FullName": "void fakeDragBy (float xOffset)"}, "onDraw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: the canvas on which the background will be drawn"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to do your drawing.", "history": "", "FullName": "void onDraw (Canvas canvas)"}, "setPageMargin(int)": {"Returns": [], "Parameters": [["int", "int: Distance between adjacent pages in pixels"]], "Throws": [], "SeeAlso": ["@B_android#support#v4#view#ViewPager#getPageMargin_E@", "@B_android#support#v4#view#ViewPager#setPageMarginDrawable_E@"], "Permissions": [], "Description": "Set the margin between pages.", "history": "added in version 22.0.0", "FullName": "void setPageMargin (int marginPixels)"}}, "Inheritance": ["java.lang.Object", "https:##developer#android#com@B_android#view#View_E@", "https:##developer#android#com@B_android#view#ViewGroup_E@"], "ClassName": "android.support.v4.view.ViewPager", "ClassDesc": "Layout manager that allows the user to flip left and right through pages of data. You supply an implementation of a @B_android#support#v4#view#PagerAdapter_E@ to generate the pages that the view shows. ViewPager is most often used in conjunction with https:##developer#android#com@B_android#app#Fragment_E@, which is a convenient way to supply and manage the lifecycle of each page. There are standard adapters implemented for using fragments with the ViewPager, which cover the most common use cases. These are @B_android#support#v4#app#FragmentPagerAdapter_E@ and @B_android#support#v4#app#FragmentStatePagerAdapter_E@; each of these classes have simple code showing how to build a full user interface with them. Views which are annotated with the @B_android#support#v4#view#ViewPager#DecorView_E@ annotation are treated as part of the view pagers 'decor'. Each decor view's position can be controlled via its android:layout_gravity attribute. For example: For more information about how to use ViewPager, read You can find examples of using ViewPager in the API 4+ Support Demos and API 13+ Support Demos sample code."}