{"Functions": {"setVolume(float)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["float", "float: output gain for all channels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the specified output gain value on all channels of this track. Gain values are clamped to the closed interval [0.0, max] where max is the value of @B_android#media#AudioTrack#getMaxVolume_E@. A value of 0.0 results in zero gain (silence), and a value of 1.0 means unity gain (signal unchanged). The default value is 1.0 meaning unity gain. This API is preferred over @B_android#media#AudioTrack#setStereoVolume_E@, as it more gracefully scales down to mono, and up to multi-channel content beyond stereo. The word \"volume\" in the API name is historical; this is actually a linear gain.", "history": "Added in API level 21", "FullName": "public int setVolume (float gain)"}, "setPositionNotificationPeriod(int)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["int", "int: update period expressed in frames. Zero period means no position updates. A negative period is not allowed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the period for the periodic notification event.", "history": "Added in API level 3", "FullName": "public int setPositionNotificationPeriod (int periodInFrames)"}, "setBufferSizeInFrames(int)": {"Returns": [["int", "the actual buffer size in frames or an error code, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["int", "int: requested buffer size in frames Value is 0 or greater"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if track is not initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Limits the effective size of the AudioTrack buffer that the application writes to. A write to this AudioTrack will not fill the buffer beyond this limit. If a blocking write is used then the write will block until the data can fit within this limit. Changing this limit modifies the latency associated with the buffer for this track. A smaller size will give lower latency but there may be more glitches due to buffer underruns. The actual size used may not be equal to this requested size. It will be limited to a valid range with a maximum of @B_android#media#AudioTrack#getBufferCapacityInFrames_E@. It may also be adjusted slightly for internal reasons. If bufferSizeInFrames is less than zero then @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@ will be returned. This method is only supported for PCM audio. It is not supported for compressed audio tracks.", "history": "Added in API level 24", "FullName": "public int setBufferSizeInFrames (int bufferSizeInFrames)"}, "getAudioAttributes()": {"Returns": [["@B_android#media#AudioAttributes_E@", "The AudioAttributes used to configure the AudioTrack. This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "If the track is not initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the @B_android#media#AudioAttributes_E@ used in configuration. If a streamType is used instead of an AudioAttributes to configure the AudioTrack (the use of streamType for configuration is deprecated), then the AudioAttributes equivalent to the streamType is returned.", "history": "Added in API level 29", "FullName": "public AudioAttributes getAudioAttributes ()"}, "setLoopPoints(int, int, int)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["int", "int: loop start marker expressed in frames. Zero corresponds to start of buffer. The start marker must not be greater than or equal to the buffer size in frames, or negative."], ["int", "int: loop end marker expressed in frames. The total buffer size in frames corresponds to end of buffer. The end marker must not be greater than the buffer size in frames. For looping, the end marker must not be less than or equal to the start marker, but to disable looping it is permitted for start marker, end marker, and loop count to all be 0. If any input parameters are out of range, this method returns @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@. If the loop period (endInFrames - startInFrames) is too small for the implementation to support, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@ is returned. The loop range is the interval [startInFrames, endInFrames). As of @B_android#os#Build#VERSION_CODES#M_E@, the position is left unchanged, unless it is greater than or equal to the loop end marker, in which case it is forced to the loop start marker. For earlier API levels, the effect on position is unspecified."], ["int", "int: the number of times the loop is looped; must be greater than or equal to -1. A value of -1 means infinite looping, and 0 disables looping. A value of positive N means to \"loop\" (go back) N times. For example, a value of one means to play the region two times in total."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the loop points and the loop count. The loop can be infinite. Similarly to setPlaybackHeadPosition, the track must be stopped or paused for the loop points to be changed, and must use the @B_android#media#AudioTrack#MODE_STATIC_E@ mode.", "history": "added in API level 3", "FullName": "public int setLoopPoints (int startInFrames, int endInFrames, int loopCount)"}, "stop()": {"Returns": [], "Parameters": [], "Throws": [["", "java.lang.IllegalStateException"], ["@B_java#lang#IllegalStateException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Stops playing the audio data. When used on an instance created in @B_android#media#AudioTrack#MODE_STREAM_E@ mode, audio will stop playing after the last buffer that was written has been played. For an immediate stop, use @B_android#media#AudioTrack#pause_E@, followed by @B_android#media#AudioTrack#flush_E@ to discard audio data that hasn't been played back yet.", "history": "Added in API level 3", "FullName": "public void stop ()"}, "pause()": {"Returns": [], "Parameters": [], "Throws": [["", "java.lang.IllegalStateException"], ["@B_java#lang#IllegalStateException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Pauses the playback of the audio data. Data that has not been played back will not be discarded. Subsequent calls to @B_android#media#AudioTrack#play_E@ will play this data back. See @B_android#media#AudioTrack#flush_E@ to discard this data.", "history": "Added in API level 3", "FullName": "public void pause ()"}, "getBufferCapacityInFrames()": {"Returns": [["int", "maximum size in frames of the AudioTrack buffer. Value is 0 or greater"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if track is not initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the maximum size of the AudioTrack buffer in frames. If the track's creation mode is @B_android#media#AudioTrack#MODE_STATIC_E@, it is equal to the specified bufferSizeInBytes on construction, converted to frame units. A static track's frame count will not change. If the track's creation mode is @B_android#media#AudioTrack#MODE_STREAM_E@, it is greater than or equal to the specified bufferSizeInBytes converted to frame units. For streaming tracks, this value may be rounded up to a larger value if needed by the target output sink, and if the track is subsequently routed to a different output sink, the frame count may enlarge to accommodate. If the AudioTrack encoding indicates compressed data, e.g. @B_android#media#AudioFormat#ENCODING_AC3_E@, then the frame count returned is the size of the AudioTrack buffer in bytes. See also @B_android#media#AudioManager#getProperty_E@ for key @B_android#media#AudioManager#PROPERTY_OUTPUT_FRAMES_PER_BUFFER_E@.", "history": "Added in API level 24", "FullName": "public int getBufferCapacityInFrames ()"}, "setPlaybackHeadPosition(int)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["int", "int: playback head position within buffer, expressed in frames. Zero corresponds to start of buffer. The position must not be greater than the buffer size in frames, or negative. Though this method and @B_android#media#AudioTrack#getPlaybackHeadPosition_E@ have similar names, the position values have different meanings. If looping is currently enabled and the new position is greater than or equal to the loop end marker, the behavior varies by API level: as of @B_android#os#Build#VERSION_CODES#M_E@, the looping is first disabled and then the position is set. For earlier API levels, the behavior is unspecified. Value is 0 or greater"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the playback head position within the static buffer. The track must be stopped or paused for the position to be changed, and must use the @B_android#media#AudioTrack#MODE_STATIC_E@ mode.", "history": "Added in API level 3", "FullName": "public int setPlaybackHeadPosition (int positionInFrames)"}, "removeOnRoutingChangedListener(android.media.AudioTrack.OnRoutingChangedListener)": {"Returns": [], "Parameters": [["@B_android#media#AudioTrack#OnRoutingChangedListener_E@", "AudioTrack.OnRoutingChangedListener: The previously added @B_android#media#AudioTrack#OnRoutingChangedListener_E@ interface to remove."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "users should switch to the general purpose @B_android#media#AudioRouting#OnRoutingChangedListener_E@ class instead. Removes an @B_android#media#AudioTrack#OnRoutingChangedListener_E@ which has been previously added to receive rerouting notifications.", "history": "Added in API level 23 Deprecated in API level 24", "FullName": "public void removeOnRoutingChangedListener (AudioTrack.OnRoutingChangedListener listener)"}, "getAudioFormat()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured audio data encoding. See @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@.", "history": "Added in API level 3", "FullName": "public int getAudioFormat ()"}, "setPlaybackPositionUpdateListener(android.media.AudioTrack.OnPlaybackPositionUpdateListener)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the listener the AudioTrack notifies when a previously set marker is reached or for each periodic playback head position update. Notifications will be received in the same thread as the one in which the AudioTrack instance was created.", "history": "Added in API level 3", "FullName": "public void setPlaybackPositionUpdateListener (AudioTrack.OnPlaybackPositionUpdateListener listener)"}, "release()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Releases the native AudioTrack resources.", "history": "Added in API level 3", "FullName": "public void release ()"}, "getMinBufferSize(int, int, int)": {"Returns": [["int", "@B_android#media#AudioTrack#ERROR_BAD_VALUE_E@ if an invalid parameter was passed, or @B_android#media#AudioTrack#ERROR_E@ if unable to query for output properties, or the minimum buffer size expressed in bytes."]], "Parameters": [["int", "int: the source sample rate expressed in Hz. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ is not permitted."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_OUT_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_OUT_STEREO_E@"], ["int", "int: the format in which the audio data is represented. See @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ and @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the estimated minimum buffer size required for an AudioTrack object to be created in the @B_android#media#AudioTrack#MODE_STREAM_E@ mode. The size is an estimate because it does not consider either the route or the sink, since neither is known yet. Note that this size doesn't guarantee a smooth playback under load, and higher values should be chosen according to the expected frequency at which the buffer will be refilled with additional data to play. For example, if you intend to dynamically set the source sample rate of an AudioTrack to a higher value than the initial source sample rate, be sure to configure the buffer size based on the highest planned sample rate.", "history": "added in API level 3", "FullName": "public static int getMinBufferSize (int sampleRateInHz, int channelConfig, int audioFormat)"}, "getAudioSessionId()": {"Returns": [["int", "the ID of the audio session this AudioTrack belongs to."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the audio session ID.", "history": "Added in API level 9", "FullName": "public int getAudioSessionId ()"}, "getPlaybackHeadPosition()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the playback head position expressed in frames. Though the \"int\" type is signed 32-bits, the value should be reinterpreted as if it is unsigned 32-bits. That is, the next position after 0x7FFFFFFF is (int) 0x80000000. This is a continuously advancing counter. It will wrap (overflow) periodically, for example approximately once every 27:03:11 hours:minutes:seconds at 44.1 kHz. It is reset to zero by @B_android#media#AudioTrack#flush_E@, @B_android#media#AudioTrack#reloadStaticData_E@, and @B_android#media#AudioTrack#stop_E@. If the track's creation mode is @B_android#media#AudioTrack#MODE_STATIC_E@, the return value indicates the total number of frames played since reset,", "history": "Added in API level 3", "FullName": "public int getPlaybackHeadPosition ()"}, "write(byte[],int,int)": {"Returns": [["int", "zero or the positive number of bytes that were written, or one of the following error codes. The number of bytes will be a multiple of the frame size in bytes not to exceed sizeInBytes. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error This is equivalent to @B_android#media#AudioTrack#write_E@ with writeMode set to @B_android#media#AudioTrack#WRITE_BLOCKING_E@."]], "Parameters": [["byte[]", "byte: the array that holds the data to play. This value must never be null."], ["int", "int: the offset expressed in bytes in audioData where the data to write starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of bytes to write in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@ to correspond to the data in the array. The format can be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, but this is deprecated. In streaming mode, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns.", "history": "Added in API level 3", "FullName": "public int write (byte[] audioData, int offsetInBytes, int sizeInBytes)"}, "AudioTrack(int, int, int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: the type of the audio stream. See @B_android#media#AudioManager#STREAM_VOICE_CALL_E@, @B_android#media#AudioManager#STREAM_SYSTEM_E@, @B_android#media#AudioManager#STREAM_RING_E@, @B_android#media#AudioManager#STREAM_MUSIC_E@, @B_android#media#AudioManager#STREAM_ALARM_E@, and @B_android#media#AudioManager#STREAM_NOTIFICATION_E@."], ["int", "int: the initial source sample rate expressed in Hz. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ means to use a route-dependent value which is usually the sample rate of the sink. @B_android#media#AudioTrack#getSampleRate_E@ can be used to retrieve the actual sample rate chosen."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_OUT_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_OUT_STEREO_E@"], ["int", "int: the format in which the audio data is represented. See @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@."], ["int", "int: the total size (in bytes) of the internal buffer where audio data is read from for playback. This should be a nonzero multiple of the frame size in bytes. If the track's creation mode is MODE_STATIC, this is the maximum length sample, or audio clip, that can be played by this instance. If the track's creation mode is MODE_STREAM, this should be the desired buffer size for the AudioTrack to satisfy the application's latency requirements. If bufferSizeInBytes is less than the minimum buffer size for the output sink, it is increased to the minimum buffer size. The method getBufferSizeInFrames() returns the actual size in frames of the buffer created, which determines the minimum frequency to write to the streaming AudioTrack to avoid underrun. See getMinBufferSize(int, int, int) to determine the estimated minimum buffer size for an AudioTrack instance in streaming mode."], ["int", "int: streaming or static buffer. See @B_android#media#AudioTrack#MODE_STATIC_E@ and @B_android#media#AudioTrack#MODE_STREAM_E@"]], "Throws": [["", "java.lang.IllegalArgumentException"], ["@B_java#lang#IllegalArgumentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#media#AudioTrack#Builder_E@ or @B_android#media#AudioTrack#AudioTrack_E@ to specify the @B_android#media#AudioAttributes_E@ instead of the stream type which is only for volume control. Class constructor.", "history": "added in API level 3", "FullName": "public AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode)"}, "write(short[],int,int,int)": {"Returns": [["int", "zero or the positive number of shorts that were written, or one of the following error codes. The number of shorts will be a multiple of the channel count not to exceed sizeInShorts. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["short[]", "short: the array that holds the data to write. This value must never be null."], ["int", "int: the offset expressed in shorts in audioData where the data to write starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of shorts to read in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. It has no effect in static mode. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking. Value is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, or @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ to correspond to the data in the array. In streaming mode, the blocking behavior depends on the write mode. If the write mode is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the write mode is @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, or the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns.", "history": "Added in API level 23", "FullName": "public int write (short[] audioData, int offsetInShorts, int sizeInShorts, int writeMode)"}, "addOnRoutingChangedListener(android.media.AudioTrack.OnRoutingChangedListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#AudioTrack#OnRoutingChangedListener_E@", "AudioTrack.OnRoutingChangedListener: The @B_android#media#AudioTrack#OnRoutingChangedListener_E@ interface to receive notifications of rerouting events."], ["@B_android#os#Handler_E@", "Handler: Specifies the @B_android#os#Handler_E@ object for the thread on which to execute the callback. If null, the @B_android#os#Handler_E@ associated with the main @B_android#os#Looper_E@ will be used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "users should switch to the general purpose @B_android#media#AudioRouting#OnRoutingChangedListener_E@ class instead. Adds an @B_android#media#AudioTrack#OnRoutingChangedListener_E@ to receive notifications of routing changes on this AudioTrack.", "history": "Added in API level 23 Deprecated in API level 24", "FullName": "public void addOnRoutingChangedListener (AudioTrack.OnRoutingChangedListener listener, Handler handler)"}, "AudioTrack(int,int,int,int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: the type of the audio stream. See @B_android#media#AudioManager#STREAM_VOICE_CALL_E@, @B_android#media#AudioManager#STREAM_SYSTEM_E@, @B_android#media#AudioManager#STREAM_RING_E@, @B_android#media#AudioManager#STREAM_MUSIC_E@, @B_android#media#AudioManager#STREAM_ALARM_E@, and @B_android#media#AudioManager#STREAM_NOTIFICATION_E@."], ["int", "int: the initial source sample rate expressed in Hz. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ means to use a route-dependent value which is usually the sample rate of the sink."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_OUT_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_OUT_STEREO_E@"], ["int", "int: the format in which the audio data is represented. See @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ and @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@."], ["int", "int: the total size (in bytes) of the internal buffer where audio data is read from for playback. This should be a nonzero multiple of the frame size in bytes. If the track's creation mode is MODE_STATIC, this is the maximum length sample, or audio clip, that can be played by this instance. If the track's creation mode is MODE_STREAM, this should be the desired buffer size for the AudioTrack to satisfy the application's latency requirements. If bufferSizeInBytes is less than the minimum buffer size for the output sink, it is increased to the minimum buffer size. The method getBufferSizeInFrames() returns the actual size in frames of the buffer created, which determines the minimum frequency to write to the streaming AudioTrack to avoid underrun. You can write data into this buffer in smaller chunks than this size. See getMinBufferSize(int, int, int) to determine the estimated minimum buffer size for an AudioTrack instance in streaming mode."], ["int", "int: streaming or static buffer. See @B_android#media#AudioTrack#MODE_STATIC_E@ and @B_android#media#AudioTrack#MODE_STREAM_E@"], ["int", "int: Id of audio session the AudioTrack must be attached to"]], "Throws": [["", "java.lang.IllegalArgumentException"], ["@B_java#lang#IllegalArgumentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#media#AudioTrack#Builder_E@ or @B_android#media#AudioTrack#AudioTrack_E@ to specify the @B_android#media#AudioAttributes_E@ instead of the stream type which is only for volume control. Class constructor with audio session. Use this constructor when the AudioTrack must be attached to a particular audio session. The primary use of the audio session ID is to associate audio effects to a particular instance of AudioTrack: if an audio session ID is provided when creating an AudioEffect, this effect will be applied only to audio tracks and media players in the same session and not to the output mix. When an AudioTrack is created without specifying a session, it will create its own session which can be retrieved by calling the @B_android#media#AudioTrack#getAudioSessionId_E@ method. If a non-zero session ID is provided, this AudioTrack will share effects attached to this session with all other media players or audio tracks in the same session, otherwise a new session will be created for this track if none is supplied.", "history": "Added in API level 9", "FullName": "public AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode, int sessionId)"}, "isOffloadedPlayback()": {"Returns": [["boolean", "true if the track is using offloaded playback."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether the track was built with @B_android#media#AudioTrack#Builder#setOffloadedPlayback_E@ set to true.", "history": "Added in API level 29", "FullName": "public boolean isOffloadedPlayback ()"}, "setNotificationMarkerPosition(int)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["int", "int: marker position in wrapping frame units similar to @B_android#media#AudioTrack#getPlaybackHeadPosition_E@, or zero to disable the marker. To set a marker at a position which would appear as zero due to wraparound, a workaround is to use a non-zero position near zero, such as -1 or 1."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the position of the notification marker. At most one marker can be active.", "history": "Added in API level 3", "FullName": "public int setNotificationMarkerPosition (int markerInFrames)"}, "getNativeFrameCount()": {"Returns": [["int", "current size in frames of the AudioTrack buffer."]], "Parameters": [], "Throws": [["", "java.lang.IllegalStateException"]], "SeeAlso": [], "Permissions": [], "Description": "Use the identical public method @B_android#media#AudioTrack#getBufferSizeInFrames_E@ instead. Returns the frame count of the native AudioTrack buffer.", "history": "Added in API level 3 Deprecated in API level 19", "FullName": "protected int getNativeFrameCount ()"}, "setLoopPoints(int,int,int)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["int", "int: loop start marker expressed in frames. Zero corresponds to start of buffer. The start marker must not be greater than or equal to the buffer size in frames, or negative. Value is 0 or greater"], ["int", "int: loop end marker expressed in frames. The total buffer size in frames corresponds to end of buffer. The end marker must not be greater than the buffer size in frames. For looping, the end marker must not be less than or equal to the start marker, but to disable looping it is permitted for start marker, end marker, and loop count to all be 0. If any input parameters are out of range, this method returns @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@. If the loop period (endInFrames - startInFrames) is too small for the implementation to support, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@ is returned. The loop range is the interval [startInFrames, endInFrames). As of @B_android#os#Build#VERSION_CODES#M_E@, the position is left unchanged, unless it is greater than or equal to the loop end marker, in which case it is forced to the loop start marker. For earlier API levels, the effect on position is unspecified. Value is 0 or greater"], ["int", "int: the number of times the loop is looped; must be greater than or equal to -1. A value of -1 means infinite looping, and 0 disables looping. A value of positive N means to \"loop\" (go back) N times. For example, a value of one means to play the region two times in total. Value is -1 or greater"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the loop points and the loop count. The loop can be infinite. Similarly to setPlaybackHeadPosition, the track must be stopped or paused for the loop points to be changed, and must use the @B_android#media#AudioTrack#MODE_STATIC_E@ mode.", "history": "Added in API level 3", "FullName": "public int setLoopPoints (int startInFrames, int endInFrames, int loopCount)"}, "isDirectPlaybackSupported(android.media.AudioFormat,android.media.AudioAttributes)": {"Returns": [["boolean", "true if the given audio format can be played directly."]], "Parameters": [["@B_android#media#AudioFormat_E@", "AudioFormat: a non-null @B_android#media#AudioFormat_E@ instance describing the format of the audio data. This value must never be null."], ["@B_android#media#AudioAttributes_E@", "AudioAttributes: a non-null @B_android#media#AudioAttributes_E@ instance. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether direct playback of an audio format with the provided attributes is currently supported on the system. Direct playback means that the audio stream is not resampled or downmixed by the framework. Checking for direct support can help the app select the representation of audio content that most closely matches the capabilities of the device and peripherials (e.g. A/V receiver) connected to it. Note that the provided stream can still be re-encoded or mixed with other streams, if needed. Also note that this query only provides information about the support of an audio format. It does not indicate whether the resources necessary for the playback are available at that instant.", "history": "Added in API level 29", "FullName": "public static boolean isDirectPlaybackSupported (AudioFormat format, AudioAttributes attributes)"}, "baseRegisterPlayer()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call from derived class when instantiation / initialization is successful", "history": "", "FullName": "protected void baseRegisterPlayer ()"}, "write(short[], int, int, int)": {"Returns": [["int", "zero or the positive number of shorts that were written, or one of the following error codes. The number of shorts will be a multiple of the channel count not to exceed sizeInShorts. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["short[]", "short: the array that holds the data to write.This value must never be null."], ["int", "int: the offset expressed in shorts in audioData where the data to write starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of shorts to read in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. It has no effect in static mode. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ to correspond to the data in the array. In streaming mode, the blocking behavior depends on the write mode. If the write mode is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the write mode is @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, or the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns.", "history": "added in API level 23", "FullName": "public int write (short[] audioData, int offsetInShorts, int sizeInShorts, int writeMode)"}, "getPlaybackParams()": {"Returns": [["@B_android#media#PlaybackParams_E@", "current @B_android#media#PlaybackParams_E@. This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if track is not initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the current playback parameters. See @B_android#media#AudioTrack#setPlaybackParams_E@ to set playback parameters", "history": "Added in API level 23", "FullName": "public PlaybackParams getPlaybackParams ()"}, "getNotificationMarkerPosition()": {"Returns": [["int", "marker position in wrapping frame units similar to @B_android#media#AudioTrack#getPlaybackHeadPosition_E@, or zero if marker is disabled."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns marker position expressed in frames.", "history": "Added in API level 3", "FullName": "public int getNotificationMarkerPosition ()"}, "write(java.nio.ByteBuffer, int, int, long)": {"Returns": [["int", "zero or the positive number of bytes that were written, or one of the following error codes. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the buffer that holds the data to write, starting at the position reported by audioData.position(). Note that upon return, the buffer position (audioData.position()) will have been advanced to reflect the amount of data that was successfully written to the AudioTrack.This value must never be null."], ["int", "int: number of bytes to write. It is recommended but not enforced that the number of bytes requested be a multiple of the frame size (sample size in bytes multiplied by the channel count). Note this may differ from audioData.remaining(), but cannot exceed it."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking."], ["long", "long: The timestamp of the first decodable audio frame in the provided audioData."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback in streaming mode on a HW_AV_SYNC track. The blocking behavior will depend on the write mode.", "history": "added in API level 23", "FullName": "public int write (ByteBuffer audioData, int sizeInBytes, int writeMode, long timestamp)"}, "write(byte[], int, int, int)": {"Returns": [["int", "zero or the positive number of bytes that were written, or one of the following error codes. The number of bytes will be a multiple of the frame size in bytes not to exceed sizeInBytes. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["byte[]", "byte: the array that holds the data to play.This value must never be null."], ["int", "int: the offset expressed in bytes in audioData where the data to write starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of bytes to write in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. It has no effect in static mode. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@ to correspond to the data in the array. The format can be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, but this is deprecated. In streaming mode, the blocking behavior depends on the write mode. If the write mode is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the write mode is @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, or the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0, and the write mode is ignored. Note that the actual playback of this data might occur after this function returns.", "history": "added in API level 23", "FullName": "public int write (byte[] audioData, int offsetInBytes, int sizeInBytes, int writeMode)"}, "write(float[], int, int, int)": {"Returns": [["int", "zero or the positive number of floats that were written, or one of the following error codes. The number of floats will be a multiple of the channel count not to exceed sizeInFloats. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["float[]", "float: the array that holds the data to write. The implementation does not clip for sample values within the nominal range [-1.0f, 1.0f], provided that all gains in the audio pipeline are less than or equal to unity (1.0f), and in the absence of post-processing effects that could add energy, such as reverb. For the convenience of applications that compute samples using filters with non-unity gain, sample values +3 dB beyond the nominal range are permitted. However such values may eventually be limited or clipped, depending on various gains and later processing in the audio path. Therefore applications are encouraged to provide samples values within the nominal range.This value must never be null."], ["int", "int: the offset, expressed as a number of floats, in audioData where the data to write starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of floats to write in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. It has no effect in static mode. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@ to correspond to the data in the array. In streaming mode, the blocking behavior depends on the write mode. If the write mode is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the write mode is @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, or the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0, and the write mode is ignored. Note that the actual playback of this data might occur after this function returns.", "history": "added in API level 21", "FullName": "public int write (float[] audioData, int offsetInFloats, int sizeInFloats, int writeMode)"}, "write(byte[],int,int,int)": {"Returns": [["int", "zero or the positive number of bytes that were written, or one of the following error codes. The number of bytes will be a multiple of the frame size in bytes not to exceed sizeInBytes. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["byte[]", "byte: the array that holds the data to play. This value must never be null."], ["int", "int: the offset expressed in bytes in audioData where the data to write starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of bytes to write in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. It has no effect in static mode. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking. Value is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, or @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@ to correspond to the data in the array. The format can be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, but this is deprecated. In streaming mode, the blocking behavior depends on the write mode. If the write mode is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the write mode is @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, or the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0, and the write mode is ignored. Note that the actual playback of this data might occur after this function returns.", "history": "Added in API level 23", "FullName": "public int write (byte[] audioData, int offsetInBytes, int sizeInBytes, int writeMode)"}, "getStartDelayMs()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "protected int getStartDelayMs ()"}, "getPreferredDevice()": {"Returns": [["@B_android#media#AudioDeviceInfo_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the selected output specified by @B_android#media#AudioTrack#setPreferredDevice_E@. Note that this is not guaranteed to correspond to the actual device being used for playback.", "history": "Added in API level 23", "FullName": "public AudioDeviceInfo getPreferredDevice ()"}, "getChannelConfiguration()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured channel position mask. For example, refer to @B_android#media#AudioFormat#CHANNEL_OUT_MONO_E@, @B_android#media#AudioFormat#CHANNEL_OUT_STEREO_E@, @B_android#media#AudioFormat#CHANNEL_OUT_5POINT1_E@. This method may return @B_android#media#AudioFormat#CHANNEL_INVALID_E@ if a channel index mask was used. Consider @B_android#media#AudioTrack#getFormat_E@ instead, to obtain an @B_android#media#AudioFormat_E@, which contains both the channel position mask and the channel index mask.", "history": "Added in API level 3", "FullName": "public int getChannelConfiguration ()"}, "setAuxEffectSendLevel(float)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@, @B_android#media#AudioTrack#ERROR_E@"]], "Parameters": [["float", "float: linear send level Value is 0.0 or greater"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the send level of the audio track to the attached auxiliary effect @B_android#media#AudioTrack#attachAuxEffect_E@. Effect levels are clamped to the closed interval [0.0, max] where max is the value of @B_android#media#AudioTrack#getMaxVolume_E@. A value of 0.0 results in no effect, and a value of 1.0 is full send. By default the send level is 0.0f, so even if an effect is attached to the player this method must be called for the effect to be applied. Note that the passed level value is a linear scalar. UI controls should be scaled logarithmically: the gain applied by audio framework ranges from -72dB to at least 0dB, so an appropriate conversion from linear UI input x to level is: x == 0 -> level = 0 0 < x <= R -> level = 10^(72*(x-R)/20/R)", "history": "Added in API level 9", "FullName": "public int setAuxEffectSendLevel (float level)"}, "getMinVolume()": {"Returns": [["float", "the minimum value, which is the constant 0.0."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the minimum gain value, which is the constant 0.0. Gain values less than 0.0 will be clamped to 0.0. The word \"volume\" in the API name is historical; this is actually a linear gain.", "history": "Added in API level 3", "FullName": "public static float getMinVolume ()"}, "setPlaybackPositionUpdateListener(android.media.AudioTrack.OnPlaybackPositionUpdateListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#os#Handler_E@", "Handler: the Handler that will receive the event notification messages."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the listener the AudioTrack notifies when a previously set marker is reached or for each periodic playback head position update. Use this method to receive AudioTrack events in the Handler associated with another thread than the one in which you created the AudioTrack instance.", "history": "Added in API level 3", "FullName": "public void setPlaybackPositionUpdateListener (AudioTrack.OnPlaybackPositionUpdateListener listener, Handler handler)"}, "setStereoVolume(float,float)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["float", "float: output gain for the left channel."], ["float", "float: output gain for the right channel"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Applications should use @B_android#media#AudioTrack#setVolume_E@ instead, as it more gracefully scales down to mono, and up to multi-channel content beyond stereo. Sets the specified left and right output gain values on the AudioTrack. Gain values are clamped to the closed interval [0.0, max] where max is the value of @B_android#media#AudioTrack#getMaxVolume_E@. A value of 0.0 results in zero gain (silence), and a value of 1.0 means unity gain (signal unchanged). The default value is 1.0 meaning unity gain. The word \"volume\" in the API name is historical; this is actually a linear gain.", "history": "Added in API level 3 Deprecated in API level 21", "FullName": "public int setStereoVolume (float leftGain, float rightGain)"}, "getUnderrunCount()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the number of underrun occurrences in the application-level write buffer since the AudioTrack was created. An underrun occurs if the application does not write audio data quickly enough, causing the buffer to underflow and a potential audio glitch or pop. Underruns are less likely when buffer sizes are large. It may be possible to eliminate underruns by recreating the AudioTrack with a larger buffer. Or by using @B_android#media#AudioTrack#setBufferSizeInFrames_E@ to dynamically increase the effective size of the buffer.", "history": "Added in API level 24", "FullName": "public int getUnderrunCount ()"}, "write(java.nio.ByteBuffer,int,int,long)": {"Returns": [["int", "zero or the positive number of bytes that were written, or one of the following error codes. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the buffer that holds the data to write, starting at the position reported by audioData.position(). Note that upon return, the buffer position (audioData.position()) will have been advanced to reflect the amount of data that was successfully written to the AudioTrack. This value must never be null."], ["int", "int: number of bytes to write. It is recommended but not enforced that the number of bytes requested be a multiple of the frame size (sample size in bytes multiplied by the channel count). Note this may differ from audioData.remaining(), but cannot exceed it."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking. Value is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, or @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@"], ["long", "long: The timestamp, in nanoseconds, of the first decodable audio frame in the provided audioData."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback in streaming mode on a HW_AV_SYNC track. The blocking behavior will depend on the write mode.", "history": "Added in API level 23", "FullName": "public int write (ByteBuffer audioData, int sizeInBytes, int writeMode, long timestamp)"}, "getPerformanceMode()": {"Returns": [["int", "one of @B_android#media#AudioTrack#PERFORMANCE_MODE_NONE_E@, @B_android#media#AudioTrack#PERFORMANCE_MODE_LOW_LATENCY_E@, or @B_android#media#AudioTrack#PERFORMANCE_MODE_POWER_SAVING_E@. Use @B_android#media#AudioTrack#Builder#setPerformanceMode_E@ in the @B_android#media#AudioTrack#Builder_E@ to enable a performance mode. Value is @B_android#media#AudioTrack#PERFORMANCE_MODE_NONE_E@, @B_android#media#AudioTrack#PERFORMANCE_MODE_LOW_LATENCY_E@, or @B_android#media#AudioTrack#PERFORMANCE_MODE_POWER_SAVING_E@"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if track is not initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the current performance mode of the @B_android#media#AudioTrack_E@.", "history": "Added in API level 26", "FullName": "public int getPerformanceMode ()"}, "removeOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener)": {"Returns": [], "Parameters": [["@B_android#media#AudioRouting#OnRoutingChangedListener_E@", "AudioRouting.OnRoutingChangedListener: The previously added @B_android#media#AudioRouting#OnRoutingChangedListener_E@ interface to remove."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes an @B_android#media#AudioRouting#OnRoutingChangedListener_E@ which has been previously added to receive rerouting notifications.", "history": "Added in API level 24", "FullName": "public void removeOnRoutingChangedListener (AudioRouting.OnRoutingChangedListener listener)"}, "getNativeOutputSampleRate(int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the output sample rate in Hz for the specified stream type.", "history": "Added in API level 3", "FullName": "public static int getNativeOutputSampleRate (int streamType)"}, "getBufferSizeInFrames()": {"Returns": [["int", "current size in frames of the AudioTrack buffer. Value is 0 or greater"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if track is not initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the effective size of the AudioTrack buffer that the application writes to. This will be less than or equal to the result of @B_android#media#AudioTrack#getBufferCapacityInFrames_E@. It will be equal if @B_android#media#AudioTrack#setBufferSizeInFrames_E@ has never been called. If the track is subsequently routed to a different output sink, the buffer size and capacity may enlarge to accommodate. If the AudioTrack encoding indicates compressed data, e.g. @B_android#media#AudioFormat#ENCODING_AC3_E@, then the frame count returned is the size of the AudioTrack buffer in bytes. See also @B_android#media#AudioManager#getProperty_E@ for key @B_android#media#AudioManager#PROPERTY_OUTPUT_FRAMES_PER_BUFFER_E@.", "history": "Added in API level 23", "FullName": "public int getBufferSizeInFrames ()"}, "getPlayState()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#AudioTrack_E@"], "Permissions": [], "Description": "Returns the playback state of the AudioTrack instance.", "history": "Added in API level 3", "FullName": "public int getPlayState ()"}, "getPositionNotificationPeriod()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the notification update period expressed in frames. Zero means that no position update notifications are being delivered.", "history": "Added in API level 3", "FullName": "public int getPositionNotificationPeriod ()"}, "createVolumeShaper(android.media.VolumeShaper.Configuration)": {"Returns": [["@B_android#media#VolumeShaper_E@", "This value will never be null."]], "Parameters": [["@B_android#media#VolumeShaper#Configuration_E@", "VolumeShaper.Configuration: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a @B_android#media#VolumeShaper_E@ object that can be used modify the volume envelope of the player or track.", "history": "Added in API level 26", "FullName": "public VolumeShaper createVolumeShaper (VolumeShaper.Configuration configuration)"}, "flush()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flushes the audio data currently queued for playback. Any data that has been written but not yet presented will be discarded. No-op if not stopped or paused, or if the track's creation mode is not @B_android#media#AudioTrack#MODE_STREAM_E@. Note that although data written but not yet presented is discarded, there is no guarantee that all of the buffer space formerly used by that data is available for a subsequent write. For example, a call to @B_android#media#AudioTrack#write_E@ with sizeInBytes less than or equal to the total buffer size may return a short actual transfer count.", "history": "Added in API level 3", "FullName": "public void flush ()"}, "getSampleRate()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured audio source sample rate in Hz. The initial source sample rate depends on the constructor parameters, but the source sample rate may change if @B_android#media#AudioTrack#setPlaybackRate_E@ is called. If the constructor had a specific sample rate, then the initial sink sample rate is that value. If the constructor had @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@, then the initial sink sample rate is a route-dependent default value based on the source [sic].", "history": "Added in API level 3", "FullName": "public int getSampleRate ()"}, "AudioTrack(android.media.AudioAttributes,android.media.AudioFormat,int,int,int)": {"Returns": [], "Parameters": [["@B_android#media#AudioAttributes_E@", "AudioAttributes: a non-null @B_android#media#AudioAttributes_E@ instance."], ["@B_android#media#AudioFormat_E@", "AudioFormat: a non-null @B_android#media#AudioFormat_E@ instance describing the format of the data that will be played through this AudioTrack. See @B_android#media#AudioFormat#Builder_E@ for configuring the audio format parameters such as encoding, channel mask and sample rate."], ["int", "int: the total size (in bytes) of the internal buffer where audio data is read from for playback. This should be a nonzero multiple of the frame size in bytes. If the track's creation mode is MODE_STATIC, this is the maximum length sample, or audio clip, that can be played by this instance. If the track's creation mode is MODE_STREAM, this should be the desired buffer size for the AudioTrack to satisfy the application's latency requirements. If bufferSizeInBytes is less than the minimum buffer size for the output sink, it is increased to the minimum buffer size. The method getBufferSizeInFrames() returns the actual size in frames of the buffer created, which determines the minimum frequency to write to the streaming AudioTrack to avoid underrun. See getMinBufferSize(int, int, int) to determine the estimated minimum buffer size for an AudioTrack instance in streaming mode."], ["int", "int: streaming or static buffer. See @B_android#media#AudioTrack#MODE_STATIC_E@ and @B_android#media#AudioTrack#MODE_STREAM_E@."], ["int", "int: ID of audio session the AudioTrack must be attached to, or @B_android#media#AudioManager#AUDIO_SESSION_ID_GENERATE_E@ if the session isn't known at construction time. See also @B_android#media#AudioManager#generateAudioSessionId_E@ to obtain a session ID before construction."]], "Throws": [["", "java.lang.IllegalArgumentException"], ["@B_java#lang#IllegalArgumentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Class constructor with @B_android#media#AudioAttributes_E@ and @B_android#media#AudioFormat_E@.", "history": "Added in API level 21", "FullName": "public AudioTrack (AudioAttributes attributes, AudioFormat format, int bufferSizeInBytes, int mode, int sessionId)"}, "reloadStaticData()": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the playback head position within the static buffer to zero, that is it rewinds to start of static buffer. The track must be stopped or paused, and the track's creation mode must be @B_android#media#AudioTrack#MODE_STATIC_E@. As of @B_android#os#Build#VERSION_CODES#M_E@, also resets the value returned by @B_android#media#AudioTrack#getPlaybackHeadPosition_E@ to zero. For earlier API levels, the reset behavior is unspecified. Use @B_android#media#AudioTrack#setPlaybackHeadPosition_E@ with a zero position if the reset of getPlaybackHeadPosition() is not needed.", "history": "Added in API level 3", "FullName": "public int reloadStaticData ()"}, "getRoutedDevice()": {"Returns": [["@B_android#media#AudioDeviceInfo_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns an @B_android#media#AudioDeviceInfo_E@ identifying the current routing of this AudioTrack. Note: The query is only valid if the AudioTrack is currently playing. If it is not, getRoutedDevice() will return null.", "history": "Added in API level 23", "FullName": "public AudioDeviceInfo getRoutedDevice ()"}, "setOffloadDelayPadding(int,int)": {"Returns": [], "Parameters": [["int", "int: number of frames to be ignored at the beginning of the stream. A value of 0 indicates no delay is to be applied. Value is 0 or greater"], ["int", "int: number of frames to be ignored at the end of the stream. A value of 0 of 0 indicates no padding is to be applied. Value is 0 or greater"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Configures the delay and padding values for the current compressed stream playing in offload mode. This can only be used on a track successfully initialized with @B_android#media#AudioTrack#Builder#setOffloadedPlayback_E@. The unit is frames, where a frame indicates the number of samples per channel, e.g. 100 frames for a stereo compressed stream corresponds to 200 decoded interleaved PCM samples.", "history": "Added in API level 29", "FullName": "public void setOffloadDelayPadding (int delayInFrames, int paddingInFrames)"}, "setPlaybackRate(int)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["int", "int: the sample rate expressed in Hz"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the playback sample rate for this track. This sets the sampling rate at which the audio data will be consumed and played back (as set by the sampleRateInHz parameter in the @B_android#media#AudioTrack#AudioTrack_E@ constructor), not the original sampling rate of the content. For example, setting it to half the sample rate of the content will cause the playback to last twice as long, but will also result in a pitch shift down by one octave. The valid sample rate range is from 1 Hz to twice the value returned by @B_android#media#AudioTrack#getNativeOutputSampleRate_E@. Use @B_android#media#AudioTrack#setPlaybackParams_E@ for speed control. This method may also be used to repurpose an existing AudioTrack for playback of content of differing sample rate, but with identical encoding and channel mask.", "history": "Added in API level 3", "FullName": "public int setPlaybackRate (int sampleRateInHz)"}, "setState(int)": {"Returns": [], "Parameters": [["int", "int: the state of the AudioTrack instance"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Only accessible by subclasses, which are not recommended for AudioTrack. Sets the initialization state of the instance. This method was originally intended to be used in an AudioTrack subclass constructor to set a subclass-specific post-initialization state. However, subclasses of AudioTrack are no longer recommended, so this method is obsolete.", "history": "Added in API level 3 Deprecated in API level 19", "FullName": "protected void setState (int state)"}, "write(java.nio.ByteBuffer,int,int)": {"Returns": [["int", "zero or the positive number of bytes that were written, or one of the following error codes. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the buffer that holds the data to write, starting at the position reported by audioData.position(). Note that upon return, the buffer position (audioData.position()) will have been advanced to reflect the amount of data that was successfully written to the AudioTrack. This value must never be null."], ["int", "int: number of bytes to write. It is recommended but not enforced that the number of bytes requested be a multiple of the frame size (sample size in bytes multiplied by the channel count). Note this may differ from audioData.remaining(), but cannot exceed it."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. It has no effect in static mode. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking. Value is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, or @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The audioData in ByteBuffer should match the format specified in the AudioTrack constructor. In streaming mode, the blocking behavior depends on the write mode. If the write mode is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the write mode is @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, or the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0, and the write mode is ignored. Note that the actual playback of this data might occur after this function returns.", "history": "Added in API level 21", "FullName": "public int write (ByteBuffer audioData, int sizeInBytes, int writeMode)"}, "getTimestamp(android.media.AudioTimestamp)": {"Returns": [["boolean", "true if a timestamp is available, or false if no timestamp is available. If a timestamp is available, the AudioTimestamp instance is filled in with a position in frame units, together with the estimated time when that frame was presented or is committed to be presented. In the case that no timestamp is available, any supplied instance is left unaltered. A timestamp may be temporarily unavailable while the audio clock is stabilizing, or during and immediately after a route change. A timestamp is permanently unavailable for a given route if the route does not support timestamps. In this case, the approximate frame position can be obtained using @B_android#media#AudioTrack#getPlaybackHeadPosition_E@. However, it may be useful to continue to query for timestamps occasionally, to recover after a route change."]], "Parameters": [["@B_android#media#AudioTimestamp_E@", "AudioTimestamp: a reference to a non-null AudioTimestamp instance allocated and owned by caller."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Poll for a timestamp on demand. If you need to track timestamps during initial warmup or after a routing or mode change, you should request a new timestamp periodically until the reported timestamps show that the frame position is advancing, or until it becomes clear that timestamps are unavailable for this route. After the clock is advancing at a stable rate, query for a new timestamp approximately once every 10 seconds to once per minute. Calling this method more often is inefficient. It is also counter-productive to call this method more often than recommended, because the short-term differences between successive timestamp reports are not meaningful. If you need a high-resolution mapping between frame position and presentation time, consider implementing that at application level, based on low-resolution timestamps. The audio data at the returned position may either already have been presented, or may have not yet been presented but is committed to be presented. It is not possible to request the time corresponding to a particular position, or to request the (fractional) position corresponding to a particular time. If you need such features, consider implementing them at application level.", "history": "Added in API level 19", "FullName": "public boolean getTimestamp (AudioTimestamp timestamp)"}, "setStereoVolume(float, float)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["float", "float: output gain for the left channel."], ["float", "float: output gain for the right channel"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Applications should use @B_android#media#AudioTrack#setVolume_E@ instead, as it more gracefully scales down to mono, and up to multi-channel content beyond stereo. Sets the specified left and right output gain values on the AudioTrack. Gain values are clamped to the closed interval [0.0, max] where max is the value of @B_android#media#AudioTrack#getMaxVolume_E@. A value of 0.0 results in zero gain (silence), and a value of 1.0 means unity gain (signal unchanged). The default value is 1.0 meaning unity gain. The word \"volume\" in the API name is historical; this is actually a linear gain.", "history": "added in API level 3", "FullName": "public int setStereoVolume (float leftGain, float rightGain)"}, "attachAuxEffect(int)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@"]], "Parameters": [["int", "int: system wide unique id of the effect to attach"]], "Throws": [], "SeeAlso": ["@B_android#media#AudioTrack#setAuxEffectSendLevel_E@"], "Permissions": [], "Description": "Attaches an auxiliary effect to the audio track. A typical auxiliary effect is a reverberation effect which can be applied on any sound source that directs a certain amount of its energy to this effect. This amount is defined by setAuxEffectSendLevel(). . After creating an auxiliary effect (e.g. @B_android#media#audiofx#EnvironmentalReverb_E@), retrieve its ID with @B_android#media#audiofx#AudioEffect#getId_E@ and use it when calling this method to attach the audio track to the effect. To detach the effect from the audio track, call this method with a null effect id.", "history": "Added in API level 9", "FullName": "public int attachAuxEffect (int effectId)"}, "getPlaybackRate()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current playback sample rate rate in Hz.", "history": "Added in API level 3", "FullName": "public int getPlaybackRate ()"}, "getMetrics()": {"Returns": [["@B_android#os#PersistableBundle_E@", "a @B_android#os#PersistableBundle_E@ containing the set of attributes and values available for the media being handled by this instance of AudioTrack The attributes are descibed in @B_android#media#AudioTrack#MetricsConstants_E@. Additional vendor-specific fields may also be present in the return value."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return Metrics data about the current AudioTrack instance.", "history": "Added in API level 28", "FullName": "public PersistableBundle getMetrics ()"}, "getFormat()": {"Returns": [["@B_android#media#AudioFormat_E@", "an @B_android#media#AudioFormat_E@ containing the AudioTrack parameters at the time of configuration. This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured AudioTrack format.", "history": "Added in API level 23", "FullName": "public AudioFormat getFormat ()"}, "getMinBufferSize(int,int,int)": {"Returns": [["int", "@B_android#media#AudioTrack#ERROR_BAD_VALUE_E@ if an invalid parameter was passed, or @B_android#media#AudioTrack#ERROR_E@ if unable to query for output properties, or the minimum buffer size expressed in bytes."]], "Parameters": [["int", "int: the source sample rate expressed in Hz. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ is not permitted."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_OUT_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_OUT_STEREO_E@"], ["int", "int: the format in which the audio data is represented. See @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ and @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the estimated minimum buffer size required for an AudioTrack object to be created in the @B_android#media#AudioTrack#MODE_STREAM_E@ mode. The size is an estimate because it does not consider either the route or the sink, since neither is known yet. Note that this size doesn't guarantee a smooth playback under load, and higher values should be chosen according to the expected frequency at which the buffer will be refilled with additional data to play. For example, if you intend to dynamically set the source sample rate of an AudioTrack to a higher value than the initial source sample rate, be sure to configure the buffer size based on the highest planned sample rate.", "history": "Added in API level 3", "FullName": "public static int getMinBufferSize (int sampleRateInHz, int channelConfig, int audioFormat)"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 3", "FullName": "protected void finalize ()"}, "getChannelCount()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the configured number of channels.", "history": "Added in API level 3", "FullName": "public int getChannelCount ()"}, "write(byte[], int, int)": {"Returns": [["int", "zero or the positive number of bytes that were written, or one of the following error codes. The number of bytes will be a multiple of the frame size in bytes not to exceed sizeInBytes. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error This is equivalent to @B_android#media#AudioTrack#write_E@ with writeMode set to @B_android#media#AudioTrack#WRITE_BLOCKING_E@."]], "Parameters": [["byte[]", "byte: the array that holds the data to play.This value must never be null."], ["int", "int: the offset expressed in bytes in audioData where the data to write starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of bytes to write in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@ to correspond to the data in the array. The format can be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, but this is deprecated. In streaming mode, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns.", "history": "added in API level 3", "FullName": "public int write (byte[] audioData, int offsetInBytes, int sizeInBytes)"}, "setPresentation(android.media.AudioPresentation)": {"Returns": [["int", "error code or success, see @B_android#media#AudioTrack#SUCCESS_E@, @B_android#media#AudioTrack#ERROR_E@, @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@, @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@"]], "Parameters": [["@B_android#media#AudioPresentation_E@", "AudioPresentation: see @B_android#media#AudioPresentation_E@. In particular, id should be set. This value must never be null."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the audio presentation is null."], ["@B_java#lang#IllegalStateException_E@", "if track is not initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the audio presentation. If the audio presentation is invalid then @B_android#media#AudioTrack#ERROR_BAD_VALUE_E@ will be returned. If a multi-stream decoder (MSD) is not present, or the format does not support multiple presentations, then @B_android#media#AudioTrack#ERROR_INVALID_OPERATION_E@ will be returned. @B_android#media#AudioTrack#ERROR_E@ is returned in case of any other error.", "history": "Added in API level 28", "FullName": "public int setPresentation (AudioPresentation presentation)"}, "write(short[], int, int)": {"Returns": [["int", "zero or the positive number of shorts that were written, or one of the following error codes. The number of shorts will be a multiple of the channel count not to exceed sizeInShorts. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error This is equivalent to @B_android#media#AudioTrack#write_E@ with writeMode set to @B_android#media#AudioTrack#WRITE_BLOCKING_E@."]], "Parameters": [["short[]", "short: the array that holds the data to play.This value must never be null."], ["int", "int: the offset expressed in shorts in audioData where the data to play starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of shorts to read in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ to correspond to the data in the array. In streaming mode, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns.", "history": "added in API level 3", "FullName": "public int write (short[] audioData, int offsetInShorts, int sizeInShorts)"}, "registerStreamEventCallback(java.util.concurrent.Executor,android.media.AudioTrack.StreamEventCallback)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#Executor_E@", "Executor: @B_java#util#concurrent#Executor_E@ to handle the callbacks. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#media#AudioTrack#StreamEventCallback_E@", "AudioTrack.StreamEventCallback: the callback to receive the stream event notifications. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Registers a callback for the notification of stream events. This callback can only be registered for instances operating in offloaded mode (see @B_android#media#AudioTrack#Builder#setOffloadedPlayback_E@ and @B_android#media#AudioManager#isOffloadedPlaybackSupported_E@ for more details).", "history": "Added in API level 29", "FullName": "public void registerStreamEventCallback (Executor executor, AudioTrack.StreamEventCallback eventCallback)"}, "getStreamType()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the volume stream type of this AudioTrack. Compare the result against @B_android#media#AudioManager#STREAM_VOICE_CALL_E@, @B_android#media#AudioManager#STREAM_SYSTEM_E@, @B_android#media#AudioManager#STREAM_RING_E@, @B_android#media#AudioManager#STREAM_MUSIC_E@, @B_android#media#AudioManager#STREAM_ALARM_E@, @B_android#media#AudioManager#STREAM_NOTIFICATION_E@, @B_android#media#AudioManager#STREAM_DTMF_E@ or @B_android#media#AudioManager#STREAM_ACCESSIBILITY_E@.", "history": "Added in API level 3", "FullName": "public int getStreamType ()"}, "getState()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#AudioTrack_E@"], "Permissions": [], "Description": "Returns the state of the AudioTrack instance. This is useful after the AudioTrack instance has been created to check if it was initialized properly. This ensures that the appropriate resources have been acquired.", "history": "Added in API level 3", "FullName": "public int getState ()"}, "AudioTrack(int,int,int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: the type of the audio stream. See @B_android#media#AudioManager#STREAM_VOICE_CALL_E@, @B_android#media#AudioManager#STREAM_SYSTEM_E@, @B_android#media#AudioManager#STREAM_RING_E@, @B_android#media#AudioManager#STREAM_MUSIC_E@, @B_android#media#AudioManager#STREAM_ALARM_E@, and @B_android#media#AudioManager#STREAM_NOTIFICATION_E@."], ["int", "int: the initial source sample rate expressed in Hz. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ means to use a route-dependent value which is usually the sample rate of the sink. @B_android#media#AudioTrack#getSampleRate_E@ can be used to retrieve the actual sample rate chosen."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_OUT_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_OUT_STEREO_E@"], ["int", "int: the format in which the audio data is represented. See @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@, @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@."], ["int", "int: the total size (in bytes) of the internal buffer where audio data is read from for playback. This should be a nonzero multiple of the frame size in bytes. If the track's creation mode is MODE_STATIC, this is the maximum length sample, or audio clip, that can be played by this instance. If the track's creation mode is MODE_STREAM, this should be the desired buffer size for the AudioTrack to satisfy the application's latency requirements. If bufferSizeInBytes is less than the minimum buffer size for the output sink, it is increased to the minimum buffer size. The method getBufferSizeInFrames() returns the actual size in frames of the buffer created, which determines the minimum frequency to write to the streaming AudioTrack to avoid underrun. See getMinBufferSize(int, int, int) to determine the estimated minimum buffer size for an AudioTrack instance in streaming mode."], ["int", "int: streaming or static buffer. See @B_android#media#AudioTrack#MODE_STATIC_E@ and @B_android#media#AudioTrack#MODE_STREAM_E@"]], "Throws": [["", "java.lang.IllegalArgumentException"], ["@B_java#lang#IllegalArgumentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#media#AudioTrack#Builder_E@ or @B_android#media#AudioTrack#AudioTrack_E@ to specify the @B_android#media#AudioAttributes_E@ instead of the stream type which is only for volume control. Class constructor.", "history": "Added in API level 3", "FullName": "public AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode)"}, "getOffloadDelay()": {"Returns": [["int", "decoder delay expressed in frames. Value is 0 or greater"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the decoder delay of an offloaded track, expressed in frames, previously set with @B_android#media#AudioTrack#setOffloadDelayPadding_E@, or 0 if it was never modified. This delay indicates the number of frames to be ignored at the beginning of the stream. This value can only be queried on a track successfully initialized with @B_android#media#AudioTrack#Builder#setOffloadedPlayback_E@.", "history": "Added in API level 29", "FullName": "public int getOffloadDelay ()"}, "addOnRoutingChangedListener(android.media.AudioRouting.OnRoutingChangedListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#AudioRouting#OnRoutingChangedListener_E@", "AudioRouting.OnRoutingChangedListener: The @B_android#media#AudioRouting#OnRoutingChangedListener_E@ interface to receive notifications of rerouting events."], ["@B_android#os#Handler_E@", "Handler: Specifies the @B_android#os#Handler_E@ object for the thread on which to execute the callback. If null, the @B_android#os#Handler_E@ associated with the main @B_android#os#Looper_E@ will be used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds an @B_android#media#AudioRouting#OnRoutingChangedListener_E@ to receive notifications of routing changes on this AudioTrack.", "history": "Added in API level 24", "FullName": "public void addOnRoutingChangedListener (AudioRouting.OnRoutingChangedListener listener, Handler handler)"}, "setOffloadEndOfStream()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#AudioTrack#Builder#setOffloadedPlayback_E@", "_E@"], "Permissions": [], "Description": "Declares that the last write() operation on this track provided the last buffer of this stream. After the end of stream, previously set padding and delay values are ignored. Can only be called only if the AudioTrack is opened in offload mode . Can only be called only if the AudioTrack is in state @B_android#media#AudioTrack#PLAYSTATE_PLAYING_E@ . Use this method in the same thread as any write() operation.", "history": "Added in API level 29", "FullName": "public void setOffloadEndOfStream ()"}, "write(java.nio.ByteBuffer, int, int)": {"Returns": [["int", "zero or the positive number of bytes that were written, or one of the following error codes. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the buffer that holds the data to write, starting at the position reported by audioData.position(). Note that upon return, the buffer position (audioData.position()) will have been advanced to reflect the amount of data that was successfully written to the AudioTrack.This value must never be null."], ["int", "int: number of bytes to write. It is recommended but not enforced that the number of bytes requested be a multiple of the frame size (sample size in bytes multiplied by the channel count). Note this may differ from audioData.remaining(), but cannot exceed it."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. It has no effect in static mode. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The audioData in ByteBuffer should match the format specified in the AudioTrack constructor. In streaming mode, the blocking behavior depends on the write mode. If the write mode is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the write mode is @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, or the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0, and the write mode is ignored. Note that the actual playback of this data might occur after this function returns.", "history": "added in API level 21", "FullName": "public int write (ByteBuffer audioData, int sizeInBytes, int writeMode)"}, "unregisterStreamEventCallback(android.media.AudioTrack.StreamEventCallback)": {"Returns": [], "Parameters": [["@B_android#media#AudioTrack#StreamEventCallback_E@", "AudioTrack.StreamEventCallback: the callback to unregister. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Unregisters the callback for notification of stream events, previously registered with @B_android#media#AudioTrack#registerStreamEventCallback_E@.", "history": "Added in API level 29", "FullName": "public void unregisterStreamEventCallback (AudioTrack.StreamEventCallback eventCallback)"}, "setPlaybackParams(android.media.PlaybackParams)": {"Returns": [], "Parameters": [["@B_android#media#PlaybackParams_E@", "PlaybackParams: see @B_android#media#PlaybackParams_E@. In particular, speed, pitch, and audio mode should be set. This value must never be null."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the parameters are invalid or not accepted."], ["@B_java#lang#IllegalStateException_E@", "if track is not initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the playback parameters. This method returns failure if it cannot apply the playback parameters. One possible cause is that the parameters for speed or pitch are out of range. Another possible cause is that the AudioTrack is streaming (see @B_android#media#AudioTrack#MODE_STREAM_E@) and the buffer size is too small. For speeds greater than 1.0f, the AudioTrack buffer on configuration must be larger than the speed multiplied by the minimum size @B_android#media#AudioTrack#getMinBufferSize_E@) to allow proper playback.", "history": "Added in API level 23", "FullName": "public void setPlaybackParams (PlaybackParams params)"}, "AudioTrack(int, int, int, int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: the type of the audio stream. See @B_android#media#AudioManager#STREAM_VOICE_CALL_E@, @B_android#media#AudioManager#STREAM_SYSTEM_E@, @B_android#media#AudioManager#STREAM_RING_E@, @B_android#media#AudioManager#STREAM_MUSIC_E@, @B_android#media#AudioManager#STREAM_ALARM_E@, and @B_android#media#AudioManager#STREAM_NOTIFICATION_E@."], ["int", "int: the initial source sample rate expressed in Hz. @B_android#media#AudioFormat#SAMPLE_RATE_UNSPECIFIED_E@ means to use a route-dependent value which is usually the sample rate of the sink."], ["int", "int: describes the configuration of the audio channels. See @B_android#media#AudioFormat#CHANNEL_OUT_MONO_E@ and @B_android#media#AudioFormat#CHANNEL_OUT_STEREO_E@"], ["int", "int: the format in which the audio data is represented. See @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ and @B_android#media#AudioFormat#ENCODING_PCM_8BIT_E@, and @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@."], ["int", "int: the total size (in bytes) of the internal buffer where audio data is read from for playback. This should be a nonzero multiple of the frame size in bytes. If the track's creation mode is MODE_STATIC, this is the maximum length sample, or audio clip, that can be played by this instance. If the track's creation mode is MODE_STREAM, this should be the desired buffer size for the AudioTrack to satisfy the application's latency requirements. If bufferSizeInBytes is less than the minimum buffer size for the output sink, it is increased to the minimum buffer size. The method getBufferSizeInFrames() returns the actual size in frames of the buffer created, which determines the minimum frequency to write to the streaming AudioTrack to avoid underrun. You can write data into this buffer in smaller chunks than this size. See getMinBufferSize(int, int, int) to determine the estimated minimum buffer size for an AudioTrack instance in streaming mode."], ["int", "int: streaming or static buffer. See @B_android#media#AudioTrack#MODE_STATIC_E@ and @B_android#media#AudioTrack#MODE_STREAM_E@"], ["int", "int: Id of audio session the AudioTrack must be attached to"]], "Throws": [["", "java.lang.IllegalArgumentException"], ["@B_java#lang#IllegalArgumentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#media#AudioTrack#Builder_E@ or @B_android#media#AudioTrack#AudioTrack_E@ to specify the @B_android#media#AudioAttributes_E@ instead of the stream type which is only for volume control. Class constructor with audio session. Use this constructor when the AudioTrack must be attached to a particular audio session. The primary use of the audio session ID is to associate audio effects to a particular instance of AudioTrack: if an audio session ID is provided when creating an AudioEffect, this effect will be applied only to audio tracks and media players in the same session and not to the output mix. When an AudioTrack is created without specifying a session, it will create its own session which can be retrieved by calling the @B_android#media#AudioTrack#getAudioSessionId_E@ method. If a non-zero session ID is provided, this AudioTrack will share effects attached to this session with all other media players or audio tracks in the same session, otherwise a new session will be created for this track if none is supplied.", "history": "added in API level 9", "FullName": "public AudioTrack (int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode, int sessionId)"}, "setPreferredDevice(android.media.AudioDeviceInfo)": {"Returns": [["boolean", "true if succesful, false if the specified @B_android#media#AudioDeviceInfo_E@ is non-null and does not correspond to a valid audio output device."]], "Parameters": [["@B_android#media#AudioDeviceInfo_E@", "AudioDeviceInfo: The @B_android#media#AudioDeviceInfo_E@ specifying the audio sink. If deviceInfo is null, default routing is restored."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Specifies an audio device (via an @B_android#media#AudioDeviceInfo_E@ object) to route the output from this AudioTrack.", "history": "Added in API level 23", "FullName": "public boolean setPreferredDevice (AudioDeviceInfo deviceInfo)"}, "play()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the track isn't properly initialized"]], "SeeAlso": [], "Permissions": [], "Description": "Starts playing an AudioTrack. If track's creation mode is @B_android#media#AudioTrack#MODE_STATIC_E@, you must have called one of the write methods (@B_android#media#AudioTrack#write_E@, @B_android#media#AudioTrack#write_E@, @B_android#media#AudioTrack#write_E@, @B_android#media#AudioTrack#write_E@, @B_android#media#AudioTrack#write_E@, or @B_android#media#AudioTrack#write_E@) prior to play(). If the mode is @B_android#media#AudioTrack#MODE_STREAM_E@, you can optionally prime the data path prior to calling play(), by writing up to bufferSizeInBytes (from constructor). If you don't call write() first, or if you call write() but with an insufficient amount of data, then the track will be in underrun state at play(). In this case, playback will not actually start playing until the data path is filled to a device-specific minimum level. This requirement for the path to be filled to a minimum level is also true when resuming audio playback after calling stop(). Similarly the buffer will need to be filled up again after the track underruns due to failure to call write() in a timely manner with sufficient data. For portability, an application should prime the data path to the maximum allowed by writing data until the write() method returns a short transfer count. This allows play() to start immediately, and reduces the chance of underrun.", "history": "Added in API level 3", "FullName": "public void play ()"}, "write(short[],int,int)": {"Returns": [["int", "zero or the positive number of shorts that were written, or one of the following error codes. The number of shorts will be a multiple of the channel count not to exceed sizeInShorts. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error This is equivalent to @B_android#media#AudioTrack#write_E@ with writeMode set to @B_android#media#AudioTrack#WRITE_BLOCKING_E@."]], "Parameters": [["short[]", "short: the array that holds the data to play. This value must never be null."], ["int", "int: the offset expressed in shorts in audioData where the data to play starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of shorts to read in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_16BIT_E@ to correspond to the data in the array. In streaming mode, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0. Note that the actual playback of this data might occur after this function returns.", "history": "Added in API level 3", "FullName": "public int write (short[] audioData, int offsetInShorts, int sizeInShorts)"}, "getOffloadPadding()": {"Returns": [["int", "decoder padding expressed in frames. Value is 0 or greater"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the decoder padding of an offloaded track, expressed in frames, previously set with @B_android#media#AudioTrack#setOffloadDelayPadding_E@, or 0 if it was never modified. This padding indicates the number of frames to be ignored at the end of the stream. This value can only be queried on a track successfully initialized with @B_android#media#AudioTrack#Builder#setOffloadedPlayback_E@.", "history": "Added in API level 29", "FullName": "public int getOffloadPadding ()"}, "write(float[],int,int,int)": {"Returns": [["int", "zero or the positive number of floats that were written, or one of the following error codes. The number of floats will be a multiple of the channel count not to exceed sizeInFloats. ERROR_INVALID_OPERATION if the track isn't properly initialized ERROR_BAD_VALUE if the parameters don't resolve to valid data and indexes ERROR_DEAD_OBJECT if the AudioTrack is not valid anymore and needs to be recreated. The dead object error code is not returned if some data was successfully transferred. In this case, the error is returned at the next write() ERROR in case of other error"]], "Parameters": [["float[]", "float: the array that holds the data to write. The implementation does not clip for sample values within the nominal range [-1.0f, 1.0f], provided that all gains in the audio pipeline are less than or equal to unity (1.0f), and in the absence of post-processing effects that could add energy, such as reverb. For the convenience of applications that compute samples using filters with non-unity gain, sample values +3 dB beyond the nominal range are permitted. However such values may eventually be limited or clipped, depending on various gains and later processing in the audio path. Therefore applications are encouraged to provide samples values within the nominal range. This value must never be null."], ["int", "int: the offset, expressed as a number of floats, in audioData where the data to write starts. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: the number of floats to write in audioData after the offset. Must not be negative, or cause the data access to go out of bounds of the array."], ["int", "int: one of @B_android#media#AudioTrack#WRITE_BLOCKING_E@, @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@. It has no effect in static mode. With @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will block until all data has been written to the audio sink. With @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, the write will return immediately after queuing as much audio data for playback as possible without blocking. Value is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, or @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Writes the audio data to the audio sink for playback (streaming mode), or copies audio data for later playback (static buffer mode). The format specified in the AudioTrack constructor should be @B_android#media#AudioFormat#ENCODING_PCM_FLOAT_E@ to correspond to the data in the array. In streaming mode, the blocking behavior depends on the write mode. If the write mode is @B_android#media#AudioTrack#WRITE_BLOCKING_E@, the write will normally block until all the data has been enqueued for playback, and will return a full transfer count. However, if the write mode is @B_android#media#AudioTrack#WRITE_NON_BLOCKING_E@, or the track is stopped or paused on entry, or another thread interrupts the write by calling stop or pause, or an I/O error occurs during the write, then the write may return a short transfer count. In static buffer mode, copies the data to the buffer starting at offset 0, and the write mode is ignored. Note that the actual playback of this data might occur after this function returns.", "history": "Added in API level 21", "FullName": "public int write (float[] audioData, int offsetInFloats, int sizeInFloats, int writeMode)"}, "getMaxVolume()": {"Returns": [["float", "the maximum value, which is greater than or equal to 1.0."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the maximum gain value, which is greater than or equal to 1.0. Gain values greater than the maximum will be clamped to the maximum. The word \"volume\" in the API name is historical; this is actually a gain. expressed as a linear multiplier on sample values, where a maximum value of 1.0 corresponds to a gain of 0 dB (sample values left unmodified).", "history": "Added in API level 3", "FullName": "public static float getMaxVolume ()"}}, "Inheritance": [], "ClassName": "android.media.AudioTrack", "ClassDesc": "The AudioTrack class manages and plays a single audio resource for Java applications. It allows streaming of PCM audio buffers to the audio sink for playback. This is achieved by \"pushing\" the data to the AudioTrack object using one of the @B_android#media#AudioTrack#write_E@, @B_android#media#AudioTrack#write_E@, and @B_android#media#AudioTrack#write_E@ methods. An AudioTrack instance can operate under two modes: static or streaming. In Streaming mode, the application writes a continuous stream of data to the AudioTrack, using one of the write() methods. These are blocking and return when the data has been transferred from the Java layer to the native layer and queued for playback. The streaming mode is most useful when playing blocks of audio data that for instance are: too big to fit in memory because of the duration of the sound to play, too big to fit in memory because of the characteristics of the audio data (high sampling rate, bits per sample ...) received or generated while previously queued audio is playing. The static mode should be chosen when dealing with short sounds that fit in memory and that need to be played with the smallest latency possible. The static mode will therefore be preferred for UI and game sounds that are played often, and with the smallest overhead possible. Upon creation, an AudioTrack object initializes its associated audio buffer. The size of this buffer, specified during the construction, determines how long an AudioTrack can play before running out of data. For an AudioTrack using the static mode, this size is the maximum size of the sound that can be played from it. For the streaming mode, data will be written to the audio sink in chunks of sizes less than or equal to the total buffer size. AudioTrack is not final and thus permits subclasses, but such use is not recommended."}