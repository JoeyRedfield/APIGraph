{"Functions": {"substring(java.lang.CharSequence,int,int)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new String object containing the given range of characters from the source string. This is different than simply calling @B_java#lang#CharSequence#subSequence_E@ in that it does not preserve any style runs in the source sequence, allowing a more efficient implementation.", "history": "Added in API level 1", "FullName": "public static String substring (CharSequence source, int start, int end)"}, "concat(java.lang.CharSequence...)": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a CharSequence concatenating the specified CharSequences, retaining their spans if any. If there are no parameters, an empty string will be returned. If the number of parameters is exactly one, that parameter is returned as output, even if it is null. If the number of parameters is at least two, any null CharSequence among the parameters is treated as if it was the string \"null\". If there are paragraph spans in the source CharSequences that satisfy paragraph boundary requirements in the sources but would no longer satisfy them in the concatenated CharSequence, they may get extended in the resulting CharSequence or not retained.", "history": "Added in API level 1", "FullName": "public static CharSequence concat (CharSequence... text)"}, "replace(java.lang.CharSequence,java.lang.String[],java.lang.CharSequence[])": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["@B_java#lang#String_E@", "String no parameter comment"], ["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a new CharSequence in which each of the source strings is replaced by the corresponding element of the destinations.", "history": "Added in API level 1", "FullName": "public static CharSequence replace (CharSequence template, String[] sources, CharSequence[] destinations)"}, "indexOf(java.lang.CharSequence,java.lang.CharSequence,int,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int indexOf (CharSequence s, CharSequence needle, int start, int end)"}, "indexOf(java.lang.CharSequence, char, int, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static int indexOf (CharSequence s, char ch, int start, int end)"}, "regionMatches(java.lang.CharSequence,int,java.lang.CharSequence,int,int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"], ["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static boolean regionMatches (CharSequence one, int toffset, CharSequence two, int ooffset, int len)"}, "split(java.lang.String,java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "an array of strings. The array will be empty if text is empty"]], "Parameters": [["@B_java#lang#String_E@", "String: the string to split"], ["@B_java#lang#String_E@", "String: the regular expression to match"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if expression or text is null"]], "SeeAlso": [], "Permissions": [], "Description": "This method yields the same result as text.split(expression, -1) except that if text.isEmpty() then this method returns an empty array whereas \"\".split(expression, -1) would have returned an array with a single \"\". The -1 means that trailing empty Strings are not removed from the result; for example split(\"a,\", \",\" ) returns {\"a\", \"\"}. Note that whether a leading zero-width match can result in a leading \"\" depends on whether your app @B_android#content#pm#ApplicationInfo#targetSdkVersion_E@ <= 28; see @B_java#util#regex#Pattern#split_E@.", "history": "Added in API level 1", "FullName": "public static String[] split (String text, String expression)"}, "join(java.lang.CharSequence, java.lang.Object[])": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: a CharSequence that will be inserted between the tokens. If null, the string \"null\" will be used as the delimiter."], ["@B_java#lang#Object_E@", "Object: an array objects to be joined. Strings will be formed from the objects by calling object.toString(). If tokens is null, a NullPointerException will be thrown. If tokens is an empty array, an empty string will be returned."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string containing the tokens joined by delimiters.", "history": "added in API level 1", "FullName": "public static String join (CharSequence delimiter, Object[] tokens)"}, "indexOf(java.lang.CharSequence, char)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static int indexOf (CharSequence s, char ch)"}, "isDigitsOnly(java.lang.CharSequence)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether the given CharSequence contains only digits.", "history": "Added in API level 1", "FullName": "public static boolean isDigitsOnly (CharSequence str)"}, "ellipsize(java.lang.CharSequence,android.text.TextPaint,float,android.text.TextUtils.TruncateAt)": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["@B_android#text#TextPaint_E@", "TextPaint no parameter comment"], ["float", "float no parameter comment"], ["@B_android#text#TextUtils#TruncateAt_E@", "TextUtils.TruncateAt no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the original text if it fits in the specified width given the properties of the specified Paint, or, if it does not fit, a truncated copy with ellipsis character added at the specified edge or center.", "history": "Added in API level 1", "FullName": "public static CharSequence ellipsize (CharSequence text, TextPaint p, float avail, TextUtils.TruncateAt where)"}, "join(java.lang.CharSequence, java.lang.Iterable)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: a CharSequence that will be inserted between the tokens. If null, the string \"null\" will be used as the delimiter."], ["@B_java#lang#Iterable_E@", "Iterable: an array objects to be joined. Strings will be formed from the objects by calling object.toString(). If tokens is null, a NullPointerException will be thrown. If tokens is empty, an empty string will be returned."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string containing the tokens joined by delimiters.", "history": "added in API level 1", "FullName": "public static String join (CharSequence delimiter, Iterable tokens)"}, "isGraphic(char)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["char", "char no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#text#TextUtils#isGraphic_E@ instead. Returns whether this character is a printable character. This does not support non-BMP characters and should not be used.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public static boolean isGraphic (char c)"}, "lastIndexOf(java.lang.CharSequence,char)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int lastIndexOf (CharSequence s, char ch)"}, "join(java.lang.CharSequence,java.lang.Iterable)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: a CharSequence that will be inserted between the tokens. If null, the string \"null\" will be used as the delimiter. This value must never be null."], ["@B_java#lang#Iterable_E@", "Iterable: an array objects to be joined. Strings will be formed from the objects by calling object.toString(). If tokens is null, a NullPointerException will be thrown. If tokens is empty, an empty string will be returned. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string containing the tokens joined by delimiters.", "history": "Added in API level 1", "FullName": "public static String join (CharSequence delimiter, Iterable tokens)"}, "getOffsetAfter(java.lang.CharSequence,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int getOffsetAfter (CharSequence text, int offset)"}, "getCapsMode(java.lang.CharSequence, int, int)": {"Returns": [["int", "Returns the actual capitalization modes that can be in effect at the current position, which is any combination of @B_android#text#TextUtils#CAP_MODE_CHARACTERS_E@, @B_android#text#TextUtils#CAP_MODE_WORDS_E@, and @B_android#text#TextUtils#CAP_MODE_SENTENCES_E@."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The text that should be checked for caps modes."], ["int", "int: Location in the text at which to check."], ["int", "int: The modes to be checked: may be any combination of @B_android#text#TextUtils#CAP_MODE_CHARACTERS_E@, @B_android#text#TextUtils#CAP_MODE_WORDS_E@, and @B_android#text#TextUtils#CAP_MODE_SENTENCES_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in @B_android#text#InputType_E@.", "history": "added in API level 3", "FullName": "public static int getCapsMode (CharSequence cs, int off, int reqModes)"}, "indexOf(java.lang.CharSequence,char)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int indexOf (CharSequence s, char ch)"}, "lastIndexOf(java.lang.CharSequence, char)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static int lastIndexOf (CharSequence s, char ch)"}, "dumpSpans(java.lang.CharSequence,android.util.Printer,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["@B_android#util#Printer_E@", "Printer no parameter comment"], ["@B_java#lang#String_E@", "String no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Debugging tool to print the spans in a CharSequence. The output will be printed one span per line. If the CharSequence is not a Spanned, then the entire string will be printed on a single line.", "history": "Added in API level 3", "FullName": "public static void dumpSpans (CharSequence cs, Printer printer, String prefix)"}, "stringOrSpannedString(java.lang.CharSequence)": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static CharSequence stringOrSpannedString (CharSequence source)"}, "equals(java.lang.CharSequence,java.lang.CharSequence)": {"Returns": [["boolean", "true if a and b are equal"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: first CharSequence to check"], ["@B_java#lang#CharSequence_E@", "CharSequence: second CharSequence to check"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if a and b are equal, including if they are both null.", "history": "Added in API level 1", "FullName": "public static boolean equals (CharSequence a, CharSequence b)"}, "indexOf(java.lang.CharSequence,char,int,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int indexOf (CharSequence s, char ch, int start, int end)"}, "getReverse(java.lang.CharSequence, int, int)": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Do not use. This function only reverses individual chars and not their associated spans. It doesn't support surrogate pairs (that correspond to non-BMP code points), combining sequences or conjuncts either.", "history": "added in API level 1", "FullName": "public static CharSequence getReverse (CharSequence source, int start, int end)"}, "split(java.lang.String, java.util.regex.Pattern)": {"Returns": [["@B_java#lang#String_E@", "an array of strings. The array will be empty if text is empty"]], "Parameters": [["@B_java#lang#String_E@", "String: the string to split"], ["@B_java#util#regex#Pattern_E@", "Pattern: the regular expression to match"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if expression or text is null"]], "SeeAlso": [], "Permissions": [], "Description": "Splits a string on a pattern. String.split() returns [''] when the string to be split is empty. This returns []. This does not remove any empty strings from the result.", "history": "added in API level 1", "FullName": "public static String[] split (String text, Pattern pattern)"}, "indexOf(java.lang.CharSequence,java.lang.CharSequence,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int indexOf (CharSequence s, CharSequence needle, int start)"}, "getTrimmedLength(java.lang.CharSequence)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the length that the specified CharSequence would have if spaces and ASCII control characters were trimmed from the start and end, as by @B_java#lang#String#trim_E@.", "history": "Added in API level 1", "FullName": "public static int getTrimmedLength (CharSequence s)"}, "getOffsetBefore(java.lang.CharSequence,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int getOffsetBefore (CharSequence text, int offset)"}, "getCapsMode(java.lang.CharSequence,int,int)": {"Returns": [["int", "Returns the actual capitalization modes that can be in effect at the current position, which is any combination of @B_android#text#TextUtils#CAP_MODE_CHARACTERS_E@, @B_android#text#TextUtils#CAP_MODE_WORDS_E@, and @B_android#text#TextUtils#CAP_MODE_SENTENCES_E@."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The text that should be checked for caps modes."], ["int", "int: Location in the text at which to check."], ["int", "int: The modes to be checked: may be any combination of @B_android#text#TextUtils#CAP_MODE_CHARACTERS_E@, @B_android#text#TextUtils#CAP_MODE_WORDS_E@, and @B_android#text#TextUtils#CAP_MODE_SENTENCES_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determine what caps mode should be in effect at the current offset in the text. Only the mode bits set in @B_android#text#InputType_E@.", "history": "Added in API level 3", "FullName": "public static int getCapsMode (CharSequence cs, int off, int reqModes)"}, "listEllipsize(android.content.Context,java.util.List<java.lang.CharSequence>,java.lang.String,android.text.TextPaint,float,int)": {"Returns": [["@B_java#lang#CharSequence_E@", "the formatted CharSequence. If even the shortest sequence (e.g. \"A, 11 more\") doesn't fit, it will return an empty string."]], "Parameters": [["@B_android#content#Context_E@", "Context: the Context to get the moreId resource from. If null, an ellipsis (U+2026) would be used for moreId. This value may be null."], ["@B_java#util#List_E@", "List: the list to format This value may be null."], ["@B_java#lang#String_E@", "String: a separator, such as \", \" This value must never be null."], ["@B_android#text#TextPaint_E@", "TextPaint: the Paint with which to measure the text This value must never be null."], ["float", "float: the horizontal width available for the text (in pixels) Value is 0.0 or greater"], ["int", "int: the resource ID for the pluralized string to insert at the end of sequence when some of the elements don't fit."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Formats a list of CharSequences by repeatedly inserting the separator between them, but stopping when the resulting sequence is too wide for the specified width. This method actually tries to fit the maximum number of elements. So if \"A, 11 more\" fits, \"A, B, 10 more\" doesn't fit, but \"A, B, C, 9 more\" fits again (due to the glyphs for the digits being very wide, for example), it returns \"A, B, C, 9 more\". Because of this, this method may be inefficient for very long lists. Note that the elements of the returned value, as well as the string for moreId, will be bidi-wrapped using @B_android#text#BidiFormatter#unicodeWrap_E@ based on the locale of the input Context. If the input Context is null, the default BidiFormatter from @B_android#text#BidiFormatter#getInstance_E@ will be used.", "history": "Added in API level 26", "FullName": "public static CharSequence listEllipsize (Context context, List<CharSequence> elements, String separator, TextPaint paint, float avail, int moreId)"}, "getChars(java.lang.CharSequence,int,int,char[],int)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"], ["char[]", "char no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static void getChars (CharSequence s, int start, int end, char[] dest, int destoff)"}, "getOffsetAfter(java.lang.CharSequence, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static int getOffsetAfter (CharSequence text, int offset)"}, "getOffsetBefore(java.lang.CharSequence, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static int getOffsetBefore (CharSequence text, int offset)"}, "substring(java.lang.CharSequence, int, int)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new String object containing the given range of characters from the source string. This is different than simply calling @B_java#lang#CharSequence#subSequence_E@ in that it does not preserve any style runs in the source sequence, allowing a more efficient implementation.", "history": "added in API level 1", "FullName": "public static String substring (CharSequence source, int start, int end)"}, "writeToParcel(java.lang.CharSequence,android.os.Parcel,int)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: This value may be null."], ["@B_android#os#Parcel_E@", "Parcel: This value must never be null."], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten a CharSequence and whatever styles can be copied across processes into the parcel.", "history": "Added in API level 1", "FullName": "public static void writeToParcel (CharSequence cs, Parcel p, int parcelableFlags)"}, "join(java.lang.CharSequence,java.lang.Object[])": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: a CharSequence that will be inserted between the tokens. If null, the string \"null\" will be used as the delimiter. This value must never be null."], ["@B_java#lang#Object_E@", "Object: an array objects to be joined. Strings will be formed from the objects by calling object.toString(). If tokens is null, a NullPointerException will be thrown. If tokens is an empty array, an empty string will be returned. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string containing the tokens joined by delimiters.", "history": "Added in API level 1", "FullName": "public static String join (CharSequence delimiter, Object[] tokens)"}, "indexOf(java.lang.CharSequence,java.lang.CharSequence)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int indexOf (CharSequence s, CharSequence needle)"}, "copySpansFrom(android.text.Spanned,int,int,java.lang.Class,android.text.Spannable,int)": {"Returns": [], "Parameters": [["@B_android#text#Spanned_E@", "Spanned no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"], ["@B_java#lang#Class_E@", "Class no parameter comment"], ["@B_android#text#Spannable_E@", "Spannable no parameter comment"], ["int", "int no parameter comment"]], "Throws": [["@B_java#lang#IndexOutOfBoundsException_E@", "if any of the copied spans are out of range in dest."]], "SeeAlso": [], "Permissions": [], "Description": "Copies the spans from the region start...end in source to the region destoff...destoff+end-start in dest. Spans in source that begin before start or end after end but overlap this range are trimmed as if they began at start or ended at end.", "history": "Added in API level 1", "FullName": "public static void copySpansFrom (Spanned source, int start, int end, Class kind, Spannable dest, int destoff)"}, "isGraphic(java.lang.CharSequence)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether the given CharSequence contains any printable characters.", "history": "Added in API level 1", "FullName": "public static boolean isGraphic (CharSequence str)"}, "lastIndexOf(java.lang.CharSequence,char,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int lastIndexOf (CharSequence s, char ch, int last)"}, "getReverse(java.lang.CharSequence,int,int)": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Do not use. This function only reverses individual chars and not their associated spans. It doesn't support surrogate pairs (that correspond to non-BMP code points), combining sequences or conjuncts either.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public static CharSequence getReverse (CharSequence source, int start, int end)"}, "split(java.lang.String,java.util.regex.Pattern)": {"Returns": [["@B_java#lang#String_E@", "an array of strings. The array will be empty if text is empty"]], "Parameters": [["@B_java#lang#String_E@", "String: the string to split"], ["@B_java#util#regex#Pattern_E@", "Pattern: the regular expression to match"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if expression or text is null"]], "SeeAlso": [], "Permissions": [], "Description": "Splits a string on a pattern. This method yields the same result as pattern.split(text, -1) except that if text.isEmpty() then this method returns an empty array whereas pattern.split(\"\", -1) would have returned an array with a single \"\". The -1 means that trailing empty Strings are not removed from the result; Note that whether a leading zero-width match can result in a leading \"\" depends on whether your app @B_android#content#pm#ApplicationInfo#targetSdkVersion_E@ <= 28; see @B_java#util#regex#Pattern#split_E@.", "history": "Added in API level 1", "FullName": "public static String[] split (String text, Pattern pattern)"}, "expandTemplate(java.lang.CharSequence,java.lang.CharSequence...)": {"Returns": [["@B_java#lang#CharSequence_E@", "the new CharSequence produced by doing the replacement"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the input text containing \"^1\"-style placeholder values. This object is not modified; a copy is returned."], ["@B_java#lang#CharSequence_E@", "CharSequence: CharSequences substituted into the template. The first is substituted for \"^1\", the second for \"^2\", and so on."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the template requests a value that was not provided, or if more than 9 values are provided."]], "SeeAlso": [], "Permissions": [], "Description": "Replace instances of \"^1\", \"^2\", etc. in the template CharSequence with the corresponding values. \"^^\" is used to produce a single caret in the output. Only up to 9 replacement values are supported, \"^10\" will be produce the first replacement value followed by a '0'.", "history": "Added in API level 1", "FullName": "public static CharSequence expandTemplate (CharSequence template, CharSequence... values)"}, "htmlEncode(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "the encoded string"]], "Parameters": [["@B_java#lang#String_E@", "String: the string to be encoded"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Html-encode the string.", "history": "Added in API level 1", "FullName": "public static String htmlEncode (String s)"}, "indexOf(java.lang.CharSequence,char,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int indexOf (CharSequence s, char ch, int start)"}, "split(java.lang.String, java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "an array of strings. The array will be empty if text is empty"]], "Parameters": [["@B_java#lang#String_E@", "String: the string to split"], ["@B_java#lang#String_E@", "String: the regular expression to match"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if expression or text is null"]], "SeeAlso": [], "Permissions": [], "Description": "String.split() returns [''] when the string to be split is empty. This returns []. This does not remove any empty strings from the result. For example split(\"a,\", \",\" ) returns {\"a\", \"\"}.", "history": "added in API level 1", "FullName": "public static String[] split (String text, String expression)"}, "lastIndexOf(java.lang.CharSequence,char,int,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int lastIndexOf (CharSequence s, char ch, int start, int last)"}, "isEmpty(java.lang.CharSequence)": {"Returns": [["boolean", "true if str is null or zero length"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the string to be examined This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the string is null or 0-length.", "history": "Added in API level 1", "FullName": "public static boolean isEmpty (CharSequence str)"}, "getLayoutDirectionFromLocale(java.util.Locale)": {"Returns": [["int", "the layout direction. This may be one of: @B_android#view#View#LAYOUT_DIRECTION_LTR_E@ or @B_android#view#View#LAYOUT_DIRECTION_RTL_E@. Be careful: this code will need to be updated when vertical scripts will be supported"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: the Locale for which we want the layout direction. Can be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the layout direction for a given Locale", "history": "Added in API level 17", "FullName": "public static int getLayoutDirectionFromLocale (Locale locale)"}, "lastIndexOf(java.lang.CharSequence, char, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static int lastIndexOf (CharSequence s, char ch, int last)"}, "commaEllipsize(java.lang.CharSequence,android.text.TextPaint,float,java.lang.String,java.lang.String)": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the text to truncate"], ["@B_android#text#TextPaint_E@", "TextPaint: the Paint with which to measure the text"], ["float", "float: the horizontal width available for the text (in pixels)"], ["@B_java#lang#String_E@", "String: the string for \"1 more\" in the current locale"], ["@B_java#lang#String_E@", "String: the string for \"%d more\" in the current locale"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Do not use. This is not internationalized, and has known issues with right-to-left text, languages that have more than one plural form, languages that use a different character as a comma-like separator, etc. Use @B_android#text#TextUtils#listEllipsize_E@ instead. Converts a CharSequence of the comma-separated form \"Andy, Bob, Charles, David\" that is too wide to fit into the specified width into one like \"Andy, Bob, 2 more\".", "history": "Added in API level 1 Deprecated in API level 26", "FullName": "public static CharSequence commaEllipsize (CharSequence text, TextPaint p, float avail, String oneMore, String more)"}, "makeSafeForPresentation(java.lang.String,int,float,int)": {"Returns": [["@B_java#lang#CharSequence_E@", "The cleaned string This value will never be null."]], "Parameters": [["@B_java#lang#String_E@", "String: The input string This value must never be null."], ["int", "int: The maximum number of characters of unclean to consider from the input string. 0 disables this feature. Value is 0 or greater"], ["float", "float: Assuming maximum length of the string (in dip), assuming font size 42. This is roughly 50 characters for ellipsizeDip == 1000. Usually ellipsizing should be left to the view showing the string. If a string is used as an input to another string, it might be useful to control the length of the input string though. 0 disables this feature. Value is 0 or greater"], ["int", "int: Flags controlling cleaning behavior (Can be @B_android#text#TextUtils#SAFE_STRING_FLAG_TRIM_E@, @B_android#text#TextUtils#SAFE_STRING_FLAG_SINGLE_LINE_E@, and @B_android#text#TextUtils#SAFE_STRING_FLAG_FIRST_LINE_E@) Value is either 0 or a combination of @B_android#text#TextUtils#SAFE_STRING_FLAG_TRIM_E@, @B_android#text#TextUtils#SAFE_STRING_FLAG_SINGLE_LINE_E@, and @B_android#text#TextUtils#SAFE_STRING_FLAG_FIRST_LINE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove html, remove bad characters, and truncate string. This method is meant to remove common mistakes and nefarious formatting from strings that were loaded from untrusted sources (such as other packages). This method first @B_android#text#Html#fromHtml_E@ and then ... Removes new lines or truncates at first new line Trims the white-space off the end Truncates the string ... if specified.", "history": "Added in API level 29", "FullName": "public static CharSequence makeSafeForPresentation (String unclean, int maxCharactersToConsider, float ellipsizeDip, int flags)"}, "indexOf(java.lang.CharSequence, char, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["char", "char no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static int indexOf (CharSequence s, char ch, int start)"}, "ellipsize(java.lang.CharSequence,android.text.TextPaint,float,android.text.TextUtils.TruncateAt,boolean,android.text.TextUtils.EllipsizeCallback)": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["@B_android#text#TextPaint_E@", "TextPaint no parameter comment"], ["float", "float no parameter comment"], ["@B_android#text#TextUtils#TruncateAt_E@", "TextUtils.TruncateAt no parameter comment"], ["boolean", "boolean no parameter comment"], ["@B_android#text#TextUtils#EllipsizeCallback_E@", "TextUtils.EllipsizeCallback: This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the original text if it fits in the specified width given the properties of the specified Paint, or, if it does not fit, a copy with ellipsis character added at the specified edge or center. If preserveLength is specified, the returned copy will be padded with zero-width spaces to preserve the original length and offsets instead of truncating. If callback is non-null, it will be called to report the start and end of the ellipsized range. TextDirection is determined by the first strong directional character.", "history": "Added in API level 1", "FullName": "public static CharSequence ellipsize (CharSequence text, TextPaint paint, float avail, TextUtils.TruncateAt where, boolean preserveLength, TextUtils.EllipsizeCallback callback)"}}, "Inheritance": [], "ClassName": "android.text.TextUtils", "ClassDesc": ""}