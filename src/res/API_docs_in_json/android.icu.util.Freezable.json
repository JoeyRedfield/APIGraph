{"Functions": {"freeze()": {"Returns": [["T", "the object itself."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Freezes the object.", "history": "Added in API level 24", "FullName": "public abstract T freeze ()"}, "cloneAsThawed()": {"Returns": [["T", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Provides for the clone operation. Any clone is initially unfrozen.", "history": "Added in API level 24", "FullName": "public abstract T cloneAsThawed ()"}, "isFrozen()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines whether the object has been frozen or not.", "history": "Added in API level 24", "FullName": "public abstract boolean isFrozen ()"}}, "Inheritance": [], "ClassName": "android.icu.util.Freezable<T>", "ClassDesc": "Provides a flexible mechanism for controlling access, without requiring that a class be immutable. Once frozen, an object can never be unfrozen, so it is thread-safe from that point onward. Once the object has been frozen, it must guarantee that no changes can be made to it. Any attempt to alter it must raise an UnsupportedOperationException exception. This means that when the object returns internal objects, or if anyone has references to those internal objects, that those internal objects must either be immutable, or must also raise exceptions if any attempt to modify them is made. Of course, the object can return clones of internal objects, since those are safe. There are often times when you need objects to be objects 'safe', so that they can't be modified. Examples are when objects need to be thread-safe, or in writing robust code, or in caches. If you are only creating your own objects, you can guarantee this, of course -- but only if you don't make a mistake. If you have objects handed into you, or are creating objects using others handed into you, it is a different story. It all comes down to whether you want to take the Blanche Dubois approach (\"depend on the kindness of strangers\") or the Andy Grove approach (\"Only the Paranoid Survive\"). For example, suppose we have a simple class: Since the class doesn't have any setters, someone might think that it is immutable. You know where this is leading, of course; this class is unsafe in a number of ways. The following illustrates that. There are a few different techniques for having safe classes. There are advantages and disadvantages of each of these. The Freezable model supplements these choices by giving you the ability to build up an object by calling various methods, then when it is in a final state, you can cloneAsThawed(), and modify the copy. This provides a simple, effective mechanism for safe classes in circumstances where the alternatives are insufficient or clumsy. (If an object is shared before it is immutable, then it is the responsibility of each thread to mutex its usage (as with other objects).) Here is what needs to be done to implement this interface, depending on the type of the object. These are the easiest. You just use the interface to reflect that, by adding the following: These can be final methods because subclasses of immutable objects must themselves be immutable. (Note: freeze is returning this for chaining.) Add a protected 'flagging' field: Add the following methods: Add a cloneAsThawed() method following the normal pattern for clone(), except that frozen=false in the new clone. Then take the setters (that is, any method that can change the internal state of the object), and add the following as the first statement: Any subclass of a Freezable will just use its superclass's flagging field. It must override freeze() and cloneAsThawed() to call the superclass, but normally does not override isFrozen(). It must then just pay attention to its own getters, setters and fields. Internal caches are cases where the object is logically unmodified, but internal state of the object changes. For example, there are const C++ functions that cast away the const on the \"this\" pointer in order to modify an object cache. These cases are handled by mutexing the internal cache to ensure thread-safety. For example, suppose that UnicodeSet had an internal marker to the last code point accessed. In this case, the field is not externally visible, so the only thing you need to do is to synchronize the field for thread safety. Internal fields are called frozen or immutable (such as String or primitives). If you've never allowed internal access to these, then you are all done. For example, converting UnicodeSet to be Freezable is just accomplished with the above steps. But remember that you These also illustrated in the code sample in To deal with unsafe internals, the simplest course of action is to do the work in the freeze() function. Just make all of your internal fields frozen, and set the frozen flag. Any subsequent getter/setter will work properly. Here is an example: If the field is a Collection or Map, then to make it frozen you have two choices. If you have never allowed access to the collection from outside your object, then just wrap it to prevent future modification. If you have clone() before wrapping it. If a collection"}