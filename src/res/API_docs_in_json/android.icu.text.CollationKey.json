{"Functions": {"CollationKey(java.lang.String, byte[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: string this CollationKey is to represent"], ["byte[]", "byte: array of bytes that represent the collation order of argument source terminated by a null"]], "Throws": [], "SeeAlso": ["@B_android#icu#text#Collator_E@"], "Permissions": [], "Description": "CollationKey constructor. This constructor is given public access, unlike the JDK version, to allow access to users extending the Collator class. See @B_android#icu#text#Collator#getCollationKey_E@.", "history": "added in API level 24", "FullName": "public CollationKey (String source, byte[] key)"}, "getSourceString()": {"Returns": [["@B_java#lang#String_E@", "source string that this CollationKey represents"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the source string that this CollationKey represents.", "history": "Added in API level 24", "FullName": "public String getSourceString ()"}, "compareTo(android.icu.text.CollationKey)": {"Returns": [["int", "an integer value. If the value is less than zero this CollationKey is less than than target, if the value is zero they are equal, and if the value is greater than zero this CollationKey is greater than target."]], "Parameters": [["@B_android#icu#text#CollationKey_E@", "CollationKey: target CollationKey"]], "Throws": [["@B_java#lang#NullPointerException_E@", "is thrown if argument is null."]], "SeeAlso": ["@B_android#icu#text#Collator#compare_E@"], "Permissions": [], "Description": "Compare this CollationKey to another CollationKey. The collation rules of the Collator that created this key are applied.", "history": "Added in API level 24", "FullName": "public int compareTo (CollationKey target)"}, "merge(android.icu.text.CollationKey)": {"Returns": [["@B_android#icu#text#CollationKey_E@", "a CollationKey that contains the valid merged sort keys with a null String representation, i.e. new CollationKey(null, merged_sort_keys)"]], "Parameters": [["@B_android#icu#text#CollationKey_E@", "CollationKey: CollationKey to merge with"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown if source CollationKey argument is null or of 0 length."]], "SeeAlso": [], "Permissions": [], "Description": "Merges this CollationKey with another. The levels are merged with their corresponding counterparts (primaries with primaries, secondaries with secondaries etc.). Between the values from the same level a separator is inserted. This is useful, for example, for combining sort keys from first and last names to sort such pairs. See http://www.unicode.org/reports/tr10/#Merging_Sort_Keys The recommended way to achieve \"merged\" sorting is by concatenating strings with U+FFFE between them. The concatenation has the same sort order as the merged sort keys, but merge(getSortKey(str1), getSortKey(str2)) may differ from getSortKey(str1 + '' + str2). Using strings with U+FFFE may yield shorter sort keys. For details about Sort Key Features see http://userguide.icu-project.org/collation/api#TOC-Sort-Key-Features It is possible to merge multiple sort keys by consecutively merging another one with the intermediate result. Only the sort key bytes of the CollationKeys are merged. This API does not attempt to merge the String representations of the CollationKeys, hence null will be returned as the result's String representation. Example (uncompressed):", "history": "Added in API level 24", "FullName": "public CollationKey merge (CollationKey source)"}, "getBound(int,int)": {"Returns": [["@B_android#icu#text#CollationKey_E@", "the result bounded CollationKey with a valid sort order but a null String representation."]], "Parameters": [["int", "int: Mode of bound required. It can be BoundMode.LOWER, which produces a lower inclusive bound, BoundMode.UPPER, that produces upper bound that matches strings of the same length or BoundMode.UPPER_LONG that matches strings that have the same starting substring as the source string."], ["int", "int: Strength levels required in the resulting bound (for most uses, the recommended value is PRIMARY). This strength should be less than the maximum strength of this CollationKey. See users guide for explanation on the strength levels a collation key can have."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown when the strength level requested is higher than or equal to the strength in this CollationKey. In the case of an Exception, information about the maximum strength to use will be returned in the Exception. The user can then call getBound() again with the appropriate strength."]], "SeeAlso": ["@B_android#icu#text#CollationKey_E@", "@B_android#icu#text#CollationKey#BoundMode_E@", "@B_android#icu#text#Collator_E@"], "Permissions": [], "Description": "Produces a bound for the sort order of a given collation key and a strength level. This API does not attempt to find a bound for the CollationKey String representation, hence null will be returned in its place. Resulting bounds can be used to produce a range of strings that are between upper and lower bounds. For example, if bounds are produced for a sortkey of string \"smith\", strings between upper and lower bounds with primary strength would include \"Smith\", \"SMITH\", \"sMiTh\". There are two upper bounds that can be produced. If BoundMode.UPPER is produced, strings matched would be as above. However, if a bound is produced using BoundMode.UPPER_LONG is used, the above example will also match \"Smithsonian\" and similar. For more on usage, see example in test procedure Collation keys produced may be compared using the", "history": "Added in API level 24", "FullName": "public CollationKey getBound (int boundType, int noOfLevels)"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if the two keys compare as equal, false otherwise."]], "Parameters": [["@B_java#lang#Object_E@", "Object: the object to compare to."]], "Throws": [["@B_java#lang#ClassCastException_E@", "is thrown when the argument is not a CollationKey. NullPointerException is thrown when the argument is null."]], "SeeAlso": ["@B_android#icu#text#CollationKey#compareTo_E@"], "Permissions": [], "Description": "Compare this CollationKey and the specified Object for equality. The collation rules of the Collator that created this key are applied. See note in compareTo(CollationKey) for warnings about possible incorrect results.", "history": "Added in API level 24", "FullName": "public boolean equals (Object target)"}, "CollationKey(java.lang.String,byte[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: string this CollationKey is to represent"], ["byte[]", "byte: array of bytes that represent the collation order of argument source terminated by a null"]], "Throws": [], "SeeAlso": ["@B_android#icu#text#Collator_E@"], "Permissions": [], "Description": "CollationKey constructor. This constructor is given public access, unlike the JDK version, to allow access to users extending the Collator class. See @B_android#icu#text#Collator#getCollationKey_E@.", "history": "Added in API level 24", "FullName": "public CollationKey (String source, byte[] key)"}, "toByteArray()": {"Returns": [["byte[]", "CollationKey value in a sequence of big-endian byte bytes terminated by a null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Duplicates and returns the value of this CollationKey as a sequence of big-endian bytes terminated by a null. If two CollationKeys can be legitimately compared, then one can compare the byte arrays of each to obtain the same result, e.g.", "history": "Added in API level 24", "FullName": "public byte[] toByteArray ()"}, "equals(android.icu.text.CollationKey)": {"Returns": [["boolean", "true if two objects are equal, false otherwise."]], "Parameters": [["@B_android#icu#text#CollationKey_E@", "CollationKey: the CollationKey to compare to."]], "Throws": [["@B_java#lang#NullPointerException_E@", "is thrown when the argument is null."]], "SeeAlso": [], "Permissions": [], "Description": "Compare this CollationKey and the argument target CollationKey for equality. The collation rules of the Collator object which created these objects are applied. See note in compareTo(CollationKey) for warnings of incorrect results", "history": "Added in API level 24", "FullName": "public boolean equals (CollationKey target)"}, "getBound(int, int)": {"Returns": [["@B_android#icu#text#CollationKey_E@", "the result bounded CollationKey with a valid sort order but a null String representation."]], "Parameters": [["int", "int: Mode of bound required. It can be BoundMode.LOWER, which produces a lower inclusive bound, BoundMode.UPPER, that produces upper bound that matches strings of the same length or BoundMode.UPPER_LONG that matches strings that have the same starting substring as the source string."], ["int", "int: Strength levels required in the resulting bound (for most uses, the recommended value is PRIMARY). This strength should be less than the maximum strength of this CollationKey. See users guide for explanation on the strength levels a collation key can have."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "thrown when the strength level requested is higher than or equal to the strength in this CollationKey. In the case of an Exception, information about the maximum strength to use will be returned in the Exception. The user can then call getBound() again with the appropriate strength."]], "SeeAlso": ["@B_android#icu#text#CollationKey_E@", "@B_android#icu#text#CollationKey#BoundMode_E@", "@B_android#icu#text#Collator_E@"], "Permissions": [], "Description": "Produces a bound for the sort order of a given collation key and a strength level. This API does not attempt to find a bound for the CollationKey String representation, hence null will be returned in its place. Resulting bounds can be used to produce a range of strings that are between upper and lower bounds. For example, if bounds are produced for a sortkey of string \"smith\", strings between upper and lower bounds with primary strength would include \"Smith\", \"SMITH\", \"sMiTh\". There are two upper bounds that can be produced. If BoundMode.UPPER is produced, strings matched would be as above. However, if a bound is produced using BoundMode.UPPER_LONG is used, the above example will also match \"Smithsonian\" and similar. For more on usage, see example in test procedure Collation keys produced may be compared using the", "history": "added in API level 24", "FullName": "public CollationKey getBound (int boundType, int noOfLevels)"}, "hashCode()": {"Returns": [["int", "the hash value."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash code for this CollationKey. The hash value is calculated on the key itself, not the String from which the key was created. Thus if x and y are CollationKeys, then x.hashCode(x) == y.hashCode() if x.equals(y) is true. This allows language-sensitive comparison in a hash table.", "history": "Added in API level 24", "FullName": "public int hashCode ()"}}, "Inheritance": [], "ClassName": "android.icu.text.CollationKey", "ClassDesc": "A CollationKey represents a String under the rules of a specific Collator object. Comparing two CollationKeys returns the relative order of the Strings they represent. Since the rule set of Collators can differ, the sort orders of the same string under two different Collators might differ. Hence comparing CollationKeys generated from different Collators can give incorrect results. Both the method CollationKey.compareTo(CollationKey) and the method Collator.compare(String, String) compare two strings and returns their relative order. The performance characteristics of these two approaches can differ. Note that collation keys are often less efficient than simply doing comparison. For more details, see the ICU User Guide. During the construction of a CollationKey, the entire source string is examined and processed into a series of bits terminated by a null, that are stored in the CollationKey. When CollationKey.compareTo(CollationKey) executes, it performs bitwise comparison on the bit sequences. This can incurs startup cost when creating the CollationKey, but once the key is created, binary comparisons are fast. This approach is recommended when the same strings are to be compared over and over again. On the other hand, implementations of Collator.compare(String, String) can examine and process the strings only until the first characters differing in order. This approach is recommended if the strings are to be compared only once. More information about the composition of the bit sequence can be found in the The following example shows how CollationKeys can be used to sort a list of Strings. This class is not subclassable"}