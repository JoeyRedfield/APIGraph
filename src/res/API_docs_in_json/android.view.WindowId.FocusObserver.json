{"Functions": {"onFocusLost(android.view.WindowId)": {"Returns": [], "Parameters": [["@B_android#view#WindowId_E@", "WindowId no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when one of the monitored windows loses input focus.", "history": "Added in API level 18", "FullName": "public abstract void onFocusLost (WindowId token)"}, "WindowId.FocusObserver()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Construct a new observer. This observer will be configured so that all of its callbacks are dispatched on the current calling thread.", "history": "Added in API level 18", "FullName": "public WindowId.FocusObserver ()"}, "onFocusGained(android.view.WindowId)": {"Returns": [], "Parameters": [["@B_android#view#WindowId_E@", "WindowId no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when one of the monitored windows gains input focus.", "history": "Added in API level 18", "FullName": "public abstract void onFocusGained (WindowId token)"}}, "Inheritance": [], "ClassName": "android.view.WindowId.FocusObserver", "ClassDesc": "Subclass for observing changes to the focus state of an @B_android#view#WindowId_E@. You should use the same instance of this class for observing multiple @B_android#view#WindowId_E@ objects, since this class is fairly heavy-weight -- the base class includes all of the mechanisms for connecting to and receiving updates from the window."}