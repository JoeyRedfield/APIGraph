{"Functions": {"call(java.lang.String,java.lang.String,android.os.Bundle)": {"Returns": [["@B_android#os#Bundle_E@", "This value may be null."]], "Parameters": [["@B_java#lang#String_E@", "String: This value must never be null."], ["@B_java#lang#String_E@", "String: This value may be null."], ["@B_android#os#Bundle_E@", "Bundle: This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 11", "FullName": "public Bundle call (String method, String arg, Bundle extras)"}, "setWritePermission(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Name of the permission required for read/write access. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change the permission required to read and write data in the content provider. This is normally set for you from its manifest information when the provider is first created.", "history": "Added in API level 1", "FullName": "protected final void setWritePermission (String permission)"}, "delete(android.net.Uri,java.lang.String,java.lang.String[])": {"Returns": [["int", "The number of rows affected."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The full URI to query, including a row ID (if a specific record is requested). This value must never be null."], ["@B_java#lang#String_E@", "String: An optional restriction to apply to rows when deleting. This value may be null."], ["@B_java#lang#String_E@", "String: This value may be null."]], "Throws": [["", "android.database.SQLException"]], "SeeAlso": [], "Permissions": [], "Description": "Implement this to handle requests to delete one or more rows. The implementation should apply the selection clause when performing deletion, allowing the operation to affect multiple rows in a directory. As a courtesy, call @B_android#content#ContentResolver#notifyChange_E@ after deleting. This method can be called from multiple threads, as described in The implementation is responsible for parsing out a row ID at the end of the URI, if a specific row is being deleted. That is, the client would pass in content://contacts/people/22 and the implementation is responsible for parsing the record number (22) when creating a SQL statement.", "history": "Added in API level 1", "FullName": "public abstract int delete (Uri uri, String selection, String[] selectionArgs)"}, "onConfigurationChanged(android.content.res.Configuration)": {"Returns": [], "Parameters": [["@B_android#content#res#Configuration_E@", "Configuration: The new device configuration. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system when the device configuration changes while your component is running. Note that, unlike activities, other components are never restarted when a configuration changes: they must always deal with the results of the change, such as by re-retrieving resources. At the time that this function has been called, your Resources object will have been updated to return resource values matching the new configuration. For more information, read The default content provider implementation does nothing. Override this method to take appropriate action. (Content providers do not usually care about things like screen orientation, but may want to know about locale changes.)", "history": "Added in API level 1", "FullName": "public void onConfigurationChanged (Configuration newConfig)"}, "getWritePermission()": {"Returns": [["@B_java#lang#String_E@", "This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the name of the permission required for read/write access to this content provider. This method can be called from multiple threads, as described in", "history": "Added in API level 1", "FullName": "public final String getWritePermission ()"}, "openAssetFile(android.net.Uri,java.lang.String)": {"Returns": [["@B_android#content#res#AssetFileDescriptor_E@", "Returns a new AssetFileDescriptor which you can use to access the file. This value may be null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI whose file is to be opened. This value must never be null."], ["@B_java#lang#String_E@", "String: Access mode for the file. May be \"r\" for read-only access, \"w\" for write-only access (erasing whatever data is currently in the file), \"wa\" for write-only access to append to any existing data, \"rw\" for read and write access on any existing data, and \"rwt\" for read and write access that truncates any existing file. This value must never be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", "Throws FileNotFoundException if there is no file associated with the given URI or the mode is invalid."], ["@B_java#lang#SecurityException_E@", "Throws SecurityException if the caller does not have permission to access the file."]], "SeeAlso": ["@B_android#content#ContentProvider#openFile_E@", "@B_android#content#ContentProvider#openFileHelper_E@", "@B_android#content#ContentProvider#getType_E@"], "Permissions": [], "Description": "This is like @B_android#content#ContentProvider#openFile_E@, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk. This method can be called from multiple threads, as described in If you implement this, your clients must be able to deal with such file slices, either directly with @B_android#content#ContentResolver#openAssetFileDescriptor_E@, or by using the higher-level @B_android#content#ContentResolver#openInputStream_E@ or @B_android#content#ContentResolver#openOutputStream_E@ methods. The returned AssetFileDescriptor can be a pipe or socket pair to enable streaming of data. If you are implementing this to return a full file, you should create the AssetFileDescriptor with @B_android#content#res#AssetFileDescriptor#UNKNOWN_LENGTH_E@ to be compatible with applications that cannot handle sub-sections of files. For use in Intents, you will want to implement @B_android#content#ContentProvider#getType_E@ to return the appropriate MIME type for the data returned here with the same URI. This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation. For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by @B_android#provider#OpenableColumns_E@.", "history": "Added in API level 3", "FullName": "public AssetFileDescriptor openAssetFile (Uri uri, String mode)"}, "getContext()": {"Returns": [["@B_android#content#Context_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieves the Context this provider is running in. Only available once @B_android#content#ContentProvider#onCreate_E@ has been called -- this will return null in the constructor.", "history": "Added in API level 1", "FullName": "public final Context getContext ()"}, "getStreamTypes(android.net.Uri, java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "Returns null if there are no possible data streams for the given mimeTypeFilter. Otherwise returns an array of all available concrete MIME types."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The data in the content provider being queried.This value must never be null."], ["@B_java#lang#String_E@", "String: The type of data the client desires. May be a pattern, such as */* to retrieve all possible data types.This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#ContentProvider#getType_E@", "@B_android#content#ContentProvider#openTypedAssetFile_E@", "@B_android#content#ClipDescription#compareMimeTypes_E@"], "Permissions": [], "Description": "Called by a client to determine the types of data streams that this content provider supports for the given URI. The default implementation returns null, meaning no types. If your content provider stores data of a particular type, return that MIME type if it matches the given mimeTypeFilter. If it can perform type conversions, return an array of all supported MIME types that match mimeTypeFilter.", "history": "added in API level 11", "FullName": "public String[] getStreamTypes (Uri uri, String mimeTypeFilter)"}, "applyBatch(java.util.ArrayList<android.content.ContentProviderOperation>)": {"Returns": [["@B_android#content#ContentProviderResult_E@", "This value will never be null."]], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: This value must never be null."]], "Throws": [["@B_android#content#OperationApplicationException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 5", "FullName": "public ContentProviderResult[] applyBatch (ArrayList<ContentProviderOperation> operations)"}, "insert(android.net.Uri,android.content.ContentValues)": {"Returns": [["@B_android#net#Uri_E@", "The URI for the newly inserted item."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The content:// URI of the insertion request. This must not be null. This value must never be null."], ["@B_android#content#ContentValues_E@", "ContentValues: A set of column_name/value pairs to add to the database. This must not be null. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to handle requests to insert a new row. As a courtesy, call @B_android#content#ContentResolver#notifyChange_E@ after inserting. This method can be called from multiple threads, as described in", "history": "Added in API level 1", "FullName": "public abstract Uri insert (Uri uri, ContentValues values)"}, "refresh(android.net.Uri,android.os.Bundle,android.os.CancellationSignal)": {"Returns": [["boolean", "true if the provider actually tried refreshing."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The Uri identifying the data to refresh."], ["@B_android#os#Bundle_E@", "Bundle: Additional options from the client. The definitions of these are specific to the content provider being called. This value may be null."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. For example, if you called refresh on a particular uri, you should call @B_android#os#CancellationSignal#throwIfCanceled_E@ to check whether the client has canceled the refresh request. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to support refresh of content identified by uri. By default, this method returns false; providers who wish to implement this should return true to signal the client that the provider has tried refreshing with its own implementation. This allows clients to request an explicit refresh of content identified by uri. Client code should only invoke this method when there is a strong indication (such as a user initiated pull to refresh gesture) that the content is stale. Remember to send @B_android#content#ContentResolver#notifyChange_E@ notifications when content changes.", "history": "Added in API level 26", "FullName": "public boolean refresh (Uri uri, Bundle args, CancellationSignal cancellationSignal)"}, "getReadPermission()": {"Returns": [["@B_java#lang#String_E@", "This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the name of the permission required for read-only access to this content provider. This method can be called from multiple threads, as described in", "history": "Added in API level 1", "FullName": "public final String getReadPermission ()"}, "query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)": {"Returns": [["@B_android#database#Cursor_E@", "a Cursor or null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI to query. This will be the full URI sent by the client; if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value. This value must never be null."], ["@B_java#lang#String_E@", "String: The list of columns to put into the cursor. If null all columns are included. This value may be null."], ["@B_java#lang#String_E@", "String: A selection criteria to apply when filtering rows. If null then all rows are included. This value may be null."], ["@B_java#lang#String_E@", "String: You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings. This value may be null."], ["@B_java#lang#String_E@", "String: How the rows in the cursor should be sorted. If null then the provider is free to define the sort order. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to handle query requests from clients. Apps targeting @B_android#os#Build#VERSION_CODES#O_E@ or higher should override @B_android#content#ContentProvider#query_E@ and provide a stub implementation of this method. This method can be called from multiple threads, as described in Example client call:", "history": "Added in API level 1", "FullName": "public abstract Cursor query (Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)"}, "openFile(android.net.Uri,java.lang.String,android.os.CancellationSignal)": {"Returns": [["@B_android#os#ParcelFileDescriptor_E@", "Returns a new ParcelFileDescriptor which you can use to access the file."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI whose file is to be opened. This value must never be null."], ["@B_java#lang#String_E@", "String: Access mode for the file. May be \"r\" for read-only access, \"w\" for write-only access, \"rw\" for read and write access, or \"rwt\" for read and write access that truncates any existing file. This value must never be null."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. For example, if you are downloading a file from the network to service a \"rw\" mode request, you should periodically call @B_android#os#CancellationSignal#throwIfCanceled_E@ to check whether the client has canceled the request and abort the download. This value may be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", "Throws FileNotFoundException if there is no file associated with the given URI or the mode is invalid."], ["@B_java#lang#SecurityException_E@", "Throws SecurityException if the caller does not have permission to access the file."]], "SeeAlso": ["@B_android#content#ContentProvider#openAssetFile_E@", "@B_android#content#ContentProvider#openFileHelper_E@", "@B_android#content#ContentProvider#getType_E@", "@B_android#os#ParcelFileDescriptor#parseMode_E@"], "Permissions": [], "Description": "Override this to handle requests to open a file blob. The default implementation always throws @B_java#io#FileNotFoundException_E@. This method can be called from multiple threads, as described in This method returns a ParcelFileDescriptor, which is returned directly to the caller. This way large data (such as images and documents) can be returned without copying the content. The returned ParcelFileDescriptor is owned by the caller, so it is their responsibility to close it when done. That is, the implementation of this method should create a new ParcelFileDescriptor for each call. If opened with the exclusive \"r\" or \"w\" modes, the returned ParcelFileDescriptor can be a pipe or socket pair to enable streaming of data. Opening with the \"rw\" or \"rwt\" modes implies a file on disk that supports seeking. If you need to detect when the returned ParcelFileDescriptor has been closed, or if the remote process has crashed or encountered some other error, you can use @B_android#os#ParcelFileDescriptor#open_E@, @B_android#os#ParcelFileDescriptor#createReliablePipe_E@, or @B_android#os#ParcelFileDescriptor#createReliableSocketPair_E@. For use in Intents, you will want to implement @B_android#content#ContentProvider#getType_E@ to return the appropriate MIME type for the data returned here with the same URI. This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation. For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by @B_android#provider#OpenableColumns_E@. You may also want to support other common columns if you have additional meta-data to supply, such as @B_android#provider#MediaStore#MediaColumns#DATE_ADDED_E@ in @B_android#provider#MediaStore#MediaColumns_E@.", "history": "Added in API level 19", "FullName": "public ParcelFileDescriptor openFile (Uri uri, String mode, CancellationSignal signal)"}, "openFileHelper(android.net.Uri,java.lang.String)": {"Returns": [["@B_android#os#ParcelFileDescriptor_E@", "Returns a new ParcelFileDescriptor that can be used by the client to access the file. This value will never be null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI to be opened. This value must never be null."], ["@B_java#lang#String_E@", "String: The file mode. May be \"r\" for read-only access, \"w\" for write-only access (erasing whatever data is currently in the file), \"wa\" for write-only access to append to any existing data, \"rw\" for read and write access on any existing data, and \"rwt\" for read and write access that truncates any existing file. This value must never be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Convenience for subclasses that wish to implement @B_android#content#ContentProvider#openFile_E@ by looking up a column named \"_data\" at the given URI.", "history": "Added in API level 1", "FullName": "protected final ParcelFileDescriptor openFileHelper (Uri uri, String mode)"}, "setReadPermission(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Name of the permission required for read-only access. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change the permission required to read data from the content provider. This is normally set for you from its manifest information when the provider is first created.", "history": "Added in API level 1", "FullName": "protected final void setReadPermission (String permission)"}, "query(android.net.Uri,java.lang.String[],android.os.Bundle,android.os.CancellationSignal)": {"Returns": [["@B_android#database#Cursor_E@", "a Cursor or null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI to query. This will be the full URI sent by the client. This value must never be null."], ["@B_java#lang#String_E@", "String: The list of columns to put into the cursor. If null provide a default set of columns. This value may be null."], ["@B_android#os#Bundle_E@", "Bundle: A Bundle containing all additional information necessary for the query. Values in the Bundle may include SQL style arguments. This value may be null."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to handle query requests where the arguments are packed into a @B_android#os#Bundle_E@. Arguments may include traditional SQL style query arguments. When present these should be handled according to the contract established in @B_android#content#ContentProvider#query_E@. Traditional SQL arguments can be found in the bundle using the following keys: @B_android#content#ContentResolver#QUERY_ARG_SQL_SELECTION_E@ @B_android#content#ContentResolver#QUERY_ARG_SQL_SELECTION_ARGS_E@ @B_android#content#ContentResolver#QUERY_ARG_SQL_SORT_ORDER_E@ This method can be called from multiple threads, as described in Example client call: See @B_android#content#ContentProvider#query_E@ for implementation details.", "history": "Added in API level 26", "FullName": "public Cursor query (Uri uri, String[] projection, Bundle queryArgs, CancellationSignal cancellationSignal)"}, "onCreate()": {"Returns": [["boolean", "true if the provider was successfully loaded, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to initialize your content provider on startup. This method is called for all registered content providers on the application main thread at application launch time. It must not perform lengthy operations, or application startup will be delayed. You should defer nontrivial initialization (such as opening, upgrading, and scanning databases) until the content provider is used (via @B_android#content#ContentProvider#query_E@, @B_android#content#ContentProvider#insert_E@, etc). Deferred initialization keeps application startup fast, avoids unnecessary work if the provider turns out not to be needed, and stops database errors (such as a full disk) from halting application launch. If you use SQLite, @B_android#database#sqlite#SQLiteOpenHelper_E@ is a helpful utility class that makes it easy to manage databases, and will automatically defer opening until first use. If you do use SQLiteOpenHelper, make sure to avoid calling @B_android#database#sqlite#SQLiteOpenHelper#getReadableDatabase_E@ or @B_android#database#sqlite#SQLiteOpenHelper#getWritableDatabase_E@ from this method. (Instead, override @B_android#database#sqlite#SQLiteOpenHelper#onOpen_E@ to initialize the database when it is first opened.)", "history": "Added in API level 1", "FullName": "public abstract boolean onCreate ()"}, "openPipeHelper(android.net.Uri,java.lang.String,android.os.Bundle,T,android.content.ContentProvider.PipeDataWriter<T>)": {"Returns": [["@B_android#os#ParcelFileDescriptor_E@", "Returns a new ParcelFileDescriptor holding the read side of the pipe. This should be returned to the caller for reading; the caller is responsible for closing it when done. This value will never be null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI whose data is to be written. This value must never be null."], ["@B_java#lang#String_E@", "String: The desired type of data to be written. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: Options supplied by caller. This value may be null."], ["T", "T: Your own custom arguments. This value may be null."], ["@B_android#content#ContentProvider#PipeDataWriter_E@", "PipeDataWriter: Interface implementing the function that will actually stream the data. This value must never be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "A helper function for implementing @B_android#content#ContentProvider#openTypedAssetFile_E@, for creating a data pipe and background thread allowing you to stream generated data back to the client. This function returns a new ParcelFileDescriptor that should be returned to the caller (the caller is responsible for closing it).", "history": "Added in API level 11", "FullName": "public ParcelFileDescriptor openPipeHelper (Uri uri, String mimeType, Bundle opts, T args, PipeDataWriter<T> func)"}, "getStreamTypes(android.net.Uri,java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "Returns null if there are no possible data streams for the given mimeTypeFilter. Otherwise returns an array of all available concrete MIME types."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The data in the content provider being queried. This value must never be null."], ["@B_java#lang#String_E@", "String: The type of data the client desires. May be a pattern, such as */* to retrieve all possible data types. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#ContentProvider#getType_E@", "@B_android#content#ContentProvider#openTypedAssetFile_E@", "@B_android#content#ClipDescription#compareMimeTypes_E@"], "Permissions": [], "Description": "Called by a client to determine the types of data streams that this content provider supports for the given URI. The default implementation returns null, meaning no types. If your content provider stores data of a particular type, return that MIME type if it matches the given mimeTypeFilter. If it can perform type conversions, return an array of all supported MIME types that match mimeTypeFilter.", "history": "Added in API level 11", "FullName": "public String[] getStreamTypes (Uri uri, String mimeTypeFilter)"}, "getType(android.net.Uri)": {"Returns": [["@B_java#lang#String_E@", "a MIME type string, or null if there is no type."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: the URI to query. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to handle requests for the MIME type of the data at the given URI. The returned MIME type should start with vnd.android.cursor.item for a single record, or vnd.android.cursor.dir/ for multiple items. This method can be called from multiple threads, as described in Note that there are no permissions needed for an application to access this information; if your content provider requires read and/or write permissions, or is not exported, all applications can still call this method regardless of their access permissions. This allows them to retrieve the MIME type for a URI when dispatching intents.", "history": "Added in API level 1", "FullName": "public abstract String getType (Uri uri)"}, "setPathPermissions(android.content.pm.PathPermission[])": {"Returns": [], "Parameters": [["@B_android#content#pm#PathPermission_E@", "PathPermission: Array of path permission descriptions. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change the path-based permission required to read and/or write data in the content provider. This is normally set for you from its manifest information when the provider is first created.", "history": "Added in API level 4", "FullName": "protected final void setPathPermissions (PathPermission[] permissions)"}, "openFileHelper(android.net.Uri, java.lang.String)": {"Returns": [["@B_android#os#ParcelFileDescriptor_E@", "Returns a new ParcelFileDescriptor that can be used by the client to access the file. This value will never be null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI to be opened.This value must never be null."], ["@B_java#lang#String_E@", "String: The file mode. May be \"r\" for read-only access, \"w\" for write-only access (erasing whatever data is currently in the file), \"wa\" for write-only access to append to any existing data, \"rw\" for read and write access on any existing data, and \"rwt\" for read and write access that truncates any existing file.This value must never be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Convenience for subclasses that wish to implement @B_android#content#ContentProvider#openFile_E@ by looking up a column named \"_data\" at the given URI.", "history": "added in API level 1", "FullName": "protected final ParcelFileDescriptor openFileHelper (Uri uri, String mode)"}, "openFile(android.net.Uri, java.lang.String)": {"Returns": [["@B_android#os#ParcelFileDescriptor_E@", "Returns a new ParcelFileDescriptor which you can use to access the file.This value may be null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI whose file is to be opened.This value must never be null."], ["@B_java#lang#String_E@", "String: Access mode for the file. May be \"r\" for read-only access, \"rw\" for read and write access, or \"rwt\" for read and write access that truncates any existing file.This value must never be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", "Throws FileNotFoundException if there is no file associated with the given URI or the mode is invalid."], ["@B_java#lang#SecurityException_E@", "Throws SecurityException if the caller does not have permission to access the file."]], "SeeAlso": ["@B_android#content#ContentProvider#openAssetFile_E@", "@B_android#content#ContentProvider#openFileHelper_E@", "@B_android#content#ContentProvider#getType_E@", "@B_android#os#ParcelFileDescriptor#parseMode_E@"], "Permissions": [], "Description": "Override this to handle requests to open a file blob. The default implementation always throws @B_java#io#FileNotFoundException_E@. This method can be called from multiple threads, as described in This method returns a ParcelFileDescriptor, which is returned directly to the caller. This way large data (such as images and documents) can be returned without copying the content. The returned ParcelFileDescriptor is owned by the caller, so it is their responsibility to close it when done. That is, the implementation of this method should create a new ParcelFileDescriptor for each call. If opened with the exclusive \"r\" or \"w\" modes, the returned ParcelFileDescriptor can be a pipe or socket pair to enable streaming of data. Opening with the \"rw\" or \"rwt\" modes implies a file on disk that supports seeking. If you need to detect when the returned ParcelFileDescriptor has been closed, or if the remote process has crashed or encountered some other error, you can use @B_android#os#ParcelFileDescriptor#open_E@, @B_android#os#ParcelFileDescriptor#createReliablePipe_E@, or @B_android#os#ParcelFileDescriptor#createReliableSocketPair_E@. If you need to return a large file that isn't backed by a real file on disk, such as a file on a network share or cloud storage service, consider using @B_android#os#storage#StorageManager#openProxyFileDescriptor_E@ which will let you to stream the content on-demand. For use in Intents, you will want to implement @B_android#content#ContentProvider#getType_E@ to return the appropriate MIME type for the data returned here with the same URI. This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation. For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by @B_android#provider#OpenableColumns_E@. You may also want to support other common columns if you have additional meta-data to supply, such as @B_android#provider#MediaStore#MediaColumns#DATE_ADDED_E@ in @B_android#provider#MediaStore#MediaColumns_E@.", "history": "added in API level 1", "FullName": "public ParcelFileDescriptor openFile (Uri uri, String mode)"}, "openTypedAssetFile(android.net.Uri,java.lang.String,android.os.Bundle,android.os.CancellationSignal)": {"Returns": [["@B_android#content#res#AssetFileDescriptor_E@", "Returns a new AssetFileDescriptor from which the client can read data of the desired type."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The data in the content provider being queried. This value must never be null."], ["@B_java#lang#String_E@", "String: The type of data the client desires. May be a pattern, such as */*, if the caller does not have specific type requirements; in this case the content provider will pick its best type matching the pattern. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: Additional options from the client. The definitions of these are specific to the content provider being called. This value may be null."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. For example, if you are downloading a file from the network to service a \"rw\" mode request, you should periodically call @B_android#os#CancellationSignal#throwIfCanceled_E@ to check whether the client has canceled the request and abort the download. This value may be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", "Throws FileNotFoundException if there is no file associated with the given URI or the mode is invalid."], ["@B_java#lang#SecurityException_E@", "Throws SecurityException if the caller does not have permission to access the data."], ["@B_java#lang#IllegalArgumentException_E@", "Throws IllegalArgumentException if the content provider does not support the requested MIME type."]], "SeeAlso": ["@B_android#content#ContentProvider#getStreamTypes_E@", "@B_android#content#ContentProvider#openAssetFile_E@", "@B_android#content#ClipDescription#compareMimeTypes_E@"], "Permissions": [], "Description": "Called by a client to open a read-only stream containing data of a particular MIME type. This is like @B_android#content#ContentProvider#openAssetFile_E@, except the file can only be read-only and the content provider may perform data conversions to generate data of the desired type. The default implementation compares the given mimeType against the result of @B_android#content#ContentProvider#getType_E@ and, if they match, simply calls @B_android#content#ContentProvider#openAssetFile_E@. See @B_android#content#ClipData_E@ for examples of the use and implementation of this method. The returned AssetFileDescriptor can be a pipe or socket pair to enable streaming of data. For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by @B_android#provider#OpenableColumns_E@. You may also want to support other common columns if you have additional meta-data to supply, such as @B_android#provider#MediaStore#MediaColumns#DATE_ADDED_E@ in @B_android#provider#MediaStore#MediaColumns_E@.", "history": "Added in API level 19", "FullName": "public AssetFileDescriptor openTypedAssetFile (Uri uri, String mimeTypeFilter, Bundle opts, CancellationSignal signal)"}, "uncanonicalize(android.net.Uri)": {"Returns": [["@B_android#net#Uri_E@", "Return the non-canonical representation of url, return the url as-is if there is nothing to do, or return null if the data identified by the canonical representation can not be found in the current environment."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The Uri to remove any canonicalization from. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove canonicalization from canonical URIs previously returned by @B_android#content#ContentProvider#canonicalize_E@. For example, if your implementation is to add a query param to canonicalize a URI, this method can simply trip any query params on the URI. The default implementation always returns the same", "history": "Added in API level 19", "FullName": "public Uri uncanonicalize (Uri url)"}, "clearCallingIdentity()": {"Returns": [["@B_android#content#ContentProvider#CallingIdentity_E@", "Returns an opaque token that can be used to restore the original calling identity by passing it to @B_android#content#ContentProvider#restoreCallingIdentity_E@. This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reset the identity of the incoming IPC on the current thread. Internally this calls @B_android#os#Binder#clearCallingIdentity_E@ and also clears any value stored in @B_android#content#ContentProvider#getCallingPackage_E@.", "history": "Added in API level 29", "FullName": "public final ContentProvider.CallingIdentity clearCallingIdentity ()"}, "canonicalize(android.net.Uri)": {"Returns": [["@B_android#net#Uri_E@", "Return the canonical representation of url, or null if canonicalization of that Uri is not supported."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The Uri to canonicalize. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to support canonicalization of URIs that refer to your content provider. A canonical URI is one that can be transported across devices, backup/restore, and other contexts, and still be able to refer to the same data item. Typically this is implemented by adding query params to the URI allowing the content provider to verify that an incoming canonical URI references the same data as it was originally intended for and, if it doesn't, to find that data (if it exists) in the current environment. For example, if the content provider holds people and a normal URI in it is created with a row index into that people database, the cananical representation may have an additional query param at the end which specifies the name of the person it is intended for. Later calls into the provider with that URI will look up the row of that URI's base index and, if it doesn't match or its entry's name doesn't match the name in the query param, perform a query on its database to find the correct row to operate on. If you implement support for canonical URIs, @B_android#content#ContentProvider#uncanonicalize_E@ to strip the canonicalization of any of these URIs. The default implementation of this method returns null, indicating that canonical URIs are not supported.", "history": "Added in API level 19", "FullName": "public Uri canonicalize (Uri url)"}, "openFile(android.net.Uri,java.lang.String)": {"Returns": [["@B_android#os#ParcelFileDescriptor_E@", "Returns a new ParcelFileDescriptor which you can use to access the file. This value may be null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI whose file is to be opened. This value must never be null."], ["@B_java#lang#String_E@", "String: Access mode for the file. May be \"r\" for read-only access, \"rw\" for read and write access, or \"rwt\" for read and write access that truncates any existing file. This value must never be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", "Throws FileNotFoundException if there is no file associated with the given URI or the mode is invalid."], ["@B_java#lang#SecurityException_E@", "Throws SecurityException if the caller does not have permission to access the file."]], "SeeAlso": ["@B_android#content#ContentProvider#openAssetFile_E@", "@B_android#content#ContentProvider#openFileHelper_E@", "@B_android#content#ContentProvider#getType_E@", "@B_android#os#ParcelFileDescriptor#parseMode_E@"], "Permissions": [], "Description": "Override this to handle requests to open a file blob. The default implementation always throws @B_java#io#FileNotFoundException_E@. This method can be called from multiple threads, as described in This method returns a ParcelFileDescriptor, which is returned directly to the caller. This way large data (such as images and documents) can be returned without copying the content. The returned ParcelFileDescriptor is owned by the caller, so it is their responsibility to close it when done. That is, the implementation of this method should create a new ParcelFileDescriptor for each call. If opened with the exclusive \"r\" or \"w\" modes, the returned ParcelFileDescriptor can be a pipe or socket pair to enable streaming of data. Opening with the \"rw\" or \"rwt\" modes implies a file on disk that supports seeking. If you need to detect when the returned ParcelFileDescriptor has been closed, or if the remote process has crashed or encountered some other error, you can use @B_android#os#ParcelFileDescriptor#open_E@, @B_android#os#ParcelFileDescriptor#createReliablePipe_E@, or @B_android#os#ParcelFileDescriptor#createReliableSocketPair_E@. If you need to return a large file that isn't backed by a real file on disk, such as a file on a network share or cloud storage service, consider using @B_android#os#storage#StorageManager#openProxyFileDescriptor_E@ which will let you to stream the content on-demand. For use in Intents, you will want to implement @B_android#content#ContentProvider#getType_E@ to return the appropriate MIME type for the data returned here with the same URI. This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation. For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by @B_android#provider#OpenableColumns_E@. You may also want to support other common columns if you have additional meta-data to supply, such as @B_android#provider#MediaStore#MediaColumns#DATE_ADDED_E@ in @B_android#provider#MediaStore#MediaColumns_E@.", "history": "Added in API level 1", "FullName": "public ParcelFileDescriptor openFile (Uri uri, String mode)"}, "getPathPermissions()": {"Returns": [["@B_android#content#pm#PathPermission_E@", "This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the path-based permissions required for read and/or write access to this content provider. This method can be called from multiple threads, as described in", "history": "Added in API level 4", "FullName": "public final PathPermission[] getPathPermissions ()"}, "ContentProvider()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Construct a ContentProvider instance. Content providers must be @B_android#content#ContentResolver_E@, and created automatically by the system, so applications usually do not create ContentProvider instances directly. At construction time, the object is uninitialized, and most fields and methods are unavailable. Subclasses should initialize themselves in @B_android#content#ContentProvider#onCreate_E@, not the constructor. Content providers are created on the application main thread at application launch time. The constructor must not perform lengthy operations, or application startup will be delayed.", "history": "Added in API level 1", "FullName": "public ContentProvider ()"}, "openAssetFile(android.net.Uri, java.lang.String)": {"Returns": [["@B_android#content#res#AssetFileDescriptor_E@", "Returns a new AssetFileDescriptor which you can use to access the file.This value may be null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI whose file is to be opened.This value must never be null."], ["@B_java#lang#String_E@", "String: Access mode for the file. May be \"r\" for read-only access, \"w\" for write-only access (erasing whatever data is currently in the file), \"wa\" for write-only access to append to any existing data, \"rw\" for read and write access on any existing data, and \"rwt\" for read and write access that truncates any existing file.This value must never be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", "Throws FileNotFoundException if there is no file associated with the given URI or the mode is invalid."], ["@B_java#lang#SecurityException_E@", "Throws SecurityException if the caller does not have permission to access the file."]], "SeeAlso": ["@B_android#content#ContentProvider#openFile_E@", "@B_android#content#ContentProvider#openFileHelper_E@", "@B_android#content#ContentProvider#getType_E@"], "Permissions": [], "Description": "This is like @B_android#content#ContentProvider#openFile_E@, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk. This method can be called from multiple threads, as described in If you implement this, your clients must be able to deal with such file slices, either directly with @B_android#content#ContentResolver#openAssetFileDescriptor_E@, or by using the higher-level @B_android#content#ContentResolver#openInputStream_E@ or @B_android#content#ContentResolver#openOutputStream_E@ methods. The returned AssetFileDescriptor can be a pipe or socket pair to enable streaming of data. If you are implementing this to return a full file, you should create the AssetFileDescriptor with @B_android#content#res#AssetFileDescriptor#UNKNOWN_LENGTH_E@ to be compatible with applications that cannot handle sub-sections of files. For use in Intents, you will want to implement @B_android#content#ContentProvider#getType_E@ to return the appropriate MIME type for the data returned here with the same URI. This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation. For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by @B_android#provider#OpenableColumns_E@.", "history": "added in API level 3", "FullName": "public AssetFileDescriptor openAssetFile (Uri uri, String mode)"}, "openTypedAssetFile(android.net.Uri,java.lang.String,android.os.Bundle)": {"Returns": [["@B_android#content#res#AssetFileDescriptor_E@", "Returns a new AssetFileDescriptor from which the client can read data of the desired type. This value may be null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The data in the content provider being queried. This value must never be null."], ["@B_java#lang#String_E@", "String: The type of data the client desires. May be a pattern, such as */*, if the caller does not have specific type requirements; in this case the content provider will pick its best type matching the pattern. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: Additional options from the client. The definitions of these are specific to the content provider being called. This value may be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", "Throws FileNotFoundException if there is no file associated with the given URI or the mode is invalid."], ["@B_java#lang#SecurityException_E@", "Throws SecurityException if the caller does not have permission to access the data."], ["@B_java#lang#IllegalArgumentException_E@", "Throws IllegalArgumentException if the content provider does not support the requested MIME type."]], "SeeAlso": ["@B_android#content#ContentProvider#getStreamTypes_E@", "@B_android#content#ContentProvider#openAssetFile_E@", "@B_android#content#ClipDescription#compareMimeTypes_E@"], "Permissions": [], "Description": "Called by a client to open a read-only stream containing data of a particular MIME type. This is like @B_android#content#ContentProvider#openAssetFile_E@, except the file can only be read-only and the content provider may perform data conversions to generate data of the desired type. The default implementation compares the given mimeType against the result of @B_android#content#ContentProvider#getType_E@ and, if they match, simply calls @B_android#content#ContentProvider#openAssetFile_E@. See @B_android#content#ClipData_E@ for examples of the use and implementation of this method. The returned AssetFileDescriptor can be a pipe or socket pair to enable streaming of data. For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by @B_android#provider#OpenableColumns_E@. You may also want to support other common columns if you have additional meta-data to supply, such as @B_android#provider#MediaStore#MediaColumns#DATE_ADDED_E@ in @B_android#provider#MediaStore#MediaColumns_E@.", "history": "Added in API level 11", "FullName": "public AssetFileDescriptor openTypedAssetFile (Uri uri, String mimeTypeFilter, Bundle opts)"}, "openAssetFile(android.net.Uri,java.lang.String,android.os.CancellationSignal)": {"Returns": [["@B_android#content#res#AssetFileDescriptor_E@", "Returns a new AssetFileDescriptor which you can use to access the file."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI whose file is to be opened. This value must never be null."], ["@B_java#lang#String_E@", "String: Access mode for the file. May be \"r\" for read-only access, \"w\" for write-only access (erasing whatever data is currently in the file), \"wa\" for write-only access to append to any existing data, \"rw\" for read and write access on any existing data, and \"rwt\" for read and write access that truncates any existing file. This value must never be null."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. For example, if you are downloading a file from the network to service a \"rw\" mode request, you should periodically call @B_android#os#CancellationSignal#throwIfCanceled_E@ to check whether the client has canceled the request and abort the download. This value may be null."]], "Throws": [["@B_java#io#FileNotFoundException_E@", "Throws FileNotFoundException if there is no file associated with the given URI or the mode is invalid."], ["@B_java#lang#SecurityException_E@", "Throws SecurityException if the caller does not have permission to access the file."]], "SeeAlso": ["@B_android#content#ContentProvider#openFile_E@", "@B_android#content#ContentProvider#openFileHelper_E@", "@B_android#content#ContentProvider#getType_E@"], "Permissions": [], "Description": "This is like @B_android#content#ContentProvider#openFile_E@, but can be implemented by providers that need to be able to return sub-sections of files, often assets inside of their .apk. This method can be called from multiple threads, as described in If you implement this, your clients must be able to deal with such file slices, either directly with @B_android#content#ContentResolver#openAssetFileDescriptor_E@, or by using the higher-level @B_android#content#ContentResolver#openInputStream_E@ or @B_android#content#ContentResolver#openOutputStream_E@ methods. The returned AssetFileDescriptor can be a pipe or socket pair to enable streaming of data. If you are implementing this to return a full file, you should create the AssetFileDescriptor with @B_android#content#res#AssetFileDescriptor#UNKNOWN_LENGTH_E@ to be compatible with applications that cannot handle sub-sections of files. For use in Intents, you will want to implement @B_android#content#ContentProvider#getType_E@ to return the appropriate MIME type for the data returned here with the same URI. This will allow intent resolution to automatically determine the data MIME type and select the appropriate matching targets as part of its operation. For better interoperability with other applications, it is recommended that for any URIs that can be opened, you also support queries on them containing at least the columns specified by @B_android#provider#OpenableColumns_E@.", "history": "Added in API level 19", "FullName": "public AssetFileDescriptor openAssetFile (Uri uri, String mode, CancellationSignal signal)"}, "shutdown()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to shut down the ContentProvider instance. You can then invoke this method in unit tests. Android normally handles ContentProvider startup and shutdown automatically. You do not need to start up or shut down a ContentProvider. When you invoke a test method on a ContentProvider, however, a ContentProvider instance is started and keeps running after the test finishes, even if a succeeding test instantiates another ContentProvider. A conflict develops because the two instances are usually running against the same underlying data source (for example, an sqlite database). Implementing shutDown() avoids this conflict by providing a way to terminate the ContentProvider. This method can also prevent memory leaks from multiple instantiations of the ContentProvider, and it can ensure unit test isolation by allowing you to completely clean up the test fixture before moving on to the next test.", "history": "Added in API level 11", "FullName": "public void shutdown ()"}, "isTemporary()": {"Returns": [["boolean", "true if this instance is a temporary content provider"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this instance is a temporary content provider.", "history": "Added in API level 1", "FullName": "protected boolean isTemporary ()"}, "onLowMemory()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the overall system is running low on memory, and actively running processes should trim their memory usage. While the exact point at which this will be called is not defined, generally it will happen when all background process have been killed. That is, before reaching the point of killing processes hosting service and foreground UI that we would like to avoid killing. You should implement this method to release any caches or other unnecessary resources you may be holding on to. The system will perform a garbage collection for you after returning from this method. Preferably, you should implement @B_android#content#ComponentCallbacks2#onTrimMemory_E@ from @B_android#content#ComponentCallbacks2_E@ to incrementally unload your resources based on various levels of memory demands. That API is available for API level 14 and higher, so you should only use this @B_android#content#ComponentCallbacks#onLowMemory_E@ method as a fallback for older versions, which can be treated the same as @B_android#content#ComponentCallbacks2#onTrimMemory_E@ with the @B_android#content#ComponentCallbacks2#TRIM_MEMORY_COMPLETE_E@ level. This method is always called on the application main thread, and must not perform lengthy operations. The default content provider implementation does nothing. Subclasses may override this method to take appropriate action.", "history": "Added in API level 1", "FullName": "public void onLowMemory ()"}, "call(java.lang.String,java.lang.String,java.lang.String,android.os.Bundle)": {"Returns": [["@B_android#os#Bundle_E@", "provider-defined return value. May be null, which is also the default for providers which don't implement any call methods."]], "Parameters": [["@B_java#lang#String_E@", "String: This value must never be null."], ["@B_java#lang#String_E@", "String: method name to call. Opaque to framework, but should not be null. This value must never be null."], ["@B_java#lang#String_E@", "String: provider-defined String argument. May be null. This value may be null."], ["@B_android#os#Bundle_E@", "Bundle: provider-defined Bundle argument. May be null. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call a provider-defined method. This can be used to implement interfaces that are cheaper and/or unnatural for a table-like model.", "history": "Added in API level 29", "FullName": "public Bundle call (String authority, String method, String arg, Bundle extras)"}, "update(android.net.Uri,android.content.ContentValues,java.lang.String,java.lang.String[])": {"Returns": [["int", "the number of rows affected."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI to query. This can potentially have a record ID if this is an update request for a specific record. This value must never be null."], ["@B_android#content#ContentValues_E@", "ContentValues: A set of column_name/value pairs to update in the database. This must not be null. This value may be null."], ["@B_java#lang#String_E@", "String: An optional filter to match rows to update. This value may be null."], ["@B_java#lang#String_E@", "String: This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to handle requests to update one or more rows. The implementation should update all rows matching the selection to set the columns according to the provided values map. As a courtesy, call @B_android#content#ContentResolver#notifyChange_E@ after updating. This method can be called from multiple threads, as described in", "history": "Added in API level 1", "FullName": "public abstract int update (Uri uri, ContentValues values, String selection, String[] selectionArgs)"}, "bulkInsert(android.net.Uri,android.content.ContentValues[])": {"Returns": [["int", "The number of values that were inserted."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The content:// URI of the insertion request. This value must never be null."], ["@B_android#content#ContentValues_E@", "ContentValues: An array of sets of column_name/value pairs to add to the database. This must not be null. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Override this to handle requests to insert a set of new rows, or the default implementation will iterate over the values and call @B_android#content#ContentProvider#insert_E@ on each of them. As a courtesy, call @B_android#content#ContentResolver#notifyChange_E@ after inserting. This method can be called from multiple threads, as described in", "history": "Added in API level 1", "FullName": "public int bulkInsert (Uri uri, ContentValues[] values)"}, "dump(java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: The raw file descriptor that the dump is being sent to."], ["@B_java#io#PrintWriter_E@", "PrintWriter: The PrintWriter to which you should dump your state. This will be closed for you after you return."], ["@B_java#lang#String_E@", "String: additional arguments to the dump request."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Print the Provider's state into the given stream. This gets invoked if you run \"adb shell dumpsys activity provider <provider_component_name>\".", "history": "Added in API level 18", "FullName": "public void dump (FileDescriptor fd, PrintWriter writer, String[] args)"}, "restoreCallingIdentity(android.content.ContentProvider.CallingIdentity)": {"Returns": [], "Parameters": [["@B_android#content#ContentProvider#CallingIdentity_E@", "ContentProvider.CallingIdentity: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Restore the identity of the incoming IPC on the current thread back to a previously identity that was returned by @B_android#content#ContentProvider#clearCallingIdentity_E@. Internally this calls @B_android#os#Binder#restoreCallingIdentity_E@ and also restores any value stored in @B_android#content#ContentProvider#getCallingPackage_E@.", "history": "Added in API level 29", "FullName": "public final void restoreCallingIdentity (ContentProvider.CallingIdentity identity)"}, "onTrimMemory(int)": {"Returns": [], "Parameters": [["int", "int: The context of the trim, giving a hint of the amount of trimming the application may like to perform. Value is @B_android#content#ComponentCallbacks2#TRIM_MEMORY_COMPLETE_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_MODERATE_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_BACKGROUND_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_UI_HIDDEN_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_RUNNING_CRITICAL_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_RUNNING_LOW_E@, or @B_android#content#ComponentCallbacks2#TRIM_MEMORY_RUNNING_MODERATE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process. This will happen for example when it goes in the background and there is not enough memory to keep as many background processes running as desired. You should never compare to exact values of the level, since new intermediate values may be added -- you will typically want to compare if the value is greater or equal to a level you are interested in. To retrieve the processes current trim level at any point, you can use @B_android#app#ActivityManager#getMyMemoryState_E@.", "history": "Added in API level 14", "FullName": "public void onTrimMemory (int level)"}, "applyBatch(java.lang.String,java.util.ArrayList<android.content.ContentProviderOperation>)": {"Returns": [["@B_android#content#ContentProviderResult_E@", "the results of the applications This value will never be null."]], "Parameters": [["@B_java#lang#String_E@", "String: This value must never be null."], ["@B_java#util#ArrayList_E@", "ArrayList: the operations to apply This value must never be null."]], "Throws": [["@B_android#content#OperationApplicationException_E@", "thrown if any operation fails."]], "SeeAlso": ["@B_android#content#ContentProviderOperation#apply_E@"], "Permissions": [], "Description": "Override this to handle requests to perform a batch of operations, or the default implementation will iterate over the operations and call @B_android#content#ContentProviderOperation#apply_E@ on each of them. If all calls to @B_android#content#ContentProviderOperation#apply_E@ succeed then a @B_android#content#ContentProviderResult_E@ array with as many elements as there were operations will be returned. If any of the calls fail, it is up to the implementation how many of the others take effect. This method can be called from multiple threads, as described in", "history": "Added in API level 29", "FullName": "public ContentProviderResult[] applyBatch (String authority, ArrayList<ContentProviderOperation> operations)"}, "attachInfo(android.content.Context,android.content.pm.ProviderInfo)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The context this provider is running in"], ["@B_android#content#pm#ProviderInfo_E@", "ProviderInfo: Registered information about this content provider"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "After being instantiated, this is called to tell the content provider about itself.", "history": "Added in API level 1", "FullName": "public void attachInfo (Context context, ProviderInfo info)"}, "getCallingPackage()": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [], "Throws": [["@B_java#lang#SecurityException_E@", "if the calling package doesn't belong to the calling UID."]], "SeeAlso": ["@B_android#os#Binder#getCallingUid_E@", "@B_android#content#Context#grantUriPermission_E@"], "Permissions": [], "Description": "Return the package name of the caller that initiated the request being processed on the current thread. The returned package will have been verified to belong to the calling UID. Returns null if not currently processing a request. This will always return null when processing @B_android#content#ContentProvider#getType_E@ or @B_android#content#ContentProvider#getStreamTypes_E@ requests.", "history": "Added in API level 19", "FullName": "public final String getCallingPackage ()"}, "query(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,android.os.CancellationSignal)": {"Returns": [["@B_android#database#Cursor_E@", "a Cursor or null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI to query. This will be the full URI sent by the client; if the client is requesting a specific record, the URI will end in a record number that the implementation should parse and add to a WHERE or HAVING clause, specifying that _id value. This value must never be null."], ["@B_java#lang#String_E@", "String: The list of columns to put into the cursor. If null all columns are included. This value may be null."], ["@B_java#lang#String_E@", "String: A selection criteria to apply when filtering rows. If null then all rows are included. This value may be null."], ["@B_java#lang#String_E@", "String: You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings. This value may be null."], ["@B_java#lang#String_E@", "String: How the rows in the cursor should be sorted. If null then the provider is free to define the sort order. This value may be null."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. If the operation is canceled, then @B_android#os#OperationCanceledException_E@ will be thrown when the query is executed. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to handle query requests from clients with support for cancellation. Apps targeting @B_android#os#Build#VERSION_CODES#O_E@ or higher should override @B_android#content#ContentProvider#query_E@ instead of this method. This method can be called from multiple threads, as described in Example client call: If you implement this method then you must also implement the version of @B_android#content#ContentProvider#query_E@ that does not take a cancellation signal to ensure correct operation on older versions of the Android Framework in which the cancellation signal overload was not available.", "history": "Added in API level 16", "FullName": "public Cursor query (Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder, CancellationSignal cancellationSignal)"}}, "Inheritance": [], "ClassName": "android.content.ContentProvider", "ClassDesc": "Content providers are one of the primary building blocks of Android applications, providing content to applications. They encapsulate data and provide it to applications through the single @B_android#content#ContentResolver_E@ interface. A content provider is only required if you need to share data between multiple applications. For example, the contacts data is used by multiple applications and must be stored in a content provider. If you don't need to share data amongst multiple applications you can use a database directly via @B_android#database#sqlite#SQLiteDatabase_E@. When a request is made via a @B_android#content#ContentResolver_E@ the system inspects the authority of the given URI and passes the request to the content provider registered with the authority. The content provider can interpret the rest of the URI however it wants. The @B_android#content#UriMatcher_E@ class is helpful for parsing URIs. The primary methods that need to be implemented are: @B_android#content#ContentProvider#onCreate_E@ which is called to initialize the provider @B_android#content#ContentProvider#query_E@ which returns data to the caller @B_android#content#ContentProvider#insert_E@ which inserts new data into the content provider @B_android#content#ContentProvider#update_E@ which updates existing data in the content provider @B_android#content#ContentProvider#delete_E@ which deletes data from the content provider @B_android#content#ContentProvider#getType_E@ which returns the MIME type of data in the content provider Data access methods (such as @B_android#content#ContentProvider#insert_E@ and @B_android#content#ContentProvider#update_E@) may be called from many threads at once, and must be thread-safe. Other methods (such as @B_android#content#ContentProvider#onCreate_E@) are only called from the application main thread, and must avoid performing lengthy operations. See the method descriptions for their expected thread behavior. Requests to @B_android#content#ContentResolver_E@ are automatically forwarded to the appropriate ContentProvider instance, so subclasses don't have to worry about the details of cross-process calls."}