{"Functions": {"getCorePoolSize()": {"Returns": [["int", "the core number of threads"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#setCorePoolSize_E@"], "Permissions": [], "Description": "Returns the core number of threads.", "history": "Added in API level 1", "FullName": "public int getCorePoolSize ()"}, "terminated()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Method invoked when the Executor has terminated. Default implementation does nothing. Note: To properly nest multiple overridings, subclasses should generally invoke super.terminated within this method.", "history": "Added in API level 1", "FullName": "protected void terminated ()"}, "getKeepAliveTime(java.util.concurrent.TimeUnit)": {"Returns": [["long", "the time limit"]], "Parameters": [["@B_java#util#concurrent#TimeUnit_E@", "TimeUnit: the desired time unit of the result"]], "Throws": [], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#setKeepAliveTime_E@"], "Permissions": [], "Description": "Returns the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated. Threads that wait this amount of time without processing a task will be terminated if there are more than the core number of threads currently in the pool, or if this pool", "history": "Added in API level 1", "FullName": "public long getKeepAliveTime (TimeUnit unit)"}, "allowCoreThreadTimeOut(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if should time out, else false"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if value is true and the current keep-alive time is not greater than zero"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive. When false, core threads are never terminated due to lack of incoming tasks. When true, the same keep-alive policy applying to non-core threads applies also to core threads. To avoid continual thread replacement, the keep-alive time must be greater than zero when setting true. This method should in general be called before the pool is actively used.", "history": "Added in API level 9", "FullName": "public void allowCoreThreadTimeOut (boolean value)"}, "isTerminated()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public boolean isTerminated ()"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Invokes shutdown when this executor is no longer referenced and it has no threads.", "history": "Added in API level 1", "FullName": "protected void finalize ()"}, "shutdownNow()": {"Returns": [["@B_java#util#List_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. These tasks are drained (removed) from the task queue upon return from this method. This method does not wait for actively executing tasks to terminate. Use @B_java#util#concurrent#ThreadPoolExecutor#awaitTermination_E@ to do that. There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. This implementation interrupts tasks via @B_java#lang#Thread#interrupt_E@; any task that fails to respond to interrupts may never terminate.", "history": "Added in API level 1", "FullName": "public List<Runnable> shutdownNow ()"}, "getLargestPoolSize()": {"Returns": [["int", "the number of threads"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the largest number of threads that have ever simultaneously been in the pool.", "history": "Added in API level 1", "FullName": "public int getLargestPoolSize ()"}, "setCorePoolSize(int)": {"Returns": [], "Parameters": [["int", "int: the new core size"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if corePoolSize < 0"]], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#getCorePoolSize_E@"], "Permissions": [], "Description": "Sets the core number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle. If larger, new threads will, if needed, be started to execute any queued tasks.", "history": "Added in API level 1", "FullName": "public void setCorePoolSize (int corePoolSize)"}, "shutdown()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down. This method does not wait for previously submitted tasks to complete execution. Use @B_java#util#concurrent#ThreadPoolExecutor#awaitTermination_E@ to do that.", "history": "Added in API level 1", "FullName": "public void shutdown ()"}, "isShutdown()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public boolean isShutdown ()"}, "getRejectedExecutionHandler()": {"Returns": [["@B_java#util#concurrent#RejectedExecutionHandler_E@", "the current handler"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#setRejectedExecutionHandler_E@"], "Permissions": [], "Description": "Returns the current handler for unexecutable tasks.", "history": "Added in API level 1", "FullName": "public RejectedExecutionHandler getRejectedExecutionHandler ()"}, "purge()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tries to remove from the work queue all @B_java#util#concurrent#Future_E@ tasks that have been cancelled. This method can be useful as a storage reclamation operation, that has no other impact on functionality. Cancelled tasks are never executed, but may accumulate in work queues until worker threads can actively remove them. Invoking this method instead tries to remove them now. However, this method may fail to remove tasks in the presence of interference by other threads.", "history": "Added in API level 1", "FullName": "public void purge ()"}, "getQueue()": {"Returns": [["@B_java#util#concurrent#BlockingQueue_E@", "the task queue"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the task queue used by this executor. Access to the task queue is intended primarily for debugging and monitoring. This queue may be in active use. Retrieving the task queue does not prevent queued tasks from executing.", "history": "Added in API level 1", "FullName": "public BlockingQueue<Runnable> getQueue ()"}, "getCompletedTaskCount()": {"Returns": [["long", "the number of tasks"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the approximate total number of tasks that have completed execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation, but one that does not ever decrease across successive calls.", "history": "Added in API level 1", "FullName": "public long getCompletedTaskCount ()"}, "getThreadFactory()": {"Returns": [["@B_java#util#concurrent#ThreadFactory_E@", "the current thread factory"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#setThreadFactory_E@"], "Permissions": [], "Description": "Returns the thread factory used to create new threads.", "history": "Added in API level 1", "FullName": "public ThreadFactory getThreadFactory ()"}, "isTerminating()": {"Returns": [["boolean", "true if terminating but not yet terminated"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this executor is in the process of terminating after @B_java#util#concurrent#ThreadPoolExecutor#shutdown_E@ or @B_java#util#concurrent#ThreadPoolExecutor#shutdownNow_E@ but has not completely terminated. This method may be useful for debugging. A return of true reported a sufficient period after shutdown may indicate that submitted tasks have ignored or suppressed interruption, causing this executor not to properly terminate.", "history": "Added in API level 1", "FullName": "public boolean isTerminating ()"}, "ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue<java.lang.Runnable>,java.util.concurrent.ThreadFactory)": {"Returns": [], "Parameters": [["int", "int: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set"], ["int", "int: the maximum number of threads to allow in the pool"], ["long", "long: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating."], ["@B_java#util#concurrent#TimeUnit_E@", "TimeUnit: the time unit for the keepAliveTime argument"], ["@B_java#util#concurrent#BlockingQueue_E@", "BlockingQueue: the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method."], ["@B_java#util#concurrent#ThreadFactory_E@", "ThreadFactory: the factory to use when the executor creates a new thread"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if one of the following holds: corePoolSize < 0 keepAliveTime < 0 maximumPoolSize <= 0 maximumPoolSize < corePoolSize"], ["@B_java#lang#NullPointerException_E@", "if workQueue or threadFactory is null"]], "SeeAlso": [], "Permissions": [], "Description": "Creates a new ThreadPoolExecutor with the given initial parameters and default rejected execution handler.", "history": "Added in API level 1", "FullName": "public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory)"}, "prestartAllCoreThreads()": {"Returns": [["int", "the number of threads started"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Starts all core threads, causing them to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed.", "history": "Added in API level 1", "FullName": "public int prestartAllCoreThreads ()"}, "getActiveCount()": {"Returns": [["int", "the number of threads"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the approximate number of threads that are actively executing tasks.", "history": "Added in API level 1", "FullName": "public int getActiveCount ()"}, "awaitTermination(long,java.util.concurrent.TimeUnit)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["long", "long no parameter comment"], ["@B_java#util#concurrent#TimeUnit_E@", "TimeUnit no parameter comment"]], "Throws": [["@B_java#lang#InterruptedException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public boolean awaitTermination (long timeout, TimeUnit unit)"}, "getMaximumPoolSize()": {"Returns": [["int", "the maximum allowed number of threads"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#setMaximumPoolSize_E@"], "Permissions": [], "Description": "Returns the maximum allowed number of threads.", "history": "Added in API level 1", "FullName": "public int getMaximumPoolSize ()"}, "getPoolSize()": {"Returns": [["int", "the number of threads"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current number of threads in the pool.", "history": "Added in API level 1", "FullName": "public int getPoolSize ()"}, "setThreadFactory(java.util.concurrent.ThreadFactory)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#ThreadFactory_E@", "ThreadFactory: the new thread factory"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if threadFactory is null"]], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#getThreadFactory_E@"], "Permissions": [], "Description": "Sets the thread factory used to create new threads.", "history": "Added in API level 1", "FullName": "public void setThreadFactory (ThreadFactory threadFactory)"}, "beforeExecute(java.lang.Thread,java.lang.Runnable)": {"Returns": [], "Parameters": [["@B_java#lang#Thread_E@", "Thread: the thread that will run task r"], ["@B_java#lang#Runnable_E@", "Runnable: the task that will be executed"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Method invoked prior to executing the given Runnable in the given thread. This method is invoked by thread t that will execute task r, and may be used to re-initialize ThreadLocals, or to perform logging. This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke super.beforeExecute at the end of this method.", "history": "Added in API level 1", "FullName": "protected void beforeExecute (Thread t, Runnable r)"}, "setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#RejectedExecutionHandler_E@", "RejectedExecutionHandler: the new handler"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if handler is null"]], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#getRejectedExecutionHandler_E@"], "Permissions": [], "Description": "Sets a new handler for unexecutable tasks.", "history": "Added in API level 1", "FullName": "public void setRejectedExecutionHandler (RejectedExecutionHandler handler)"}, "ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue<java.lang.Runnable>,java.util.concurrent.ThreadFactory,java.util.concurrent.RejectedExecutionHandler)": {"Returns": [], "Parameters": [["int", "int: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set"], ["int", "int: the maximum number of threads to allow in the pool"], ["long", "long: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating."], ["@B_java#util#concurrent#TimeUnit_E@", "TimeUnit: the time unit for the keepAliveTime argument"], ["@B_java#util#concurrent#BlockingQueue_E@", "BlockingQueue: the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method."], ["@B_java#util#concurrent#ThreadFactory_E@", "ThreadFactory: the factory to use when the executor creates a new thread"], ["@B_java#util#concurrent#RejectedExecutionHandler_E@", "RejectedExecutionHandler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if one of the following holds: corePoolSize < 0 keepAliveTime < 0 maximumPoolSize <= 0 maximumPoolSize < corePoolSize"], ["@B_java#lang#NullPointerException_E@", "if workQueue or threadFactory or handler is null"]], "SeeAlso": [], "Permissions": [], "Description": "Creates a new ThreadPoolExecutor with the given initial parameters.", "history": "Added in API level 1", "FullName": "public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)"}, "prestartCoreThread()": {"Returns": [["boolean", "true if a thread was started"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Starts a core thread, causing it to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed. This method will return false if all core threads have already been started.", "history": "Added in API level 1", "FullName": "public boolean prestartCoreThread ()"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string identifying this pool, as well as its state"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.", "history": "Added in API level 1", "FullName": "public String toString ()"}, "setMaximumPoolSize(int)": {"Returns": [], "Parameters": [["int", "int: the new maximum"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the new maximum is less than or equal to zero, or less than the core pool size"]], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#getMaximumPoolSize_E@"], "Permissions": [], "Description": "Sets the maximum allowed number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle.", "history": "Added in API level 1", "FullName": "public void setMaximumPoolSize (int maximumPoolSize)"}, "execute(java.lang.Runnable)": {"Returns": [], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: the task to execute"]], "Throws": [["@B_java#util#concurrent#RejectedExecutionException_E@", "at discretion of RejectedExecutionHandler, if the task cannot be accepted for execution"], ["@B_java#lang#NullPointerException_E@", "if command is null"]], "SeeAlso": [], "Permissions": [], "Description": "Executes the given task sometime in the future. The task may execute in a new thread or in an existing pooled thread. If the task cannot be submitted for execution, either because this executor has been shutdown or because its capacity has been reached, the task is handled by the current RejectedExecutionHandler.", "history": "Added in API level 1", "FullName": "public void execute (Runnable command)"}, "ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue<java.lang.Runnable>)": {"Returns": [], "Parameters": [["int", "int: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set"], ["int", "int: the maximum number of threads to allow in the pool"], ["long", "long: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating."], ["@B_java#util#concurrent#TimeUnit_E@", "TimeUnit: the time unit for the keepAliveTime argument"], ["@B_java#util#concurrent#BlockingQueue_E@", "BlockingQueue: the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if one of the following holds: corePoolSize < 0 keepAliveTime < 0 maximumPoolSize <= 0 maximumPoolSize < corePoolSize"], ["@B_java#lang#NullPointerException_E@", "if workQueue is null"]], "SeeAlso": [], "Permissions": [], "Description": "Creates a new ThreadPoolExecutor with the given initial parameters and default thread factory and rejected execution handler. It may be more convenient to use one of the @B_java#util#concurrent#Executors_E@ factory methods instead of this general purpose constructor.", "history": "Added in API level 1", "FullName": "public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue)"}, "remove(java.lang.Runnable)": {"Returns": [["boolean", "true if the task was removed"]], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: the task to remove"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started. This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using submit might be converted into a form that maintains Future status. However, in such cases, method @B_java#util#concurrent#ThreadPoolExecutor#purge_E@ may be used to remove those Futures that have been cancelled.", "history": "Added in API level 1", "FullName": "public boolean remove (Runnable task)"}, "setKeepAliveTime(long,java.util.concurrent.TimeUnit)": {"Returns": [], "Parameters": [["long", "long: the time to wait. A time value of zero will cause excess threads to terminate immediately after executing tasks."], ["@B_java#util#concurrent#TimeUnit_E@", "TimeUnit: the time unit of the time argument"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if time less than zero or if time is zero and allowsCoreThreadTimeOut"]], "SeeAlso": ["@B_java#util#concurrent#ThreadPoolExecutor#getKeepAliveTime_E@"], "Permissions": [], "Description": "Sets the thread keep-alive time, which is the amount of time that threads may remain idle before being terminated. Threads that wait this amount of time without processing a task will be terminated if there are more than the core number of threads currently in the pool, or if this pool", "history": "Added in API level 1", "FullName": "public void setKeepAliveTime (long time, TimeUnit unit)"}, "getTaskCount()": {"Returns": [["long", "the number of tasks"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the approximate total number of tasks that have ever been scheduled for execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation.", "history": "Added in API level 1", "FullName": "public long getTaskCount ()"}, "afterExecute(java.lang.Runnable,java.lang.Throwable)": {"Returns": [], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: the runnable that has completed"], ["@B_java#lang#Throwable_E@", "Throwable: the exception that caused termination, or null if execution completed normally"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Method invoked upon completion of execution of the given Runnable. This method is invoked by the thread that executed the task. If non-null, the Throwable is the uncaught RuntimeException or Error that caused execution to terminate abruptly. This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke super.afterExecute at the beginning of this method. @B_java#util#concurrent#FutureTask_E@) either explicitly or via methods such as submit, these task objects catch and maintain computational exceptions, and so they do not cause abrupt termination, and the internal exceptions are not passed to this method. If you would like to trap both kinds of failures in this method, you can further probe for such cases, as in this sample subclass that prints either the direct cause or the underlying exception if a task has been aborted:", "history": "Added in API level 1", "FullName": "protected void afterExecute (Runnable r, Throwable t)"}, "ThreadPoolExecutor(int,int,long,java.util.concurrent.TimeUnit,java.util.concurrent.BlockingQueue<java.lang.Runnable>,java.util.concurrent.RejectedExecutionHandler)": {"Returns": [], "Parameters": [["int", "int: the number of threads to keep in the pool, even if they are idle, unless allowCoreThreadTimeOut is set"], ["int", "int: the maximum number of threads to allow in the pool"], ["long", "long: when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating."], ["@B_java#util#concurrent#TimeUnit_E@", "TimeUnit: the time unit for the keepAliveTime argument"], ["@B_java#util#concurrent#BlockingQueue_E@", "BlockingQueue: the queue to use for holding tasks before they are executed. This queue will hold only the Runnable tasks submitted by the execute method."], ["@B_java#util#concurrent#RejectedExecutionHandler_E@", "RejectedExecutionHandler: the handler to use when execution is blocked because the thread bounds and queue capacities are reached"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if one of the following holds: corePoolSize < 0 keepAliveTime < 0 maximumPoolSize <= 0 maximumPoolSize < corePoolSize"], ["@B_java#lang#NullPointerException_E@", "if workQueue or handler is null"]], "SeeAlso": [], "Permissions": [], "Description": "Creates a new ThreadPoolExecutor with the given initial parameters and default thread factory.", "history": "Added in API level 1", "FullName": "public ThreadPoolExecutor (int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler)"}, "allowsCoreThreadTimeOut()": {"Returns": [["boolean", "true if core threads are allowed to time out, else false"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive. When true, the same keep-alive policy applying to non-core threads applies also to core threads. When false (the default), core threads are never terminated due to lack of incoming tasks.", "history": "Added in API level 9", "FullName": "public boolean allowsCoreThreadTimeOut ()"}}, "Inheritance": ["@B_java#util#concurrent#AbstractExecutorService_E@"], "ClassName": "java.util.concurrent.ThreadPoolExecutor", "ClassDesc": "An @B_java#util#concurrent#ExecutorService_E@ that executes each submitted task using one of possibly several pooled threads, normally configured using @B_java#util#concurrent#Executors_E@ factory methods. Thread pools address two different problems: they usually provide improved performance when executing large numbers of asynchronous tasks, due to reduced per-task invocation overhead, and they provide a means of bounding and managing the resources, including threads, consumed when executing a collection of tasks. Each ThreadPoolExecutor also maintains some basic statistics, such as the number of completed tasks. To be useful across a wide range of contexts, this class provides many adjustable parameters and extensibility hooks. However, programmers are urged to use the more convenient @B_java#util#concurrent#Executors_E@ factory methods @B_java#util#concurrent#Executors#newCachedThreadPool_E@ (unbounded thread pool, with automatic thread reclamation), @B_java#util#concurrent#Executors#newFixedThreadPool_E@ (fixed size thread pool) and @B_java#util#concurrent#Executors#newSingleThreadExecutor_E@ (single background thread), that preconfigure settings for the most common usage scenarios. Otherwise, use the following guide when manually configuring and tuning this class:"}