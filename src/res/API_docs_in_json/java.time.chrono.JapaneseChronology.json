{"Functions": {"range(java.time.temporal.ChronoField)": {"Returns": [["@B_java#time#temporal#ValueRange_E@", "no returns description in source"]], "Parameters": [["@B_java#time#temporal#ChronoField_E@", "ChronoField no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public ValueRange range (ChronoField field)"}, "zonedDateTime(java.time.Instant, java.time.ZoneId)": {"Returns": [["@B_java#time#chrono#ChronoZonedDateTime_E@", "no returns description in source"]], "Parameters": [["@B_java#time#Instant_E@", "Instant no parameter comment"], ["@B_java#time#ZoneId_E@", "ZoneId no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 26", "FullName": "public ChronoZonedDateTime<JapaneseDate> zonedDateTime (Instant instant, ZoneId zone)"}, "getCalendarType()": {"Returns": [["@B_java#lang#String_E@", "the calendar system type - 'japanese'"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_java#time#chrono#JapaneseChronology#getId_E@"], "Permissions": [], "Description": "Gets the calendar type of the underlying calendar system - 'japanese'. The calendar type is an identifier defined by the Unicode Locale Data Markup Language (LDML) specification. It can be used to lookup the Chronology using @B_java#time#chrono#Chronology#of_E@. It can also be used as part of a locale, accessible via @B_java#util#Locale#getUnicodeLocaleType_E@ with the key 'ca'.", "history": "Added in API level 26", "FullName": "public String getCalendarType ()"}, "zonedDateTime(java.time.temporal.TemporalAccessor)": {"Returns": [["@B_java#time#chrono#ChronoZonedDateTime_E@", "no returns description in source"]], "Parameters": [["@B_java#time#temporal#TemporalAccessor_E@", "TemporalAccessor no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public ChronoZonedDateTime<JapaneseDate> zonedDateTime (TemporalAccessor temporal)"}, "dateNow(java.time.Clock)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "no returns description in source"]], "Parameters": [["@B_java#time#Clock_E@", "Clock no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public JapaneseDate dateNow (Clock clock)"}, "date(int, int, int)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the Japanese local date, not null"]], "Parameters": [["int", "int: the proleptic-year"], ["int", "int: the month-of-year"], ["int", "int: the day-of-month"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Japanese calendar system from the proleptic-year, month-of-year and day-of-month fields. The Japanese proleptic year, month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes.", "history": "added in API level 26", "FullName": "public JapaneseDate date (int prolepticYear, int month, int dayOfMonth)"}, "zonedDateTime(java.time.Instant,java.time.ZoneId)": {"Returns": [["@B_java#time#chrono#ChronoZonedDateTime_E@", "no returns description in source"]], "Parameters": [["@B_java#time#Instant_E@", "Instant no parameter comment"], ["@B_java#time#ZoneId_E@", "ZoneId no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public ChronoZonedDateTime<JapaneseDate> zonedDateTime (Instant instant, ZoneId zone)"}, "dateYearDay(int, int)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the Japanese local date, not null"]], "Parameters": [["int", "int: the proleptic-year"], ["int", "int: the day-of-year"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Japanese calendar system from the proleptic-year and day-of-year fields. The day-of-year in this factory is expressed relative to the start of the proleptic year. The Japanese proleptic year and day-of-year are the same as those in the ISO calendar system. They are not reset when the era changes.", "history": "added in API level 26", "FullName": "public JapaneseDate dateYearDay (int prolepticYear, int dayOfYear)"}, "dateEpochDay(long)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the Japanese local date, not null"]], "Parameters": [["long", "long: the epoch day"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in the Japanese calendar system from the epoch-day.", "history": "Added in API level 26", "FullName": "public JapaneseDate dateEpochDay (long epochDay)"}, "prolepticYear(java.time.chrono.Era, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 26", "FullName": "public int prolepticYear (Era era, int yearOfEra)"}, "dateNow()": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public JapaneseDate dateNow ()"}, "resolveDate(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>,java.time.format.ResolverStyle)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the resolved date, null if insufficient information to create a date"]], "Parameters": [["@B_java#util#Map_E@", "Map: the map of fields to values, which can be updated, not null"], ["@B_java#time#format#ResolverStyle_E@", "ResolverStyle: the requested type of resolve, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Resolves parsed ChronoField values into a date during parsing. Most TemporalField implementations are resolved using the resolve method on the field. By contrast, the ChronoField class defines fields that only have meaning relative to the chronology. As such, ChronoField date fields are resolved here in the context of a specific chronology. ChronoField instances are resolved by this method, which may be overridden in subclasses. EPOCH_DAY - If present, this is converted to a date and all other date fields are then cross-checked against the date. PROLEPTIC_MONTH - If present, then it is split into the YEAR and MONTH_OF_YEAR. If the mode is strict or smart then the field is validated. YEAR_OF_ERA and ERA - If both are present, then they are combined to form a YEAR. In lenient mode, the YEAR_OF_ERA range is not validated, in smart and strict mode it is. The ERA is validated for range in all three modes. If only the YEAR_OF_ERA is present, and the mode is smart or lenient, then the last available era is assumed. In strict mode, no era is assumed and the YEAR_OF_ERA is left untouched. If only the ERA is present, then it is left untouched. YEAR, MONTH_OF_YEAR and DAY_OF_MONTH - If all three are present, then they are combined to form a date. In all three modes, the YEAR is validated. If the mode is smart or strict, then the month and day are validated. If the mode is lenient, then the date is combined in a manner equivalent to creating a date on the first day of the first month in the requested year, then adding the difference in months, then the difference in days. If the mode is smart, and the day-of-month is greater than the maximum for the year-month, then the day-of-month is adjusted to the last day-of-month. If the mode is strict, then the three fields must form a valid date. YEAR and DAY_OF_YEAR - If both are present, then they are combined to form a date. In all three modes, the YEAR is validated. If the mode is lenient, then the date is combined in a manner equivalent to creating a date on the first day of the requested year, then adding the difference in days. If the mode is smart or strict, then the two fields must form a valid date. YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and ALIGNED_DAY_OF_WEEK_IN_MONTH - If all four are present, then they are combined to form a date. In all three modes, the YEAR is validated. If the mode is lenient, then the date is combined in a manner equivalent to creating a date on the first day of the first month in the requested year, then adding the difference in months, then the difference in weeks, then in days. If the mode is smart or strict, then the all four fields are validated to their outer ranges. The date is then combined in a manner equivalent to creating a date on the first day of the requested year and month, then adding the amount in weeks and days to reach their values. If the mode is strict, the date is additionally validated to check that the day and week adjustment did not change the month. YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and DAY_OF_WEEK - If all four are present, then they are combined to form a date. The approach is the same as described above for years, months and weeks in ALIGNED_DAY_OF_WEEK_IN_MONTH. The day-of-week is adjusted as the next or same matching day-of-week once the years, months and weeks have been handled. YEAR, ALIGNED_WEEK_OF_YEAR and ALIGNED_DAY_OF_WEEK_IN_YEAR - If all three are present, then they are combined to form a date. In all three modes, the YEAR is validated. If the mode is lenient, then the date is combined in a manner equivalent to creating a date on the first day of the requested year, then adding the difference in weeks, then in days. If the mode is smart or strict, then the all three fields are validated to their outer ranges. The date is then combined in a manner equivalent to creating a date on the first day of the requested year, then adding the amount in weeks and days to reach their values. If the mode is strict, the date is additionally validated to check that the day and week adjustment did not change the year. YEAR, ALIGNED_WEEK_OF_YEAR and DAY_OF_WEEK - If all three are present, then they are combined to form a date. The approach is the same as described above for years and weeks in ALIGNED_DAY_OF_WEEK_IN_YEAR. The day-of-week is adjusted as the next or same matching day-of-week once the years and weeks have been handled. The default implementation is suitable for most calendar systems. If @B_java#time#temporal#ChronoField#YEAR_OF_ERA_E@ is found without an @B_java#time#temporal#ChronoField#ERA_E@ then the last era in @B_java#time#chrono#Chronology#eras_E@ is used. The implementation assumes a 7 day week, that the first day-of-month has the value 1, that first day-of-year has the value 1, and that the first of the month and year always exists.", "history": "Added in API level 26", "FullName": "public JapaneseDate resolveDate (Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle)"}, "getId()": {"Returns": [["@B_java#lang#String_E@", "the chronology ID - 'Japanese'"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_java#time#chrono#JapaneseChronology#getCalendarType_E@"], "Permissions": [], "Description": "Gets the ID of the chronology - 'Japanese'. The ID uniquely identifies the Chronology. It can be used to lookup the Chronology using @B_java#time#chrono#Chronology#of_E@.", "history": "Added in API level 26", "FullName": "public String getId ()"}, "dateNow(java.time.ZoneId)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "no returns description in source"]], "Parameters": [["@B_java#time#ZoneId_E@", "ZoneId no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public JapaneseDate dateNow (ZoneId zone)"}, "prolepticYear(java.time.chrono.Era,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public int prolepticYear (Era era, int yearOfEra)"}, "isLeapYear(long)": {"Returns": [["boolean", "true if the year is a leap year"]], "Parameters": [["long", "long: the proleptic-year to check, not validated for range"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Checks if the specified year is a leap year. Japanese calendar leap years occur exactly in line with ISO leap years. This method does not validate the year passed in, and only has a well-defined result for years in the supported range.", "history": "Added in API level 26", "FullName": "public boolean isLeapYear (long prolepticYear)"}, "date(java.time.chrono.Era, int, int, int)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the Japanese local date, not null"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era: the Japanese era, not null"], ["int", "int: the year-of-era"], ["int", "int: the month-of-year"], ["int", "int: the day-of-month"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"], ["@B_java#lang#ClassCastException_E@", "if the era is not a JapaneseEra"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Japanese calendar system from the era, year-of-era, month-of-year and day-of-month fields. The Japanese month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes. For example:", "history": "added in API level 26", "FullName": "public JapaneseDate date (Era era, int yearOfEra, int month, int dayOfMonth)"}, "date(java.time.chrono.Era,int,int,int)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the Japanese local date, not null"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era: the Japanese era, not null"], ["int", "int: the year-of-era"], ["int", "int: the month-of-year"], ["int", "int: the day-of-month"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"], ["@B_java#lang#ClassCastException_E@", "if the era is not a JapaneseEra"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Japanese calendar system from the era, year-of-era, month-of-year and day-of-month fields. The Japanese month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes. For example:", "history": "Added in API level 26", "FullName": "public JapaneseDate date (Era era, int yearOfEra, int month, int dayOfMonth)"}, "eras()": {"Returns": [["@B_java#util#List_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public List<Era> eras ()"}, "dateYearDay(java.time.chrono.Era,int,int)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the Japanese local date, not null"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era: the Japanese era, not null"], ["int", "int: the year-of-era"], ["int", "int: the day-of-year"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"], ["@B_java#lang#ClassCastException_E@", "if the era is not a JapaneseEra"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Japanese calendar system from the era, year-of-era and day-of-year fields. The day-of-year in this factory is expressed relative to the start of the year-of-era. This definition changes the normal meaning of day-of-year only in those years where the year-of-era is reset to one due to a change in the era. For example:", "history": "Added in API level 26", "FullName": "public JapaneseDate dateYearDay (Era era, int yearOfEra, int dayOfYear)"}, "dateYearDay(int,int)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the Japanese local date, not null"]], "Parameters": [["int", "int: the proleptic-year"], ["int", "int: the day-of-year"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Japanese calendar system from the proleptic-year and day-of-year fields. The day-of-year in this factory is expressed relative to the start of the proleptic year. The Japanese proleptic year and day-of-year are the same as those in the ISO calendar system. They are not reset when the era changes.", "history": "Added in API level 26", "FullName": "public JapaneseDate dateYearDay (int prolepticYear, int dayOfYear)"}, "date(java.time.temporal.TemporalAccessor)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "no returns description in source"]], "Parameters": [["@B_java#time#temporal#TemporalAccessor_E@", "TemporalAccessor no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public JapaneseDate date (TemporalAccessor temporal)"}, "dateYearDay(java.time.chrono.Era, int, int)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the Japanese local date, not null"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era: the Japanese era, not null"], ["int", "int: the year-of-era"], ["int", "int: the day-of-year"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"], ["@B_java#lang#ClassCastException_E@", "if the era is not a JapaneseEra"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Japanese calendar system from the era, year-of-era and day-of-year fields. The day-of-year in this factory is expressed relative to the start of the year-of-era. This definition changes the normal meaning of day-of-year only in those years where the year-of-era is reset to one due to a change in the era. For example:", "history": "added in API level 26", "FullName": "public JapaneseDate dateYearDay (Era era, int yearOfEra, int dayOfYear)"}, "date(int,int,int)": {"Returns": [["@B_java#time#chrono#JapaneseDate_E@", "the Japanese local date, not null"]], "Parameters": [["int", "int: the proleptic-year"], ["int", "int: the month-of-year"], ["int", "int: the day-of-month"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Japanese calendar system from the proleptic-year, month-of-year and day-of-month fields. The Japanese proleptic year, month and day-of-month are the same as those in the ISO calendar system. They are not reset when the era changes.", "history": "Added in API level 26", "FullName": "public JapaneseDate date (int prolepticYear, int month, int dayOfMonth)"}, "eraOf(int)": {"Returns": [["@B_java#time#chrono#JapaneseEra_E@", "the Japanese Era for the given numeric era value"]], "Parameters": [["int", "int: the era value"]], "Throws": [["@B_java#time#DateTimeException_E@", "if eraValue is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the calendar system era object from the given numeric value. See the description of each Era for the numeric values of: @B_java#time#chrono#JapaneseEra#HEISEI_E@, @B_java#time#chrono#JapaneseEra#SHOWA_E@,@B_java#time#chrono#JapaneseEra#TAISHO_E@, @B_java#time#chrono#JapaneseEra#MEIJI_E@), only Meiji and later eras are supported.", "history": "Added in API level 26", "FullName": "public JapaneseEra eraOf (int eraValue)"}, "localDateTime(java.time.temporal.TemporalAccessor)": {"Returns": [["@B_java#time#chrono#ChronoLocalDateTime_E@", "no returns description in source"]], "Parameters": [["@B_java#time#temporal#TemporalAccessor_E@", "TemporalAccessor no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public ChronoLocalDateTime<JapaneseDate> localDateTime (TemporalAccessor temporal)"}}, "Inheritance": ["@B_java#time#chrono#AbstractChronology_E@"], "ClassName": "java.time.chrono.JapaneseChronology", "ClassDesc": "The Japanese Imperial calendar system. This chronology defines the rules of the Japanese Imperial calendar system. This calendar system is primarily used in Japan. The Japanese Imperial calendar system is the same as the ISO calendar system apart from the era-based year numbering. Japan introduced the Gregorian calendar starting with Meiji 6. Only Meiji and later eras are supported; dates before Meiji 6, January 1 are not supported. The supported ChronoField instances are: DAY_OF_WEEK DAY_OF_MONTH DAY_OF_YEAR EPOCH_DAY MONTH_OF_YEAR PROLEPTIC_MONTH YEAR_OF_ERA YEAR ERA"}