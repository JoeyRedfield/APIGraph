{"Functions": {"onStop()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when you are no longer visible to the user. You will next receive either @B_android#app#Activity#onRestart_E@, @B_android#app#Activity#onDestroy_E@, or nothing, depending on later user activity. This is a good place to stop refreshing UI, running animations and other visual things. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 9", "FullName": "protected void onStop ()"}, "dispatchKeyEvent(android.view.KeyEvent)": {"Returns": [["", "boolean Return true if this event was consumed."]], "Parameters": [["@B_android#view#KeyEvent_E@", "The key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to process key events. You can override this to intercept all key events before they are dispatched to the window. Be sure to call this implementation for key events that should be handled normally.", "history": "Added in API level 9", "FullName": "public boolean dispatchKeyEvent (KeyEvent event)"}, "surfaceCreated(android.view.SurfaceHolder)": {"Returns": [], "Parameters": [["@B_android#view#SurfaceHolder_E@", "SurfaceHolder: The SurfaceHolder whose surface is being created."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called immediately after the surface is first created. Implementations of this should start up whatever rendering code they desire. Note that only one thread can ever draw into a @B_android#view#Surface_E@, so you should not draw into the Surface here if your normal rendering will be in another thread.", "history": "Added in API level 9", "FullName": "public void surfaceCreated (SurfaceHolder holder)"}, "onResume()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called after @B_android#app#Activity#onRestoreInstanceState_E@, @B_android#app#Activity#onRestart_E@, or @B_android#app#Activity#onPause_E@, for your activity to start interacting with the user. This is an indicator that the activity became active and ready to receive input. It is on top of an activity stack and visible to user. On platform versions prior to @B_android#os#Build#VERSION_CODES#Q_E@ this is also a good place to try to open exclusive-access devices or to get access to singleton resources. Starting with @B_android#os#Build#VERSION_CODES#Q_E@ there can be multiple resumed activities in the system simultaneously, so @B_android#app#Activity#onTopResumedActivityChanged_E@ should be used for that purpose instead. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 9", "FullName": "protected void onResume ()"}, "onGlobalLayout()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Callback method to be invoked when the global layout state or the visibility of views within the view tree changes", "history": "Added in API level 9", "FullName": "public void onGlobalLayout ()"}, "onLowMemory()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the overall system is running low on memory, and actively running processes should trim their memory usage. While the exact point at which this will be called is not defined, generally it will happen when all background process have been killed. That is, before reaching the point of killing processes hosting service and foreground UI that we would like to avoid killing. You should implement this method to release any caches or other unnecessary resources you may be holding on to. The system will perform a garbage collection for you after returning from this method. Preferably, you should implement @B_android#content#ComponentCallbacks2#onTrimMemory_E@ from @B_android#content#ComponentCallbacks2_E@ to incrementally unload your resources based on various levels of memory demands. That API is available for API level 14 and higher, so you should only use this @B_android#content#ComponentCallbacks#onLowMemory_E@ method as a fallback for older versions, which can be treated the same as @B_android#content#ComponentCallbacks2#onTrimMemory_E@ with the @B_android#content#ComponentCallbacks2#TRIM_MEMORY_COMPLETE_E@ level.", "history": "Added in API level 9", "FullName": "public void onLowMemory ()"}, "onInputQueueCreated(android.view.InputQueue)": {"Returns": [], "Parameters": [["@B_android#view#InputQueue_E@", "InputQueue no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the given InputQueue is now associated with the thread making this call, so it can start receiving events from it.", "history": "Added in API level 9", "FullName": "public void onInputQueueCreated (InputQueue queue)"}, "onPause()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called as part of the activity lifecycle when the user no longer actively interacts with the activity, but it is still visible on screen. The counterpart to @B_android#app#Activity#onResume_E@. When activity B is launched in front of activity A, this callback will be invoked on A. B will not be created until A's @B_android#app#Activity#onPause_E@ returns, so be sure to not do anything lengthy here. This callback is mostly used for saving any persistent state the activity is editing, to present a \"edit in place\" model to the user and making sure nothing is lost if there are not enough resources to start the new activity without first killing this one. This is also a good place to stop things that consume a noticeable amount of CPU in order to make the switch to the next activity as fast as possible. On platform versions prior to @B_android#os#Build#VERSION_CODES#Q_E@ this is also a good place to try to close exclusive-access devices or to release access to singleton resources. Starting with @B_android#os#Build#VERSION_CODES#Q_E@ there can be multiple resumed activities in the system at the same time, so @B_android#app#Activity#onTopResumedActivityChanged_E@ should be used for that purpose instead. If an activity is launched on top, after receiving this call you will usually receive a following call to @B_android#app#Activity#onStop_E@ (after the next activity has been resumed and displayed above). However in some cases there will be a direct call back to @B_android#app#Activity#onResume_E@ without going through the stopped state. An activity can also rest in paused state in some cases when in multi-window mode, still visible to user. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 9", "FullName": "protected void onPause ()"}, "onDestroy()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform any final cleanup before an activity is destroyed. This can happen either because the activity is finishing (someone called @B_android#app#Activity#finish_E@ on it), or because the system is temporarily destroying this instance of the activity to save space. You can distinguish between these two scenarios with the @B_android#app#Activity#isFinishing_E@ method. Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either @B_android#app#Activity#onPause_E@ or @B_android#app#Activity#onSaveInstanceState_E@, not here. This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running. There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 9", "FullName": "protected void onDestroy ()"}, "onConfigurationChanged(android.content.res.Configuration)": {"Returns": [], "Parameters": [["@B_android#content#res#Configuration_E@", "Configuration: The new device configuration. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system when the device configuration changes while your activity is running. Note that this will only be called if you have selected configurations you would like to handle with the @B_android#R#attr#configChanges_E@ attribute in your manifest. If any configuration change occurs that is not selected to be reported by that attribute, then instead of reporting it the system will stop and restart the activity (to have it launched with the new configuration). At the time that this function has been called, your Resources object will have been updated to return resource values matching the new configuration.", "history": "Added in API level 9", "FullName": "public void onConfigurationChanged (Configuration newConfig)"}, "onStart()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called after @B_android#app#Activity#onCreate_E@ \u2014 or after @B_android#app#Activity#onRestart_E@ when the activity had been stopped, but is now again being displayed to the user. It will usually be followed by @B_android#app#Activity#onResume_E@. This is a good place to begin drawing visual elements, running animations, etc. You can call @B_android#app#Activity#finish_E@ from within this function, in which case @B_android#app#Activity#onStop_E@ will be immediately called after @B_android#app#Activity#onStart_E@ without the lifecycle transitions in-between (@B_android#app#Activity#onResume_E@, @B_android#app#Activity#onPause_E@, etc) executing. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 9", "FullName": "protected void onStart ()"}, "onWindowFocusChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether the window of this activity has focus."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the current @B_android#view#Window_E@ of the activity gains or loses focus. This is the best indicator of whether this activity is the entity with which the user actively interacts. The default implementation clears the key tracking state, so should always be called. Note that this provides information about global focus state, which is managed independently of activity lifecycle. As such, while focus changes will generally have some relation to lifecycle changes (an activity that is stopped will not generally get window focus), you should not rely on any particular order between the callbacks here and those in the other lifecycle methods such as @B_android#app#Activity#onResume_E@. As a general rule, however, a foreground activity will have window focus... unless it has displayed other dialogs or popups that take input focus, in which case the activity itself will not have focus when the other windows have it. Likewise, the system may display system-level windows (such as the status bar notification panel or a system alert) which will temporarily take window input focus without pausing the foreground activity. Starting with @B_android#os#Build#VERSION_CODES#Q_E@ there can be multiple resumed activities at the same time in multi-window mode, so resumed state does not guarantee window focus even if there are no overlays above. If the intent is to know when an activity is the topmost active, the one the user interacted with last among all activities but not including non-activity windows like dialogs and popups, then @B_android#app#Activity#onTopResumedActivityChanged_E@ should be used. On platform versions prior to @B_android#os#Build#VERSION_CODES#Q_E@, @B_android#app#Activity#onResume_E@ is the best indicator.", "history": "Added in API level 9", "FullName": "public void onWindowFocusChanged (boolean hasFocus)"}, "onSaveInstanceState(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: Bundle in which to place your saved state. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to retrieve per-instance state from an activity before being killed so that the state can be restored in @B_android#app#Activity#onCreate_E@ or @B_android#app#Activity#onRestoreInstanceState_E@ (the @B_android#os#Bundle_E@ populated by this method will be passed to both). This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via @B_android#app#Activity#onCreate_E@ or @B_android#app#Activity#onRestoreInstanceState_E@. Do not confuse this method with activity lifecycle callbacks such as @B_android#app#Activity#onPause_E@, which is always called when the user no longer actively interacts with an activity, or @B_android#app#Activity#onStop_E@ which is called when activity becomes invisible. One example of when @B_android#app#Activity#onPause_E@ and @B_android#app#Activity#onStop_E@ is called and not this method is when a user navigates back from activity B to activity A: there is no need to call @B_android#app#Activity#onSaveInstanceState_E@ on B because that particular instance will never be restored, so the system avoids calling it. An example when @B_android#app#Activity#onPause_E@ is called and not @B_android#app#Activity#onSaveInstanceState_E@ is when activity B is launched in front of activity A: the system may avoid calling @B_android#app#Activity#onSaveInstanceState_E@ on activity A if it isn't killed during the lifetime of B since the state of the user interface of A will stay intact. The default implementation takes care of most of the UI per-instance state for you by calling @B_android#view#View#onSaveInstanceState_E@ on each view in the hierarchy that has an id, and by saving the id of the currently focused view (all of which is restored by the default implementation of @B_android#app#Activity#onRestoreInstanceState_E@). If you override this method to save additional information not captured by each individual view, you will likely want to call through to the default implementation, otherwise be prepared to save all of the state of each view yourself. If called, this method will occur after @B_android#app#Activity#onStop_E@ for applications targeting platforms starting with @B_android#os#Build#VERSION_CODES#P_E@. For applications targeting earlier platform versions this method will occur before @B_android#app#Activity#onStop_E@ and there are no guarantees about whether it will occur before or after @B_android#app#Activity#onPause_E@.", "history": "Added in API level 9", "FullName": "protected void onSaveInstanceState (Bundle outState)"}, "onCreate(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: If the activity is being re-initialized after previously being shut down then this Bundle contains the data it most recently supplied in @B_android#app#NativeActivity#onSaveInstanceState_E@. Note: Otherwise it is null. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the activity is starting. This is where most initialization should go: calling @B_android#app#Activity#setContentView_E@ to inflate the activity's UI, using @B_android#app#Activity#findViewById_E@ to programmatically interact with widgets in the UI, calling @B_android#app#Activity#managedQuery_E@ to retrieve cursors for data being displayed, etc. You can call @B_android#app#Activity#finish_E@ from within this function, in which case onDestroy() will be immediately called after @B_android#app#Activity#onCreate_E@ without any of the rest of the activity lifecycle (@B_android#app#Activity#onStart_E@, @B_android#app#Activity#onResume_E@, @B_android#app#Activity#onPause_E@, etc) executing. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. This method must be called from the If you override this method you must call through to the superclass implementation.", "history": "Added in API level 9", "FullName": "protected void onCreate (Bundle savedInstanceState)"}, "surfaceRedrawNeeded(android.view.SurfaceHolder)": {"Returns": [], "Parameters": [["@B_android#view#SurfaceHolder_E@", "SurfaceHolder: The SurfaceHolder whose surface has changed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the application needs to redraw the content of its surface, after it is resized or for some other reason. By not returning from here until the redraw is complete, you can ensure that the user will not see your surface in a bad state (at its new size before it has been correctly drawn that way). This will typically be preceeded by a call to @B_android#view#SurfaceHolder#Callback#surfaceChanged_E@. As of O, @B_android#view#SurfaceHolder#Callback2#surfaceRedrawNeededAsync_E@ may be implemented to provide a non-blocking implementation. If @B_android#view#SurfaceHolder#Callback2#surfaceRedrawNeededAsync_E@ is not implemented, then this will be called instead.", "history": "Added in API level 9", "FullName": "public void surfaceRedrawNeeded (SurfaceHolder holder)"}, "surfaceDestroyed(android.view.SurfaceHolder)": {"Returns": [], "Parameters": [["@B_android#view#SurfaceHolder_E@", "SurfaceHolder: The SurfaceHolder whose surface is being destroyed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called immediately before a surface is being destroyed. After returning from this call, you should no longer try to access this surface. If you have a rendering thread that directly accesses the surface, you must ensure that thread is no longer touching the Surface before returning from this function.", "history": "Added in API level 9", "FullName": "public void surfaceDestroyed (SurfaceHolder holder)"}, "surfaceChanged(android.view.SurfaceHolder,int,int,int)": {"Returns": [], "Parameters": [["@B_android#view#SurfaceHolder_E@", "SurfaceHolder: The SurfaceHolder whose surface has changed."], ["int", "int: The new PixelFormat of the surface."], ["int", "int: The new width of the surface."], ["int", "int: The new height of the surface."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called immediately after any structural changes (format or size) have been made to the surface. You should at this point update the imagery in the surface. This method is always called at least once, after @B_android#view#SurfaceHolder#Callback#surfaceCreated_E@.", "history": "Added in API level 9", "FullName": "public void surfaceChanged (SurfaceHolder holder, int format, int width, int height)"}, "NativeActivity()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 9", "FullName": "public NativeActivity ()"}, "onInputQueueDestroyed(android.view.InputQueue)": {"Returns": [], "Parameters": [["@B_android#view#InputQueue_E@", "InputQueue no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the given InputQueue is no longer associated with the thread and thus not dispatching events.", "history": "Added in API level 9", "FullName": "public void onInputQueueDestroyed (InputQueue queue)"}}, "Inheritance": ["@B_android#content#Context_E@", "@B_android#content#ContextWrapper_E@", "@B_android#view#ContextThemeWrapper_E@", "@B_android#app#Activity_E@"], "ClassName": "android.app.NativeActivity", "ClassDesc": "Convenience for implementing an activity that will be implemented purely in native code. That is, a game (or game-like thing). There is no need to derive from this class; you can simply declare it in your manifest, and use the NDK APIs from there. A"}