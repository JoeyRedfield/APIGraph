{"Functions": {"startForeground(int, android.app.Notification)": {"Returns": [], "Parameters": [["int", "int: The identifier for this notification as per @B_android#app#NotificationManager#notify_E@; must not be 0."], ["@B_android#app#Notification_E@", "Notification: The Notification to be displayed."]], "Throws": [], "SeeAlso": ["@B_android#app#Service#stopForeground_E@"], "Permissions": ["@B_android#Manifest#permission#FOREGROUND_SERVICE_E@"], "Description": "If your service is started (running through @B_android#content#Context#startService_E@), then also make this service run in the foreground, supplying the ongoing notification to be shown to the user while in this state. By default started services are background, meaning that their process won't be given foreground CPU scheduling (unless something else in that process is foreground) and, if the system needs to kill them to reclaim more memory (such as to display a large page in a web browser), they can be killed without too much harm. You use @B_android#app#Service#startForeground_E@ if killing your service would be disruptive to the user, such as if your service is performing background music playback, so the user would notice if their music stopped playing. Note that calling this method does not put the service in the started state itself, even though the name sounds like it. You must always call @B_android#content#ContextWrapper#startService_E@ first to tell the system it should keep the service running, and then use this method to tell it to keep it running harder. Apps targeting API @B_android#os#Build#VERSION_CODES#P_E@ or later must request the permission @B_android#Manifest#permission#FOREGROUND_SERVICE_E@ in order to use this API.", "history": "added in API level 5", "FullName": "public final void startForeground (int id, Notification notification)"}, "startForeground(int,android.app.Notification)": {"Returns": [], "Parameters": [["int", "int: The identifier for this notification as per @B_android#app#NotificationManager#notify_E@; must not be 0."], ["@B_android#app#Notification_E@", "Notification: The Notification to be displayed."]], "Throws": [], "SeeAlso": ["@B_android#app#Service#stopForeground_E@"], "Permissions": ["@B_android#Manifest#permission#FOREGROUND_SERVICE_E@"], "Description": "If your service is started (running through @B_android#content#Context#startService_E@), then also make this service run in the foreground, supplying the ongoing notification to be shown to the user while in this state. By default started services are background, meaning that their process won't be given foreground CPU scheduling (unless something else in that process is foreground) and, if the system needs to kill them to reclaim more memory (such as to display a large page in a web browser), they can be killed without too much harm. You use @B_android#app#Service#startForeground_E@ if killing your service would be disruptive to the user, such as if your service is performing background music playback, so the user would notice if their music stopped playing. Note that calling this method does not put the service in the started state itself, even though the name sounds like it. You must always call @B_android#content#ContextWrapper#startService_E@ first to tell the system it should keep the service running, and then use this method to tell it to keep it running harder. Apps targeting API @B_android#os#Build#VERSION_CODES#P_E@ or later must request the permission @B_android#Manifest#permission#FOREGROUND_SERVICE_E@ in order to use this API. Apps built with SDK version @B_android#os#Build#VERSION_CODES#Q_E@ or later can specify the foreground service types using attribute @B_android#R#attr#foregroundServiceType_E@ in service element of manifest file. The value of attribute @B_android#R#attr#foregroundServiceType_E@ can be multiple flags ORed together.", "history": "Added in API level 5", "FullName": "public final void startForeground (int id, Notification notification)"}, "onStartCommand(android.content.Intent,int,int)": {"Returns": [["int", "The return value indicates what semantics the system should use for the service's current started state. It may be one of the constants associated with the @B_android#app#Service#START_CONTINUATION_MASK_E@ bits. Value is @B_android#app#Service#START_STICKY_COMPATIBILITY_E@, @B_android#app#Service#START_STICKY_E@, @B_android#app#Service#START_NOT_STICKY_E@, or @B_android#app#Service#START_REDELIVER_INTENT_E@"]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent supplied to @B_android#content#Context#startService_E@, as given. This may be null if the service is being restarted after its process has gone away, and it had previously returned anything except @B_android#app#Service#START_STICKY_COMPATIBILITY_E@."], ["int", "int: Additional data about this start request. Value is either 0 or a combination of @B_android#app#Service#START_FLAG_REDELIVERY_E@, and @B_android#app#Service#START_FLAG_RETRY_E@"], ["int", "int: A unique integer representing this specific request to start. Use with @B_android#app#Service#stopSelfResult_E@."]], "Throws": [], "SeeAlso": ["@B_android#app#Service#stopSelfResult_E@"], "Permissions": [], "Description": "Called by the system every time a client explicitly starts the service by calling @B_android#content#Context#startService_E@, providing the arguments it supplied and a unique integer token representing the start request. Do not call this method directly. For backwards compatibility, the default implementation calls @B_android#app#Service#onStart_E@ and returns either @B_android#app#Service#START_STICKY_E@ or @B_android#app#Service#START_STICKY_COMPATIBILITY_E@. Note that the system calls this on your service's main thread. A service's main thread is the same thread where UI operations take place for Activities running in the same process. You should always avoid stalling the main thread's event loop. When doing long-running operations, network calls, or heavy disk I/O, you should kick off a new thread, or use @B_android#os#AsyncTask_E@.", "history": "Added in API level 5", "FullName": "public int onStartCommand (Intent intent, int flags, int startId)"}, "onConfigurationChanged(android.content.res.Configuration)": {"Returns": [], "Parameters": [["@B_android#content#res#Configuration_E@", "Configuration: The new device configuration. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system when the device configuration changes while your component is running. Note that, unlike activities, other components are never restarted when a configuration changes: they must always deal with the results of the change, such as by re-retrieving resources. At the time that this function has been called, your Resources object will have been updated to return resource values matching the new configuration. For more information, read", "history": "Added in API level 1", "FullName": "public void onConfigurationChanged (Configuration newConfig)"}, "onTaskRemoved(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The original root Intent that was used to launch the task that is being removed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called if the service is currently running and the user has removed a task that comes from the service's application. If you have set @B_android#content#pm#ServiceInfo#FLAG_STOP_WITH_TASK_E@ then you will not receive this callback; instead, the service will simply be stopped.", "history": "Added in API level 14", "FullName": "public void onTaskRemoved (Intent rootIntent)"}, "onStart(android.content.Intent,int)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement @B_android#app#Service#onStartCommand_E@ instead.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public void onStart (Intent intent, int startId)"}, "onUnbind(android.content.Intent)": {"Returns": [["boolean", "Return true if you would like to have the service's @B_android#app#Service#onRebind_E@ method later called when new clients bind to it."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent that was used to bind to this service, as given to @B_android#content#Context#bindService_E@. Note that any extras that were included with the Intent at that point will not be seen here."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when all clients have disconnected from a particular interface published by the service. The default implementation does nothing and returns false.", "history": "Added in API level 1", "FullName": "public boolean onUnbind (Intent intent)"}, "stopForeground(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: If true, the @B_android#app#Service#STOP_FOREGROUND_REMOVE_E@ flag will be supplied."]], "Throws": [], "SeeAlso": ["@B_android#app#Service#stopForeground_E@", "@B_android#app#Service#startForeground_E@"], "Permissions": [], "Description": "Synonym for @B_android#app#Service#stopForeground_E@.", "history": "Added in API level 5", "FullName": "public final void stopForeground (boolean removeNotification)"}, "stopSelfResult(int)": {"Returns": [["boolean", "Returns true if the startId matches the last start request and the service will be stopped, else false."]], "Parameters": [["int", "int: The most recent start identifier received in @B_android#app#Service#onStart_E@."]], "Throws": [], "SeeAlso": ["@B_android#app#Service#stopSelf_E@"], "Permissions": [], "Description": "Stop the service if the most recent time it was started was @B_android#content#Context#stopService_E@ for this particular service but allows you to safely avoid stopping if there is a start request from a client that you haven't yet seen in @B_android#app#Service#onStart_E@. Be careful about ordering of your calls to this function.. If you call this function with the most-recently received ID before you have called it for previously received IDs, the service will be immediately stopped anyway. If you may end up processing IDs out of order (such as by dispatching them on separate threads), then you are responsible for stopping them in the same order you received them.", "history": "Added in API level 1", "FullName": "public final boolean stopSelfResult (int startId)"}, "onStart(android.content.Intent, int)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement @B_android#app#Service#onStartCommand_E@ instead.", "history": "added in API level 1", "FullName": "public void onStart (Intent intent, int startId)"}, "onStartCommand(android.content.Intent, int, int)": {"Returns": [["int", "The return value indicates what semantics the system should use for the service's current started state. It may be one of the constants associated with the @B_android#app#Service#START_CONTINUATION_MASK_E@ bits.Value is START_STICKY_COMPATIBILITY, START_STICKY, START_NOT_STICKY or START_REDELIVER_INTENT."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent supplied to @B_android#content#Context#startService_E@, as given. This may be null if the service is being restarted after its process has gone away, and it had previously returned anything except @B_android#app#Service#START_STICKY_COMPATIBILITY_E@."], ["int", "int: Additional data about this start request.Value is either 0 or combination of START_FLAG_REDELIVERY or START_FLAG_RETRY."], ["int", "int: A unique integer representing this specific request to start. Use with @B_android#app#Service#stopSelfResult_E@."]], "Throws": [], "SeeAlso": ["@B_android#app#Service#stopSelfResult_E@"], "Permissions": [], "Description": "Called by the system every time a client explicitly starts the service by calling @B_android#content#Context#startService_E@, providing the arguments it supplied and a unique integer token representing the start request. Do not call this method directly. For backwards compatibility, the default implementation calls @B_android#app#Service#onStart_E@ and returns either @B_android#app#Service#START_STICKY_E@ or @B_android#app#Service#START_STICKY_COMPATIBILITY_E@. Note that the system calls this on your service's main thread. A service's main thread is the same thread where UI operations take place for Activities running in the same process. You should always avoid stalling the main thread's event loop. When doing long-running operations, network calls, or heavy disk I/O, you should kick off a new thread, or use @B_android#os#AsyncTask_E@.", "history": "added in API level 5", "FullName": "public int onStartCommand (Intent intent, int flags, int startId)"}, "getForegroundServiceType()": {"Returns": [["int", "current foreground service type flags. Value is either 0 or a combination of @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_MANIFEST_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_NONE_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_DATA_SYNC_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_PHONE_CALL_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_LOCATION_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_CONNECTED_DEVICE_E@, and @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_MEDIA_PROJECTION_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If the service has become a foreground service by calling @B_android#app#Service#startForeground_E@ or @B_android#app#Service#startForeground_E@, @B_android#app#Service#getForegroundServiceType_E@ returns the current foreground service type. If there is no foregroundServiceType specified in manifest, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_NONE_E@ is returned. If the service is not a foreground service, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_NONE_E@ is returned.", "history": "Added in API level 29", "FullName": "public final int getForegroundServiceType ()"}, "onDestroy()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system to notify a Service that it is no longer used and is being removed. The service should clean up any resources it holds (threads, registered receivers, etc) at this point. Upon return, there will be no more calls in to this Service object and it is effectively dead. Do not call this method directly.", "history": "Added in API level 1", "FullName": "public void onDestroy ()"}, "onRebind(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent that was used to bind to this service, as given to @B_android#content#Context#bindService_E@. Note that any extras that were included with the Intent at that point will not be seen here."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when new clients have connected to the service, after it had previously been notified that all had disconnected in its @B_android#app#Service#onUnbind_E@. This will only be called if the implementation of @B_android#app#Service#onUnbind_E@ was overridden to return true.", "history": "Added in API level 1", "FullName": "public void onRebind (Intent intent)"}, "onLowMemory()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the overall system is running low on memory, and actively running processes should trim their memory usage. While the exact point at which this will be called is not defined, generally it will happen when all background process have been killed. That is, before reaching the point of killing processes hosting service and foreground UI that we would like to avoid killing. You should implement this method to release any caches or other unnecessary resources you may be holding on to. The system will perform a garbage collection for you after returning from this method. Preferably, you should implement @B_android#content#ComponentCallbacks2#onTrimMemory_E@ from @B_android#content#ComponentCallbacks2_E@ to incrementally unload your resources based on various levels of memory demands. That API is available for API level 14 and higher, so you should only use this @B_android#content#ComponentCallbacks#onLowMemory_E@ method as a fallback for older versions, which can be treated the same as @B_android#content#ComponentCallbacks2#onTrimMemory_E@ with the @B_android#content#ComponentCallbacks2#TRIM_MEMORY_COMPLETE_E@ level.", "history": "Added in API level 1", "FullName": "public void onLowMemory ()"}, "onBind(android.content.Intent)": {"Returns": [["@B_android#os#IBinder_E@", "Return an IBinder through which clients can call on to the service."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent that was used to bind to this service, as given to @B_android#content#Context#bindService_E@. Note that any extras that were included with the Intent at that point will not be seen here."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the communication channel to the service. May return null if clients can not bind to the service. The returned @B_android#os#IBinder_E@ is usually for a complex interface that has been Note that unlike other application components, calls on to the IBinder interface returned here may not happen on the main thread of the process. More information about the main thread can be found in", "history": "Added in API level 1", "FullName": "public abstract IBinder onBind (Intent intent)"}, "stopSelf(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": ["@B_android#app#Service#stopSelfResult_E@"], "Permissions": [], "Description": "Old version of @B_android#app#Service#stopSelfResult_E@ that doesn't return a result.", "history": "Added in API level 1", "FullName": "public final void stopSelf (int startId)"}, "stopSelf()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Service#stopSelfResult_E@"], "Permissions": [], "Description": "Stop the service, if it was previously started. This is the same as calling @B_android#content#Context#stopService_E@ for this particular service.", "history": "Added in API level 1", "FullName": "public final void stopSelf ()"}, "dump(java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: The raw file descriptor that the dump is being sent to."], ["@B_java#io#PrintWriter_E@", "PrintWriter: The PrintWriter to which you should dump your state. This will be closed for you after you return."], ["@B_java#lang#String_E@", "String: additional arguments to the dump request."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Print the Service's state into the given stream. This gets invoked if you run \"adb shell dumpsys activity service <yourservicename>\" (note that for this command to work, the service must be running, and you must specify a fully-qualified service name). This is distinct from \"dumpsys <servicename>\", which only works for named system services and which invokes the @B_android#os#IBinder#dump_E@ method on the @B_android#os#IBinder_E@ interface registered with ServiceManager.", "history": "Added in API level 1", "FullName": "protected void dump (FileDescriptor fd, PrintWriter writer, String[] args)"}, "onCreate()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system when the service is first created. Do not call this method directly.", "history": "Added in API level 1", "FullName": "public void onCreate ()"}, "onTrimMemory(int)": {"Returns": [], "Parameters": [["int", "int: The context of the trim, giving a hint of the amount of trimming the application may like to perform. Value is @B_android#content#ComponentCallbacks2#TRIM_MEMORY_COMPLETE_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_MODERATE_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_BACKGROUND_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_UI_HIDDEN_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_RUNNING_CRITICAL_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_RUNNING_LOW_E@, or @B_android#content#ComponentCallbacks2#TRIM_MEMORY_RUNNING_MODERATE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process. This will happen for example when it goes in the background and there is not enough memory to keep as many background processes running as desired. You should never compare to exact values of the level, since new intermediate values may be added -- you will typically want to compare if the value is greater or equal to a level you are interested in. To retrieve the processes current trim level at any point, you can use @B_android#app#ActivityManager#getMyMemoryState_E@.", "history": "Added in API level 14", "FullName": "public void onTrimMemory (int level)"}, "startForeground(int,android.app.Notification,int)": {"Returns": [], "Parameters": [["int", "int: The identifier for this notification as per @B_android#app#NotificationManager#notify_E@; must not be 0."], ["@B_android#app#Notification_E@", "Notification: The Notification to be displayed. This value must never be null."], ["int", "int: must be a subset flags of manifest attribute @B_android#R#attr#foregroundServiceType_E@ flags. Value is either 0 or a combination of @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_MANIFEST_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_NONE_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_DATA_SYNC_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_PHONE_CALL_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_LOCATION_E@, @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_CONNECTED_DEVICE_E@, and @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_MEDIA_PROJECTION_E@"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if param foregroundServiceType is not subset of manifest attribute @B_android#R#attr#foregroundServiceType_E@."]], "SeeAlso": ["@B_android#content#pm#ServiceInfo_E@"], "Permissions": [], "Description": "An overloaded version of @B_android#app#Service#startForeground_E@ with additional foregroundServiceType parameter. Apps built with SDK version @B_android#os#Build#VERSION_CODES#Q_E@ or later can specify the foreground service types using attribute @B_android#R#attr#foregroundServiceType_E@ in service element of manifest file. The value of attribute @B_android#R#attr#foregroundServiceType_E@ can be multiple flags ORed together. The foregroundServiceType parameter must be a subset flags of what is specified in manifest attribute @B_android#R#attr#foregroundServiceType_E@, if not, an IllegalArgumentException is thrown. Specify foregroundServiceType parameter as @B_android#content#pm#ServiceInfo#FOREGROUND_SERVICE_TYPE_MANIFEST_E@ to use all flags that is specified in manifest attribute foregroundServiceType.", "history": "Added in API level 29", "FullName": "public final void startForeground (int id, Notification notification, int foregroundServiceType)"}, "getApplication()": {"Returns": [["@B_android#app#Application_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the application that owns this service.", "history": "Added in API level 1", "FullName": "public final Application getApplication ()"}, "stopForeground(int)": {"Returns": [], "Parameters": [["int", "int: additional behavior options. Value is either 0 or a combination of @B_android#app#Service#STOP_FOREGROUND_REMOVE_E@, and @B_android#app#Service#STOP_FOREGROUND_DETACH_E@"]], "Throws": [], "SeeAlso": ["@B_android#app#Service#startForeground_E@"], "Permissions": [], "Description": "Remove this service from foreground state, allowing it to be killed if more memory is needed. This does not stop the service from running (for that you use @B_android#app#Service#stopSelf_E@ or related methods), just takes it out of the foreground state.", "history": "Added in API level 24", "FullName": "public final void stopForeground (int flags)"}, "Service()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public Service ()"}}, "Inheritance": ["@B_android#content#Context_E@", "@B_android#content#ContextWrapper_E@"], "ClassName": "android.app.Service", "ClassDesc": "A Service is an application component representing either an application's desire to perform a longer-running operation while not interacting with the user or to supply functionality for other applications to use. Each service class must have a corresponding @B_android#R#styleable#AndroidManifestService_E@ declaration in its package's AndroidManifest.xml. Services can be started with @B_android#content#Context#startService_E@ and @B_android#content#Context#bindService_E@. Note that services, like other application objects, run in the main thread of their hosting process. This means that, if your service is going to do any CPU intensive (such as MP3 playback) or blocking (such as networking) operations, it should spawn its own thread in which to do that work. More information on this can be found in @B_android#app#IntentService_E@ class is available as a standard implementation of Service that has its own thread where it schedules its work to be done. Topics covered here: Most confusion about the Service class actually revolves around what it is not: A Service is A Service is Thus a Service itself is actually very simple, providing two main features: A facility for the application to tell the system about something it wants to be doing in the background (even when the user is not directly interacting with the application). This corresponds to calls to @B_android#content#Context#startService_E@, which ask the system to schedule work for the service, to be run until the service or someone else explicitly stop it. A facility for an application to expose some of its functionality to other applications. This corresponds to calls to @B_android#content#Context#bindService_E@, which allows a long-standing connection to be made to the service in order to interact with it. When a Service component is actually created, for either of these reasons, all that the system actually does is instantiate the component and call its @B_android#app#Service#onCreate_E@ and any other appropriate callbacks on the main thread. It is up to the Service to implement these with the appropriate behavior, such as creating a secondary thread in which it does its work. Note that because Service itself is so simple, you can make your interaction with it as simple or complicated as you want: from treating it as a local Java object that you make direct method calls on (as illustrated by There are two reasons that a service can be run by the system. If someone calls @B_android#content#Context#startService_E@ then the system will retrieve the service (creating it and calling its @B_android#app#Service#onCreate_E@ method if needed) and then call its @B_android#app#Service#onStartCommand_E@ method with the arguments supplied by the client. The service will at this point continue running until @B_android#content#Context#stopService_E@ or @B_android#app#Service#stopSelf_E@ is called. Note that multiple calls to Context.startService() do not nest (though they do result in multiple corresponding calls to onStartCommand()), so no matter how many times it is started a service will be stopped once Context.stopService() or stopSelf() is called; however, services can use their @B_android#app#Service#stopSelf_E@ method to ensure the service is not stopped until started intents have been processed. For started services, there are two additional major modes of operation they can decide to run in, depending on the value they return from onStartCommand(): @B_android#app#Service#START_STICKY_E@ is used for services that are explicitly started and stopped as needed, while @B_android#app#Service#START_NOT_STICKY_E@ or @B_android#app#Service#START_REDELIVER_INTENT_E@ are used for services that should only remain running while processing any commands sent to them. See the linked documentation for more detail on the semantics. Clients can also use @B_android#content#Context#bindService_E@ to obtain a persistent connection to a service. This likewise creates the service if it is not already running (calling @B_android#app#Service#onCreate_E@ while doing so), but does not call onStartCommand(). The client will receive the @B_android#os#IBinder_E@ object that the service returns from its @B_android#app#Service#onBind_E@ method, allowing the client to then make calls back to the service. The service will remain running as long as the connection is established (whether or not the client retains a reference on the service's IBinder). Usually the IBinder returned is for a complex interface that has been A service can be both started and have connections bound to it. In such a case, the system will keep the service running as long as either it is started or there are one or more connections to it with the @B_android#content#Context#BIND_AUTO_CREATE_E@ flag. Once neither of these situations hold, the service's @B_android#app#Service#onDestroy_E@ method is called and the service is effectively terminated. All cleanup (stopping threads, unregistering receivers) should be complete upon returning from onDestroy(). Global access to a service can be enforced when it is declared in its manifest's @B_android#R#styleable#AndroidManifestService_E@ tag. By doing so, other applications will need to declare a corresponding @B_android#R#styleable#AndroidManifestUsesPermission_E@ element in their own manifest to be able to start, stop, or bind to the service. As of @B_android#os#Build#VERSION_CODES#GINGERBREAD_E@, when using @B_android#content#Context#startService_E@, you can also set @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@ and/or @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@ on the Intent. This will grant the Service temporary access to the specific URIs in the Intent. Access will remain until the Service has called @B_android#app#Service#stopSelf_E@ for that start command or a later one, or until the Service has been completely stopped. This works for granting access to the other apps that have not requested the permission protecting the Service, or even when the Service is not exported at all. In addition, a service can protect individual IPC calls into it with permissions, by calling the @B_android#content#ContextWrapper#checkCallingPermission_E@ method before executing the implementation of that call. See the The Android system will attempt to keep the process hosting a service around as long as the service has been started or has clients bound to it. When running low on memory and needing to kill existing processes, the priority of a process hosting the service will be the higher of the following possibilities: If the service is currently executing code in its @B_android#app#Service#onCreate_E@, @B_android#app#Service#onStartCommand_E@, or @B_android#app#Service#onDestroy_E@ methods, then the hosting process will be a foreground process to ensure this code can execute without being killed. If the service has been started, then its hosting process is considered to be less important than any processes that are currently visible to the user on-screen, but more important than any process not visible. Because only a few processes are generally visible to the user, this means that the service should not be killed except in low memory conditions. However, since the user is not directly aware of a background service, in that state it is considered a valid candidate to kill, and you should be prepared for this to happen. In particular, long-running services will be increasingly likely to kill and are guaranteed to be killed (and restarted if appropriate) if they remain started long enough. If there are clients bound to the service, then the service's hosting process is never less important than the most important client. That is, if one of its clients is visible to the user, then the service itself is considered to be visible. The way a client's importance impacts the service's importance can be adjusted through @B_android#content#Context#BIND_ABOVE_CLIENT_E@, @B_android#content#Context#BIND_ALLOW_OOM_MANAGEMENT_E@, @B_android#content#Context#BIND_WAIVE_PRIORITY_E@, @B_android#content#Context#BIND_IMPORTANT_E@, and @B_android#content#Context#BIND_ADJUST_WITH_ACTIVITY_E@. A started service can use the @B_android#app#Service#startForeground_E@ API to put the service in a foreground state, where the system considers it to be something the user is actively aware of and thus not a candidate for killing when low on memory. (It is still theoretically possible for the service to be killed under extreme memory pressure from the current foreground application, but in practice this should not be a concern.) Note this means that most of the time your service is running, it may be killed by the system if it is under heavy memory pressure. If this happens, the system will later try to restart the service. An important consequence of this is that if you implement @B_android#app#Service#onStartCommand_E@ to schedule work to be done asynchronously or in another thread, then you may want to use @B_android#app#Service#START_FLAG_REDELIVERY_E@ to have the system re-deliver an Intent for you so that it does not get lost if your service is killed while processing it. Other application components running in the same process as the service (such as an @B_android#app#Activity_E@) can, of course, increase the importance of the overall process beyond just the importance of the service itself. One of the most common uses of a Service is as a secondary component running alongside other parts of an application, in the same process as the rest of the components. All components of an .apk run in the same process unless explicitly stated otherwise, so this is a typical situation. When used in this way, by assuming the components are in the same process, you can greatly simplify the interaction between them: clients of the service can simply cast the IBinder they receive from it to a concrete class published by the service. An example of this use of a Service is shown here. First is the Service itself, publishing a custom class when bound: With that done, one can now write client code that directly accesses the running service, such as: If you need to be able to write a Service that can perform complicated communication with clients in remote processes (beyond simply the use of @B_android#content#Context#startService_E@ to send commands to it), then you can use the @B_android#os#Messenger_E@ class instead of writing full AIDL files. An example of a Service that uses Messenger as its client interface is shown here. First is the Service itself, publishing a Messenger to an internal Handler when bound: If we want to make this service run in a remote process (instead of the standard one for its .apk), we can use android:process in its manifest tag to specify one: Note that the name \"remote\" chosen here is arbitrary, and you can use other names if you want additional processes. The ':' prefix appends the name to your package's standard process name. With that done, clients can now bind to the service and send messages to it. Note that this allows clients to register with it to receive messages back as well:"}