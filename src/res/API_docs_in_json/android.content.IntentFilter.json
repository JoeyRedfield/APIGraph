{"Functions": {"matchDataAuthority(android.net.Uri)": {"Returns": [["int", "Returns either @B_android#content#IntentFilter#MATCH_CATEGORY_HOST_E@, @B_android#content#IntentFilter#MATCH_CATEGORY_PORT_E@, @B_android#content#IntentFilter#NO_MATCH_DATA_E@."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The data whose authority is being looked for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Match this intent filter against the given Intent data. This ignores the data scheme -- unlike @B_android#content#IntentFilter#matchData_E@, the authority will match regardless of whether there is a matching scheme.", "history": "Added in API level 1", "FullName": "public final int matchDataAuthority (Uri data)"}, "dump(android.util.Printer,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#util#Printer_E@", "Printer no parameter comment"], ["@B_java#lang#String_E@", "String no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public void dump (Printer du, String prefix)"}, "getAction(int)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an action in the filter.", "history": "Added in API level 1", "FullName": "public final String getAction (int index)"}, "addAction(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Name of the action to match, such as Intent.ACTION_VIEW."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add a new Intent action to match against. If any actions are included in the filter, then an Intent's action must be one of those values for it to match. If no actions are included, the Intent action is ignored.", "history": "Added in API level 1", "FullName": "public final void addAction (String action)"}, "pathsIterator()": {"Returns": [["@B_java#util#Iterator_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an iterator over the filter's data paths.", "history": "Added in API level 1", "FullName": "public final Iterator<PatternMatcher> pathsIterator ()"}, "hasDataType(java.lang.String)": {"Returns": [["boolean", "True if the type is explicitly mentioned in the filter."]], "Parameters": [["@B_java#lang#String_E@", "String: The data type to look for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Is the given data type included in the filter? Note that if the filter does not include any type, false will always be returned.", "history": "Added in API level 1", "FullName": "public final boolean hasDataType (String type)"}, "schemeSpecificPartsIterator()": {"Returns": [["@B_java#util#Iterator_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an iterator over the filter's data scheme specific parts.", "history": "Added in API level 19", "FullName": "public final Iterator<PatternMatcher> schemeSpecificPartsIterator ()"}, "writeToParcel(android.os.Parcel, int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "added in API level 1", "FullName": "public final void writeToParcel (Parcel dest, int flags)"}, "hasDataAuthority(android.net.Uri)": {"Returns": [["boolean", "Returns true if the data string matches an authority listed in the filter."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The data whose authority is being looked for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Is the given data authority included in the filter? Note that if the filter does not include any authorities, false will always be returned.", "history": "Added in API level 1", "FullName": "public final boolean hasDataAuthority (Uri data)"}, "countDataTypes()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of data types in the filter.", "history": "Added in API level 1", "FullName": "public final int countDataTypes ()"}, "IntentFilter(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The action to match, such as Intent.ACTION_MAIN."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "New IntentFilter that matches a single action with no data. If no data characteristics are subsequently specified, then the filter will only match intents that contain no data.", "history": "Added in API level 1", "FullName": "public IntentFilter (String action)"}, "hasCategory(java.lang.String)": {"Returns": [["boolean", "True if the category is explicitly mentioned in the filter."]], "Parameters": [["@B_java#lang#String_E@", "String: The category that the filter supports."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Is the given category included in the filter?", "history": "Added in API level 1", "FullName": "public final boolean hasCategory (String category)"}, "addDataScheme(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Name of the scheme to match, such as \"http\"."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#matchData_E@"], "Permissions": [], "Description": "Add a new Intent data scheme to match against. If any schemes are included in the filter, then an Intent's data must be either one of these schemes or a matching data type. If no schemes are included, then an Intent will match only if it includes no data. Note: scheme matching in the Android framework is case-sensitive, unlike formal RFC schemes. As a result, you should always write your schemes with lower case letters, and any schemes you receive from outside of Android should be converted to lower case before supplying them here.", "history": "Added in API level 1", "FullName": "public final void addDataScheme (String scheme)"}, "matchAction(java.lang.String)": {"Returns": [["boolean", "True if the action is listed in the filter."]], "Parameters": [["@B_java#lang#String_E@", "String: The desired action to look for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Match this filter against an Intent's action. If the filter does not specify any actions, the match will always fail.", "history": "Added in API level 1", "FullName": "public final boolean matchAction (String action)"}, "getDataPath(int)": {"Returns": [["@B_android#os#PatternMatcher_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a data path in the filter.", "history": "Added in API level 1", "FullName": "public final PatternMatcher getDataPath (int index)"}, "match(java.lang.String,java.lang.String,java.lang.String,android.net.Uri,java.util.Set<java.lang.String>,java.lang.String)": {"Returns": [["int", "Returns either a valid match constant (a combination of @B_android#content#IntentFilter#MATCH_CATEGORY_MASK_E@ and @B_android#content#IntentFilter#MATCH_ADJUSTMENT_MASK_E@), or one of the error codes @B_android#content#IntentFilter#NO_MATCH_TYPE_E@ if the type didn't match, @B_android#content#IntentFilter#NO_MATCH_DATA_E@ if the scheme/path didn't match, @B_android#content#IntentFilter#NO_MATCH_ACTION_E@ if the action didn't match, or @B_android#content#IntentFilter#NO_MATCH_CATEGORY_E@ if one or more categories didn't match."]], "Parameters": [["@B_java#lang#String_E@", "String: The intent action to match against (Intent.getAction)."], ["@B_java#lang#String_E@", "String: The intent type to match against (Intent.resolveType())."], ["@B_java#lang#String_E@", "String: The data scheme to match against (Intent.getScheme())."], ["@B_android#net#Uri_E@", "Uri: The data URI to match against (Intent.getData())."], ["@B_java#util#Set_E@", "Set: The categories to match against (Intent.getCategories())."], ["@B_java#lang#String_E@", "String: Tag to use in debugging messages."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#matchData_E@", "@B_android#content#Intent#getAction_E@", "@B_android#content#Intent#resolveType_E@", "@B_android#content#Intent#getScheme_E@", "@B_android#content#Intent#getData_E@", "@B_android#content#Intent#getCategories_E@"], "Permissions": [], "Description": "Test whether this filter matches the given intent data. A match is only successful if the actions and categories in the Intent match against the filter, as described in @B_android#content#IntentFilter_E@; in that case, the match result returned will be as per @B_android#content#IntentFilter#matchData_E@.", "history": "Added in API level 1", "FullName": "public final int match (String action, String type, String scheme, Uri data, Set<String> categories, String logTag)"}, "IntentFilter(java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The action to match, such as Intent.ACTION_VIEW."], ["@B_java#lang#String_E@", "String: The type to match, such as \"vnd.android.cursor.dir/person\"."]], "Throws": [["@B_android#content#IntentFilter#MalformedMimeTypeException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "New IntentFilter that matches a single action and data type. Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types. As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here. Throws @B_android#content#IntentFilter#MalformedMimeTypeException_E@ if the given MIME type is not syntactically correct.", "history": "Added in API level 1", "FullName": "public IntentFilter (String action, String dataType)"}, "hasDataPath(java.lang.String)": {"Returns": [["boolean", "True if the data string matches a path listed in the filter."]], "Parameters": [["@B_java#lang#String_E@", "String: The data path to look for. This is without the scheme prefix."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Is the given data path included in the filter? Note that if the filter does not include any paths, false will always be returned.", "history": "Added in API level 1", "FullName": "public final boolean hasDataPath (String data)"}, "getPriority()": {"Returns": [["int", "The priority of the filter."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#setPriority_E@"], "Permissions": [], "Description": "Return the priority of this filter.", "history": "Added in API level 1", "FullName": "public final int getPriority ()"}, "categoriesIterator()": {"Returns": [["@B_java#util#Iterator_E@", "Iterator if this filter has categories or null if none."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an iterator over the filter's categories.", "history": "Added in API level 1", "FullName": "public final Iterator<String> categoriesIterator ()"}, "dump(android.util.Printer, java.lang.String)": {"Returns": [], "Parameters": [["@B_android#util#Printer_E@", "Printer no parameter comment"], ["@B_java#lang#String_E@", "String no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public void dump (Printer du, String prefix)"}, "authoritiesIterator()": {"Returns": [["@B_java#util#Iterator_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an iterator over the filter's data authorities.", "history": "Added in API level 1", "FullName": "public final Iterator<IntentFilter.AuthorityEntry> authoritiesIterator ()"}, "matchData(java.lang.String,java.lang.String,android.net.Uri)": {"Returns": [["int", "Returns either a valid match constant (a combination of @B_android#content#IntentFilter#MATCH_CATEGORY_MASK_E@ and @B_android#content#IntentFilter#MATCH_ADJUSTMENT_MASK_E@), or one of the error codes @B_android#content#IntentFilter#NO_MATCH_TYPE_E@ if the type didn't match or @B_android#content#IntentFilter#NO_MATCH_DATA_E@ if the scheme/path didn't match."]], "Parameters": [["@B_java#lang#String_E@", "String: The desired data type to look for, as returned by Intent.resolveType()."], ["@B_java#lang#String_E@", "String: The desired data scheme to look for, as returned by Intent.getScheme()."], ["@B_android#net#Uri_E@", "Uri: The full data string to match against, as supplied in Intent.data."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#match_E@"], "Permissions": [], "Description": "Match this filter against an Intent's data (type, scheme and path). If the filter does not specify any types and does not specify any schemes/paths, the match will only succeed if the intent does not also specify a type or data. If the filter does not specify any schemes, it will implicitly match intents with no scheme, or the schemes \"content:\" or \"file:\" (basically performing a MIME-type only match). If the filter does not specify any MIME types, the Intent also must not specify a MIME type. Be aware that to match against an authority, you must also specify a base scheme the authority is in. To match against a data path, both a scheme and authority must be specified. If the filter does not specify any types or schemes that it matches against, it is considered to be empty (any authority or data path given is ignored, as if it were empty as well). Note: MIME type, Uri scheme, and host name matching in the Android framework is case-sensitive, unlike the formal RFC definitions. As a result, you should always write these elements with lower case letters, and normalize any MIME types or Uris you receive from outside of Android to ensure these elements are lower case before supplying them here.", "history": "Added in API level 1", "FullName": "public final int matchData (String type, String scheme, Uri data)"}, "addDataPath(java.lang.String,int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Either a raw string that must exactly match the file path, or a simple pattern, depending on type."], ["int", "int: Determines how path will be compared to determine a match: either @B_android#os#PatternMatcher#PATTERN_LITERAL_E@, @B_android#os#PatternMatcher#PATTERN_PREFIX_E@, or @B_android#os#PatternMatcher#PATTERN_SIMPLE_GLOB_E@."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#matchData_E@", "@B_android#content#IntentFilter#addDataScheme_E@", "@B_android#content#IntentFilter#addDataAuthority_E@"], "Permissions": [], "Description": "Add a new Intent data path to match against. The filter must include one or more schemes (via @B_android#content#IntentFilter#addDataScheme_E@) and one or more authorities (via @B_android#content#IntentFilter#addDataAuthority_E@) for the path to be considered. If any paths are included in the filter, then an Intent's data must match one of them. If no paths are included, then only the scheme/authority must match. The path given here can either be a literal that must directly match or match against a prefix, or it can be a simple globbing pattern. If the latter, you can use '*' anywhere in the pattern to match zero or more instances of the previous character, '.' as a wildcard to match any character, and '\\' to escape the next character.", "history": "Added in API level 1", "FullName": "public final void addDataPath (String path, int type)"}, "addDataAuthority(java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The host part of the authority to match. May start with a single '*' to wildcard the front of the host name."], ["@B_java#lang#String_E@", "String: Optional port part of the authority to match. If null, any port is allowed."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#matchData_E@", "@B_android#content#IntentFilter#addDataScheme_E@"], "Permissions": [], "Description": "Add a new Intent data authority to match against. The filter must include one or more schemes (via @B_android#content#IntentFilter#addDataScheme_E@) for the authority to be considered. If any authorities are included in the filter, then an Intent's data must match one of them. If no authorities are included, then only the scheme must match. Note: host name in the Android framework is case-sensitive, unlike formal RFC host names. As a result, you should always write your host names with lower case letters, and any host names you receive from outside of Android should be converted to lower case before supplying them here.", "history": "Added in API level 1", "FullName": "public final void addDataAuthority (String host, String port)"}, "IntentFilter(android.content.IntentFilter)": {"Returns": [], "Parameters": [["@B_android#content#IntentFilter_E@", "IntentFilter: The original filter to copy."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "New IntentFilter containing a copy of an existing filter.", "history": "Added in API level 1", "FullName": "public IntentFilter (IntentFilter o)"}, "countCategories()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of categories in the filter.", "history": "Added in API level 1", "FullName": "public final int countCategories ()"}, "addDataSchemeSpecificPart(java.lang.String,int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Either a raw string that must exactly match the scheme specific part path, or a simple pattern, depending on type."], ["int", "int: Determines how ssp will be compared to determine a match: either @B_android#os#PatternMatcher#PATTERN_LITERAL_E@, @B_android#os#PatternMatcher#PATTERN_PREFIX_E@, or @B_android#os#PatternMatcher#PATTERN_SIMPLE_GLOB_E@."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#matchData_E@", "@B_android#content#IntentFilter#addDataScheme_E@"], "Permissions": [], "Description": "Add a new Intent data \"scheme specific part\" to match against. The filter must include one or more schemes (via @B_android#content#IntentFilter#addDataScheme_E@) for the scheme specific part to be considered. If any scheme specific parts are included in the filter, then an Intent's data must match one of them. If no scheme specific parts are included, then only the scheme must match. The \"scheme specific part\" that this matches against is the string returned by @B_android#net#Uri#getSchemeSpecificPart_E@. For Uris that contain a path, this kind of matching is not generally of interest, since @B_android#content#IntentFilter#addDataAuthority_E@ and @B_android#content#IntentFilter#addDataPath_E@ can provide a better mechanism for matching them. However, for Uris that do not contain a path, the authority and path are empty, so this is the only way to match against the non-scheme part.", "history": "Added in API level 19", "FullName": "public final void addDataSchemeSpecificPart (String ssp, int type)"}, "IntentFilter(java.lang.String, java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The action to match, such as Intent.ACTION_VIEW."], ["@B_java#lang#String_E@", "String: The type to match, such as \"vnd.android.cursor.dir/person\"."]], "Throws": [["@B_android#content#IntentFilter#MalformedMimeTypeException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "New IntentFilter that matches a single action and data type. Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types. As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here. Throws @B_android#content#IntentFilter#MalformedMimeTypeException_E@ if the given MIME type is not syntactically correct.", "history": "added in API level 1", "FullName": "public IntentFilter (String action, String dataType)"}, "writeToParcel(android.os.Parcel,int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@. Value is either 0 or a combination of @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "Added in API level 1", "FullName": "public final void writeToParcel (Parcel dest, int flags)"}, "matchCategories(java.util.Set<java.lang.String>)": {"Returns": [["@B_java#lang#String_E@", "If all categories match (success), null; else the name of the first category that didn't match."]], "Parameters": [["@B_java#util#Set_E@", "Set: The categories included in the intent, as returned by Intent.getCategories()."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Match this filter against an Intent's categories. Each category in the Intent must be specified by the filter; if any are not in the filter, the match fails.", "history": "Added in API level 1", "FullName": "public final String matchCategories (Set<String> categories)"}, "IntentFilter()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "New empty IntentFilter.", "history": "Added in API level 1", "FullName": "public IntentFilter ()"}, "countDataPaths()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of data paths in the filter.", "history": "Added in API level 1", "FullName": "public final int countDataPaths ()"}, "describeContents()": {"Returns": [["int", "a bitmask indicating the set of special object types marshaled by this Parcelable object instance. Value is either 0 or @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Describe the kinds of special objects contained in this Parcelable instance's marshaled representation. For example, if the object will include a file descriptor in the output of @B_android#os#Parcelable#writeToParcel_E@, the return value of this method must include the @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@ bit.", "history": "Added in API level 1", "FullName": "public final int describeContents ()"}, "countDataSchemeSpecificParts()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of data scheme specific parts in the filter.", "history": "Added in API level 19", "FullName": "public final int countDataSchemeSpecificParts ()"}, "countDataAuthorities()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of data authorities in the filter.", "history": "Added in API level 1", "FullName": "public final int countDataAuthorities ()"}, "writeToXml(org.xmlpull.v1.XmlSerializer)": {"Returns": [], "Parameters": [["@B_org#xmlpull#v1#XmlSerializer_E@", "XmlSerializer no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Write the contents of the IntentFilter as an XML stream.", "history": "Added in API level 1", "FullName": "public void writeToXml (XmlSerializer serializer)"}, "countActions()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of actions in the filter.", "history": "Added in API level 1", "FullName": "public final int countActions ()"}, "actionsIterator()": {"Returns": [["@B_java#util#Iterator_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an iterator over the filter's actions. If there are no actions, returns null.", "history": "Added in API level 1", "FullName": "public final Iterator<String> actionsIterator ()"}, "addDataSchemeSpecificPart(java.lang.String, int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Either a raw string that must exactly match the scheme specific part path, or a simple pattern, depending on type."], ["int", "int: Determines how ssp will be compared to determine a match: either @B_android#os#PatternMatcher#PATTERN_LITERAL_E@, @B_android#os#PatternMatcher#PATTERN_PREFIX_E@, or @B_android#os#PatternMatcher#PATTERN_SIMPLE_GLOB_E@."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#matchData_E@", "@B_android#content#IntentFilter#addDataScheme_E@"], "Permissions": [], "Description": "Add a new Intent data \"scheme specific part\" to match against. The filter must include one or more schemes (via @B_android#content#IntentFilter#addDataScheme_E@) for the scheme specific part to be considered. If any scheme specific parts are included in the filter, then an Intent's data must match one of them. If no scheme specific parts are included, then only the scheme must match. The \"scheme specific part\" that this matches against is the string returned by @B_android#net#Uri#getSchemeSpecificPart_E@. For Uris that contain a path, this kind of matching is not generally of interest, since @B_android#content#IntentFilter#addDataAuthority_E@ and @B_android#content#IntentFilter#addDataPath_E@ can provide a better mechanism for matching them. However, for Uris that do not contain a path, the authority and path are empty, so this is the only way to match against the non-scheme part.", "history": "added in API level 19", "FullName": "public final void addDataSchemeSpecificPart (String ssp, int type)"}, "match(android.content.ContentResolver,android.content.Intent,boolean,java.lang.String)": {"Returns": [["int", "Returns either a valid match constant (a combination of @B_android#content#IntentFilter#MATCH_CATEGORY_MASK_E@ and @B_android#content#IntentFilter#MATCH_ADJUSTMENT_MASK_E@), or one of the error codes @B_android#content#IntentFilter#NO_MATCH_TYPE_E@ if the type didn't match, @B_android#content#IntentFilter#NO_MATCH_DATA_E@ if the scheme/path didn't match, @B_android#content#IntentFilter#NO_MATCH_ACTION_E@ if the action didn't match, or @B_android#content#IntentFilter#NO_MATCH_CATEGORY_E@ if one or more categories didn't match."]], "Parameters": [["@B_android#content#ContentResolver_E@", "ContentResolver no parameter comment"], ["@B_android#content#Intent_E@", "Intent: The Intent to compare against."], ["boolean", "boolean: If true, the intent's type will be resolved by calling Intent.resolveType(); otherwise a simple match against Intent.type will be performed."], ["@B_java#lang#String_E@", "String: Tag to use in debugging messages."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#match_E@"], "Permissions": [], "Description": "Test whether this filter matches the given", "history": "Added in API level 1", "FullName": "public final int match (ContentResolver resolver, Intent intent, boolean resolve, String logTag)"}, "getCategory(int)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a category in the filter.", "history": "Added in API level 1", "FullName": "public final String getCategory (int index)"}, "addCategory(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Name of category to match, such as Intent.CATEGORY_EMBED."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add a new Intent category to match against. The semantics of categories is the opposite of actions -- an Intent includes the categories that it requires, all of which must be included in the filter in order to match. In other words, adding a category to the filter has no impact on matching unless that category is specified in the intent.", "history": "Added in API level 1", "FullName": "public final void addCategory (String category)"}, "addDataType(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Name of the data type to match, such as \"vnd.android.cursor.dir/person\"."]], "Throws": [["@B_android#content#IntentFilter#MalformedMimeTypeException_E@", ""]], "SeeAlso": ["@B_android#content#IntentFilter#matchData_E@"], "Permissions": [], "Description": "Add a new Intent data type to match against. If any types are included in the filter, then an Intent's data must be either one of these types or a matching scheme. If no data types are included, then an Intent will only match if it specifies no data. Note: MIME type matching in the Android framework is case-sensitive, unlike formal RFC MIME types. As a result, you should always write your MIME types with lower case letters, and any MIME types you receive from outside of Android should be converted to lower case before supplying them here. Throws @B_android#content#IntentFilter#MalformedMimeTypeException_E@ if the given MIME type is not syntactically correct.", "history": "Added in API level 1", "FullName": "public final void addDataType (String type)"}, "create(java.lang.String,java.lang.String)": {"Returns": [["@B_android#content#IntentFilter_E@", "A new IntentFilter for the given action and type."]], "Parameters": [["@B_java#lang#String_E@", "String: The action to match, such as Intent.ACTION_VIEW."], ["@B_java#lang#String_E@", "String: The type to match, such as \"vnd.android.cursor.dir/person\"."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#IntentFilter_E@"], "Permissions": [], "Description": "Create a new IntentFilter instance with a specified action and MIME type, where you know the MIME type is correctly formatted. This catches the @B_android#content#IntentFilter#MalformedMimeTypeException_E@ exception that the constructor can call and turns it into a runtime exception.", "history": "Added in API level 1", "FullName": "public static IntentFilter create (String action, String dataType)"}, "getDataSchemeSpecificPart(int)": {"Returns": [["@B_android#os#PatternMatcher_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a data scheme specific part in the filter.", "history": "Added in API level 19", "FullName": "public final PatternMatcher getDataSchemeSpecificPart (int index)"}, "create(java.lang.String, java.lang.String)": {"Returns": [["@B_android#content#IntentFilter_E@", "A new IntentFilter for the given action and type."]], "Parameters": [["@B_java#lang#String_E@", "String: The action to match, such as Intent.ACTION_VIEW."], ["@B_java#lang#String_E@", "String: The type to match, such as \"vnd.android.cursor.dir/person\"."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#IntentFilter_E@"], "Permissions": [], "Description": "Create a new IntentFilter instance with a specified action and MIME type, where you know the MIME type is correctly formatted. This catches the @B_android#content#IntentFilter#MalformedMimeTypeException_E@ exception that the constructor can call and turns it into a runtime exception.", "history": "added in API level 1", "FullName": "public static IntentFilter create (String action, String dataType)"}, "getDataAuthority(int)": {"Returns": [["@B_android#content#IntentFilter#AuthorityEntry_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a data authority in the filter.", "history": "Added in API level 1", "FullName": "public final IntentFilter.AuthorityEntry getDataAuthority (int index)"}, "hasDataSchemeSpecificPart(java.lang.String)": {"Returns": [["boolean", "Returns true if the data string matches a scheme specific part listed in the filter."]], "Parameters": [["@B_java#lang#String_E@", "String: The scheme specific part that is being looked for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Is the given data scheme specific part included in the filter? Note that if the filter does not include any scheme specific parts, false will always be returned.", "history": "Added in API level 19", "FullName": "public final boolean hasDataSchemeSpecificPart (String data)"}, "schemesIterator()": {"Returns": [["@B_java#util#Iterator_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an iterator over the filter's data schemes.", "history": "Added in API level 1", "FullName": "public final Iterator<String> schemesIterator ()"}, "hasDataScheme(java.lang.String)": {"Returns": [["boolean", "True if the scheme is explicitly mentioned in the filter."]], "Parameters": [["@B_java#lang#String_E@", "String: The data scheme to look for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Is the given data scheme included in the filter? Note that if the filter does not include any scheme, false will always be returned.", "history": "Added in API level 1", "FullName": "public final boolean hasDataScheme (String scheme)"}, "getDataScheme(int)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a data scheme in the filter.", "history": "Added in API level 1", "FullName": "public final String getDataScheme (int index)"}, "countDataSchemes()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of data schemes in the filter.", "history": "Added in API level 1", "FullName": "public final int countDataSchemes ()"}, "getDataType(int)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a data type in the filter.", "history": "Added in API level 1", "FullName": "public final String getDataType (int index)"}, "readFromXml(org.xmlpull.v1.XmlPullParser)": {"Returns": [], "Parameters": [["@B_org#xmlpull#v1#XmlPullParser_E@", "XmlPullParser no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""], ["@B_org#xmlpull#v1#XmlPullParserException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public void readFromXml (XmlPullParser parser)"}, "hasAction(java.lang.String)": {"Returns": [["boolean", "True if the action is explicitly mentioned in the filter."]], "Parameters": [["@B_java#lang#String_E@", "String: The action to look for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Is the given action included in the filter? Note that if the filter does not include any actions, false will always be returned.", "history": "Added in API level 1", "FullName": "public final boolean hasAction (String action)"}, "setPriority(int)": {"Returns": [], "Parameters": [["int", "int: The new priority value."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#getPriority_E@", "@B_android#content#IntentFilter_E@"], "Permissions": [], "Description": "Modify priority of this filter. This only affects receiver filters. The priority of activity filters are set in XML and cannot be changed programmatically. The default priority is 0. Positive values will be before the default, lower values will be after it. Applications should use a value that is larger than @B_android#content#IntentFilter#SYSTEM_LOW_PRIORITY_E@ and smaller than @B_android#content#IntentFilter#SYSTEM_HIGH_PRIORITY_E@ .", "history": "Added in API level 1", "FullName": "public final void setPriority (int priority)"}, "typesIterator()": {"Returns": [["@B_java#util#Iterator_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an iterator over the filter's data types.", "history": "Added in API level 1", "FullName": "public final Iterator<String> typesIterator ()"}, "addDataPath(java.lang.String, int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Either a raw string that must exactly match the file path, or a simple pattern, depending on type."], ["int", "int: Determines how path will be compared to determine a match: either @B_android#os#PatternMatcher#PATTERN_LITERAL_E@, @B_android#os#PatternMatcher#PATTERN_PREFIX_E@, or @B_android#os#PatternMatcher#PATTERN_SIMPLE_GLOB_E@."]], "Throws": [], "SeeAlso": ["@B_android#content#IntentFilter#matchData_E@", "@B_android#content#IntentFilter#addDataScheme_E@", "@B_android#content#IntentFilter#addDataAuthority_E@"], "Permissions": [], "Description": "Add a new Intent data path to match against. The filter must include one or more schemes (via @B_android#content#IntentFilter#addDataScheme_E@) and one or more authorities (via @B_android#content#IntentFilter#addDataAuthority_E@) for the path to be considered. If any paths are included in the filter, then an Intent's data must match one of them. If no paths are included, then only the scheme/authority must match. The path given here can either be a literal that must directly match or match against a prefix, or it can be a simple globbing pattern. If the latter, you can use '*' anywhere in the pattern to match zero or more instances of the previous character, '.' as a wildcard to match any character, and '\\' to escape the next character.", "history": "added in API level 1", "FullName": "public final void addDataPath (String path, int type)"}}, "Inheritance": [], "ClassName": "android.content.IntentFilter", "ClassDesc": "Structured description of Intent values to be matched. An IntentFilter can match against actions, categories, and data (either via its type, scheme, and/or path) in an Intent. It also includes a \"priority\" value which is used to order multiple matching filters. IntentFilter objects are often created in XML as part of a package's @B_android#R#styleable#AndroidManifest_E@ file, using @B_android#R#styleable#AndroidManifestIntentFilter_E@ tags. There are three Intent characteristics you can filter on: the action, data, and categories. For each of these characteristics you can provide multiple possible matching values (via @B_android#content#IntentFilter#addAction_E@, @B_android#content#IntentFilter#addDataType_E@, @B_android#content#IntentFilter#addDataScheme_E@, @B_android#content#IntentFilter#addDataSchemeSpecificPart_E@, @B_android#content#IntentFilter#addDataAuthority_E@, @B_android#content#IntentFilter#addDataPath_E@, and @B_android#content#IntentFilter#addCategory_E@, respectively). For actions, if no data characteristics are specified, then the filter will only match intents that contain no data. The data characteristic is itself divided into three attributes: type, scheme, authority, and path. Any that are specified must match the contents of the Intent. If you specify a scheme but no type, only Intent that does not have a type (such as mailto:) will match; a content: URI will never match because they always have a MIME type that is supplied by their content provider. Specifying a type with no scheme has somewhat special meaning: it will match either an Intent with no URI field, or an Intent with a content: or file: URI. If you specify neither, then only an Intent with no data or type will match. To specify an authority, you must also specify one or more schemes that it is associated with. To specify a path, you also must specify both one or more authorities and one or more schemes it is associated with. A match is based on the following rules. Note that for an IntentFilter to match an Intent, three conditions must hold: the @B_android#content#IntentFilter#match_E@ for more details on how the data fields match). @B_android#content#Intent#resolveType_E@. A wildcard can be used for the MIME sub-type, in both the Intent and IntentFilter, so that the type \"audio/*\" will match \"audio/mpeg\", \"audio/aiff\", \"audio/*\", etc. Note that MIME type matching here is You should thus always use lower case letters for your MIME types. @B_android#content#Intent#getData_E@ and @B_android#net#Uri#getScheme_E@ on that URI. Note that scheme matching here is You should thus always use lower case letters for your schemes. and one of the data schemes in the filter has matched the Intent, or no scheme specific parts were supplied in the filter. The Intent scheme specific part is determined by calling @B_android#content#Intent#getData_E@ and @B_android#net#Uri#getSchemeSpecificPart_E@ on that URI. Note that scheme specific part matching is and one of the data schemes in the filter has matched the Intent, or no authorities were supplied in the filter. The Intent authority is determined by calling @B_android#content#Intent#getData_E@ and @B_android#net#Uri#getAuthority_E@ on that URI. Note that authority matching here is You should thus always use lower case letters for your authority. and both a scheme and authority in the filter has matched against the Intent, or no paths were supplied in the filter. The Intent authority is determined by calling @B_android#content#Intent#getData_E@ and @B_android#net#Uri#getPath_E@ on that URI. all of the categories in the Intent match categories given in the filter. Extra categories in the filter that are not in the Intent will not cause the match to fail. Note that unlike the action, an IntentFilter with no categories will only match an Intent that does not have any categories."}