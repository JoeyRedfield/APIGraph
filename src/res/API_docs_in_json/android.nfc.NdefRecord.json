{"Functions": {"createTextRecord(java.lang.String,java.lang.String)": {"Returns": [["@B_android#nfc#NdefRecord_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: The languageCode for the record. If locale is empty or null, the language code of the current default locale will be used."], ["@B_java#lang#String_E@", "String: The text to be encoded in the record. Will be represented in UTF-8 format."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if text is null"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new NDEF record containing UTF-8 text data. The caller can either specify the language code for the provided text, or otherwise the language code corresponding to the current default locale will be used. Reference specification: NFCForum-TS-RTD_Text_1.0", "history": "Added in API level 21", "FullName": "public static NdefRecord createTextRecord (String languageCode, String text)"}, "createUri(android.net.Uri)": {"Returns": [["@B_android#nfc#NdefRecord_E@", "an NDEF Record containing the URI"]], "Parameters": [["@B_android#net#Uri_E@", "Uri: URI to encode."]], "Throws": [["", "if the uri is empty or invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new NDEF Record containing a URI. Use this method to encode a URI (or URL) into an NDEF Record. Uses the well known URI type representation: @B_android#nfc#NdefRecord#TNF_WELL_KNOWN_E@ and @B_android#nfc#NdefRecord#RTD_URI_E@. This is the most efficient encoding of a URI into NDEF. The uri parameter will be normalized with @B_android#net#Uri#normalizeScheme_E@ to set the scheme to lower case to follow Android best practices for intent filtering. However the unchecked exception @B_java#lang#IllegalArgumentException_E@ may be thrown if the uri parameter has serious problems, for example if it is empty, so always catch this exception if you are passing user-generated data into this method. Reference specification: NFCForum-TS-RTD_URI_1.0", "history": "Added in API level 14", "FullName": "public static NdefRecord createUri (Uri uri)"}, "NdefRecord(short, byte[], byte[], byte[])": {"Returns": [], "Parameters": [["short", "short: a 3-bit TNF constant"], ["byte[]", "byte: byte array, containing zero to 255 bytes, or null"], ["byte[]", "byte: byte array, containing zero to 255 bytes, or null"], ["byte[]", "byte: byte array, containing zero to (2 ** 32 - 1) bytes, or null"]], "Throws": [["", "if a valid record cannot be created"]], "SeeAlso": [], "Permissions": [], "Description": "Construct an NDEF Record from its component fields. Recommend to use helpers such as {#createUri} or {@B_android#nfc#NdefRecord#createExternal_E@ where possible, since they perform stricter validation that the record is correctly formatted as per NDEF specifications. However if you know what you are doing then this constructor offers the most flexibility. An @B_android#nfc#NdefRecord_E@ represents a logical (complete) record, and cannot represent NDEF Record chunks. Basic validation of the tnf, type, id and payload is performed as per the following rules: The tnf paramter must be a 3-bit value. Records with a tnf of @B_android#nfc#NdefRecord#TNF_EMPTY_E@ cannot have a type, id or payload. Records with a tnf of @B_android#nfc#NdefRecord#TNF_UNKNOWN_E@ or 0x07 cannot have a type. Records with a tnf of @B_android#nfc#NdefRecord#TNF_UNCHANGED_E@ are not allowed since this class only represents complete (unchunked) records. This minimal validation is specified by NFCForum-TS-NDEF_1.0 section 3.2.6 (Type Name Format). If any of the above validation steps fail then @B_java#lang#IllegalArgumentException_E@ is thrown. Deep inspection of the type, id and payload fields is not performed, so it is possible to create NDEF Records that conform to section 3.2.6 but fail other more strict NDEF specification requirements. For example, the payload may be invalid given the tnf and type. To omit a type, id or payload field, set the parameter to an empty byte array or null.", "history": "added in API level 9", "FullName": "public NdefRecord (short tnf, byte[] type, byte[] id, byte[] payload)"}, "describeContents()": {"Returns": [["int", "a bitmask indicating the set of special object types marshaled by this Parcelable object instance. Value is either 0 or @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Describe the kinds of special objects contained in this Parcelable instance's marshaled representation. For example, if the object will include a file descriptor in the output of @B_android#os#Parcelable#writeToParcel_E@, the return value of this method must include the @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@ bit.", "history": "Added in API level 9", "FullName": "public int describeContents ()"}, "NdefRecord(short,byte[],byte[],byte[])": {"Returns": [], "Parameters": [["short", "short: a 3-bit TNF constant"], ["byte[]", "byte: byte array, containing zero to 255 bytes, or null"], ["byte[]", "byte: byte array, containing zero to 255 bytes, or null"], ["byte[]", "byte: byte array, containing zero to (2 ** 32 - 1) bytes, or null"]], "Throws": [["", "if a valid record cannot be created"]], "SeeAlso": [], "Permissions": [], "Description": "Construct an NDEF Record from its component fields. Recommend to use helpers such as {#createUri} or {@B_android#nfc#NdefRecord#createExternal_E@ where possible, since they perform stricter validation that the record is correctly formatted as per NDEF specifications. However if you know what you are doing then this constructor offers the most flexibility. An @B_android#nfc#NdefRecord_E@ represents a logical (complete) record, and cannot represent NDEF Record chunks. Basic validation of the tnf, type, id and payload is performed as per the following rules: The tnf paramter must be a 3-bit value. Records with a tnf of @B_android#nfc#NdefRecord#TNF_EMPTY_E@ cannot have a type, id or payload. Records with a tnf of @B_android#nfc#NdefRecord#TNF_UNKNOWN_E@ or 0x07 cannot have a type. Records with a tnf of @B_android#nfc#NdefRecord#TNF_UNCHANGED_E@ are not allowed since this class only represents complete (unchunked) records. This minimal validation is specified by NFCForum-TS-NDEF_1.0 section 3.2.6 (Type Name Format). If any of the above validation steps fail then @B_java#lang#IllegalArgumentException_E@ is thrown. Deep inspection of the type, id and payload fields is not performed, so it is possible to create NDEF Records that conform to section 3.2.6 but fail other more strict NDEF specification requirements. For example, the payload may be invalid given the tnf and type. To omit a type, id or payload field, set the parameter to an empty byte array or null.", "history": "Added in API level 9", "FullName": "public NdefRecord (short tnf, byte[] type, byte[] id, byte[] payload)"}, "createMime(java.lang.String, byte[])": {"Returns": [["@B_android#nfc#NdefRecord_E@", "an NDEF Record containing the MIME-typed data"]], "Parameters": [["@B_java#lang#String_E@", "String: a valid MIME type"], ["byte[]", "byte: MIME data as bytes"]], "Throws": [["", "if the mimeType is empty or invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new NDEF Record containing MIME data. Use this method to encode MIME-typed data into an NDEF Record, such as \"text/plain\", or \"image/jpeg\". The mimeType parameter will be normalized with @B_android#content#Intent#normalizeMimeType_E@ to follow Android best practices for intent filtering, for example to force lower-case. However the unchecked exception @B_java#lang#IllegalArgumentException_E@ may be thrown if the mimeType parameter has serious problems, for example if it is empty, so always catch this exception if you are passing user-generated data into this method. For efficiency, This method might not make an internal copy of the mimeData byte array, so take care not to modify the mimeData byte array while still using the returned NdefRecord.", "history": "added in API level 16", "FullName": "public static NdefRecord createMime (String mimeType, byte[] mimeData)"}, "toByteArray()": {"Returns": [["byte[]", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#nfc#NdefMessage#toByteArray_E@ instead Return this NDEF Record as a byte array. This method is deprecated, use @B_android#nfc#NdefMessage#toByteArray_E@ instead. This is because the NDEF binary format is not defined for a record outside of the context of a message: the MB and ME flags cannot be set without knowing the location inside a message. This implementation will attempt to serialize a single record by always setting the MB and ME flags (in other words, assume this is a single-record NDEF Message).", "history": "Added in API level 9 Deprecated in API level 16", "FullName": "public byte[] toByteArray ()"}, "getTnf()": {"Returns": [["short", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the 3-bit TNF. TNF is the top-level type.", "history": "Added in API level 9", "FullName": "public short getTnf ()"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if this object is the same as the obj argument; false otherwise."]], "Parameters": [["@B_java#lang#Object_E@", "Object: the reference object with which to compare."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the specified NDEF Record contains identical tnf, type, id and payload fields.", "history": "Added in API level 9", "FullName": "public boolean equals (Object obj)"}, "createApplicationRecord(java.lang.String)": {"Returns": [["@B_android#nfc#NdefRecord_E@", "Android application NDEF record"]], "Parameters": [["@B_java#lang#String_E@", "String: Android package name"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new Android Application Record (AAR). This record indicates to other Android devices the package that should be used to handle the entire NDEF message. You can embed this record anywhere into your message to ensure that the intended package receives the message. When an Android device dispatches an @B_android#nfc#NdefMessage_E@ containing one or more Android application records, the applications contained in those records will be the preferred target for the @B_android#nfc#NfcAdapter#ACTION_NDEF_DISCOVERED_E@ intent, in the order in which they appear in the message. This dispatch behavior was first added to Android in Ice Cream Sandwich. If none of the applications have a are installed on the device, a Market link will be opened to the first application. Note that Android application records do not overrule applications that have called @B_android#nfc#NfcAdapter#enableForegroundDispatch_E@.", "history": "Added in API level 14", "FullName": "public static NdefRecord createApplicationRecord (String packageName)"}, "getPayload()": {"Returns": [["byte[]", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the variable length payload. Returns an empty byte array if this record does not have a payload field.", "history": "Added in API level 9", "FullName": "public byte[] getPayload ()"}, "getId()": {"Returns": [["byte[]", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the variable length ID. Returns an empty byte array if this record does not have an id field.", "history": "Added in API level 9", "FullName": "public byte[] getId ()"}, "hashCode()": {"Returns": [["int", "a hash code value for this object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by @B_java#util#HashMap_E@. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the @B_java#lang#Object#equals_E@ method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java\u2122 programming language.)", "history": "Added in API level 9", "FullName": "public int hashCode ()"}, "NdefRecord(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: raw bytes to parse"]], "Throws": [["@B_android#nfc#FormatException_E@", "if the data cannot be parsed into a valid record"]], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#nfc#NdefMessage#NdefMessage_E@ instead. Construct an NDEF Record from raw bytes. This method is deprecated, use @B_android#nfc#NdefMessage#NdefMessage_E@ instead. This is because it does not make sense to parse a record: the NDEF binary format is only defined for a message, and the record flags MB and ME do not make sense outside of the context of an entire message. This implementation will attempt to parse a single record by ignoring the MB and ME flags, and otherwise following the rules of @B_android#nfc#NdefMessage#NdefMessage_E@.", "history": "Added in API level 9", "FullName": "public NdefRecord (byte[] data)"}, "createUri(java.lang.String)": {"Returns": [["@B_android#nfc#NdefRecord_E@", "an NDEF Record containing the URI"]], "Parameters": [["@B_java#lang#String_E@", "String: string URI to encode."]], "Throws": [["", "if the uriString is empty or invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new NDEF Record containing a URI. Use this method to encode a URI (or URL) into an NDEF Record. Uses the well known URI type representation: @B_android#nfc#NdefRecord#TNF_WELL_KNOWN_E@ and @B_android#nfc#NdefRecord#RTD_URI_E@. This is the most efficient encoding of a URI into NDEF. The uriString parameter will be normalized with @B_android#net#Uri#normalizeScheme_E@ to set the scheme to lower case to follow Android best practices for intent filtering. However the unchecked exception @B_java#lang#IllegalArgumentException_E@ may be thrown if the uriString parameter has serious problems, for example if it is empty, so always catch this exception if you are passing user-generated data into this method. Reference specification: NFCForum-TS-RTD_URI_1.0", "history": "Added in API level 14", "FullName": "public static NdefRecord createUri (String uriString)"}, "writeToParcel(android.os.Parcel, int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "added in API level 9", "FullName": "public void writeToParcel (Parcel dest, int flags)"}, "createExternal(java.lang.String,java.lang.String,byte[])": {"Returns": [["@B_android#nfc#NdefRecord_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: domain-name of issuing organization"], ["@B_java#lang#String_E@", "String: domain-specific type of data"], ["byte[]", "byte: payload as bytes"]], "Throws": [["", "if either domain or type are empty or invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new NDEF Record containing external (application-specific) data. Use this method to encode application specific data into an NDEF Record. The data is typed by a domain name (usually your Android package name) and a domain-specific type. This data is packaged into a \"NFC Forum External Type\" NDEF Record. NFC Forum requires that the domain and type used in an external record are treated as case insensitive, however Android intent filtering is always case sensitive. So this method will force the domain and type to lower-case before creating the NDEF Record. The unchecked exception @B_java#lang#IllegalArgumentException_E@ will be thrown if the domain and type have serious problems, for example if either field is empty, so always catch this exception if you are passing user-generated data into this method. There are no such restrictions on the payload data. For efficiency, This method might not make an internal copy of the data byte array, so take care not to modify the data byte array while still using the returned NdefRecord. Reference specification: NFCForum-TS-RTD_1.0", "history": "Added in API level 16", "FullName": "public static NdefRecord createExternal (String domain, String type, byte[] data)"}, "createMime(java.lang.String,byte[])": {"Returns": [["@B_android#nfc#NdefRecord_E@", "an NDEF Record containing the MIME-typed data"]], "Parameters": [["@B_java#lang#String_E@", "String: a valid MIME type"], ["byte[]", "byte: MIME data as bytes"]], "Throws": [["", "if the mimeType is empty or invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Create a new NDEF Record containing MIME data. Use this method to encode MIME-typed data into an NDEF Record, such as \"text/plain\", or \"image/jpeg\". The mimeType parameter will be normalized with @B_android#content#Intent#normalizeMimeType_E@ to follow Android best practices for intent filtering, for example to force lower-case. However the unchecked exception @B_java#lang#IllegalArgumentException_E@ may be thrown if the mimeType parameter has serious problems, for example if it is empty, so always catch this exception if you are passing user-generated data into this method. For efficiency, This method might not make an internal copy of the mimeData byte array, so take care not to modify the mimeData byte array while still using the returned NdefRecord.", "history": "Added in API level 16", "FullName": "public static NdefRecord createMime (String mimeType, byte[] mimeData)"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of the object. In general, the toString method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:", "history": "Added in API level 9", "FullName": "public String toString ()"}, "writeToParcel(android.os.Parcel,int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@. Value is either 0 or a combination of @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "Added in API level 9", "FullName": "public void writeToParcel (Parcel dest, int flags)"}, "toUri()": {"Returns": [["@B_android#net#Uri_E@", "URI, or null if this is not a URI record"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Map this record to a URI, or return null if it cannot be mapped. Currently this method considers the following to be URI records: @B_android#nfc#NdefRecord#TNF_ABSOLUTE_URI_E@ records. @B_android#nfc#NdefRecord#TNF_WELL_KNOWN_E@ with a type of @B_android#nfc#NdefRecord#RTD_URI_E@. @B_android#nfc#NdefRecord#TNF_WELL_KNOWN_E@ with a type of @B_android#nfc#NdefRecord#RTD_SMART_POSTER_E@ and containing a URI record in the NDEF message nested in the payload. @B_android#nfc#NdefRecord#TNF_EXTERNAL_TYPE_E@ records. If this is not a URI record by the above rules, then null is returned. This method does not perform validation that the URI is actually valid: it always attempts to create and return a URI if this record appears to be a URI record by the above rules. The returned URI will be normalized to have a lower case scheme using @B_android#net#Uri#normalizeScheme_E@.", "history": "Added in API level 16", "FullName": "public Uri toUri ()"}, "getType()": {"Returns": [["byte[]", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the variable length Type field. This should be used in conjunction with the TNF field to determine the payload format. Returns an empty byte array if this record does not have a type field.", "history": "Added in API level 9", "FullName": "public byte[] getType ()"}, "toMimeType()": {"Returns": [["@B_java#lang#String_E@", "MIME type as a string, or null if this is not a MIME record"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Map this record to a MIME type, or return null if it cannot be mapped. Currently this method considers all @B_android#nfc#NdefRecord#TNF_MIME_MEDIA_E@ records to be MIME records, as well as some @B_android#nfc#NdefRecord#TNF_WELL_KNOWN_E@ records such as @B_android#nfc#NdefRecord#RTD_TEXT_E@. If this is a MIME record then the MIME type as string is returned, otherwise null is returned. This method does not perform validation that the MIME type is actually valid. It always attempts to return a string containing the type if this is a MIME record. The returned MIME type will by normalized to lower-case using @B_android#content#Intent#normalizeMimeType_E@. The MIME payload can be obtained using @B_android#nfc#NdefRecord#getPayload_E@.", "history": "Added in API level 16", "FullName": "public String toMimeType ()"}}, "Inheritance": [], "ClassName": "android.nfc.NdefRecord", "ClassDesc": "Represents an immutable NDEF Record. NDEF (NFC Data Exchange Format) is a light-weight binary format, used to encapsulate typed data. It is specified by the NFC Forum, for transmission and storage with NFC, however it is transport agnostic. NDEF defines messages and records. An NDEF Record contains typed data, such as MIME-type media, a URI, or a custom application payload. An NDEF Message is a container for one or more NDEF Records. This class represents logical (complete) NDEF Records, and can not be used to represent chunked (partial) NDEF Records. However @B_android#nfc#NdefMessage#NdefMessage_E@ can be used to parse a message containing chunked records, and will return a message with unchunked (complete) records. A logical NDEF Record always contains a 3-bit TNF (Type Name Field) that provides high level typing for the rest of the record. The remaining fields are variable length and not always present: type: detailed typing for the payload id: identifier meta-data, not commonly used payload: the actual payload Helpers such as @B_android#nfc#NdefRecord#createUri_E@, @B_android#nfc#NdefRecord#createMime_E@ and @B_android#nfc#NdefRecord#createExternal_E@ are included to create well-formatted NDEF Records with correctly set tnf, type, id and payload fields, please use these helpers whenever possible. Use the constructor @B_android#nfc#NdefRecord#NdefRecord_E@ if you know what you are doing and what to set the fields individually. Only basic validation is performed with this constructor, so it is possible to create records that do not confirm to the strict NFC Forum specifications. The binary representation of an NDEF Record includes additional flags to indicate location with an NDEF message, provide support for chunking of NDEF records, and to pack optional fields. This class does not expose those details. To write an NDEF Record as binary you must first put it into an @B_android#nfc#NdefMessage_E@, then call @B_android#nfc#NdefMessage#toByteArray_E@. @B_android#nfc#NdefMessage_E@ and @B_android#nfc#NdefRecord_E@ implementations are always available, even on Android devices that do not have NFC hardware. @B_android#nfc#NdefRecord_E@s are intended to be immutable (and thread-safe), however they may contain mutable fields. So take care not to modify mutable fields passed into constructors, or modify mutable fields obtained by getter methods, unless such modification is explicitly marked as safe."}