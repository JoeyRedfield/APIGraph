{"Functions": {"toString()": {"Returns": [["@B_java#lang#String_E@", "the String representation of the @B_java#util#concurrent#atomic#LongAdder#sum_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the String representation of the @B_java#util#concurrent#atomic#LongAdder#sum_E@.", "history": "Added in API level 24", "FullName": "public String toString ()"}, "intValue()": {"Returns": [["int", "the numeric value represented by this object after conversion to type int."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the @B_java#util#concurrent#atomic#LongAdder#sum_E@ as an int after a narrowing primitive conversion.", "history": "Added in API level 24", "FullName": "public int intValue ()"}, "reset()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Resets variables maintaining the sum to zero. This method may be a useful alternative to creating a new adder, but is only effective if there are no concurrent updates. Because this method is intrinsically racy, it should only be used when it is known that no threads are concurrently updating.", "history": "Added in API level 24", "FullName": "public void reset ()"}, "longValue()": {"Returns": [["long", "the sum"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to @B_java#util#concurrent#atomic#LongAdder#sum_E@.", "history": "Added in API level 24", "FullName": "public long longValue ()"}, "add(long)": {"Returns": [], "Parameters": [["long", "long: the value to add"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds the given value.", "history": "Added in API level 24", "FullName": "public void add (long x)"}, "floatValue()": {"Returns": [["float", "the numeric value represented by this object after conversion to type float."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the @B_java#util#concurrent#atomic#LongAdder#sum_E@ as a float after a widening primitive conversion.", "history": "Added in API level 24", "FullName": "public float floatValue ()"}, "sumThenReset()": {"Returns": [["long", "the sum"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent in effect to @B_java#util#concurrent#atomic#LongAdder#sum_E@ followed by @B_java#util#concurrent#atomic#LongAdder#reset_E@. This method may apply for example during quiescent points between multithreaded computations. If there are updates concurrent with this method, the returned value is not guaranteed to be the final value occurring before the reset.", "history": "Added in API level 24", "FullName": "public long sumThenReset ()"}, "LongAdder()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a new adder with initial sum of zero.", "history": "Added in API level 24", "FullName": "public LongAdder ()"}, "doubleValue()": {"Returns": [["double", "the numeric value represented by this object after conversion to type double."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the @B_java#util#concurrent#atomic#LongAdder#sum_E@ as a double after a widening primitive conversion.", "history": "Added in API level 24", "FullName": "public double doubleValue ()"}, "increment()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to add(1).", "history": "Added in API level 24", "FullName": "public void increment ()"}, "decrement()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to add(-1).", "history": "Added in API level 24", "FullName": "public void decrement ()"}, "sum()": {"Returns": [["long", "the sum"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current sum. The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the sum is being calculated might not be incorporated.", "history": "Added in API level 24", "FullName": "public long sum ()"}}, "Inheritance": ["@B_java#lang#Number_E@"], "ClassName": "java.util.concurrent.atomic.LongAdder", "ClassDesc": "One or more variables that together maintain an initially zero long sum. When updates (method @B_java#util#concurrent#atomic#LongAdder#add_E@) are contended across threads, the set of variables may grow dynamically to reduce contention. Method @B_java#util#concurrent#atomic#LongAdder#sum_E@ (or, equivalently, @B_java#util#concurrent#atomic#LongAdder#longValue_E@) returns the current total combined across the variables maintaining the sum. This class is usually preferable to @B_java#util#concurrent#atomic#AtomicLong_E@ when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption. LongAdders can be used with a @B_java#util#concurrent#ConcurrentHashMap_E@ to maintain a scalable frequency map (a form of histogram or multiset). For example, to add a count to a ConcurrentHashMap<String,LongAdder> freqs, initializing if not already present, you can use freqs.computeIfAbsent(key, k -> new LongAdder()).increment(); This class extends @B_java#lang#Number_E@, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys."}