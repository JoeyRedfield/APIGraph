{"Functions": {"ofPattern(java.lang.String)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "the formatter based on the pattern, not null"]], "Parameters": [["@B_java#lang#String_E@", "String: the pattern to use, not null"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"]], "SeeAlso": ["@B_java#time#format#DateTimeFormatterBuilder#appendPattern_E@"], "Permissions": [], "Description": "Creates a formatter using the specified pattern. This method will create a formatter based on a simple d MMM uuuu will format 2011-12-03 as '3 Dec 2011'. The formatter will use the @B_java#util#Locale#getDefault_E@. This can be changed using @B_java#time#format#DateTimeFormatter#withLocale_E@ on the returned formatter Alternatively use the @B_java#time#format#DateTimeFormatter#ofPattern_E@ variant of this method. The returned formatter has no override chronology or zone. It uses @B_java#time#format#ResolverStyle#SMART_E@ resolver style.", "history": "Added in API level 26", "FullName": "public static DateTimeFormatter ofPattern (String pattern)"}, "ofLocalizedTime(java.time.format.FormatStyle)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "the time formatter, not null"]], "Parameters": [["@B_java#time#format#FormatStyle_E@", "FormatStyle: the formatter style to obtain, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a locale specific time format for the ISO chronology. This returns a formatter that will format or parse a time. The exact format pattern used varies by locale. The locale is determined from the formatter. The formatter returned directly by this method will use the @B_java#util#Locale#getDefault_E@. The locale can be controlled using @B_java#time#format#DateTimeFormatter#withLocale_E@ on the result of this method. Note that the localized pattern is looked up lazily. This DateTimeFormatter holds the style required and the locale, looking up the pattern required on demand. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the @B_java#time#format#ResolverStyle#SMART_E@ resolver style.", "history": "Added in API level 26", "FullName": "public static DateTimeFormatter ofLocalizedTime (FormatStyle timeStyle)"}, "withChronology(java.time.chrono.Chronology)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "a formatter based on this formatter with the requested override chronology, not null"]], "Parameters": [["@B_java#time#chrono#Chronology_E@", "Chronology: the new chronology, null if no override"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a copy of this formatter with a new override chronology. This returns a formatter with similar state to this formatter but with the override chronology set. By default, a formatter has no override chronology, returning null. If an override is added, then any date that is formatted or parsed will be affected. When formatting, if the temporal object contains a date, then it will be converted to a date in the override chronology. Whether the temporal contains a date is determined by querying the @B_java#time#temporal#ChronoField#EPOCH_DAY_E@ field. Any time or zone will be retained unaltered unless overridden. If the temporal object does not contain a date, but does contain one or more ChronoField date fields, then a DateTimeException is thrown. In all other cases, the override chronology is added to the temporal, replacing any previous chronology, but without changing the date/time. When parsing, there are two distinct cases to consider. If a chronology has been parsed directly from the text, perhaps because @B_java#time#format#DateTimeFormatterBuilder#appendChronologyId_E@ was used, then this override chronology has no effect. If no zone has been parsed, then this override chronology will be used to interpret the ChronoField values into a date according to the date resolving rules of the chronology. This instance is immutable and unaffected by this method call.", "history": "Added in API level 26", "FullName": "public DateTimeFormatter withChronology (Chronology chrono)"}, "getResolverStyle()": {"Returns": [["@B_java#time#format#ResolverStyle_E@", "the resolver style of this formatter, not null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the resolver style to use during parsing. This returns the resolver style, used during the second phase of parsing when fields are resolved into dates and times. By default, a formatter has the @B_java#time#format#ResolverStyle#SMART_E@ resolver style. See @B_java#time#format#DateTimeFormatter#withResolverStyle_E@ for more details.", "history": "Added in API level 26", "FullName": "public ResolverStyle getResolverStyle ()"}, "getResolverFields()": {"Returns": [["@B_java#util#Set_E@", "the immutable set of resolver fields of this formatter, null if no fields"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the resolver fields to use during parsing. This returns the resolver fields, used during the second phase of parsing when fields are resolved into dates and times. By default, a formatter has no resolver fields, and thus returns null. See @B_java#time#format#DateTimeFormatter#withResolverFields_E@ for more details.", "history": "Added in API level 26", "FullName": "public Set<TemporalField> getResolverFields ()"}, "ofPattern(java.lang.String,java.util.Locale)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "the formatter based on the pattern, not null"]], "Parameters": [["@B_java#lang#String_E@", "String: the pattern to use, not null"], ["@B_java#util#Locale_E@", "Locale: the locale to use, not null"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"]], "SeeAlso": ["@B_java#time#format#DateTimeFormatterBuilder#appendPattern_E@"], "Permissions": [], "Description": "Creates a formatter using the specified pattern and locale. This method will create a formatter based on a simple d MMM uuuu will format 2011-12-03 as '3 Dec 2011'. The formatter will use the specified locale. This can be changed using @B_java#time#format#DateTimeFormatter#withLocale_E@ on the returned formatter The returned formatter has no override chronology or zone. It uses @B_java#time#format#ResolverStyle#SMART_E@ resolver style.", "history": "Added in API level 26", "FullName": "public static DateTimeFormatter ofPattern (String pattern, Locale locale)"}, "ofLocalizedDate(java.time.format.FormatStyle)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "the date formatter, not null"]], "Parameters": [["@B_java#time#format#FormatStyle_E@", "FormatStyle: the formatter style to obtain, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a locale specific date format for the ISO chronology. This returns a formatter that will format or parse a date. The exact format pattern used varies by locale. The locale is determined from the formatter. The formatter returned directly by this method will use the @B_java#util#Locale#getDefault_E@. The locale can be controlled using @B_java#time#format#DateTimeFormatter#withLocale_E@ on the result of this method. Note that the localized pattern is looked up lazily. This DateTimeFormatter holds the style required and the locale, looking up the pattern required on demand. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the @B_java#time#format#ResolverStyle#SMART_E@ resolver style.", "history": "Added in API level 26", "FullName": "public static DateTimeFormatter ofLocalizedDate (FormatStyle dateStyle)"}, "getChronology()": {"Returns": [["@B_java#time#chrono#Chronology_E@", "the override chronology of this formatter, null if no override"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the overriding chronology to be used during formatting. This returns the override chronology, used to convert dates. By default, a formatter has no override chronology, returning null. See @B_java#time#format#DateTimeFormatter#withChronology_E@ for more details on overriding.", "history": "Added in API level 26", "FullName": "public Chronology getChronology ()"}, "parse(java.lang.CharSequence,java.time.temporal.TemporalQuery<T>)": {"Returns": [["T", "the parsed date-time, not null"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the text to parse, not null"], ["@B_java#time#temporal#TemporalQuery_E@", "TemporalQuery: the query defining the type to parse to, not null"]], "Throws": [["@B_java#time#format#DateTimeParseException_E@", "if unable to parse the requested result"]], "SeeAlso": [], "Permissions": [], "Description": "Fully parses the text producing an object of the specified type. Most applications should use this method for parsing. It parses the entire text to produce the required date-time. The query is typically a method reference to a from(TemporalAccessor) method. For example:", "history": "Added in API level 26", "FullName": "public T parse (CharSequence text, TemporalQuery<T> query)"}, "ofLocalizedDateTime(java.time.format.FormatStyle,java.time.format.FormatStyle)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "the date, time or date-time formatter, not null"]], "Parameters": [["@B_java#time#format#FormatStyle_E@", "FormatStyle: the date formatter style to obtain, not null"], ["@B_java#time#format#FormatStyle_E@", "FormatStyle: the time formatter style to obtain, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a locale specific date and time format for the ISO chronology. This returns a formatter that will format or parse a date-time. The exact format pattern used varies by locale. The locale is determined from the formatter. The formatter returned directly by this method will use the @B_java#util#Locale#getDefault_E@. The locale can be controlled using @B_java#time#format#DateTimeFormatter#withLocale_E@ on the result of this method. Note that the localized pattern is looked up lazily. This DateTimeFormatter holds the style required and the locale, looking up the pattern required on demand. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the @B_java#time#format#ResolverStyle#SMART_E@ resolver style.", "history": "Added in API level 26", "FullName": "public static DateTimeFormatter ofLocalizedDateTime (FormatStyle dateStyle, FormatStyle timeStyle)"}, "withResolverStyle(java.time.format.ResolverStyle)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "a formatter based on this formatter with the requested resolver style, not null"]], "Parameters": [["@B_java#time#format#ResolverStyle_E@", "ResolverStyle: the new resolver style, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a copy of this formatter with a new resolver style. This returns a formatter with similar state to this formatter but with the resolver style set. By default, a formatter has the @B_java#time#format#ResolverStyle#SMART_E@ resolver style. Changing the resolver style only has an effect during parsing. Parsing a text string occurs in two phases. Phase 1 is a basic text parse according to the fields added to the builder. Phase 2 resolves the parsed field-value pairs into date and/or time objects. The resolver style is used to control how phase 2, resolving, happens. See ResolverStyle for more information on the options available. This instance is immutable and unaffected by this method call.", "history": "Added in API level 26", "FullName": "public DateTimeFormatter withResolverStyle (ResolverStyle resolverStyle)"}, "toFormat()": {"Returns": [["@B_java#text#Format_E@", "this formatter as a classic format instance, not null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns this formatter as a java.text.Format instance. The returned @B_java#text#Format_E@ instance will format any @B_java#time#temporal#TemporalAccessor_E@ and parses to a resolved @B_java#time#temporal#TemporalAccessor_E@. Exceptions will follow the definitions of Format, see those methods for details about IllegalArgumentException during formatting and ParseException or null during parsing. The format does not support attributing of the returned format string.", "history": "Added in API level 26", "FullName": "public Format toFormat ()"}, "ofLocalizedDateTime(java.time.format.FormatStyle)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "the date-time formatter, not null"]], "Parameters": [["@B_java#time#format#FormatStyle_E@", "FormatStyle: the formatter style to obtain, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a locale specific date-time formatter for the ISO chronology. This returns a formatter that will format or parse a date-time. The exact format pattern used varies by locale. The locale is determined from the formatter. The formatter returned directly by this method will use the @B_java#util#Locale#getDefault_E@. The locale can be controlled using @B_java#time#format#DateTimeFormatter#withLocale_E@ on the result of this method. Note that the localized pattern is looked up lazily. This DateTimeFormatter holds the style required and the locale, looking up the pattern required on demand. The returned formatter has a chronology of ISO set to ensure dates in other calendar systems are correctly converted. It has no override zone and uses the @B_java#time#format#ResolverStyle#SMART_E@ resolver style.", "history": "Added in API level 26", "FullName": "public static DateTimeFormatter ofLocalizedDateTime (FormatStyle dateTimeStyle)"}, "formatTo(java.time.temporal.TemporalAccessor,java.lang.Appendable)": {"Returns": [], "Parameters": [["@B_java#time#temporal#TemporalAccessor_E@", "TemporalAccessor: the temporal object to format, not null"], ["@B_java#lang#Appendable_E@", "Appendable: the appendable to format to, not null"]], "Throws": [["@B_java#time#DateTimeException_E@", "if an error occurs during formatting"]], "SeeAlso": [], "Permissions": [], "Description": "Formats a date-time object to an Appendable using this formatter. This outputs the formatted date-time to the specified destination. @B_java#lang#Appendable_E@ is a general purpose interface that is implemented by all key character output classes including StringBuffer, StringBuilder, PrintStream and Writer. Although Appendable methods throw an IOException, this method does not. Instead, any IOException is wrapped in a runtime exception.", "history": "Added in API level 26", "FullName": "public void formatTo (TemporalAccessor temporal, Appendable appendable)"}, "withResolverFields(java.util.Set<java.time.temporal.TemporalField>)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "a formatter based on this formatter with the requested resolver style, not null"]], "Parameters": [["@B_java#util#Set_E@", "Set: the new set of resolver fields, null if no fields"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a copy of this formatter with a new set of resolver fields. This returns a formatter with similar state to this formatter but with the resolver fields set. By default, a formatter has no resolver fields. Changing the resolver fields only has an effect during parsing. Parsing a text string occurs in two phases. Phase 1 is a basic text parse according to the fields added to the builder. Phase 2 resolves the parsed field-value pairs into date and/or time objects. The resolver fields are used to filter the field-value pairs between phase 1 and 2. This can be used to select between two or more ways that a date or time might be resolved. For example, if the formatter consists of year, month, day-of-month and day-of-year, then there are two ways to resolve a date. Calling this method with the arguments @B_java#time#temporal#ChronoField#YEAR_E@ and @B_java#time#temporal#ChronoField#DAY_OF_YEAR_E@ will ensure that the date is resolved using the year and day-of-year, effectively meaning that the month and day-of-month are ignored during the resolving phase. In a similar manner, this method can be used to ignore secondary fields that would otherwise be cross-checked. For example, if the formatter consists of year, month, day-of-month and day-of-week, then there is only one way to resolve a date, but the parsed value for day-of-week will be cross-checked against the resolved date. Calling this method with the arguments @B_java#time#temporal#ChronoField#YEAR_E@, @B_java#time#temporal#ChronoField#MONTH_OF_YEAR_E@ and @B_java#time#temporal#ChronoField#DAY_OF_MONTH_E@ will ensure that the date is resolved correctly, but without any cross-check for the day-of-week. In implementation terms, this method behaves as follows. The result of the parsing phase can be considered to be a map of field to value. The behavior of this method is to cause that map to be filtered between phase 1 and 2, removing all fields other than those specified as arguments to this method. This instance is immutable and unaffected by this method call.", "history": "Added in API level 26", "FullName": "public DateTimeFormatter withResolverFields (Set<TemporalField> resolverFields)"}, "parsedLeapSecond()": {"Returns": [["@B_java#time#temporal#TemporalQuery_E@", "a query that provides access to whether a leap-second was parsed"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "A query that provides access to whether a leap-second was parsed. This returns a singleton Instant parsing handles the special \"leap second\" time of '23:59:60'. Leap seconds occur at '23:59:60' in the UTC time-zone, but at other local times in different time-zones. To avoid this potential ambiguity, the handling of leap-seconds is limited to @B_java#time#format#DateTimeFormatterBuilder#appendInstant_E@, as that method always parses the instant with the UTC zone offset. If the time '23:59:60' is received, then a simple conversion is applied, replacing the second-of-minute of 60 with 59. This query can be used on the parse result to determine if the leap-second adjustment was made. The query will return true if it did adjust to remove the leap-second, and false if not. Note that applying a leap-second smoothing mechanism, such as UTC-SLS, is the responsibility of the application, as follows:", "history": "Added in API level 26", "FullName": "public static TemporalQuery<Boolean> parsedLeapSecond ()"}, "parsedExcessDays()": {"Returns": [["@B_java#time#temporal#TemporalQuery_E@", "a query that provides access to the excess days that were parsed"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "A query that provides access to the excess days that were parsed. This returns a singleton There are two situations where this query may return a non-zero period. If the ResolverStyle is LENIENT and a time is parsed without a date, then the complete result of the parse consists of a LocalTime and an excess Period in days. If the ResolverStyle is SMART and a time is parsed without a date where the time is 24:00:00, then the complete result of the parse consists of a LocalTime of 00:00:00 and an excess Period of one day. In both cases, if a complete ChronoLocalDateTime or Instant is parsed, then the excess days are added to the date part. As a result, this query will return a zero period. The SMART behaviour handles the common \"end of day\" 24:00 value. Processing in LENIENT mode also produces the same result:", "history": "Added in API level 26", "FullName": "public static TemporalQuery<Period> parsedExcessDays ()"}, "withResolverFields(java.time.temporal.TemporalField...)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "a formatter based on this formatter with the requested resolver style, not null"]], "Parameters": [["@B_java#time#temporal#TemporalField_E@", "TemporalField: the new set of resolver fields, null if no fields"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a copy of this formatter with a new set of resolver fields. This returns a formatter with similar state to this formatter but with the resolver fields set. By default, a formatter has no resolver fields. Changing the resolver fields only has an effect during parsing. Parsing a text string occurs in two phases. Phase 1 is a basic text parse according to the fields added to the builder. Phase 2 resolves the parsed field-value pairs into date and/or time objects. The resolver fields are used to filter the field-value pairs between phase 1 and 2. This can be used to select between two or more ways that a date or time might be resolved. For example, if the formatter consists of year, month, day-of-month and day-of-year, then there are two ways to resolve a date. Calling this method with the arguments @B_java#time#temporal#ChronoField#YEAR_E@ and @B_java#time#temporal#ChronoField#DAY_OF_YEAR_E@ will ensure that the date is resolved using the year and day-of-year, effectively meaning that the month and day-of-month are ignored during the resolving phase. In a similar manner, this method can be used to ignore secondary fields that would otherwise be cross-checked. For example, if the formatter consists of year, month, day-of-month and day-of-week, then there is only one way to resolve a date, but the parsed value for day-of-week will be cross-checked against the resolved date. Calling this method with the arguments @B_java#time#temporal#ChronoField#YEAR_E@, @B_java#time#temporal#ChronoField#MONTH_OF_YEAR_E@ and @B_java#time#temporal#ChronoField#DAY_OF_MONTH_E@ will ensure that the date is resolved correctly, but without any cross-check for the day-of-week. In implementation terms, this method behaves as follows. The result of the parsing phase can be considered to be a map of field to value. The behavior of this method is to cause that map to be filtered between phase 1 and 2, removing all fields other than those specified as arguments to this method. This instance is immutable and unaffected by this method call.", "history": "Added in API level 26", "FullName": "public DateTimeFormatter withResolverFields (TemporalField... resolverFields)"}, "parseBest(java.lang.CharSequence,java.time.temporal.TemporalQuery<?>...)": {"Returns": [["@B_java#time#temporal#TemporalAccessor_E@", "the parsed date-time, not null"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the text to parse, not null"], ["@B_java#time#temporal#TemporalQuery_E@", "TemporalQuery: the queries defining the types to attempt to parse to, must implement TemporalAccessor, not null"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if less than 2 types are specified"], ["@B_java#time#format#DateTimeParseException_E@", "if unable to parse the requested result"]], "SeeAlso": [], "Permissions": [], "Description": "Fully parses the text producing an object of one of the specified types. This parse method is convenient for use when the parser can handle optional elements. For example, a pattern of 'uuuu-MM-dd HH.mm[ VV]' can be fully parsed to a ZonedDateTime, or partially parsed to a LocalDateTime. The queries must be specified in order, starting from the best matching full-parse option and ending with the worst matching minimal parse option. The query is typically a method reference to a from(TemporalAccessor) method. The result is associated with the first type that successfully parses. Normally, applications will use instanceof to check the result. For example:", "history": "Added in API level 26", "FullName": "public TemporalAccessor parseBest (CharSequence text, TemporalQuery...<?> queries)"}, "parse(java.lang.CharSequence,java.text.ParsePosition)": {"Returns": [["@B_java#time#temporal#TemporalAccessor_E@", "the parsed temporal object, not null"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the text to parse, not null"], ["@B_java#text#ParsePosition_E@", "ParsePosition: the position to parse from, updated with length parsed and the index of any error, not null"]], "Throws": [["@B_java#time#format#DateTimeParseException_E@", "if unable to parse the requested result"], ["@B_java#lang#IndexOutOfBoundsException_E@", "if the position is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Parses the text using this formatter, providing control over the text position. This parses the text without requiring the parse to start from the beginning of the string or finish at the end. The result of this method is TemporalAccessor which has been resolved, applying basic validation checks to help ensure a valid date-time. The text will be parsed from the specified start ParsePosition. The entire length of the text does not have to be parsed, the ParsePosition will be updated with the index at the end of parsing. The operation of this method is slightly different to similar methods using ParsePosition on java.text.Format. That class will return errors using the error index on the ParsePosition. By contrast, this method will throw a @B_java#time#format#DateTimeParseException_E@ if an error occurs, with the exception containing the error index. This change in behavior is necessary due to the increased complexity of parsing and resolving dates/times in this API. If the formatter parses the same field more than once with different values, the result will be an error.", "history": "Added in API level 26", "FullName": "public TemporalAccessor parse (CharSequence text, ParsePosition position)"}, "parseUnresolved(java.lang.CharSequence,java.text.ParsePosition)": {"Returns": [["@B_java#time#temporal#TemporalAccessor_E@", "the parsed text, null if the parse results in an error"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the text to parse, not null"], ["@B_java#text#ParsePosition_E@", "ParsePosition: the position to parse from, updated with length parsed and the index of any error, not null"]], "Throws": [["@B_java#time#DateTimeException_E@", "if some problem occurs during parsing"], ["@B_java#lang#IndexOutOfBoundsException_E@", "if the position is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Parses the text using this formatter, without resolving the result, intended for advanced use cases. Parsing is implemented as a two-phase operation. First, the text is parsed using the layout defined by the formatter, producing a Map of field to value, a ZoneId and a Chronology. Second, the parsed data is resolved, by validating, combining and simplifying the various fields into more useful ones. This method performs the parsing stage but not the resolving stage. The result of this method is TemporalAccessor which represents the data as seen in the input. Values are not validated, thus parsing a date string of '2012-00-65' would result in a temporal with three fields - year of '2012', month of '0' and day-of-month of '65'. The text will be parsed from the specified start ParsePosition. The entire length of the text does not have to be parsed, the ParsePosition will be updated with the index at the end of parsing. Errors are returned using the error index field of the ParsePosition instead of DateTimeParseException. The returned error index will be set to an index indicative of the error. Callers must check for errors before using the result. If the formatter parses the same field more than once with different values, the result will be an error. This method is intended for advanced use cases that need access to the internal state during parsing. Typical application code should use @B_java#time#format#DateTimeFormatter#parse_E@ or the parse method on the target type.", "history": "Added in API level 26", "FullName": "public TemporalAccessor parseUnresolved (CharSequence text, ParsePosition position)"}, "getZone()": {"Returns": [["@B_java#time#ZoneId_E@", "the override zone of this formatter, null if no override"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the overriding zone to be used during formatting. This returns the override zone, used to convert instants. By default, a formatter has no override zone, returning null. See @B_java#time#format#DateTimeFormatter#withZone_E@ for more details on overriding.", "history": "Added in API level 26", "FullName": "public ZoneId getZone ()"}, "format(java.time.temporal.TemporalAccessor)": {"Returns": [["@B_java#lang#String_E@", "the formatted string, not null"]], "Parameters": [["@B_java#time#temporal#TemporalAccessor_E@", "TemporalAccessor: the temporal object to format, not null"]], "Throws": [["@B_java#time#DateTimeException_E@", "if an error occurs during formatting"]], "SeeAlso": [], "Permissions": [], "Description": "Formats a date-time object using this formatter. This formats the date-time to a String using the rules of the formatter.", "history": "Added in API level 26", "FullName": "public String format (TemporalAccessor temporal)"}, "withLocale(java.util.Locale)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "a formatter based on this formatter with the requested locale, not null"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: the new locale, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a copy of this formatter with a new locale. This is used to lookup any part of the formatter needing specific localization, such as the text or localized pattern. This instance is immutable and unaffected by this method call.", "history": "Added in API level 26", "FullName": "public DateTimeFormatter withLocale (Locale locale)"}, "withZone(java.time.ZoneId)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "a formatter based on this formatter with the requested override zone, not null"]], "Parameters": [["@B_java#time#ZoneId_E@", "ZoneId: the new override zone, null if no override"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a copy of this formatter with a new override zone. This returns a formatter with similar state to this formatter but with the override zone set. By default, a formatter has no override zone, returning null. If an override is added, then any instant that is formatted or parsed will be affected. When formatting, if the temporal object contains an instant, then it will be converted to a zoned date-time using the override zone. Whether the temporal is an instant is determined by querying the @B_java#time#temporal#ChronoField#INSTANT_SECONDS_E@ field. If the input has a chronology then it will be retained unless overridden. If the input does not have a chronology, such as Instant, then the ISO chronology will be used. If the temporal object does not contain an instant, but does contain an offset then an additional check is made. If the normalized override zone is an offset that differs from the offset of the temporal, then a DateTimeException is thrown. In all other cases, the override zone is added to the temporal, replacing any previous zone, but without changing the date/time. When parsing, there are two distinct cases to consider. If a zone has been parsed directly from the text, perhaps because @B_java#time#format#DateTimeFormatterBuilder#appendZoneId_E@ was used, then this override zone has no effect. If no zone has been parsed, then this override zone will be included in the result of the parse where it can be used to build instants and date-times. This instance is immutable and unaffected by this method call.", "history": "Added in API level 26", "FullName": "public DateTimeFormatter withZone (ZoneId zone)"}, "toFormat(java.time.temporal.TemporalQuery<?>)": {"Returns": [["@B_java#text#Format_E@", "this formatter as a classic format instance, not null"]], "Parameters": [["@B_java#time#temporal#TemporalQuery_E@", "TemporalQuery: the query defining the type to parse to, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns this formatter as a java.text.Format instance that will parse using the specified query. The returned @B_java#text#Format_E@ instance will format any @B_java#time#temporal#TemporalAccessor_E@ and parses to the type specified. The type must be one that is supported by @B_java#time#format#DateTimeFormatter#parse_E@. Exceptions will follow the definitions of Format, see those methods for details about IllegalArgumentException during formatting and ParseException or null during parsing. The format does not support attributing of the returned format string.", "history": "Added in API level 26", "FullName": "public Format toFormat (TemporalQuery<?> parseQuery)"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a description of this formatter, not null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a description of the underlying formatters.", "history": "Added in API level 26", "FullName": "public String toString ()"}, "withDecimalStyle(java.time.format.DecimalStyle)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "a formatter based on this formatter with the requested DecimalStyle, not null"]], "Parameters": [["@B_java#time#format#DecimalStyle_E@", "DecimalStyle: the new DecimalStyle, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a copy of this formatter with a new DecimalStyle. This instance is immutable and unaffected by this method call.", "history": "Added in API level 26", "FullName": "public DateTimeFormatter withDecimalStyle (DecimalStyle decimalStyle)"}, "parse(java.lang.CharSequence)": {"Returns": [["@B_java#time#temporal#TemporalAccessor_E@", "the parsed temporal object, not null"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the text to parse, not null"]], "Throws": [["@B_java#time#format#DateTimeParseException_E@", "if unable to parse the requested result"]], "SeeAlso": [], "Permissions": [], "Description": "Fully parses the text producing a temporal object. This parses the entire text producing a temporal object. It is typically more useful to use @B_java#time#format#DateTimeFormatter#parse_E@. The result of this method is TemporalAccessor which has been resolved, applying basic validation checks to help ensure a valid date-time. If the parse completes without reading the entire length of the text, or a problem occurs during parsing or merging, then an exception is thrown.", "history": "Added in API level 26", "FullName": "public TemporalAccessor parse (CharSequence text)"}, "ofPattern(java.lang.String, java.util.Locale)": {"Returns": [["@B_java#time#format#DateTimeFormatter_E@", "the formatter based on the pattern, not null"]], "Parameters": [["@B_java#lang#String_E@", "String: the pattern to use, not null"], ["@B_java#util#Locale_E@", "Locale: the locale to use, not null"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"]], "SeeAlso": ["@B_java#time#format#DateTimeFormatterBuilder#appendPattern_E@"], "Permissions": [], "Description": "Creates a formatter using the specified pattern and locale. This method will create a formatter based on a simple d MMM uuuu will format 2011-12-03 as '3 Dec 2011'. The formatter will use the specified locale. This can be changed using @B_java#time#format#DateTimeFormatter#withLocale_E@ on the returned formatter The returned formatter has no override chronology or zone. It uses @B_java#time#format#ResolverStyle#SMART_E@ resolver style.", "history": "added in API level 26", "FullName": "public static DateTimeFormatter ofPattern (String pattern, Locale locale)"}, "getLocale()": {"Returns": [["@B_java#util#Locale_E@", "the locale of this formatter, not null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the locale to be used during formatting. This is used to lookup any part of the formatter needing specific localization, such as the text or localized pattern.", "history": "Added in API level 26", "FullName": "public Locale getLocale ()"}, "getDecimalStyle()": {"Returns": [["@B_java#time#format#DecimalStyle_E@", "the locale of this formatter, not null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the DecimalStyle to be used during formatting.", "history": "Added in API level 26", "FullName": "public DecimalStyle getDecimalStyle ()"}}, "Inheritance": [], "ClassName": "java.time.format.DateTimeFormatter", "ClassDesc": "Formatter for printing and parsing date-time objects. This class provides the main application entry point for printing and parsing and provides common implementations of DateTimeFormatter: Using predefined constants, such as @B_java#time#format#DateTimeFormatter#ISO_LOCAL_DATE_E@ Using pattern letters, such as uuuu-MMM-dd Using localized styles, such as long or medium More complex formatters are provided by @B_java#time#format#DateTimeFormatterBuilder_E@. The main date-time classes provide two methods - one for formatting, format(DateTimeFormatter formatter), and one for parsing, parse(CharSequence text, DateTimeFormatter formatter). For example: In addition to the format, formatters can be created with desired Locale, Chronology, ZoneId, and DecimalStyle. The @B_java#time#format#DateTimeFormatter#withLocale_E@ method returns a new formatter that overrides the locale. The locale affects some aspects of formatting and parsing. For example, the @B_java#time#format#DateTimeFormatter#ofLocalizedDate_E@ provides a formatter that uses the locale specific date format. The @B_java#time#format#DateTimeFormatter#withChronology_E@ method returns a new formatter that overrides the chronology. If overridden, the date-time value is converted to the chronology before formatting. During parsing the date-time value is converted to the chronology before it is returned. The @B_java#time#format#DateTimeFormatter#withZone_E@ method returns a new formatter that overrides the zone. If overridden, the date-time value is converted to a ZonedDateTime with the requested ZoneId before formatting. During parsing the ZoneId is applied before the value is returned. The @B_java#time#format#DateTimeFormatter#withDecimalStyle_E@ method returns a new formatter that overrides the @B_java#time#format#DecimalStyle_E@. The DecimalStyle symbols are used for formatting and parsing. Some applications may need to use the older @B_java#text#Format_E@ class for formatting. The @B_java#time#format#DateTimeFormatter#toFormat_E@ method returns an implementation of java.text.Format. @B_java#time#format#DateTimeFormatter#ofPattern_E@ and @B_java#time#format#DateTimeFormatter#ofPattern_E@ methods. For example, \"d MMM uuuu\" will format 2011-12-03 as '3 Dec 2011'. A formatter created from a pattern can be used as many times as necessary, it is immutable and is thread-safe. For example: All letters 'A' to 'Z' and 'a' to 'z' are reserved as pattern letters. The following pattern letters are defined: The count of pattern letters determines the format. @B_java#time#format#TextStyle#SHORT_E@. Exactly 4 pattern letters will use the @B_java#time#format#TextStyle#FULL_E@. Exactly 5 pattern letters will use the @B_java#time#format#TextStyle#NARROW_E@. Pattern letters 'L', 'c', and 'q' specify the stand-alone form of the text styles. @B_java#time#format#DateTimeFormatterBuilder#appendValueReduced_E@ two digit form is used. For printing, this outputs the rightmost two digits. For parsing, this will parse using the base value of 2000, resulting in a year within the range 2000 to 2099 inclusive. If the count of letters is less than four (but not two), then the sign is only output for negative years as per @B_java#time#format#SignStyle#NORMAL_E@. Otherwise, the sign is output if the pad width is exceeded, as per @B_java#time#format#SignStyle#EXCEEDS_PAD_E@. IllegalArgumentException. IllegalArgumentException. IllegalArgumentException. Pattern letter 'X' (upper case) will output 'Z' when the offset to be output would be zero, whereas pattern letter 'x' (lower case) will output '+00', '+0000', or '+00:00'. IllegalArgumentException. IllegalArgumentException. @B_java#time#format#DateTimeFormatterBuilder#optionalStart_E@ and @B_java#time#format#DateTimeFormatterBuilder#optionalEnd_E@. @B_java#time#format#DateTimeFormatterBuilder#padNext_E@. For example, 'ppH' outputs the hour-of-day padded on the left with spaces to a width of 2. Any unrecognized letter is an error. Any non-letter character, other than '[', ']', '{', '}', '#' and the single quote will be output directly. Despite this, it is recommended to use single quotes around all characters that you want to output directly to ensure that future changes do not break your application. Map of field to value, a ZoneId and a Chronology. Second, the parsed data is resolved, by validating, combining and simplifying the various fields into more useful ones. Five parsing methods are supplied by this class. Four of these perform both the parse and resolve phases. The fifth method, @B_java#time#format#DateTimeFormatter#parseUnresolved_E@, only performs the first phase, leaving the result unresolved. As such, it is essentially a low-level operation. The resolve phase is controlled by two parameters, set on this class. The @B_java#time#format#ResolverStyle_E@ is an enum that offers three different approaches, strict, smart and lenient. The smart option is the default. It can be set using @B_java#time#format#DateTimeFormatter#withResolverStyle_E@. The @B_java#time#format#DateTimeFormatter#withResolverFields_E@ parameter allows the set of fields that will be resolved to be filtered before resolving starts. For example, if the formatter has parsed a year, month, day-of-month and day-of-year, then there are two approaches to resolve a date: (year + month + day-of-month) and (year + day-of-year). The resolver fields allows one of the two approaches to be selected. If no resolver fields are set then both approaches must result in the same date. Resolving separate fields to form a complete date and time is a complex process with behaviour distributed across a number of classes. It follows these steps:"}