{"Functions": {"isOrderedBroadcast()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the receiver is currently processing an ordered broadcast.", "history": "Added in API level 5", "FullName": "public final boolean isOrderedBroadcast ()"}, "getAbortBroadcast()": {"Returns": [["boolean", "True if the broadcast should be aborted."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the flag indicating whether or not this receiver should abort the current broadcast.", "history": "Added in API level 1", "FullName": "public final boolean getAbortBroadcast ()"}, "setResultCode(int)": {"Returns": [], "Parameters": [["int", "int: The new result code."]], "Throws": [], "SeeAlso": ["@B_android#content#BroadcastReceiver#setResult_E@"], "Permissions": [], "Description": "Change the current result code of this broadcast; only works with broadcasts sent through @B_android#content#Context#sendOrderedBroadcast_E@. Often uses the Activity @B_android#app#Activity#RESULT_CANCELED_E@ and @B_android#app#Activity#RESULT_OK_E@ constants, though the actual meaning of this value is ultimately up to the broadcaster. This method does not work with non-ordered broadcasts such as those sent with @B_android#content#Context#sendBroadcast_E@", "history": "Added in API level 1", "FullName": "public final void setResultCode (int code)"}, "peekService(android.content.Context,android.content.Intent)": {"Returns": [["@B_android#os#IBinder_E@", "no returns description in source"]], "Parameters": [["@B_android#content#Context_E@", "Context: The Context that had been passed to @B_android#content#BroadcastReceiver#onReceive_E@"], ["@B_android#content#Intent_E@", "Intent: Identifies the already-bound service you wish to use. See @B_android#content#Context#bindService_E@ for more information."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Provide a binder to an already-bound service. This method is synchronous and will not start the target service if it is not present, so it is safe to call from @B_android#content#BroadcastReceiver#onReceive_E@. For peekService() to return a non null @B_android#os#IBinder_E@ interface the service must have published it before. In other words some component must have called @B_android#content#Context#bindService_E@ on it.", "history": "Added in API level 3", "FullName": "public IBinder peekService (Context myContext, Intent service)"}, "isInitialStickyBroadcast()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the receiver is currently processing the initial value of a sticky broadcast -- that is, the value that was last broadcast and is currently held in the sticky cache, so this is not directly the result of a broadcast right now.", "history": "Added in API level 5", "FullName": "public final boolean isInitialStickyBroadcast ()"}, "getDebugUnregister()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the last value given to @B_android#content#BroadcastReceiver#setDebugUnregister_E@.", "history": "Added in API level 1", "FullName": "public final boolean getDebugUnregister ()"}, "setResultExtras(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: The new extra data map; may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#BroadcastReceiver#setResult_E@"], "Permissions": [], "Description": "Change the current result extras of this broadcast; only works with broadcasts sent through @B_android#content#Context#sendOrderedBroadcast_E@. This is a Bundle holding arbitrary data, whose interpretation is up to the broadcaster. Can be set to null. Calling this method completely replaces the current map (if any).", "history": "Added in API level 1", "FullName": "public final void setResultExtras (Bundle extras)"}, "setResultData(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The new result data; may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#BroadcastReceiver#setResult_E@"], "Permissions": [], "Description": "Change the current result data of this broadcast; only works with broadcasts sent through @B_android#content#Context#sendOrderedBroadcast_E@. This is an arbitrary string whose interpretation is up to the broadcaster.", "history": "Added in API level 1", "FullName": "public final void setResultData (String data)"}, "getResultData()": {"Returns": [["@B_java#lang#String_E@", "String The current result data; may be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the current result data, as set by the previous receiver. Often this is null.", "history": "Added in API level 1", "FullName": "public final String getResultData ()"}, "BroadcastReceiver()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public BroadcastReceiver ()"}, "setOrderedHint(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "For internal use, sets the hint about whether this BroadcastReceiver is running in ordered mode.", "history": "Added in API level 1", "FullName": "public final void setOrderedHint (boolean isOrdered)"}, "getResultCode()": {"Returns": [["int", "int The current result code."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the current result code, as set by the previous receiver.", "history": "Added in API level 1", "FullName": "public final int getResultCode ()"}, "clearAbortBroadcast()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clears the flag indicating that this receiver should abort the current broadcast.", "history": "Added in API level 1", "FullName": "public final void clearAbortBroadcast ()"}, "getResultExtras(boolean)": {"Returns": [["@B_android#os#Bundle_E@", "Map The current extras map."]], "Parameters": [["boolean", "boolean: If true then a new empty Map will be made for you if the current Map is null; if false you should be prepared to receive a null Map."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the current result extra data, as set by the previous receiver. Any changes you make to the returned Map will be propagated to the next receiver.", "history": "Added in API level 1", "FullName": "public final Bundle getResultExtras (boolean makeMap)"}, "goAsync()": {"Returns": [["@B_android#content#BroadcastReceiver#PendingResult_E@", "Returns a @B_android#content#BroadcastReceiver#PendingResult_E@ representing the result of the active broadcast. The BroadcastRecord itself is no longer active; all data and other interaction must go through @B_android#content#BroadcastReceiver#PendingResult_E@ APIs. The @B_android#content#BroadcastReceiver#PendingResult#finish_E@ method must be called once processing of the broadcast is done."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This can be called by an application in @B_android#content#BroadcastReceiver#onReceive_E@ to allow it to keep the broadcast active after returning from that function. This does not change the expectation of being relatively responsive to the broadcast, but does allow the implementation to move work related to it over to another thread to avoid glitching the main UI thread due to disk IO. As a general rule, broadcast receivers are allowed to run for up to 10 seconds before they system will consider them non-responsive and ANR the app. Since these usually execute on the app's main thread, they are already bound by the ~5 second time limit of various operations that can happen there (not to mention just avoiding UI jank), so the receive limit is generally not of concern. However, once you use goAsync, though able to be off the main thread, the broadcast execution limit still applies, and that includes the time spent between calling this method and ultimately @B_android#content#BroadcastReceiver#PendingResult#finish_E@. If you are taking advantage of this method to have more time to execute, it is useful to know that the available time can be longer in certain situations. In particular, if the broadcast you are receiving is not a foreground broadcast (that is, the sender has not used @B_android#content#Intent#FLAG_RECEIVER_FOREGROUND_E@), then more time is allowed for the receivers to run, allowing them to execute for 30 seconds or even a bit more. This is something that receivers should rarely take advantage of (long work should be punted to another system facility such as @B_android#app#job#JobScheduler_E@, @B_android#app#Service_E@, or see especially https:##developer#android#com@B_android#support#v4#app#JobIntentService_E@), but can be useful in certain rare cases where it is necessary to do some work as soon as the broadcast is delivered. Keep in mind that the work you do here will block further broadcasts until it completes, so taking advantage of this at all excessively can be counter-productive and cause later events to be received more slowly.", "history": "Added in API level 11", "FullName": "public final BroadcastReceiver.PendingResult goAsync ()"}, "abortBroadcast()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the flag indicating that this receiver should abort the current broadcast; only works with broadcasts sent through @B_android#content#Context#sendOrderedBroadcast_E@. This will prevent any other broadcast receivers from receiving the broadcast. It will still call @B_android#content#BroadcastReceiver#onReceive_E@ of the BroadcastReceiver that the caller of @B_android#content#Context#sendOrderedBroadcast_E@ passed in.", "history": "Added in API level 1", "FullName": "public final void abortBroadcast ()"}, "setResult(int,java.lang.String,android.os.Bundle)": {"Returns": [], "Parameters": [["int", "int: The new result code. Often uses the Activity @B_android#app#Activity#RESULT_CANCELED_E@ and @B_android#app#Activity#RESULT_OK_E@ constants, though the actual meaning of this value is ultimately up to the broadcaster."], ["@B_java#lang#String_E@", "String: The new result data. This is an arbitrary string whose interpretation is up to the broadcaster; may be null."], ["@B_android#os#Bundle_E@", "Bundle: The new extra data map. This is a Bundle holding arbitrary data, whose interpretation is up to the broadcaster. Can be set to null. This completely replaces the current map (if any)."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change all of the result data returned from this broadcasts; only works with broadcasts sent through @B_android#content#Context#sendOrderedBroadcast_E@. All current result data is replaced by the value given to this method.", "history": "Added in API level 1", "FullName": "public final void setResult (int code, String data, Bundle extras)"}, "onReceive(android.content.Context,android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The Context in which the receiver is running."], ["@B_android#content#Intent_E@", "Intent: The Intent being received."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is called when the BroadcastReceiver is receiving an Intent broadcast. During this time you can use the other methods on BroadcastReceiver to view/modify the current result values. This method is always called within the main thread of its process, unless you explicitly asked for it to be scheduled on a different thread using @B_android#content#Context#registerReceiver_E@. When it runs on the main thread you should never perform long-running operations in it (there is a timeout of 10 seconds that the system allows before considering the receiver to be blocked and a candidate to be killed). You cannot launch a popup dialog in your implementation of onReceive(). @B_android#app#job#JobService_E@ with @B_android#app#job#JobScheduler_E@. If you wish to interact with a service that is already running and previously bound using @B_android#content#Context#bindService_E@, you can use @B_android#content#BroadcastReceiver#peekService_E@. The Intent filters used in @B_android#content#Context#registerReceiver_E@ and in application manifests are not guaranteed to be exclusive. They are hints to the operating system about how to find suitable recipients. It is possible for senders to force delivery to specific recipients, bypassing filter resolution. For this reason, @B_android#content#BroadcastReceiver#onReceive_E@ implementations should respond only to known actions, ignoring any unexpected Intents that they may receive.", "history": "Added in API level 1", "FullName": "public abstract void onReceive (Context context, Intent intent)"}, "setDebugUnregister(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Control inclusion of debugging help for mismatched calls to @B_android#content#Context#registerReceiver_E@. If called with true, before given to registerReceiver(), then the callstack of the following @B_android#content#Context#unregisterReceiver_E@ call is retained, to be printed if a later incorrect unregister call is made. Note that doing this requires retaining information about the BroadcastReceiver for the lifetime of the app, resulting in a leak -- this should only be used for debugging.", "history": "Added in API level 1", "FullName": "public final void setDebugUnregister (boolean debug)"}}, "Inheritance": [], "ClassName": "android.content.BroadcastReceiver", "ClassDesc": "Base class for code that receives and handles broadcast intents sent by @B_android#content#Context#sendBroadcast_E@. You can either dynamically register an instance of this class with @B_android#content#Context#registerReceiver_E@ or statically declare an implementation with the @B_android#R#styleable#AndroidManifestReceiver_E@ tag in your AndroidManifest.xml."}