{"Functions": {"postFrameCallbackDelayed(android.view.Choreographer.FrameCallback,long)": {"Returns": [], "Parameters": [["@B_android#view#Choreographer#FrameCallback_E@", "Choreographer.FrameCallback: The frame callback to run during the next frame."], ["long", "long: The delay time in milliseconds."]], "Throws": [], "SeeAlso": ["@B_android#view#Choreographer#postFrameCallback_E@", "@B_android#view#Choreographer#removeFrameCallback_E@"], "Permissions": [], "Description": "Posts a frame callback to run on the next frame after the specified delay. The callback runs once then is automatically removed.", "history": "Added in API level 16", "FullName": "public void postFrameCallbackDelayed (Choreographer.FrameCallback callback, long delayMillis)"}, "getInstance()": {"Returns": [["@B_android#view#Choreographer_E@", "The choreographer for this thread."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the thread does not have a looper."]], "SeeAlso": [], "Permissions": [], "Description": "Gets the choreographer for the calling thread. Must be called from a thread that already has a @B_android#os#Looper_E@ associated with it.", "history": "Added in API level 16", "FullName": "public static Choreographer getInstance ()"}, "postFrameCallback(android.view.Choreographer.FrameCallback)": {"Returns": [], "Parameters": [["@B_android#view#Choreographer#FrameCallback_E@", "Choreographer.FrameCallback: The frame callback to run during the next frame."]], "Throws": [], "SeeAlso": ["@B_android#view#Choreographer#postFrameCallbackDelayed_E@", "@B_android#view#Choreographer#removeFrameCallback_E@"], "Permissions": [], "Description": "Posts a frame callback to run on the next frame. The callback runs once then is automatically removed.", "history": "Added in API level 16", "FullName": "public void postFrameCallback (Choreographer.FrameCallback callback)"}, "removeFrameCallback(android.view.Choreographer.FrameCallback)": {"Returns": [], "Parameters": [["@B_android#view#Choreographer#FrameCallback_E@", "Choreographer.FrameCallback: The frame callback to remove."]], "Throws": [], "SeeAlso": ["@B_android#view#Choreographer#postFrameCallback_E@", "@B_android#view#Choreographer#postFrameCallbackDelayed_E@"], "Permissions": [], "Description": "Removes a previously posted frame callback.", "history": "Added in API level 16", "FullName": "public void removeFrameCallback (Choreographer.FrameCallback callback)"}}, "Inheritance": [], "ClassName": "android.view.Choreographer", "ClassDesc": "Coordinates the timing of animations, input and drawing. The choreographer receives timing pulses (such as vertical synchronization) from the display subsystem then schedules work to occur as part of rendering the next display frame. Applications typically interact with the choreographer indirectly using higher level abstractions in the animation framework or the view hierarchy. Here are some examples of things you can do using the higher-level APIs. To post an animation to be processed on a regular time basis synchronized with display frame rendering, use @B_android#animation#ValueAnimator#start_E@. To post a @B_java#lang#Runnable_E@ to be invoked once at the beginning of the next display frame, use @B_android#view#View#postOnAnimation_E@. To post a @B_java#lang#Runnable_E@ to be invoked once at the beginning of the next display frame after a delay, use @B_android#view#View#postOnAnimationDelayed_E@. To post a call to @B_android#view#View#invalidate_E@ to occur once at the beginning of the next display frame, use @B_android#view#View#postInvalidateOnAnimation_E@ or @B_android#view#View#postInvalidateOnAnimation_E@. To ensure that the contents of a @B_android#view#View_E@ scroll smoothly and are drawn in sync with display frame rendering, do nothing. This already happens automatically. @B_android#view#View#onDraw_E@ will be called at the appropriate time. However, there are a few cases where you might want to use the functions of the choreographer directly in your application. Here are some examples. If your application does its rendering in a different thread, possibly using GL, or does not use the animation framework or view hierarchy at all and you want to ensure that it is appropriately synchronized with the display, then use @B_android#view#Choreographer#postFrameCallback_E@. ... and that's about it. Each @B_android#os#Looper_E@ thread has its own choreographer. Other threads can post callbacks to run on the choreographer but they will run on the @B_android#os#Looper_E@ to which the choreographer belongs."}