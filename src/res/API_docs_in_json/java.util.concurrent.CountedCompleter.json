{"Functions": {"exec()": {"Returns": [["boolean", "true if this task is known to have completed normally"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implements execution conventions for CountedCompleters.", "history": "Added in API level 24", "FullName": "protected final boolean exec ()"}, "helpComplete(int)": {"Returns": [], "Parameters": [["int", "int: the maximum number of tasks to process. If less than or equal to zero, then no tasks are processed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If this task has not completed, attempts to process at most the given number of other unprocessed tasks for which this task is on the completion path, if any are known to exist.", "history": "Added in API level 24", "FullName": "public final void helpComplete (int maxTasks)"}, "addToPendingCount(int)": {"Returns": [], "Parameters": [["int", "int: the value to add"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds (atomically) the given value to the pending count.", "history": "Added in API level 24", "FullName": "public final void addToPendingCount (int delta)"}, "quietlyCompleteRoot()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to getRoot().quietlyComplete().", "history": "Added in API level 24", "FullName": "public final void quietlyCompleteRoot ()"}, "getPendingCount()": {"Returns": [["int", "the current pending count"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current pending count.", "history": "Added in API level 24", "FullName": "public final int getPendingCount ()"}, "compareAndSetPendingCount(int, int)": {"Returns": [["boolean", "true if successful"]], "Parameters": [["int", "int: the expected value"], ["int", "int: the new value"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets (atomically) the pending count to the given count only if it currently holds the given expected value.", "history": "added in API level 24", "FullName": "public final boolean compareAndSetPendingCount (int expected, int count)"}, "tryComplete()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If the pending count is nonzero, decrements the count; otherwise invokes @B_java#util#concurrent#CountedCompleter#onCompletion_E@ and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.", "history": "Added in API level 24", "FullName": "public final void tryComplete ()"}, "CountedCompleter(java.util.concurrent.CountedCompleter<?>,int)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#CountedCompleter_E@", "CountedCompleter: this task's completer, or null if none"], ["int", "int: the initial pending count"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a new CountedCompleter with the given completer and initial pending count.", "history": "Added in API level 24", "FullName": "protected CountedCompleter (CountedCompleter<?> completer, int initialPendingCount)"}, "propagateCompletion()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to @B_java#util#concurrent#CountedCompleter#tryComplete_E@ but does not invoke @B_java#util#concurrent#CountedCompleter#onCompletion_E@ along the completion path: If the pending count is nonzero, decrements the count; otherwise, similarly tries to complete this task's completer, if one exists, else marks this task as complete. This method may be useful in cases where onCompletion should not, or need not, be invoked for each completer in a computation.", "history": "Added in API level 24", "FullName": "public final void propagateCompletion ()"}, "getRawResult()": {"Returns": [["T", "the result of the computation"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the result of the computation. By default, returns null, which is appropriate for Void actions, but in other cases should be overridden, almost always to return a field or function of a field that holds the result upon completion.", "history": "Added in API level 24", "FullName": "public T getRawResult ()"}, "compute()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The main computation performed by this task.", "history": "Added in API level 24", "FullName": "public abstract void compute ()"}, "setRawResult(T)": {"Returns": [], "Parameters": [["T", "T: the value"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "A method that result-bearing CountedCompleters may optionally use to help maintain result data. By default, does nothing. Overrides are not recommended. However, if this method is overridden to update existing objects or fields, then it must in general be defined to be thread-safe.", "history": "Added in API level 24", "FullName": "protected void setRawResult (T t)"}, "firstComplete()": {"Returns": [["@B_java#util#concurrent#CountedCompleter_E@", "this task, if pending count was zero, else null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If this task's pending count is zero, returns this task; otherwise decrements its pending count and returns null. This method is designed to be used with @B_java#util#concurrent#CountedCompleter#nextComplete_E@ in completion traversal loops.", "history": "Added in API level 24", "FullName": "public final CountedCompleter<?> firstComplete ()"}, "nextComplete()": {"Returns": [["@B_java#util#concurrent#CountedCompleter_E@", "the completer, or null if none"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If this task does not have a completer, invokes @B_java#util#concurrent#ForkJoinTask#quietlyComplete_E@ and returns null. Or, if the completer's pending count is non-zero, decrements that pending count and returns null. Otherwise, returns the completer. This method can be used as part of a completion traversal loop for homogeneous task hierarchies:", "history": "Added in API level 24", "FullName": "public final CountedCompleter<?> nextComplete ()"}, "setPendingCount(int)": {"Returns": [], "Parameters": [["int", "int: the count"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the pending count to the given value.", "history": "Added in API level 24", "FullName": "public final void setPendingCount (int count)"}, "getRoot()": {"Returns": [["@B_java#util#concurrent#CountedCompleter_E@", "the root of the current computation"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the root of the current computation; i.e., this task if it has no completer, else its completer's root.", "history": "Added in API level 24", "FullName": "public final CountedCompleter<?> getRoot ()"}, "getCompleter()": {"Returns": [["@B_java#util#concurrent#CountedCompleter_E@", "the completer"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the completer established in this task's constructor, or null if none.", "history": "Added in API level 24", "FullName": "public final CountedCompleter<?> getCompleter ()"}, "CountedCompleter(java.util.concurrent.CountedCompleter<?>)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#CountedCompleter_E@", "CountedCompleter: this task's completer, or null if none"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a new CountedCompleter with the given completer and an initial pending count of zero.", "history": "Added in API level 24", "FullName": "protected CountedCompleter (CountedCompleter<?> completer)"}, "complete(T)": {"Returns": [], "Parameters": [["T", "T: the raw result"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Regardless of pending count, invokes @B_java#util#concurrent#CountedCompleter#onCompletion_E@, marks this task as complete and further triggers @B_java#util#concurrent#CountedCompleter#tryComplete_E@ on this task's completer, if one exists. The given rawResult is used as an argument to @B_java#util#concurrent#CountedCompleter#setRawResult_E@ before invoking @B_java#util#concurrent#CountedCompleter#onCompletion_E@ or marking this task as complete; its value is meaningful only for classes overriding setRawResult. This method does not modify the pending count. This method may be useful when forcing completion as soon as any one (versus all) of several subtask results are obtained. However, in the common (and recommended) case in which setRawResult is not overridden, this effect can be obtained more simply using @B_java#util#concurrent#CountedCompleter#quietlyCompleteRoot_E@.", "history": "Added in API level 24", "FullName": "public void complete (T rawResult)"}, "CountedCompleter()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a new CountedCompleter with no completer and an initial pending count of zero.", "history": "Added in API level 24", "FullName": "protected CountedCompleter ()"}, "compareAndSetPendingCount(int,int)": {"Returns": [["boolean", "true if successful"]], "Parameters": [["int", "int: the expected value"], ["int", "int: the new value"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets (atomically) the pending count to the given count only if it currently holds the given expected value.", "history": "Added in API level 24", "FullName": "public final boolean compareAndSetPendingCount (int expected, int count)"}, "onExceptionalCompletion(java.lang.Throwable,java.util.concurrent.CountedCompleter<?>)": {"Returns": [["boolean", "true if this exception should be propagated to this task's completer, if one exists"]], "Parameters": [["@B_java#lang#Throwable_E@", "Throwable: the exception"], ["@B_java#util#concurrent#CountedCompleter_E@", "CountedCompleter: the task invoking this method (which may be this task itself)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Performs an action when method @B_java#util#concurrent#ForkJoinTask#completeExceptionally_E@ is invoked or method @B_java#util#concurrent#CountedCompleter#compute_E@ throws an exception, and this task has not already otherwise completed normally. On entry to this method, this task @B_java#util#concurrent#ForkJoinTask#isCompletedAbnormally_E@. The return value of this method controls further propagation: If true and this task has a completer that has not completed, then that completer is also completed exceptionally, with the same exception as this completer. The default implementation of this method does nothing except return true.", "history": "Added in API level 24", "FullName": "public boolean onExceptionalCompletion (Throwable ex, CountedCompleter<?> caller)"}, "onCompletion(java.util.concurrent.CountedCompleter<?>)": {"Returns": [], "Parameters": [["@B_java#util#concurrent#CountedCompleter_E@", "CountedCompleter: the task invoking this method (which may be this task itself)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Performs an action when method @B_java#util#concurrent#CountedCompleter#tryComplete_E@ is invoked and the pending count is zero, or when the unconditional method @B_java#util#concurrent#CountedCompleter#complete_E@ is invoked. By default, this method does nothing. You can distinguish cases by checking the identity of the given caller argument. If not equal to this, then it is typically a subtask that may contain results (and/or links to other results) to combine.", "history": "Added in API level 24", "FullName": "public void onCompletion (CountedCompleter<?> caller)"}, "decrementPendingCountUnlessZero()": {"Returns": [["int", "the initial (undecremented) pending count holding on entry to this method"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If the pending count is nonzero, (atomically) decrements it.", "history": "Added in API level 24", "FullName": "public final int decrementPendingCountUnlessZero ()"}}, "Inheritance": ["@B_java#util#concurrent#ForkJoinTask_E@"], "ClassName": "java.util.concurrent.CountedCompleter<T>", "ClassDesc": "A @B_java#util#concurrent#ForkJoinTask_E@ with a completion action performed when triggered and there are no remaining pending actions. CountedCompleters are in general more robust in the presence of subtask stalls and blockage than are other forms of ForkJoinTasks, but are less intuitive to program. Uses of CountedCompleter are similar to those of other completion based components (such as @B_java#nio#channels#CompletionHandler_E@) except that multiple pending completions may be necessary to trigger the completion action @B_java#util#concurrent#CountedCompleter#onCompletion_E@, not just one. Unless initialized otherwise, the @B_java#util#concurrent#CountedCompleter#setPendingCount_E@, @B_java#util#concurrent#CountedCompleter#addToPendingCount_E@, and @B_java#util#concurrent#CountedCompleter#compareAndSetPendingCount_E@. Upon invocation of @B_java#util#concurrent#CountedCompleter#tryComplete_E@, if the pending action count is nonzero, it is decremented; otherwise, the completion action is performed, and if this completer itself has a completer, the process is continued with its completer. As is the case with related synchronization components such as @B_java#util#concurrent#Phaser_E@ and @B_java#util#concurrent#Semaphore_E@, these methods affect only internal counts; they do not establish any further internal bookkeeping. In particular, the identities of pending tasks are not maintained. As illustrated below, you can create subclasses that do record some or all pending tasks or their results when needed. As illustrated below, utility methods supporting customization of completion traversals are also provided. However, because CountedCompleters provide only basic synchronization mechanisms, it may be useful to create further abstract subclasses that maintain linkages, fields, and additional support methods appropriate for a set of related usages. A concrete CountedCompleter class must define method @B_java#util#concurrent#CountedCompleter#compute_E@, that should in most cases (as illustrated below), invoke tryComplete() once before returning. The class may also optionally override method @B_java#util#concurrent#CountedCompleter#onCompletion_E@ to perform an action upon normal completion, and method @B_java#util#concurrent#CountedCompleter#onExceptionalCompletion_E@ to perform an action upon any exception. CountedCompleters most often do not bear results, in which case they are normally declared as CountedCompleter<Void>, and will always return null as a result value. In other cases, you should override method @B_java#util#concurrent#CountedCompleter#getRawResult_E@ to provide a result from join(), invoke(), and related methods. In general, this method should return the value of a field (or a function of one or more fields) of the CountedCompleter object that holds the result upon completion. Method @B_java#util#concurrent#CountedCompleter#setRawResult_E@ by default plays no role in CountedCompleters. It is possible, but rarely applicable, to override this method to maintain other objects or fields holding result data. A CountedCompleter that does not itself have a completer (i.e., one for which @B_java#util#concurrent#CountedCompleter#getCompleter_E@ returns null) can be used as a regular ForkJoinTask with this added functionality. However, any completer that in turn has another completer serves only as an internal helper for other computations, so its own task status (as reported in methods such as @B_java#util#concurrent#ForkJoinTask#isDone_E@) is arbitrary; this status changes only upon explicit invocations of @B_java#util#concurrent#CountedCompleter#complete_E@, @B_java#util#concurrent#ForkJoinTask#cancel_E@, @B_java#util#concurrent#ForkJoinTask#completeExceptionally_E@ or upon exceptional completion of method compute. Upon any exceptional completion, the exception may be relayed to a task's completer (and its completer, and so on), if one exists and it has not otherwise already completed. Similarly, cancelling an internal CountedCompleter has only a local effect on that completer, so is not often useful. @B_java#util#concurrent#RecursiveAction_E@s, although the constructions involved in setting them up typically vary. Here, the completer of each task is its parent in the computation tree. Even though they entail a bit more bookkeeping, CountedCompleters may be better choices when applying a possibly time-consuming operation (that cannot be further subdivided) to each element of an array or collection; especially when the operation takes a significantly different amount of time to complete for some elements than others, either because of intrinsic variation (for example I/O) or auxiliary effects such as garbage collection. Because CountedCompleters provide their own continuations, other threads need not block waiting to perform them. For example, here is an initial version of a class that uses divide-by-two recursive decomposition to divide work into single pieces (leaf tasks). Even when work is split into individual calls, tree-based techniques are usually preferable to directly forking leaf tasks, because they reduce inter-thread communication and improve load balancing. In the recursive case, the second of each pair of subtasks to finish triggers completion of its parent (because no result combination is performed, the default no-op implementation of method onCompletion is not overridden). A static utility method sets up the base task and invokes it (here, implicitly using the @B_java#util#concurrent#ForkJoinPool#commonPool_E@). tryComplete) the pending count is set to one: @B_java#util#concurrent#CountedCompleter#onCompletion_E@ method, tryComplete() can be replaced with @B_java#util#concurrent#CountedCompleter#propagateCompletion_E@. @B_java#util#concurrent#atomic#AtomicReference_E@ as soon as one is found. The others can poll the result to avoid unnecessary work. (You could additionally compareAndSet a common result, the trailing unconditional invocation of tryComplete could be made conditional (if (result.get() == null) tryComplete();) because no further bookkeeping is required to manage completions once the root task completes. @B_java#util#concurrent#CountedCompleter#onCompletion_E@. As illustrated in the following class (that performs a simplified form of map-reduce where mappings and reductions are all of type E), one way to do this in divide and conquer designs is to have each subtask record its sibling, so that it can be accessed in method onCompletion. This technique applies to reductions in which the order of combining left and right results does not matter; ordered reductions require explicit left/right designations. Variants of other streamlinings seen in the above examples may also apply. onCompletion takes a form common to many completion designs that combine results. This callback-style method is triggered once per task, in either of the two different contexts in which the pending count is, or becomes, zero: (1) by a task itself, if its pending count is zero upon invocation of tryComplete, or (2) by any of its subtasks when they complete and decrement the pending count to zero. The caller argument distinguishes cases. Most often, when the caller is this, no action is necessary. Otherwise the caller argument can be used (usually via a cast) to supply a value (and/or links to other values) to be combined. Assuming proper use of pending counts, the actions inside onCompletion occur (once) upon completion of a task and its subtasks. No additional synchronization is required within this method to ensure thread safety of accesses to fields of this task or other completed tasks. onCompletion to process completions is inapplicable or inconvenient, you can use methods @B_java#util#concurrent#CountedCompleter#firstComplete_E@ and @B_java#util#concurrent#CountedCompleter#nextComplete_E@ to create custom traversals. For example, to define a MapReducer that only splits out right-hand tasks in the form of the third ForEach example, the completions must cooperatively reduce along unexhausted subtask links, which can be done as follows:"}