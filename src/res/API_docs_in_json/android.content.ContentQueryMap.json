{"Functions": {"ContentQueryMap(android.database.Cursor,java.lang.String,boolean,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#database#Cursor_E@", "Cursor: the cursor whose contents should be cached"], ["@B_java#lang#String_E@", "String: the column that is to be used as the key of the values map"], ["boolean", "boolean: true if the cursor's ContentProvider should be monitored for changes and the map updated when changes do occur"], ["@B_android#os#Handler_E@", "Handler: the Handler that should be used to receive notifications of changes (if requested). Normally you pass null here, but if you know that the thread that is creating this isn't a thread that can receive messages then you can create your own handler and use that here."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a ContentQueryMap that caches the content backing the cursor", "history": "Added in API level 1", "FullName": "public ContentQueryMap (Cursor cursor, String columnNameOfKey, boolean keepUpdated, Handler handlerForUpdateNotifications)"}, "setKeepUpdated(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: if true the ContentQueryMap should be registered with the cursor's ContentProvider, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change whether or not the ContentQueryMap will register with the cursor's ContentProvider for change notifications. If you use a ContentQueryMap in an activity you should call this with false in onPause(), which means you need to call it with true in onResume() if want it to be kept updated.", "history": "Added in API level 1", "FullName": "public void setKeepUpdated (boolean keepUpdated)"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#Throwable_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 1", "FullName": "protected void finalize ()"}, "getRows()": {"Returns": [["@B_java#util#Map_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public Map<String, ContentValues> getRows ()"}, "close()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public void close ()"}, "requery()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Requeries the cursor and reads the contents into the cache", "history": "Added in API level 1", "FullName": "public void requery ()"}, "getValues(java.lang.String)": {"Returns": [["@B_android#content#ContentValues_E@", "the ContentValues for the row, or null if the row wasn't present in the cursor"]], "Parameters": [["@B_java#lang#String_E@", "String: which row to read"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Access the ContentValues for the row specified by rowName", "history": "Added in API level 1", "FullName": "public ContentValues getValues (String rowName)"}}, "Inheritance": ["@B_java#util#Observable_E@"], "ClassName": "android.content.ContentQueryMap", "ClassDesc": "Caches the contents of a cursor into a Map of String->ContentValues and optionally keeps the cache fresh by registering for updates on the content backing the cursor. The column of the database that is to be used as the key of the map is user-configurable, and the ContentValues contains all columns other than the one that is designated the key. The cursor data is accessed by row key and column name via getValue()."}