{"Functions": {"getAllocatableBytes(java.util.UUID)": {"Returns": [["long", "the maximum number of new bytes that the calling app can allocate using @B_android#os#storage#StorageManager#allocateBytes_E@ or @B_android#os#storage#StorageManager#allocateBytes_E@. Value is a non-negative number of bytes."]], "Parameters": [["@B_java#util#UUID_E@", "UUID: the UUID of the storage volume where you're considering allocating disk space, since allocatable space can vary widely depending on the underlying storage device. The UUID for a specific path can be obtained using @B_android#os#storage#StorageManager#getUuidForPath_E@. This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "when the storage device isn't present, or when it doesn't support allocating space."]], "SeeAlso": [], "Permissions": [], "Description": "Return the maximum number of new bytes that your app can allocate for itself on the given storage volume. This value is typically larger than @B_java#io#File#getUsableSpace_E@, since the system may be willing to delete cached files to satisfy an allocation request. You can then allocate space for yourself using @B_android#os#storage#StorageManager#allocateBytes_E@ or @B_android#os#storage#StorageManager#allocateBytes_E@. This method is best used as a pre-flight check, such as deciding if there is enough space to store an entire music album before you allocate space for each audio file in the album. Attempts to allocate disk space beyond the returned value will fail. If the returned value is not large enough for the data you'd like to persist, you can launch @B_android#os#storage#StorageManager#ACTION_MANAGE_STORAGE_E@ with the @B_android#os#storage#StorageManager#EXTRA_UUID_E@ and @B_android#os#storage#StorageManager#EXTRA_REQUESTED_BYTES_E@ options to help involve the user in freeing up disk space. If you're progressively allocating an unbounded amount of storage space (such as when recording a video) you should avoid calling this method more than once every 30 seconds. Note: if your app uses the android:sharedUserId manifest feature, then allocatable space for all packages in your shared UID is tracked together as a single unit. This method may take several seconds to complete, so it should only be called from a worker thread. Value is a non-negative number of bytes.", "history": "Added in API level 26", "FullName": "public long getAllocatableBytes (UUID storageUuid)"}, "isCacheBehaviorTombstone(java.io.File)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#io#File_E@", "File no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Read the current value set by @B_android#os#storage#StorageManager#setCacheBehaviorTombstone_E@.", "history": "Added in API level 26", "FullName": "public boolean isCacheBehaviorTombstone (File path)"}, "getStorageVolume(java.io.File)": {"Returns": [["@B_android#os#storage#StorageVolume_E@", "no returns description in source"]], "Parameters": [["@B_java#io#File_E@", "File no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the @B_android#os#storage#StorageVolume_E@ that contains the given file, or null if none.", "history": "Added in API level 24", "FullName": "public StorageVolume getStorageVolume (File file)"}, "isObbMounted(java.lang.String)": {"Returns": [["boolean", "true if OBB is mounted; false if not mounted or on error"]], "Parameters": [["@B_java#lang#String_E@", "String: path to OBB image"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check whether an Opaque Binary Blob (OBB) is mounted or not.", "history": "Added in API level 9", "FullName": "public boolean isObbMounted (String rawPath)"}, "isEncrypted(java.io.File)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#io#File_E@", "File no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return if data stored at or under the given path will be encrypted while at rest. This can help apps avoid the overhead of double-encrypting data.", "history": "Added in API level 24", "FullName": "public boolean isEncrypted (File file)"}, "getCacheQuotaBytes(java.util.UUID)": {"Returns": [["long", "Value is a non-negative number of bytes."]], "Parameters": [["@B_java#util#UUID_E@", "UUID: the UUID of the storage volume that you're interested in. The UUID for a specific path can be obtained using @B_android#os#storage#StorageManager#getUuidForPath_E@. This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "when the storage device isn't present, or when it doesn't support cache quotas."]], "SeeAlso": ["@B_android#os#storage#StorageManager#getCacheSizeBytes_E@"], "Permissions": [], "Description": "Return quota size in bytes for all cached data belonging to the calling app on the given storage volume. If your app goes above this quota, your cached files will be some of the first to be deleted when additional disk space is needed. Conversely, if your app stays under this quota, your cached files will be some of the last to be deleted when additional disk space is needed. This quota will change over time depending on how frequently the user interacts with your app, and depending on how much system-wide disk space is used. Note: if your app uses the android:sharedUserId manifest feature, then cached data for all packages in your shared UID is tracked together as a single unit. This method may take several seconds to complete, so it should only be called from a worker thread. Value is a non-negative number of bytes.", "history": "Added in API level 26", "FullName": "public long getCacheQuotaBytes (UUID storageUuid)"}, "getMountedObbPath(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "absolute path to mounted OBB image data or null if not mounted or exception encountered trying to read status"]], "Parameters": [["@B_java#lang#String_E@", "String: path to OBB image"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check the mounted path of an Opaque Binary Blob (OBB) file. This will give you the path to where you can obtain access to the internals of the OBB.", "history": "Added in API level 9", "FullName": "public String getMountedObbPath (String rawPath)"}, "getUuidForPath(java.io.File)": {"Returns": [["@B_java#util#UUID_E@", "This value will never be null."]], "Parameters": [["@B_java#io#File_E@", "File: This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "when the storage device hosting the given path isn't present, or when it doesn't have a valid UUID."]], "SeeAlso": [], "Permissions": [], "Description": "Return a UUID identifying the storage volume that hosts the given filesystem path. If this path is hosted by the default internal storage of the device at @B_android#os#Environment#getDataDirectory_E@, the returned value will be @B_android#os#storage#StorageManager#UUID_DEFAULT_E@.", "history": "Added in API level 26", "FullName": "public UUID getUuidForPath (File path)"}, "allocateBytes(java.util.UUID, long)": {"Returns": [], "Parameters": [["@B_java#util#UUID_E@", "UUID: the UUID of the storage volume where you'd like to allocate disk space. The UUID for a specific path can be obtained using @B_android#os#storage#StorageManager#getUuidForPath_E@.This value must never be null."], ["long", "long: the number of bytes to allocate.Value is a non-negative number of bytes."]], "Throws": [["@B_java#io#IOException_E@", "when the storage device isn't present, or when it doesn't support allocating space, or if the device had trouble allocating the requested space."]], "SeeAlso": ["@B_android#os#storage#StorageManager#getAllocatableBytes_E@"], "Permissions": [], "Description": "Allocate the requested number of bytes for your application to use on the given storage volume. This will cause the system to delete any cached files necessary to satisfy your request. Attempts to allocate disk space beyond the value returned by @B_android#os#storage#StorageManager#getAllocatableBytes_E@ will fail. Since multiple apps can be running simultaneously, this method may be subject to race conditions. If possible, consider using @B_android#os#storage#StorageManager#allocateBytes_E@ which will guarantee that bytes are allocated to an opened file. If you're progressively allocating an unbounded amount of storage space (such as when recording a video) you should avoid calling this method more than once every 60 seconds.This method may take several seconds to complete, so it should only be called from a worker thread.", "history": "added in API level 26", "FullName": "public void allocateBytes (UUID storageUuid, long bytes)"}, "isAllocationSupported(java.io.FileDescriptor)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Test if the given file descriptor supports allocation of disk space using @B_android#os#storage#StorageManager#allocateBytes_E@.", "history": "Added in API level 27", "FullName": "public boolean isAllocationSupported (FileDescriptor fd)"}, "unmountObb(java.lang.String,boolean,android.os.storage.OnObbStateChangeListener)": {"Returns": [["boolean", "whether the unmount call was successfully queued or not"]], "Parameters": [["@B_java#lang#String_E@", "String: path to the OBB file"], ["boolean", "boolean: whether to kill any programs using this in order to unmount it"], ["@B_android#os#storage#OnObbStateChangeListener_E@", "OnObbStateChangeListener: will receive the success or failure of the operation"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Unmount an Opaque Binary Blob (OBB) file asynchronously. If the force flag is true, it will kill any application needed to unmount the given OBB (even the calling application). The @B_android#os#storage#OnObbStateChangeListener_E@ registered with this call will receive the success or failure of this operation. Note: you can only mount OBB files for which the OBB tag on the file matches a package ID that is owned by the calling program's UID. That is, shared UID applications can obtain access to any other application's OBB that shares its UID.", "history": "Added in API level 9", "FullName": "public boolean unmountObb (String rawPath, boolean force, OnObbStateChangeListener listener)"}, "allocateBytes(java.io.FileDescriptor,long)": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: the open file that you'd like to allocate disk space for."], ["long", "long: the number of bytes to allocate. This is the desired final size of the open file. If the open file is smaller than this requested size, it will be extended without modifying any existing contents. If the open file is larger than this requested size, it will be truncated. Value is a non-negative number of bytes."]], "Throws": [["@B_java#io#IOException_E@", "when the storage device isn't present, or when it doesn't support allocating space, or if the device had trouble allocating the requested space."]], "SeeAlso": ["@B_android#os#storage#StorageManager#isAllocationSupported_E@", "@B_android#os#Environment#isExternalStorageEmulated_E@"], "Permissions": [], "Description": "Allocate the requested number of bytes for your application to use in the given open file. This will cause the system to delete any cached files necessary to satisfy your request. Attempts to allocate disk space beyond the value returned by @B_android#os#storage#StorageManager#getAllocatableBytes_E@ will fail. This method guarantees that bytes have been allocated to the opened file, otherwise it will throw if fast allocation is not possible. Fast allocation is typically only supported in private app data directories, and on shared/external storage devices which are emulated. If you're progressively allocating an unbounded amount of storage space (such as when recording a video) you should avoid calling this method more than once every 60 seconds. This method may take several seconds to complete, so it should only be called from a worker thread.", "history": "Added in API level 26", "FullName": "public void allocateBytes (FileDescriptor fd, long bytes)"}, "getPrimaryStorageVolume()": {"Returns": [["@B_android#os#storage#StorageVolume_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the primary shared/external storage volume available to the current user. This volume is the same storage device returned by @B_android#os#Environment#getExternalStorageDirectory_E@ and @B_android#content#Context#getExternalFilesDir_E@.", "history": "Added in API level 24", "FullName": "public StorageVolume getPrimaryStorageVolume ()"}, "setCacheBehaviorGroup(java.io.File,boolean)": {"Returns": [], "Parameters": [["@B_java#io#File_E@", "File no parameter comment"], ["boolean", "boolean no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable special cache behavior that treats this directory and its contents as an entire group. When enabled and this directory is considered for automatic deletion by the OS, all contained files will either be deleted together, or not at all. This is useful when you have a directory that contains several related metadata files that depend on each other, such as movie file and a subtitle file. When enabled, the newest @B_java#io#File#lastModified_E@ value of any contained files is considered the modified time of the entire directory. This behavior can only be set on a directory, and it applies recursively to all contained files and directories.", "history": "Added in API level 26", "FullName": "public void setCacheBehaviorGroup (File path, boolean group)"}, "getStorageVolume(android.net.Uri)": {"Returns": [["@B_android#os#storage#StorageVolume_E@", "This value will never be null."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the @B_android#os#storage#StorageVolume_E@ that contains the given @B_android#provider#MediaStore_E@ item.", "history": "Added in API level 29", "FullName": "public StorageVolume getStorageVolume (Uri uri)"}, "allocateBytes(java.io.FileDescriptor, long)": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: the open file that you'd like to allocate disk space for."], ["long", "long: the number of bytes to allocate. This is the desired final size of the open file. If the open file is smaller than this requested size, it will be extended without modifying any existing contents. If the open file is larger than this requested size, it will be truncated.Value is a non-negative number of bytes."]], "Throws": [["@B_java#io#IOException_E@", "when the storage device isn't present, or when it doesn't support allocating space, or if the device had trouble allocating the requested space."]], "SeeAlso": ["_E@", "@B_android#os#storage#StorageManager#isAllocationSupported_E@", "@B_android#os#Environment#isExternalStorageEmulated_E@"], "Permissions": [], "Description": "Allocate the requested number of bytes for your application to use in the given open file. This will cause the system to delete any cached files necessary to satisfy your request. Attempts to allocate disk space beyond the value returned by @B_android#os#storage#StorageManager#getAllocatableBytes_E@ will fail. This method guarantees that bytes have been allocated to the opened file, otherwise it will throw if fast allocation is not possible. Fast allocation is typically only supported in private app data directories, and on shared/external storage devices which are emulated. If you're progressively allocating an unbounded amount of storage space (such as when recording a video) you should avoid calling this method more than once every 60 seconds.This method may take several seconds to complete, so it should only be called from a worker thread.", "history": "added in API level 26", "FullName": "public void allocateBytes (FileDescriptor fd, long bytes)"}, "setCacheBehaviorTombstone(java.io.File,boolean)": {"Returns": [], "Parameters": [["@B_java#io#File_E@", "File no parameter comment"], ["boolean", "boolean no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable special cache behavior that leaves deleted cache files intact as tombstones. When enabled and a file contained in this directory is automatically deleted by the OS, the file will be truncated to have a length of 0 bytes instead of being fully deleted. This is useful if you need to distinguish between a file that was deleted versus one that never existed. This behavior can only be set on a directory, and it applies recursively to all contained files and directories. Note: this behavior is ignored completely if the user explicitly requests that all cached data be cleared.", "history": "Added in API level 26", "FullName": "public void setCacheBehaviorTombstone (File path, boolean tombstone)"}, "allocateBytes(java.util.UUID,long)": {"Returns": [], "Parameters": [["@B_java#util#UUID_E@", "UUID: the UUID of the storage volume where you'd like to allocate disk space. The UUID for a specific path can be obtained using @B_android#os#storage#StorageManager#getUuidForPath_E@. This value must never be null."], ["long", "long: the number of bytes to allocate. Value is a non-negative number of bytes."]], "Throws": [["@B_java#io#IOException_E@", "when the storage device isn't present, or when it doesn't support allocating space, or if the device had trouble allocating the requested space."]], "SeeAlso": ["@B_android#os#storage#StorageManager#getAllocatableBytes_E@"], "Permissions": [], "Description": "Allocate the requested number of bytes for your application to use on the given storage volume. This will cause the system to delete any cached files necessary to satisfy your request. Attempts to allocate disk space beyond the value returned by @B_android#os#storage#StorageManager#getAllocatableBytes_E@ will fail. Since multiple apps can be running simultaneously, this method may be subject to race conditions. If possible, consider using @B_android#os#storage#StorageManager#allocateBytes_E@ which will guarantee that bytes are allocated to an opened file. If you're progressively allocating an unbounded amount of storage space (such as when recording a video) you should avoid calling this method more than once every 60 seconds. This method may take several seconds to complete, so it should only be called from a worker thread.", "history": "Added in API level 26", "FullName": "public void allocateBytes (UUID storageUuid, long bytes)"}, "getStorageVolumes()": {"Returns": [["@B_java#util#List_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#os#Environment#getExternalStorageDirectory_E@", "@B_android#os#storage#StorageVolume#createAccessIntent_E@"], "Permissions": [], "Description": "Return the list of shared/external storage volumes available to the current user. This includes both the primary shared storage device and any attached external volumes including SD cards and USB drives.", "history": "Added in API level 24", "FullName": "public List<StorageVolume> getStorageVolumes ()"}, "isCacheBehaviorGroup(java.io.File)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_java#io#File_E@", "File no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Read the current value set by @B_android#os#storage#StorageManager#setCacheBehaviorGroup_E@.", "history": "Added in API level 26", "FullName": "public boolean isCacheBehaviorGroup (File path)"}, "mountObb(java.lang.String,java.lang.String,android.os.storage.OnObbStateChangeListener)": {"Returns": [["boolean", "whether the mount call was successfully queued or not"]], "Parameters": [["@B_java#lang#String_E@", "String: the path to the OBB file"], ["@B_java#lang#String_E@", "String: secret used to encrypt the OBB; may be null if no encryption was used on the OBB."], ["@B_android#os#storage#OnObbStateChangeListener_E@", "OnObbStateChangeListener: will receive the success or failure of the operation"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Mount an Opaque Binary Blob (OBB) file. If a key is specified, it is supplied to the mounting process to be used in any encryption used in the OBB. The OBB will remain mounted for as long as the StorageManager reference is held by the application. As soon as this reference is lost, the OBBs in use will be unmounted. The @B_android#os#storage#OnObbStateChangeListener_E@ registered with this call will receive the success or failure of this operation. Note: you can only mount OBB files for which the OBB tag on the file matches a package ID that is owned by the calling program's UID. That is, shared UID applications can attempt to mount any other application's OBB that shares its UID.", "history": "Added in API level 9", "FullName": "public boolean mountObb (String rawPath, String key, OnObbStateChangeListener listener)"}, "setCacheBehaviorGroup(java.io.File, boolean)": {"Returns": [], "Parameters": [["@B_java#io#File_E@", "File no parameter comment"], ["boolean", "boolean no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable special cache behavior that treats this directory and its contents as an entire group. When enabled and this directory is considered for automatic deletion by the OS, all contained files will either be deleted together, or not at all. This is useful when you have a directory that contains several related metadata files that depend on each other, such as movie file and a subtitle file. When enabled, the newest @B_java#io#File#lastModified_E@ value of any contained files is considered the modified time of the entire directory. This behavior can only be set on a directory, and it applies recursively to all contained files and directories.", "history": "added in API level 26", "FullName": "public void setCacheBehaviorGroup (File path, boolean group)"}, "setCacheBehaviorTombstone(java.io.File, boolean)": {"Returns": [], "Parameters": [["@B_java#io#File_E@", "File no parameter comment"], ["boolean", "boolean no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable special cache behavior that leaves deleted cache files intact as tombstones. When enabled and a file contained in this directory is automatically deleted by the OS, the file will be truncated to have a length of 0 bytes instead of being fully deleted. This is useful if you need to distinguish between a file that was deleted versus one that never existed. This behavior can only be set on a directory, and it applies recursively to all contained files and directories. Note: this behavior is ignored completely if the user explicitly requests that all cached data be cleared.", "history": "added in API level 26", "FullName": "public void setCacheBehaviorTombstone (File path, boolean tombstone)"}, "getCacheSizeBytes(java.util.UUID)": {"Returns": [["long", "Value is a non-negative number of bytes."]], "Parameters": [["@B_java#util#UUID_E@", "UUID: the UUID of the storage volume that you're interested in. The UUID for a specific path can be obtained using @B_android#os#storage#StorageManager#getUuidForPath_E@. This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "when the storage device isn't present, or when it doesn't support cache quotas."]], "SeeAlso": ["@B_android#os#storage#StorageManager#getCacheQuotaBytes_E@"], "Permissions": [], "Description": "Return total size in bytes of all cached data belonging to the calling app on the given storage volume. Cached data tracked by this method always includes @B_android#content#Context#getCacheDir_E@ and @B_android#content#Context#getCodeCacheDir_E@, and it also includes @B_android#content#Context#getExternalCacheDir_E@ if the primary shared/external storage is hosted on the same storage device as your private data. Note: if your app uses the android:sharedUserId manifest feature, then cached data for all packages in your shared UID is tracked together as a single unit. This method may take several seconds to complete, so it should only be called from a worker thread. Value is a non-negative number of bytes.", "history": "Added in API level 26", "FullName": "public long getCacheSizeBytes (UUID storageUuid)"}, "openProxyFileDescriptor(int,android.os.ProxyFileDescriptorCallback,android.os.Handler)": {"Returns": [["@B_android#os#ParcelFileDescriptor_E@", "Seekable ParcelFileDescriptor. This value will never be null."]], "Parameters": [["int", "int: The desired access mode, must be one of @B_android#os#ParcelFileDescriptor#MODE_READ_ONLY_E@, @B_android#os#ParcelFileDescriptor#MODE_WRITE_ONLY_E@, or @B_android#os#ParcelFileDescriptor#MODE_READ_WRITE_E@"], ["@B_android#os#ProxyFileDescriptorCallback_E@", "ProxyFileDescriptorCallback: Callback to process file operation requests issued on returned file descriptor."], ["@B_android#os#Handler_E@", "Handler: Handler that invokes callback methods."]], "Throws": [["", "java.io.IOException"], ["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Opens a seekable @B_android#os#ParcelFileDescriptor_E@ that proxies all low-level I/O requests back to the given @B_android#os#ProxyFileDescriptorCallback_E@. This can be useful when you want to provide quick access to a large file that isn't backed by a real file on disk, such as a file on a network share, cloud storage service, etc. As an example, you could respond to a @B_android#content#ContentResolver#openFileDescriptor_E@ request by returning a @B_android#os#ParcelFileDescriptor_E@ created with this method, and then stream the content on-demand as requested. Another useful example might be where you have an encrypted file that you're willing to decrypt on-demand, but where you want to avoid persisting the cleartext version.", "history": "Added in API level 26", "FullName": "public ParcelFileDescriptor openProxyFileDescriptor (int mode, ProxyFileDescriptorCallback callback, Handler handler)"}}, "Inheritance": [], "ClassName": "android.os.storage.StorageManager", "ClassDesc": "StorageManager is the interface to the systems storage service. The storage manager handles storage-related items such as Opaque Binary Blobs (OBBs). OBBs contain a filesystem that maybe be encrypted on disk and mounted on-demand from an application. OBBs are a good way of providing large amounts of binary assets without packaging them into APKs as they may be multiple gigabytes in size. However, due to their size, they're most likely stored in a shared storage pool accessible from all programs. The system does not guarantee the security of the OBB file itself: if any program modifies the OBB, there is no guarantee that a read from that OBB will produce the expected output."}