{"Functions": {"flush()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Flush both input and output ports of the component. Upon return, all indices previously returned in calls to @B_android#media#MediaCodec#dequeueInputBuffer_E@ and @B_android#media#MediaCodec#dequeueOutputBuffer_E@ \u2014 or obtained via @B_android#media#MediaCodec#Callback#onInputBufferAvailable_E@ or @B_android#media#MediaCodec#Callback#onOutputBufferAvailable_E@ callbacks \u2014 become invalid, and all buffers are owned by the codec. If the codec is configured in asynchronous mode, call @B_android#media#MediaCodec#start_E@ after flush has returned to resume codec operations. The codec will not request input buffers until this has happened. If the codec is configured in synchronous mode, codec will resume automatically if it is configured with an input surface. Otherwise, it will resume when @B_android#media#MediaCodec#dequeueInputBuffer_E@ is called.", "history": "Added in API level 16", "FullName": "public void flush ()"}, "setOutputSurface(android.view.Surface)": {"Returns": [], "Parameters": [["@B_android#view#Surface_E@", "Surface: the output surface to use. It must not be null. This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the codec does not support setting the output surface in the current state."], ["@B_java#lang#IllegalArgumentException_E@", "if the new surface is not of a suitable type for the codec."]], "SeeAlso": [], "Permissions": [], "Description": "Dynamically sets the output surface of a codec. This can only be used if the codec was configured with an output surface. The new output surface should have a compatible usage type to the original output surface. E.g. codecs may not support switching from a SurfaceTexture (GPU readable) output to ImageReader (software readable) output.", "history": "Added in API level 23", "FullName": "public void setOutputSurface (Surface surface)"}, "releaseOutputBuffer(int,boolean)": {"Returns": [], "Parameters": [["int", "int: The index of a client-owned output buffer previously returned from a call to @B_android#media#MediaCodec#dequeueOutputBuffer_E@."], ["boolean", "boolean: If a valid surface was specified when configuring the codec, passing true renders this output buffer to the surface."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "If you are done with a buffer, use this call to return the buffer to the codec or to render it on the output surface. If you configured the codec with an output surface, setting render to true will first send the buffer to that output surface. The surface will release the buffer back to the codec once it is no longer used/displayed. Once an output buffer is released to the codec, it MUST NOT be used until it is later retrieved by @B_android#media#MediaCodec#getOutputBuffer_E@ in response to a @B_android#media#MediaCodec#dequeueOutputBuffer_E@ return value or a @B_android#media#MediaCodec#Callback#onOutputBufferAvailable_E@ callback.", "history": "Added in API level 16", "FullName": "public void releaseOutputBuffer (int index, boolean render)"}, "queueInputBuffer(int, int, int, long, int)": {"Returns": [], "Parameters": [["int", "int: The index of a client-owned input buffer previously returned in a call to @B_android#media#MediaCodec#dequeueInputBuffer_E@."], ["int", "int: The byte offset into the input buffer at which the data starts."], ["int", "int: The number of bytes of valid input data."], ["long", "long: The presentation timestamp in microseconds for this buffer. This is normally the media time at which this buffer should be presented (rendered). When using an output surface, this will be propagated as the @B_android#graphics#SurfaceTexture#getTimestamp_E@ for the frame (after conversion to nanoseconds)."], ["int", "int: A bitmask of flags @B_android#media#MediaCodec#BUFFER_FLAG_CODEC_CONFIG_E@ and @B_android#media#MediaCodec#BUFFER_FLAG_END_OF_STREAM_E@. While not prohibited, most codecs do not use the @B_android#media#MediaCodec#BUFFER_FLAG_KEY_FRAME_E@ flag for input buffers."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."], ["@B_android#media#MediaCodec#CryptoException_E@", "if a crypto object has been specified in @B_android#media#MediaCodec#configure_E@"]], "SeeAlso": [], "Permissions": [], "Description": "After filling a range of the input buffer at the specified index submit it to the component. Once an input buffer is queued to the codec, it MUST NOT be used until it is later retrieved by @B_android#media#MediaCodec#getInputBuffer_E@ in response to a @B_android#media#MediaCodec#dequeueInputBuffer_E@ return value or a @B_android#media#MediaCodec#Callback#onInputBufferAvailable_E@ callback. Many decoders require the actual compressed data stream to be preceded by \"codec specific data\", i.e. setup data used to initialize the codec such as PPS/SPS in the case of AVC video or code tables in the case of vorbis audio. The class @B_android#media#MediaExtractor_E@ provides codec specific data as part of the returned track format in entries named \"csd-0\", \"csd-1\" ... These buffers can be submitted directly after @B_android#media#MediaCodec#start_E@ or @B_android#media#MediaCodec#flush_E@ by specifying the flag @B_android#media#MediaCodec#BUFFER_FLAG_CODEC_CONFIG_E@. However, if you configure the codec with a @B_android#media#MediaFormat_E@ containing these keys, they will be automatically submitted by MediaCodec directly after start. Therefore, the use of @B_android#media#MediaCodec#BUFFER_FLAG_CODEC_CONFIG_E@ flag is discouraged and is recommended only for advanced users. To indicate that this is the final piece of input data (or rather that no more input data follows unless the decoder is subsequently flushed) specify the flag @B_android#media#MediaCodec#BUFFER_FLAG_END_OF_STREAM_E@. @B_android#os#Build#VERSION_CODES#M_E@, presentationTimeUs was not propagated to the frame timestamp of (rendered) Surface output buffers, and the resulting frame timestamp was undefined. Use @B_android#media#MediaCodec#releaseOutputBuffer_E@ to ensure a specific frame timestamp is set. Similarly, since frame timestamps can be used by the destination surface for rendering synchronization,", "history": "added in API level 16", "FullName": "public void queueInputBuffer (int index, int offset, int size, long presentationTimeUs, int flags)"}, "start()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Configured state or just after @B_android#media#MediaCodec#flush_E@ for a codec that is configured in asynchronous mode."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error. Note that some codec errors for start may be attributed to future method calls."]], "SeeAlso": [], "Permissions": [], "Description": "After successfully configuring the component, call start. Call start also if the codec is configured in asynchronous mode, and it has just been flushed, to resume requesting input buffers.", "history": "Added in API level 16", "FullName": "public void start ()"}, "getInputFormat()": {"Returns": [["@B_android#media#MediaFormat_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing or Configured state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Call this after @B_android#media#MediaCodec#configure_E@ returns successfully to get the input format accepted by the codec. Do this to determine what optional configuration parameters were supported by the codec.", "history": "Added in API level 21", "FullName": "public MediaFormat getInputFormat ()"}, "signalEndOfInputStream()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Signals end-of-stream on input. Equivalent to submitting an empty buffer with @B_android#media#MediaCodec#BUFFER_FLAG_END_OF_STREAM_E@ set. This may only be used with encoders receiving input from a Surface created by @B_android#media#MediaCodec#createInputSurface_E@.", "history": "Added in API level 18", "FullName": "public void signalEndOfInputStream ()"}, "getOutputImage(int)": {"Returns": [["@B_android#media#Image_E@", "the output image, or null if the index is not a dequeued output buffer, not a raw video frame, or if the codec was configured with an output surface."]], "Parameters": [["int", "int: The index of a client-owned output buffer previously returned from a call to @B_android#media#MediaCodec#dequeueOutputBuffer_E@, or received via an onOutputBufferAvailable callback."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a read-only Image object for a dequeued output buffer index that contains the raw video frame. After calling this method, any ByteBuffer or Image object previously returned for the same output index MUST no longer be used.", "history": "Added in API level 21", "FullName": "public Image getOutputImage (int index)"}, "configure(android.media.MediaFormat,android.view.Surface,int,android.media.MediaDescrambler)": {"Returns": [], "Parameters": [["@B_android#media#MediaFormat_E@", "MediaFormat: The format of the input data (decoder) or the desired format of the output data (encoder). Passing null as format is equivalent to passing an @B_android#media#MediaFormat#MediaFormat_E@. This value may be null."], ["@B_android#view#Surface_E@", "Surface: Specify a surface on which to render the output of this decoder. Pass null as surface if the codec does not generate raw video output (e.g. not a video decoder) and/or if you want to configure the codec for @B_java#nio#ByteBuffer_E@ output. This value may be null."], ["int", "int: Specify @B_android#media#MediaCodec#CONFIGURE_FLAG_ENCODE_E@ to configure the component as an encoder. Value is either 0 or @B_android#media#MediaCodec#CONFIGURE_FLAG_ENCODE_E@"], ["@B_android#media#MediaDescrambler_E@", "MediaDescrambler: Specify a descrambler object to facilitate secure descrambling of the media data, or null for non-secure codecs. This value may be null."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the surface has been released (or is invalid), or the format is unacceptable (e.g. missing a mandatory key), or the flags are not set properly (e.g. missing @B_android#media#MediaCodec#CONFIGURE_FLAG_ENCODE_E@ for an encoder)."], ["@B_java#lang#IllegalStateException_E@", "if not in the Uninitialized state."], ["@B_android#media#MediaCodec#CryptoException_E@", "upon DRM error."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Configure a component to be used with a descrambler.", "history": "Added in API level 26", "FullName": "public void configure (MediaFormat format, Surface surface, int flags, MediaDescrambler descrambler)"}, "getOutputFormat(int)": {"Returns": [["@B_android#media#MediaFormat_E@", "the format for the output buffer, or null if the index is not a dequeued output buffer."]], "Parameters": [["int", "int: The index of a client-owned input buffer previously returned from a call to @B_android#media#MediaCodec#dequeueInputBuffer_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the output format for a specific output buffer.", "history": "Added in API level 21", "FullName": "public MediaFormat getOutputFormat (int index)"}, "configure(android.media.MediaFormat,android.view.Surface,android.media.MediaCrypto,int)": {"Returns": [], "Parameters": [["@B_android#media#MediaFormat_E@", "MediaFormat: The format of the input data (decoder) or the desired format of the output data (encoder). Passing null as format is equivalent to passing an @B_android#media#MediaFormat#MediaFormat_E@. This value may be null."], ["@B_android#view#Surface_E@", "Surface: Specify a surface on which to render the output of this decoder. Pass null as surface if the codec does not generate raw video output (e.g. not a video decoder) and/or if you want to configure the codec for @B_java#nio#ByteBuffer_E@ output. This value may be null."], ["@B_android#media#MediaCrypto_E@", "MediaCrypto: Specify a crypto object to facilitate secure decryption of the media data. Pass null as crypto for non-secure codecs. Please note that @B_android#media#MediaCodec_E@ does NOT take ownership of the @B_android#media#MediaCrypto_E@ object; it is the application's responsibility to properly cleanup the @B_android#media#MediaCrypto_E@ object when not in use. This value may be null."], ["int", "int: Specify @B_android#media#MediaCodec#CONFIGURE_FLAG_ENCODE_E@ to configure the component as an encoder. Value is either 0 or @B_android#media#MediaCodec#CONFIGURE_FLAG_ENCODE_E@"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the surface has been released (or is invalid), or the format is unacceptable (e.g. missing a mandatory key), or the flags are not set properly (e.g. missing @B_android#media#MediaCodec#CONFIGURE_FLAG_ENCODE_E@ for an encoder)."], ["@B_java#lang#IllegalStateException_E@", "if not in the Uninitialized state."], ["@B_android#media#MediaCodec#CryptoException_E@", "upon DRM error."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Configures a component.", "history": "Added in API level 16", "FullName": "public void configure (MediaFormat format, Surface surface, MediaCrypto crypto, int flags)"}, "stop()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if in the Released state."]], "SeeAlso": [], "Permissions": [], "Description": "Finish the decode/encode session, note that the codec instance remains active and ready to be @B_android#media#MediaCodec#start_E@ed again. To ensure that it is available to other client call @B_android#media#MediaCodec#release_E@ and don't just rely on garbage collection to eventually do this for you.", "history": "Added in API level 16", "FullName": "public void stop ()"}, "createByCodecName(java.lang.String)": {"Returns": [["@B_android#media#MediaCodec_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the codec to be instantiated. This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "if the codec cannot be created."], ["@B_java#lang#IllegalArgumentException_E@", "if name is not valid."], ["@B_java#lang#NullPointerException_E@", "if name is null."]], "SeeAlso": [], "Permissions": [], "Description": "If you know the exact name of the component you want to instantiate use this method to instantiate it. Use with caution. Likely to be used with information obtained from @B_android#media#MediaCodecList_E@", "history": "Added in API level 16", "FullName": "public static MediaCodec createByCodecName (String name)"}, "setVideoScalingMode(int)": {"Returns": [], "Parameters": [["int", "int: Value is @B_android#media#MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT_E@, or @B_android#media#MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING_E@"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if mode is not recognized."], ["@B_java#lang#IllegalStateException_E@", "if in the Released state."]], "SeeAlso": [], "Permissions": [], "Description": "If a surface has been specified in a previous call to @B_android#media#MediaCodec#configure_E@ specifies the scaling mode to use. The default is \"scale to fit\". The scaling mode may be reset to the @B_android#media#MediaCodec#INFO_OUTPUT_BUFFERS_CHANGED_E@ event is received from the codec; therefore, the client must call this method after every buffer change event (and before the first output buffer is released for rendering) to ensure consistent scaling mode. Since the @B_android#media#MediaCodec#INFO_OUTPUT_BUFFERS_CHANGED_E@ event is deprecated, this can also be done after each @B_android#media#MediaCodec#INFO_OUTPUT_FORMAT_CHANGED_E@ event.", "history": "Added in API level 16", "FullName": "public void setVideoScalingMode (int mode)"}, "releaseOutputBuffer(int, long)": {"Returns": [], "Parameters": [["int", "int: The index of a client-owned output buffer previously returned from a call to @B_android#media#MediaCodec#dequeueOutputBuffer_E@."], ["long", "long: The timestamp to associate with this buffer when it is sent to the Surface."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "If you are done with a buffer, use this call to update its surface timestamp and return it to the codec to render it on the output surface. If you have not specified an output surface when configuring this video codec, this call will simply return the buffer to the codec. The timestamp may have special meaning depending on the destination surface. @B_android#media#MediaCodec#getOutputBuffer_E@ in response to a @B_android#media#MediaCodec#dequeueOutputBuffer_E@ return value or a @B_android#media#MediaCodec#Callback#onOutputBufferAvailable_E@ callback.", "history": "added in API level 21", "FullName": "public void releaseOutputBuffer (int index, long renderTimestampNs)"}, "createEncoderByType(java.lang.String)": {"Returns": [["@B_android#media#MediaCodec_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: The desired mime type of the output data. This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "if the codec cannot be created."], ["@B_java#lang#IllegalArgumentException_E@", "if type is not a valid mime type."], ["@B_java#lang#NullPointerException_E@", "if type is null."]], "SeeAlso": [], "Permissions": [], "Description": "Instantiate the preferred encoder supporting output data of the given mime type. @B_android#media#MediaCodecList#findEncoderForFormat_E@ and @B_android#media#MediaCodec#createByCodecName_E@ to ensure that the resulting codec can handle a given format.", "history": "Added in API level 16", "FullName": "public static MediaCodec createEncoderByType (String type)"}, "createDecoderByType(java.lang.String)": {"Returns": [["@B_android#media#MediaCodec_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: The mime type of the input data. This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "if the codec cannot be created."], ["@B_java#lang#IllegalArgumentException_E@", "if type is not a valid mime type."], ["@B_java#lang#NullPointerException_E@", "if type is null."]], "SeeAlso": [], "Permissions": [], "Description": "Instantiate the preferred decoder supporting input data of the given mime type. The following is a partial list of defined mime types and their semantics: \"video/x-vnd.on2.vp8\" - VP8 video (i.e. video in .webm) \"video/x-vnd.on2.vp9\" - VP9 video (i.e. video in .webm) \"video/avc\" - H.264/AVC video \"video/hevc\" - H.265/HEVC video \"video/mp4v-es\" - MPEG4 video \"video/3gpp\" - H.263 video \"audio/3gpp\" - AMR narrowband audio \"audio/amr-wb\" - AMR wideband audio \"audio/mpeg\" - MPEG1/2 audio layer III \"audio/mp4a-latm\" - AAC audio (note, this is raw AAC packets, not packaged in LATM!) \"audio/vorbis\" - vorbis audio \"audio/g711-alaw\" - G.711 alaw audio \"audio/g711-mlaw\" - G.711 ulaw audio @B_android#media#MediaCodecList#findDecoderForFormat_E@ and @B_android#media#MediaCodec#createByCodecName_E@ to ensure that the resulting codec can handle a given format.", "history": "Added in API level 16", "FullName": "public static MediaCodec createDecoderByType (String type)"}, "setOnFrameRenderedListener(android.media.MediaCodec.OnFrameRenderedListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaCodec#OnFrameRenderedListener_E@", "MediaCodec.OnFrameRenderedListener: the callback that will be run This value may be null."], ["@B_android#os#Handler_E@", "Handler: the callback will be run on the handler's thread. If null, the callback will be run on the default thread, which is the looper from which the codec was created, or a new thread if there was none. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Registers a callback to be invoked when an output frame is rendered on the output surface. This method can be called in any codec state, but will only have an effect in the Executing state for codecs that render buffers to the output surface.", "history": "Added in API level 23", "FullName": "public void setOnFrameRenderedListener (MediaCodec.OnFrameRenderedListener listener, Handler handler)"}, "getOutputBuffer(int)": {"Returns": [["@B_java#nio#ByteBuffer_E@", "the output buffer, or null if the index is not a dequeued output buffer, or the codec is configured with an output surface."]], "Parameters": [["int", "int: The index of a client-owned output buffer previously returned from a call to @B_android#media#MediaCodec#dequeueOutputBuffer_E@, or received via an onOutputBufferAvailable callback."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a read-only ByteBuffer for a dequeued output buffer index. The position and limit of the returned buffer are set to the valid output data. After calling this method, any ByteBuffer or Image object previously returned for the same output index MUST no longer be used.", "history": "Added in API level 21", "FullName": "public ByteBuffer getOutputBuffer (int index)"}, "queueSecureInputBuffer(int,int,android.media.MediaCodec.CryptoInfo,long,int)": {"Returns": [], "Parameters": [["int", "int: The index of a client-owned input buffer previously returned in a call to @B_android#media#MediaCodec#dequeueInputBuffer_E@."], ["int", "int: The byte offset into the input buffer at which the data starts."], ["@B_android#media#MediaCodec#CryptoInfo_E@", "MediaCodec.CryptoInfo: Metadata required to facilitate decryption, the object can be reused immediately after this call returns. This value must never be null."], ["long", "long: The presentation timestamp in microseconds for this buffer. This is normally the media time at which this buffer should be presented (rendered)."], ["int", "int: A bitmask of flags @B_android#media#MediaCodec#BUFFER_FLAG_CODEC_CONFIG_E@ and @B_android#media#MediaCodec#BUFFER_FLAG_END_OF_STREAM_E@. While not prohibited, most codecs do not use the @B_android#media#MediaCodec#BUFFER_FLAG_KEY_FRAME_E@ flag for input buffers."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."], ["@B_android#media#MediaCodec#CryptoException_E@", "if an error occurs while attempting to decrypt the buffer. An error code associated with the exception helps identify the reason for the failure."]], "SeeAlso": [], "Permissions": [], "Description": "Similar to @B_android#media#MediaCodec#queueInputBuffer_E@ but submits a buffer that is potentially encrypted.", "history": "Added in API level 16", "FullName": "public void queueSecureInputBuffer (int index, int offset, MediaCodec.CryptoInfo info, long presentationTimeUs, int flags)"}, "getMetrics()": {"Returns": [["@B_android#os#PersistableBundle_E@", "a @B_android#os#PersistableBundle_E@ containing the set of attributes and values available for the media being handled by this instance of MediaCodec The attributes are descibed in @B_android#media#MediaCodec#MetricsConstants_E@. Additional vendor-specific fields may also be present in the return value."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return Metrics data about the current codec instance.", "history": "Added in API level 26", "FullName": "public PersistableBundle getMetrics ()"}, "getName()": {"Returns": [["@B_java#lang#String_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if in the Released state."]], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the codec name. If the codec was created by createDecoderByType or createEncoderByType, what component is chosen is not known beforehand. This method returns the name of the codec that was selected by the platform. @B_android#media#MediaCodec#createByCodecName_E@. This method returns the name used to create the codec in this case.", "history": "Added in API level 18", "FullName": "public String getName ()"}, "release()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Free up resources used by the codec instance. Make sure you call this when you're done to free up any opened component instance instead of relying on the garbage collector to do this for you at some point in the future.", "history": "Added in API level 16", "FullName": "public void release ()"}, "setAudioPresentation(android.media.AudioPresentation)": {"Returns": [], "Parameters": [["@B_android#media#AudioPresentation_E@", "AudioPresentation: see @B_android#media#AudioPresentation_E@. In particular, id should be set. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the audio presentation.", "history": "Added in API level 29", "FullName": "public void setAudioPresentation (AudioPresentation presentation)"}, "setInputSurface(android.view.Surface)": {"Returns": [], "Parameters": [["@B_android#view#Surface_E@", "Surface: a persistent input surface created by @B_android#media#MediaCodec#createPersistentInputSurface_E@ This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Configured state or does not require an input surface."], ["@B_java#lang#IllegalArgumentException_E@", "if the surface was not created by @B_android#media#MediaCodec#createPersistentInputSurface_E@."]], "SeeAlso": [], "Permissions": [], "Description": "Configures the codec (e.g. encoder) to use a persistent input surface in place of input buffers. This may only be called after @B_android#media#MediaCodec#configure_E@ and before @B_android#media#MediaCodec#start_E@, in lieu of @B_android#media#MediaCodec#createInputSurface_E@.", "history": "Added in API level 23", "FullName": "public void setInputSurface (Surface surface)"}, "getCanonicalName()": {"Returns": [["@B_java#lang#String_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if in the Released state."]], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the underlying codec name. This method is similar to @B_android#media#MediaCodec#getName_E@, except that it returns the underlying component name even if an alias was used to create this MediaCodec object by name,", "history": "Added in API level 29", "FullName": "public String getCanonicalName ()"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 16", "FullName": "protected void finalize ()"}, "dequeueInputBuffer(long)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["long", "long: The timeout in microseconds, a negative timeout indicates \"infinite\"."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state, or codec is configured in asynchronous mode."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the index of an input buffer to be filled with valid data or -1 if no such buffer is currently available. This method will return immediately if timeoutUs == 0, wait indefinitely for the availability of an input buffer if timeoutUs < 0 or wait up to \"timeoutUs\" microseconds if timeoutUs > 0.", "history": "Added in API level 16", "FullName": "public int dequeueInputBuffer (long timeoutUs)"}, "getInputBuffers()": {"Returns": [["@B_java#nio#ByteBuffer_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state, or codec is configured in asynchronous mode."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Use the new @B_android#media#MediaCodec#getInputBuffer_E@ method instead each time an input buffer is dequeued. @B_java#nio#Buffer#clear_E@. Do not use this method if using an input surface. Retrieve the set of input buffers. Call this after start() returns. After calling this method, any ByteBuffers previously returned by an earlier call to this method MUST no longer be used.", "history": "Added in API level 16 Deprecated in API level 21", "FullName": "public ByteBuffer[] getInputBuffers ()"}, "createPersistentInputSurface()": {"Returns": [["@B_android#view#Surface_E@", "an input surface that can be used with @B_android#media#MediaCodec#setInputSurface_E@. This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a persistent input surface that can be used with codecs that normally have an input surface, such as video encoders. A persistent input can be reused by subsequent @B_android#media#MediaCodec_E@ or @B_android#media#MediaRecorder_E@ instances, but can only be used by at most one codec or recorder instance concurrently. The application is responsible for calling release() on the Surface when done.", "history": "Added in API level 23", "FullName": "public static Surface createPersistentInputSurface ()"}, "queueInputBuffer(int,int,int,long,int)": {"Returns": [], "Parameters": [["int", "int: The index of a client-owned input buffer previously returned in a call to @B_android#media#MediaCodec#dequeueInputBuffer_E@."], ["int", "int: The byte offset into the input buffer at which the data starts."], ["int", "int: The number of bytes of valid input data."], ["long", "long: The presentation timestamp in microseconds for this buffer. This is normally the media time at which this buffer should be presented (rendered). When using an output surface, this will be propagated as the @B_android#graphics#SurfaceTexture#getTimestamp_E@ for the frame (after conversion to nanoseconds)."], ["int", "int: A bitmask of flags @B_android#media#MediaCodec#BUFFER_FLAG_CODEC_CONFIG_E@ and @B_android#media#MediaCodec#BUFFER_FLAG_END_OF_STREAM_E@. While not prohibited, most codecs do not use the @B_android#media#MediaCodec#BUFFER_FLAG_KEY_FRAME_E@ flag for input buffers."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."], ["@B_android#media#MediaCodec#CryptoException_E@", "if a crypto object has been specified in @B_android#media#MediaCodec#configure_E@"]], "SeeAlso": [], "Permissions": [], "Description": "After filling a range of the input buffer at the specified index submit it to the component. Once an input buffer is queued to the codec, it MUST NOT be used until it is later retrieved by @B_android#media#MediaCodec#getInputBuffer_E@ in response to a @B_android#media#MediaCodec#dequeueInputBuffer_E@ return value or a @B_android#media#MediaCodec#Callback#onInputBufferAvailable_E@ callback. Many decoders require the actual compressed data stream to be preceded by \"codec specific data\", i.e. setup data used to initialize the codec such as PPS/SPS in the case of AVC video or code tables in the case of vorbis audio. The class @B_android#media#MediaExtractor_E@ provides codec specific data as part of the returned track format in entries named \"csd-0\", \"csd-1\" ... These buffers can be submitted directly after @B_android#media#MediaCodec#start_E@ or @B_android#media#MediaCodec#flush_E@ by specifying the flag @B_android#media#MediaCodec#BUFFER_FLAG_CODEC_CONFIG_E@. However, if you configure the codec with a @B_android#media#MediaFormat_E@ containing these keys, they will be automatically submitted by MediaCodec directly after start. Therefore, the use of @B_android#media#MediaCodec#BUFFER_FLAG_CODEC_CONFIG_E@ flag is discouraged and is recommended only for advanced users. To indicate that this is the final piece of input data (or rather that no more input data follows unless the decoder is subsequently flushed) specify the flag @B_android#media#MediaCodec#BUFFER_FLAG_END_OF_STREAM_E@. @B_android#os#Build#VERSION_CODES#M_E@, presentationTimeUs was not propagated to the frame timestamp of (rendered) Surface output buffers, and the resulting frame timestamp was undefined. Use @B_android#media#MediaCodec#releaseOutputBuffer_E@ to ensure a specific frame timestamp is set. Similarly, since frame timestamps can be used by the destination surface for rendering synchronization,", "history": "Added in API level 16", "FullName": "public void queueInputBuffer (int index, int offset, int size, long presentationTimeUs, int flags)"}, "setParameters(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: The bundle of parameters to set. This value may be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if in the Released state."]], "SeeAlso": [], "Permissions": [], "Description": "Communicate additional parameter changes to the component instance.", "history": "Added in API level 19", "FullName": "public void setParameters (Bundle params)"}, "setCallback(android.media.MediaCodec.Callback,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaCodec#Callback_E@", "MediaCodec.Callback: The callback that will run. Use null to clear a previously set callback (before @B_android#media#MediaCodec#configure_E@ is called and run in synchronous mode). This value may be null."], ["@B_android#os#Handler_E@", "Handler: Callbacks will happen on the handler's thread. If null, callbacks are done on the default thread (the caller's thread or the main thread.) This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets an asynchronous callback for actionable MediaCodec events. If the client intends to use the component in asynchronous mode, a valid callback should be provided before @B_android#media#MediaCodec#configure_E@ is called. When asynchronous callback is enabled, the client should not call @B_android#media#MediaCodec#getInputBuffers_E@, @B_android#media#MediaCodec#getOutputBuffers_E@, @B_android#media#MediaCodec#dequeueInputBuffer_E@ or @B_android#media#MediaCodec#dequeueOutputBuffer_E@. Also, @B_android#media#MediaCodec#flush_E@ behaves differently in asynchronous mode. After calling flush, you must call @B_android#media#MediaCodec#start_E@ to \"resume\" receiving input buffers, even if an input surface was created.", "history": "Added in API level 23", "FullName": "public void setCallback (MediaCodec.Callback cb, Handler handler)"}, "getInputBuffer(int)": {"Returns": [["@B_java#nio#ByteBuffer_E@", "the input buffer, or null if the index is not a dequeued input buffer, or if the codec is configured for surface input."]], "Parameters": [["int", "int: The index of a client-owned input buffer previously returned from a call to @B_android#media#MediaCodec#dequeueInputBuffer_E@, or received via an onInputBufferAvailable callback."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a @B_java#nio#Buffer#clear_E@, writable ByteBuffer object for a dequeued input buffer index to contain the input data. After calling this method any ByteBuffer or Image object previously returned for the same input index MUST no longer be used.", "history": "Added in API level 21", "FullName": "public ByteBuffer getInputBuffer (int index)"}, "getOutputBuffers()": {"Returns": [["@B_java#nio#ByteBuffer_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state, or codec is configured in asynchronous mode."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Use the new @B_android#media#MediaCodec#getOutputBuffer_E@ method instead each time an output buffer is dequeued. This method is not supported if codec is configured in asynchronous mode. Do not use this method if using an output surface. Retrieve the set of output buffers. Call this after start() returns and whenever dequeueOutputBuffer signals an output buffer change by returning @B_android#media#MediaCodec#INFO_OUTPUT_BUFFERS_CHANGED_E@. After calling this method, any ByteBuffers previously returned by an earlier call to this method MUST no longer be used.", "history": "Added in API level 16 Deprecated in API level 21", "FullName": "public ByteBuffer[] getOutputBuffers ()"}, "reset()": {"Returns": [], "Parameters": [], "Throws": [["@B_android#media#MediaCodec#CodecException_E@", "if an unrecoverable error has occured and the codec could not be reset."], ["@B_java#lang#IllegalStateException_E@", "if in the Released state."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the codec to its initial (Uninitialized) state. Call this if an @B_android#media#MediaCodec#CodecException#isRecoverable_E@ error has occured to reset the codec to its initial state after creation.", "history": "Added in API level 21", "FullName": "public void reset ()"}, "getCodecInfo()": {"Returns": [["@B_android#media#MediaCodecInfo_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if in the Released state."]], "SeeAlso": [], "Permissions": [], "Description": "Get the codec info. If the codec was created by createDecoderByType or createEncoderByType, what component is chosen is not known beforehand, and thus the caller does not have the MediaCodecInfo.", "history": "Added in API level 18", "FullName": "public MediaCodecInfo getCodecInfo ()"}, "setCallback(android.media.MediaCodec.Callback)": {"Returns": [], "Parameters": [["@B_android#media#MediaCodec#Callback_E@", "MediaCodec.Callback: The callback that will run. Use null to clear a previously set callback (before @B_android#media#MediaCodec#configure_E@ is called and run in synchronous mode). This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#media#MediaCodec#setCallback_E@"], "Permissions": [], "Description": "Sets an asynchronous callback for actionable MediaCodec events on the default looper. Same as @B_android#media#MediaCodec#setCallback_E@ with handler set to null.", "history": "Added in API level 21", "FullName": "public void setCallback (MediaCodec.Callback cb)"}, "getInputImage(int)": {"Returns": [["@B_android#media#Image_E@", "the input image, or null if the index is not a dequeued input buffer, or not a ByteBuffer that contains a raw image."]], "Parameters": [["int", "int: The index of a client-owned input buffer previously returned from a call to @B_android#media#MediaCodec#dequeueInputBuffer_E@, or received via an onInputBufferAvailable callback."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a writable Image object for a dequeued input buffer index to contain the raw input video frame. After calling this method any ByteBuffer or Image object previously returned for the same input index MUST no longer be used.", "history": "Added in API level 21", "FullName": "public Image getInputImage (int index)"}, "releaseOutputBuffer(int, boolean)": {"Returns": [], "Parameters": [["int", "int: The index of a client-owned output buffer previously returned from a call to @B_android#media#MediaCodec#dequeueOutputBuffer_E@."], ["boolean", "boolean: If a valid surface was specified when configuring the codec, passing true renders this output buffer to the surface."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "If you are done with a buffer, use this call to return the buffer to the codec or to render it on the output surface. If you configured the codec with an output surface, setting render to true will first send the buffer to that output surface. The surface will release the buffer back to the codec once it is no longer used/displayed. Once an output buffer is released to the codec, it MUST NOT be used until it is later retrieved by @B_android#media#MediaCodec#getOutputBuffer_E@ in response to a @B_android#media#MediaCodec#dequeueOutputBuffer_E@ return value or a @B_android#media#MediaCodec#Callback#onOutputBufferAvailable_E@ callback.", "history": "added in API level 16", "FullName": "public void releaseOutputBuffer (int index, boolean render)"}, "getOutputFormat()": {"Returns": [["@B_android#media#MediaFormat_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing or Configured state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Call this after dequeueOutputBuffer signals a format change by returning @B_android#media#MediaCodec#INFO_OUTPUT_FORMAT_CHANGED_E@. You can also call this after @B_android#media#MediaCodec#configure_E@ returns successfully to get the output format initially configured for the codec. Do this to determine what optional configuration parameters were supported by the codec.", "history": "Added in API level 16", "FullName": "public MediaFormat getOutputFormat ()"}, "releaseOutputBuffer(int,long)": {"Returns": [], "Parameters": [["int", "int: The index of a client-owned output buffer previously returned from a call to @B_android#media#MediaCodec#dequeueOutputBuffer_E@."], ["long", "long: The timestamp to associate with this buffer when it is sent to the Surface."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "If you are done with a buffer, use this call to update its surface timestamp and return it to the codec to render it on the output surface. If you have not specified an output surface when configuring this video codec, this call will simply return the buffer to the codec. The timestamp may have special meaning depending on the destination surface. @B_android#media#MediaCodec#getOutputBuffer_E@ in response to a @B_android#media#MediaCodec#dequeueOutputBuffer_E@ return value or a @B_android#media#MediaCodec#Callback#onOutputBufferAvailable_E@ callback.", "history": "Added in API level 21", "FullName": "public void releaseOutputBuffer (int index, long renderTimestampNs)"}, "createInputSurface()": {"Returns": [["@B_android#view#Surface_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Configured state."]], "SeeAlso": [], "Permissions": [], "Description": "Requests a Surface to use as the input to an encoder, in place of input buffers. This may only be called after @B_android#media#MediaCodec#configure_E@ and before @B_android#media#MediaCodec#start_E@. The application is responsible for calling release() on the Surface when done. The Surface must be rendered with a hardware-accelerated API, such as OpenGL ES. @B_android#view#Surface#lockCanvas_E@ may fail or produce unexpected results.", "history": "Added in API level 18", "FullName": "public Surface createInputSurface ()"}, "dequeueOutputBuffer(android.media.MediaCodec.BufferInfo,long)": {"Returns": [["int", "Value is @B_android#media#MediaCodec#INFO_TRY_AGAIN_LATER_E@, @B_android#media#MediaCodec#INFO_OUTPUT_FORMAT_CHANGED_E@, or @B_android#media#MediaCodec#INFO_OUTPUT_BUFFERS_CHANGED_E@"]], "Parameters": [["@B_android#media#MediaCodec#BufferInfo_E@", "MediaCodec.BufferInfo: Will be filled with buffer meta data. This value must never be null."], ["long", "long: The timeout in microseconds, a negative timeout indicates \"infinite\"."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not in the Executing state, or codec is configured in asynchronous mode."], ["@B_android#media#MediaCodec#CodecException_E@", "upon codec error."]], "SeeAlso": [], "Permissions": [], "Description": "Dequeue an output buffer, block at most \"timeoutUs\" microseconds. Returns the index of an output buffer that has been successfully decoded or one of the INFO_* constants.", "history": "Added in API level 16", "FullName": "public int dequeueOutputBuffer (MediaCodec.BufferInfo info, long timeoutUs)"}}, "Inheritance": [], "ClassName": "android.media.MediaCodec", "ClassDesc": "MediaCodec class can be used to access low-level media codecs, i.e. encoder/decoder components. It is part of the Android low-level multimedia support infrastructure (normally used together with @B_android#media#MediaExtractor_E@, @B_android#media#MediaSync_E@, @B_android#media#MediaMuxer_E@, @B_android#media#MediaCrypto_E@, @B_android#media#MediaDrm_E@, @B_android#media#Image_E@, @B_android#view#Surface_E@, and @B_android#media#AudioTrack_E@.) In broad terms, a codec processes input data to generate output data. It processes data asynchronously and uses a set of input and output buffers. At a simplistic level, you request (or receive) an empty input buffer, fill it up with data and send it to the codec for processing. The codec uses up the data and transforms it into one of its empty output buffers. Finally, you request (or receive) a filled output buffer, consume its contents and release it back to the codec. Codecs operate on three kinds of data: compressed data, raw audio data and raw video data. All three kinds of data can be processed using @B_java#nio#ByteBuffer_E@, but you should use a @B_android#view#Surface_E@ for raw video data to improve codec performance. Surface uses native video buffers without mapping or copying them to ByteBuffers; thus, it is much more efficient. You normally cannot access the raw video data when using a Surface, but you can use the @B_android#media#ImageReader_E@ class to access unsecured decoded (raw) video frames. This may still be more efficient than using ByteBuffers, as some native buffers may be mapped into @B_android#media#Image_E@ class and @B_android#media#MediaCodec#getInputImage_E@/@B_android#media#MediaCodec#getOutputImage_E@. Input buffers (for decoders) and output buffers (for encoders) contain compressed data according to the @B_android#media#MediaCodec#BUFFER_FLAG_PARTIAL_FRAME_E@. Raw audio buffers contain entire frames of PCM audio data, which is one sample for each channel in channel order. Each PCM audio sample is either a 16 bit signed integer or a float, in native byte order. Raw audio buffers in the float PCM encoding are only possible if the MediaFormat's @B_android#media#MediaCodec#configure_E@ and confirmed by @B_android#media#MediaCodec#getOutputFormat_E@ for decoders or @B_android#media#MediaCodec#getInputFormat_E@ for encoders. A sample method to check for float PCM in the MediaFormat is as follows: In ByteBuffer mode video buffers are laid out according to their @B_android#media#MediaCodec#getCodecInfo_E@.@B_android#media#MediaCodecInfo#getCapabilitiesForType_E@.@B_android#media#MediaCodecInfo#CodecCapabilities#colorFormats_E@. Video codecs may support three kinds of color formats: @B_android#media#MediaCodecInfo#CodecCapabilities#COLOR_FormatSurface_E@ and it can be used with an input or output Surface. @B_android#media#MediaCodecInfo#CodecCapabilities#COLOR_FormatYUV420Flexible_E@): These can be used with an input/output Surface, as well as in ByteBuffer mode, by using @B_android#media#MediaCodec#getInputImage_E@/@B_android#media#MediaCodec#getOutputImage_E@. @B_android#media#MediaCodecInfo#CodecCapabilities_E@. For color formats that are equivalent to a flexible format, you can still use @B_android#media#MediaCodec#getInputImage_E@/@B_android#media#MediaCodec#getOutputImage_E@. All video codecs support flexible YUV 4:2:0 buffers since @B_android#os#Build#VERSION_CODES#LOLLIPOP_MR1_E@. Prior to @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@ and @B_android#media#Image_E@ support, you need to use the @B_android#media#MediaFormat#KEY_STRIDE_E@ and @B_android#media#MediaFormat#KEY_SLICE_HEIGHT_E@ output format values to understand the layout of the raw output buffers. Note that on some devices the slice-height is advertised as 0. This could mean either that the slice-height is the same as the frame height, or that the slice-height is the frame height aligned to some value (usually a power of 2). Unfortunately, there is no standard and simple way to tell the actual slice height in this case. Furthermore, the vertical stride of the U plane in planar formats is also not specified or defined, though usually it is half of the slice height. The @B_android#media#MediaFormat#KEY_WIDTH_E@ and @B_android#media#MediaFormat#KEY_HEIGHT_E@ keys specify the size of the video frames; however, for most encondings the video (picture) only occupies a portion of the video frame. This is represented by the 'crop rectangle'. You need to use the following keys to get the crop rectangle of raw output images from the before applying any The size of the video frame (before rotation) can be calculated as such: Also note that the meaning of @B_android#media#MediaCodec#BufferInfo#offset_E@ was not consistent across devices. On some devices the offset pointed to the top-left pixel of the crop rectangle, while on most devices it pointed to the top-left pixel of the entire frame. During its life a codec conceptually exists in one of three states: Stopped, Executing or Released. The Stopped collective state is actually the conglomeration of three states: Uninitialized, Configured and Error, whereas the Executing state conceptually progresses through three sub-states: Flushed, Running and End-of-Stream. When you create a codec using one of the factory methods, the codec is in the Uninitialized state. First, you need to configure it via @B_android#media#MediaCodec#configure_E@, which brings it to the Configured state, then call @B_android#media#MediaCodec#start_E@ to move it to the Executing state. In this state you can process data through the buffer queue manipulation described above. The Executing state has three sub-states: Flushed, Running and End-of-Stream. Immediately after @B_android#media#MediaCodec#start_E@ the codec is in the Flushed sub-state, where it holds all the buffers. As soon as the first input buffer is dequeued, the codec moves to the Running sub-state, where it spends most of its life. When you queue an input buffer with the @B_android#media#MediaCodec#flush_E@. Call @B_android#media#MediaCodec#stop_E@ to return the codec to the Uninitialized state, whereupon it may be configured again. When you are done using a codec, you must release it by calling @B_android#media#MediaCodec#release_E@. On rare occasions the codec may encounter an error and move to the Error state. This is communicated using an invalid return value from a queuing operation, or sometimes via an exception. Call @B_android#media#MediaCodec#reset_E@ to make the codec usable again. You can call it from any state to move the codec back to the Uninitialized state. Otherwise, call @B_android#media#MediaCodec#release_E@ to move to the terminal Released state. Use @B_android#media#MediaCodecList_E@ to create a MediaCodec for a specific @B_android#media#MediaFormat_E@. When decoding a file or a stream, you can get the desired format from @B_android#media#MediaExtractor#getTrackFormat_E@. Inject any specific features that you want to add using @B_android#media#MediaFormat#setFeatureEnabled_E@, then call @B_android#media#MediaCodecList#findDecoderForFormat_E@ to get the name of a codec that can handle that specific media format. Finally, create the codec using @B_android#media#MediaCodec#createByCodecName_E@. @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@, the format to MediaCodecList.findDecoder/EncoderForFormat must not contain a format.setString(MediaFormat.KEY_FRAME_RATE, null) to clear any existing frame rate setting in the format. You can also create the preferred codec for a specific MIME type using @B_android#media#MediaCodec#createDecoderByType_E@/@B_android#media#MediaCodec#createEncoderByType_E@. This, however, cannot be used to inject features, and may create a codec that cannot handle the specific desired media format. On versions @B_android#os#Build#VERSION_CODES#KITKAT_WATCH_E@ and earlier, secure codecs might not be listed in @B_android#media#MediaCodecList_E@, but may still be available on the system. Secure codecs that exist can be instantiated by name only, by appending \".secure\" to the name of a regular codec (the name of all secure codecs must end in \".secure\".) @B_android#media#MediaCodec#createByCodecName_E@ will throw an IOException if the codec is not present on the system. From @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@ onwards, you should use the @B_android#media#MediaCodecInfo#CodecCapabilities#FEATURE_SecurePlayback_E@ feature in the media format to create a secure decoder. After creating the codec, you can set a callback using @B_android#media#MediaCodec#setCallback_E@ if you want to process data asynchronously. Then, @B_android#view#Surface_E@ for video producers \u2013 codecs that generate raw video data (e.g. video decoders). This is also when you can set the decryption parameters for secure codecs (see @B_android#media#MediaCrypto_E@). Finally, since some codecs can operate in multiple modes, you must specify whether you want it to work as a decoder or an encoder. Since @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@, you can query the resulting input and output format in the Configured state. You can use this to verify the resulting configuration, e.g. color formats, before starting the codec. If you want to process raw input video buffers natively with a video consumer \u2013 a codec that processes raw video input, such as a video encoder \u2013 create a destination Surface for your input data using @B_android#media#MediaCodec#createInputSurface_E@ after configuration. Alternately, set up the codec to use a previously created @B_android#media#MediaCodec#setInputSurface_E@. Some formats, notably AAC audio and MPEG4, H.264 and H.265 video formats require the actual data to be prefixed by a number of buffers containing setup data, or codec specific data. When processing such compressed formats, this data must be submitted to the codec after @B_android#media#MediaCodec#start_E@ and before any frame data. Such data must be marked using the flag @B_android#media#MediaCodec#BUFFER_FLAG_CODEC_CONFIG_E@ in a call to @B_android#media#MediaCodec#queueInputBuffer_E@. Codec-specific data can also be included in the format passed to @B_android#media#MediaCodec#configure_E@ in ByteBuffer entries with keys \"csd-0\", \"csd-1\", etc. These keys are always included in the track @B_android#media#MediaFormat_E@ obtained from the @B_android#media#MediaExtractor#getTrackFormat_E@. Codec-specific data in the format is automatically submitted to the codec upon @B_android#media#MediaCodec#start_E@; you Android uses the following codec-specific data buffers. These are also required to be set in the track format for proper @B_android#media#MediaMuxer_E@ track configuration. Each parameter set and the codec-specific-data sections marked with (\"\\x00\\x00\\x00\\x01\". @B_android#media#MediaCodec#BUFFER_FLAG_CODEC_CONFIG_E@ after such flush to ensure proper codec operation. Encoders (or codecs that generate compressed data) will create and return the codec specific data before any valid output buffer in output buffers marked with the Each codec maintains a set of input and output buffers that are referred to by a buffer-ID in API calls. After a successful call to @B_android#media#MediaCodec#start_E@ the client \"owns\" neither input nor output buffers. In synchronous mode, call @B_android#media#MediaCodec#dequeueInputBuffer_E@/@B_android#media#MediaCodec#dequeueOutputBuffer_E@ to obtain (get ownership of) an input or output buffer from the codec. In asynchronous mode, you will automatically receive available buffers via the @B_android#media#MediaCodec#Callback#onInputBufferAvailable_E@/@B_android#media#MediaCodec#Callback#onOutputBufferAvailable_E@ callbacks. Upon obtaining an input buffer, fill it with data and submit it to the codec using @B_android#media#MediaCodec#queueInputBuffer_E@ \u2013 or @B_android#media#MediaCodec#queueSecureInputBuffer_E@ if using decryption. Do not submit multiple input buffers with the same timestamp (unless it is The codec in turn will return a read-only output buffer via the @B_android#media#MediaCodec#Callback#onOutputBufferAvailable_E@ callback in asynchronous mode, or in response to a @B_android#media#MediaCodec#dequeueOutputBuffer_E@ call in synchronous mode. After the output buffer has been processed, call one of the @B_android#media#MediaCodec#releaseOutputBuffer_E@ methods to return the buffer to the codec. While you are not required to resubmit/release buffers immediately to the codec, holding onto input and/or output buffers may stall the codec, and this behavior is device dependent. Depending on the API version, you can process data in three ways: Since @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@, the preferred method is to process data asynchronously by setting a callback before calling @B_android#media#MediaCodec#configure_E@. Asynchronous mode changes the state transitions slightly, because you must call @B_android#media#MediaCodec#start_E@ after @B_android#media#MediaCodec#flush_E@ to transition the codec to the Running sub-state and start receiving input buffers. Similarly, upon an initial call to start the codec will move directly to the Running sub-state and start passing available input buffers via the callback. MediaCodec is typically used like this in asynchronous mode: Since @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@, you should retrieve input and output buffers using @B_android#media#MediaCodec#getInputBuffer_E@/@B_android#media#MediaCodec#getOutputBuffer_E@ and/or @B_android#media#MediaCodec#getInputImage_E@/@B_android#media#MediaCodec#getOutputImage_E@ even when using the codec in synchronous mode. This allows certain optimizations by the framework, e.g. when processing dynamic content. This optimization is disabled if you call @B_android#media#MediaCodec#getInputBuffers_E@/@B_android#media#MediaCodec#getOutputBuffers_E@. getInput/OutputBuffers directly after @B_android#media#MediaCodec#start_E@ or after having dequeued an output buffer ID with the value of @B_android#media#MediaCodec#INFO_OUTPUT_FORMAT_CHANGED_E@. MediaCodec is typically used like this in synchronous mode: In versions @B_android#os#Build#VERSION_CODES#KITKAT_WATCH_E@ and before, the set of input and output buffers are represented by the ByteBuffer[] arrays. After a successful call to @B_android#media#MediaCodec#start_E@, retrieve the buffer arrays using @B_android#media#MediaCodec#getInputBuffers_E@/@B_android#media#MediaCodec#getOutputBuffers_E@. Use the buffer ID-s as indices into these arrays (when non-negative), as demonstrated in the sample below. Note that there is no inherent correlation between the size of the arrays and the number of input and output buffers used by the system, although the array size provides an upper bound. When you reach the end of the input data, you must signal it to the codec by specifying the @B_android#media#MediaCodec#BUFFER_FLAG_END_OF_STREAM_E@ flag in the call to @B_android#media#MediaCodec#queueInputBuffer_E@. You can do this on the last valid input buffer, or by submitting an additional empty input buffer with the end-of-stream flag set. If using an empty buffer, the timestamp will be ignored. The codec will continue to return output buffers until it eventually signals the end of the output stream by specifying the same end-of-stream flag in the @B_android#media#MediaCodec#BufferInfo_E@ set in @B_android#media#MediaCodec#dequeueOutputBuffer_E@ or returned via @B_android#media#MediaCodec#Callback#onOutputBufferAvailable_E@. This can be set on the last valid output buffer, or on an empty buffer after the last valid output buffer. The timestamp of such empty buffer should be ignored. Do not submit additional input buffers after signaling the end of the input stream, unless the codec has been flushed, or stopped and restarted. The data processing is nearly identical to the ByteBuffer mode when using an output @B_android#view#Surface_E@; however, the output buffers will not be accessible, and are represented as null values. E.g. @B_android#media#MediaCodec#getOutputBuffer_E@/@B_android#media#MediaCodec#getOutputImage_E@ will return null and @B_android#media#MediaCodec#getOutputBuffers_E@ will return an array containing only null-s. When using an output Surface, you can select whether or not to render each output buffer on the surface. You have three choices: @B_android#media#MediaCodec#releaseOutputBuffer_E@. @B_android#media#MediaCodec#releaseOutputBuffer_E@. @B_android#media#MediaCodec#releaseOutputBuffer_E@. Since @B_android#os#Build#VERSION_CODES#M_E@, the default timestamp is the Also since @B_android#os#Build#VERSION_CODES#M_E@, you can change the output Surface dynamically using @B_android#media#MediaCodec#setOutputSurface_E@. When rendering output to a Surface, the Surface may be configured to drop excessive frames (that are not consumed by the Surface in a timely manner). Or it may be configured to not drop excessive frames. In the latter mode if the Surface is not consuming output frames fast enough, it will eventually block the decoder. Prior to @B_android#os#Build#VERSION_CODES#Q_E@ the exact behavior was undefined, with the exception that View surfaces (SuerfaceView or TextureView) always dropped excessive frames. Since @B_android#os#Build#VERSION_CODES#Q_E@ the default behavior is to drop excessive frames. Applications can opt out of this behavior for non-View surfaces (such as ImageReader or SurfaceTexture) by targeting SDK @B_android#os#Build#VERSION_CODES#Q_E@ and setting the key \"allow-frame-drop\" to 0 in their configure format. Prior to the @B_android#os#Build#VERSION_CODES#M_E@ release, software decoders may not have applied the rotation when being rendered onto a Surface. Unfortunately, there is no standard and simple way to identify software decoders, or if they apply the rotation other than by trying it out. There are also some caveats. Note that the pixel aspect ratio is not considered when displaying the output onto the Surface. This means that if you are using @B_android#media#MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT_E@ mode, you must position the output Surface so that it has the proper final display aspect ratio. Conversely, you can only use @B_android#media#MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING_E@ mode for content with square pixels (pixel aspect ratio or 1:1). Note also that as of @B_android#os#Build#VERSION_CODES#N_E@ release, @B_android#media#MediaCodec#VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING_E@ mode may not work correctly for videos rotated by 90 or 270 degrees. When setting the video scaling mode, note that it must be reset after each time the output buffers change. Since the @B_android#media#MediaCodec#INFO_OUTPUT_BUFFERS_CHANGED_E@ event is deprecated, you can do this after each time the output format changes. When using an input Surface, there are no accessible input buffers, as buffers are automatically passed from the input surface to the codec. Calling @B_android#media#MediaCodec#dequeueInputBuffer_E@ will throw an IllegalStateException, and @B_android#media#MediaCodec#getInputBuffers_E@ returns a bogus ByteBuffer[] array that Call @B_android#media#MediaCodec#signalEndOfInputStream_E@ to signal end-of-stream. The input surface will stop submitting data to the codec immediately after this call. Video decoders (and in general codecs that consume compressed video data) behave differently regarding seek and format change whether or not they support and are configured for adaptive playback. You can check if a decoder supports @B_android#media#MediaCodecInfo#CodecCapabilities#isFeatureSupported_E@. Adaptive playback support for video decoders is only activated if you configure the codec to decode onto a @B_android#view#Surface_E@. It is important that the input data after @B_android#media#MediaCodec#start_E@ or @B_android#media#MediaCodec#flush_E@ starts at a suitable stream boundary: the first frame must a key frame. A key frame can be decoded completely on its own (for most codecs this means an I-frame), and no frames that are to be displayed after a key frame refer to frames before the key frame. The following table summarizes suitable key frames for various video formats. In order to start decoding data that is not adjacent to previously submitted data (i.e. after a seek) you flush. It is important that the input data after a flush starts at a suitable stream boundary/key frame. @B_android#media#MediaCodec#flush_E@ does not support format discontinuities; for that, a full @B_android#media#MediaCodec#stop_E@ - @B_android#media#MediaCodec#configure_E@ - @B_android#media#MediaCodec#start_E@ cycle is necessary. @B_android#media#MediaCodec#start_E@ \u2013 generally, before the first output buffer or output format change is received \u2013 you will need to resubmit the codec-specific-data to the codec. See the In order to start decoding data that is not adjacent to previously submitted data (i.e. after a seek) it is not necessary to flush the decoder; however, input data after the discontinuity must start at a suitable stream boundary/key frame. For some video formats - namely H.264, H.265, VP8 and VP9 - it is also possible to change the picture size or configuration mid-stream. To do this you must package the entire new codec-specific configuration data together with the key frame into a single buffer (including any start codes), and submit it as a You will receive an @B_android#media#MediaCodec#INFO_OUTPUT_FORMAT_CHANGED_E@ return value from @B_android#media#MediaCodec#dequeueOutputBuffer_E@ or a @B_android#media#MediaCodec#Callback#onOutputBufferAvailable_E@ callback just after the picture-size change takes place and before any frames with the new size have been returned. @B_android#media#MediaCodec#flush_E@ shortly after you have changed the picture size. If you have not received confirmation of the picture size change, you will need to repeat the request for the new picture size. The factory methods @B_android#media#MediaCodec#createByCodecName_E@ and @B_android#media#MediaCodec#createDecoderByType_E@/@B_android#media#MediaCodec#createEncoderByType_E@ throw IOException on failure which you must catch or declare to pass up. MediaCodec methods throw IllegalStateException when the method is called from a codec state that does not allow it; this is typically due to incorrect application API usage. Methods involving secure buffers may throw @B_android#media#MediaCodec#CryptoException_E@, which has further error information obtainable from @B_android#media#MediaCodec#CryptoException#getErrorCode_E@. Internal codec errors result in a @B_android#media#MediaCodec#CodecException_E@, which may be due to media content corruption, hardware failure, resource exhaustion, and so forth, even when the application is correctly using the API. The recommended action when receiving a CodecException can be determined by calling @B_android#media#MediaCodec#CodecException#isRecoverable_E@ and @B_android#media#MediaCodec#CodecException#isTransient_E@: isRecoverable() returns true, then call @B_android#media#MediaCodec#stop_E@, @B_android#media#MediaCodec#configure_E@, and @B_android#media#MediaCodec#start_E@ to recover. isTransient() returns true, then resources are temporarily unavailable and the method may be retried at a later time. isRecoverable() and isTransient() return false, then the CodecException is fatal and the codec must be Both isRecoverable() and isTransient() do not return true at the same time. This sections summarizes the valid API calls in each state and the API history of the MediaCodec class. For API version numbers, see @B_android#os#Build#VERSION_CODES_E@."}