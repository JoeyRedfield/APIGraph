{"Functions": {"ViewGroup(android.content.Context,android.util.AttributeSet,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["@B_android#util#AttributeSet_E@", "AttributeSet no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public ViewGroup (Context context, AttributeSet attrs, int defStyleAttr)"}, "requestDisallowInterceptTouchEvent(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the child does not want the parent to intercept touch events."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child does not want this parent and its ancestors to intercept touch events with @B_android#view#ViewGroup#onInterceptTouchEvent_E@. This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel.", "history": "Added in API level 1", "FullName": "public void requestDisallowInterceptTouchEvent (boolean disallowIntercept)"}, "setAddStatesFromChildren(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets whether this ViewGroup's drawable states also include its children's drawable states. This is used, for example, to make a group appear to be focused when its child EditText or button is focused.", "history": "Added in API level 1", "FullName": "public void setAddStatesFromChildren (boolean addsStates)"}, "dispatchProvideAutofillStructure(android.view.ViewStructure,int)": {"Returns": [], "Parameters": [["@B_android#view#ViewStructure_E@", "ViewStructure: fill in with structured view data for autofill purposes. This value must never be null."], ["int", "int: Value is either 0 or @B_android#view#View#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatches creation of a @B_android#view#ViewStructure_E@s for autofill purposes down the hierarchy, when an Assist structure is being created as part of an autofill request. The default implementation does the following: Sets the @B_android#view#autofill#AutofillId_E@ in the structure. Calls @B_android#view#View#onProvideAutofillStructure_E@. Calls @B_android#view#View#onProvideAutofillVirtualStructure_E@. Typically, this method should only be overridden by subclasses that provide a view hierarchy (such as @B_android#view#ViewGroup_E@) - other classes should override @B_android#view#View#onProvideAutofillStructure_E@ or @B_android#view#View#onProvideAutofillVirtualStructure_E@ instead. When overridden, it must: Either call super.dispatchProvideAutofillStructure(structure, flags) or explicitly set the @B_android#view#autofill#AutofillId_E@ in the structure (for example, by calling structure.setAutofillId(getAutofillId())). Decide how to handle the @B_android#view#View#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS_E@ flag - when set, all views in the structure should be considered important for autofill, regardless of what @B_android#view#View#isImportantForAutofill_E@ returns. We encourage you to respect this flag to provide a better user experience - this flag is typically used when an user explicitly requested autofill. If the flag is not set, then only views marked as important for autofill should be included in the structure - skipping non-important views optimizes the overall autofill performance. This implementation adds in all child views of the view group, in addition to calling the default @B_android#view#View_E@ implementation.", "history": "Added in API level 26", "FullName": "public void dispatchProvideAutofillStructure (ViewStructure structure, int flags)"}, "dispatchWindowVisibilityChanged(int)": {"Returns": [], "Parameters": [["int", "int: The new visibility of the window. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a window visibility change down the view hierarchy. ViewGroups should override to route to their children.", "history": "Added in API level 1", "FullName": "public void dispatchWindowVisibilityChanged (int visibility)"}, "measureChild(android.view.View, int, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child to measure"], ["int", "int: The width requirements for this view"], ["int", "int: The height requirements for this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding. The heavy lifting is done in getChildMeasureSpec.", "history": "added in API level 1", "FullName": "protected void measureChild (View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)"}, "dispatchHoverEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a hover event. Do not call this method directly. Call @B_android#view#View#dispatchGenericMotionEvent_E@ instead.", "history": "Added in API level 14", "FullName": "protected boolean dispatchHoverEvent (MotionEvent event)"}, "gatherTransparentRegion(android.graphics.Region)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#graphics#Region_E@", "Region no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public boolean gatherTransparentRegion (Region region)"}, "layout(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Assign a size and position to a view and all of its descendants This is the second phase of the layout mechanism. (The first is measuring). In this phase, each parent calls layout on all of its children to position them. This is typically done using the child measurements that were stored in the measure pass(). Derived classes should not override this method. Derived classes with children should override onLayout. In that method, they should call layout on each of their children.", "history": "added in API level 1", "FullName": "public final void layout (int l, int t, int r, int b)"}, "drawableHotspotChanged(float, float)": {"Returns": [], "Parameters": [["float", "hotspot x coordinate"], ["float", "hotspot y coordinate"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function is called whenever the view hotspot changes and needs to be propagated to drawables managed by the view. Be sure to call through to the superclass when overriding this function.", "history": "Added in API level 21", "FullName": "public void drawableHotspotChanged (float x, float y)"}, "attachViewToParent(android.view.View,int,android.view.ViewGroup.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child to attach"], ["int", "int: the index at which the child should be attached"], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: the layout parameters of the child"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#removeDetachedView_E@", "@B_android#view#ViewGroup#detachAllViewsFromParent_E@", "@B_android#view#ViewGroup#detachViewFromParent_E@"], "Permissions": [], "Description": "Attaches a view to this view group. Attaching a view assigns this group as the parent, sets the layout parameters and puts the view in the list of children so that it can be retrieved by calling @B_android#view#ViewGroup#getChildAt_E@. This method is intended to be lightweight and makes no assumptions about whether the parent or child should be redrawn. Proper use of this method will include also making any appropriate @B_android#view#View#requestLayout_E@ or @B_android#view#View#invalidate_E@ calls. For example, callers can @B_android#view#View#post_E@ a @B_java#lang#Runnable_E@ which performs a @B_android#view#View#requestLayout_E@ on the next frame, after all detach/attach calls are finished, causing layout to be run prior to redrawing the view hierarchy. This method should be called only for views which were detached from their parent.", "history": "Added in API level 1", "FullName": "protected void attachViewToParent (View child, int index, ViewGroup.LayoutParams params)"}, "onNestedPrePerformAccessibilityAction(android.view.View,int,android.os.Bundle)": {"Returns": [["boolean", "false by default. Subclasses should return true if they handle the event."]], "Parameters": [["@B_android#view#View_E@", "View: The target view dispatching this action"], ["int", "int: Action being performed; see @B_android#view#accessibility#AccessibilityNodeInfo_E@"], ["@B_android#os#Bundle_E@", "Bundle: Optional action arguments"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to an accessibility action delegated by a target descendant view before the target processes it. This method may be called by a target descendant view if the target wishes to give a view in its parent chain a chance to react to the event before normal processing occurs. Most commonly this will be a scroll event such as @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_SCROLL_FORWARD_E@. A ViewParent that supports acting as a nested scrolling parent should override this method and act accordingly to implement scrolling via accesibility systems. Subclasses should always call super.onNestedPrePerformAccessibilityAction", "history": "Added in API level 22", "FullName": "public boolean onNestedPrePerformAccessibilityAction (View target, int action, Bundle args)"}, "dispatchConfigurationChanged(android.content.res.Configuration)": {"Returns": [], "Parameters": [["@B_android#content#res#Configuration_E@", "Configuration: The new resource configuration."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a notification about a resource configuration change down the view hierarchy. ViewGroups should override to route to their children.", "history": "Added in API level 8", "FullName": "public void dispatchConfigurationChanged (Configuration newConfig)"}, "setLayoutTransition(android.animation.LayoutTransition)": {"Returns": [], "Parameters": [["@B_android#animation#LayoutTransition_E@", "LayoutTransition: The LayoutTransition object that will animated changes in layout. A value of null means no transition will run on layout changes."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the LayoutTransition object for this ViewGroup. If the LayoutTransition object is not null, changes in layout which occur because of children being added to or removed from the ViewGroup will be animated according to the animations defined in that LayoutTransition object. By default, the transition object is null (so layout changes are not animated). Replacing a non-null transition will cause that previous transition to be canceled, if it is currently running, to restore this container to its correct post-transition state.", "history": "Added in API level 11", "FullName": "public void setLayoutTransition (LayoutTransition transition)"}, "getChildDrawingOrder(int, int)": {"Returns": [["int", "The index of the child to draw this iteration."]], "Parameters": [["int", "int no parameter comment"], ["int", "int: The current iteration."]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@", "@B_android#view#ViewGroup#isChildrenDrawingOrderEnabled_E@"], "Permissions": [], "Description": "Returns the index of the child to draw for this iteration. Override this if you want to change the drawing order of children. By default, it returns i. NOTE: In order for this method to be called, you must enable child ordering first by calling @B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@.", "history": "added in API level 1", "FullName": "protected int getChildDrawingOrder (int childCount, int i)"}, "dispatchTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Pass the touch screen motion event down to the target view, or this view if it is the target.", "history": "Added in API level 1", "FullName": "public boolean dispatchTouchEvent (MotionEvent ev)"}, "dispatchDraw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: the canvas on which to draw the view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by draw to draw the child views. This may be overridden by derived classes to gain control just before its children are drawn (but after its own view has been drawn).", "history": "Added in API level 1", "FullName": "protected void dispatchDraw (Canvas canvas)"}, "setLayoutAnimation(android.view.animation.LayoutAnimationController)": {"Returns": [], "Parameters": [["@B_android#view#animation#LayoutAnimationController_E@", "LayoutAnimationController: the animation controller"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the layout animation controller used to animate the group's children after the first layout.", "history": "Added in API level 1", "FullName": "public void setLayoutAnimation (LayoutAnimationController controller)"}, "onRequestFocusInDescendants(int,android.graphics.Rect)": {"Returns": [["boolean", "Whether focus was taken."]], "Parameters": [["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT"], ["@B_android#graphics#Rect_E@", "Rect: The rectangle (in this View's coordinate system) to give a finer grained hint about where focus is coming from. May be null if there is no hint."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Look for a descendant to call @B_android#view#View#requestFocus_E@ on. Called by @B_android#view#ViewGroup#requestFocus_E@ when it wants to request focus within its children. Override this to customize how your @B_android#view#ViewGroup_E@ requests focus within its children.", "history": "Added in API level 1", "FullName": "protected boolean onRequestFocusInDescendants (int direction, Rect previouslyFocusedRect)"}, "invalidateChild(android.view.View,android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child which is dirty"], ["@B_android#graphics#Rect_E@", "Rect: The area within the child that is invalid"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#view#ViewGroup#onDescendantInvalidated_E@ instead to observe updates to draw state in descendants. Don't call or override this method. It is used for the implementation of the view hierarchy.", "history": "Added in API level 1", "FullName": "public final void invalidateChild (View child, Rect dirty)"}, "ViewGroup(android.content.Context,android.util.AttributeSet,int,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["@B_android#util#AttributeSet_E@", "AttributeSet no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 21", "FullName": "public ViewGroup (Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)"}, "fitSystemWindows(android.graphics.Rect)": {"Returns": [["", "true if this view applied the insets and it should not continue propagating further down the hierarchy, false otherwise."]], "Parameters": [["@B_android#graphics#Rect_E@", "Current content insets of the window. Prior to @B_android#os#Build#VERSION_CODES#JELLY_BEAN_E@ you must not modify the insets or else you and Android will be unhappy."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows. The content insets tell you the space that the status bar, input method, and other system windows infringe on the application's window. You do not normally need to deal with this function, since the default window decoration given to applications takes care of applying it to the content of the window. If you use @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN_E@ or @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION_E@ this will not be the case, and your content can be placed under those system elements. You can then use this method within your view hierarchy if you have parts of your UI which you would like to ensure are not being covered. The default implementation of this method simply applies the content insets to the view's padding, consuming that content (modifying the insets to be 0), and returning true. This behavior is off by default, but can be enabled through @B_android#view#View#setFitsSystemWindows_E@. This function's traversal down the hierarchy is depth-first. The same content insets object is propagated down the hierarchy, so any changes made to it will be seen by all following views (including potentially ones above in the hierarchy since this is a depth-first traversal). The first view that returns true will abort the entire traversal. The default implementation works well for a situation where it is used with a container that covers the entire window, allowing it to apply the appropriate insets to its content on all edges. If you need a more complicated layout (such as two different views fitting system windows, one on the top of the window, and one on the bottom), you can override the method and handle the insets however you would like. Note that the insets provided by the framework are always relative to the far edges of the window, not accounting for the location of the called view within that window. (In fact when this method is called you do not yet know where the layout will place the view, as it is done before layout happens.) Note: unlike many View methods, there is no dispatch phase to this call. If you are overriding it in a ViewGroup and want to allow the call to continue to your children, you must be sure to call the super implementation. Here is a sample layout that makes use of fitting system windows to have controls for a video view placed inside of the window decorations that it hides and shows. This can be used with code like the second sample (video player) shown in @B_android#view#View#setSystemUiVisibility_E@.", "history": "Added in API level 1", "FullName": "protected boolean fitSystemWindows (Rect insets)"}, "requestFocus(int,android.graphics.Rect)": {"Returns": [["boolean", "Whether this view or one of its descendants actually took focus."]], "Parameters": [["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT"], ["@B_android#graphics#Rect_E@", "Rect: The rectangle (in this View's coordinate system) to give a finer grained hint about where focus is coming from. May be null if there is no hint."]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup_E@", "@B_android#view#ViewGroup#onRequestFocusInDescendants_E@"], "Permissions": [], "Description": "Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from. The rectangle can help give larger views a finer grained hint about where focus is coming from, and therefore, where to show selection, or forward focus change internally. A view will not actually take focus if it is not focusable (@B_android#view#View#isFocusable_E@ returns false), or if it is focusable and it is not focusable in touch mode (@B_android#view#View#isFocusableInTouchMode_E@) while the device is in touch mode. A View will not take focus if it is not visible. A View will not take focus if one of its parents has @B_android#view#ViewGroup#getDescendantFocusability_E@ equal to @B_android#view#ViewGroup#FOCUS_BLOCK_DESCENDANTS_E@. See also @B_android#view#View#focusSearch_E@, which is what you call to say that you have focus, and you want your parent to look for the next one. You may wish to override this method if your custom @B_android#view#View_E@ has an internal @B_android#view#View_E@ that it wishes to forward the request to. Looks for a view to give focus to respecting the setting specified by @B_android#view#ViewGroup#getDescendantFocusability_E@. Uses @B_android#view#ViewGroup#onRequestFocusInDescendants_E@ to find focus within the children of this group when appropriate.", "history": "Added in API level 1", "FullName": "public boolean requestFocus (int direction, Rect previouslyFocusedRect)"}, "addView(android.view.View, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["int", "int: the position at which to add the child"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#generateDefaultLayoutParams_E@"], "Permissions": [], "Description": "Adds a child view. If no layout parameters are already set on the child, the default parameters for this ViewGroup are set on the child. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "added in API level 1", "FullName": "public void addView (View child, int index)"}, "resetResolvedLayoutDirection()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reset the resolved layout direction. Subclasses need to override this method to clear cached information that depends on the resolved layout direction, or to inform child views that inherit their layout direction. Overrides must also call the superclass implementation at the start of their implementation.", "history": "Since: API Level 14", "FullName": "protected void resetResolvedLayoutDirection ()"}, "measureChildren(int, int)": {"Returns": [], "Parameters": [["int", "int: The width requirements for this view"], ["int", "int: The height requirements for this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask all of the children of this view to measure themselves, taking into account both the MeasureSpec requirements for this view and its padding. We skip children that are in the GONE state The heavy lifting is done in getChildMeasureSpec.", "history": "added in API level 1", "FullName": "protected void measureChildren (int widthMeasureSpec, int heightMeasureSpec)"}, "dispatchSetSelected(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: The new selected state"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch setSelected to all of this View's children.", "history": "Added in API level 1", "FullName": "public void dispatchSetSelected (boolean selected)"}, "onAnimationEnd()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Invoked by a parent ViewGroup to notify the end of the animation currently associated with this view. If you override this method, always call super.onAnimationEnd();", "history": "Added in API level 1", "FullName": "protected void onAnimationEnd ()"}, "detachViewFromParent(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child to detach"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#detachViewFromParent_E@", "@B_android#view#ViewGroup#detachViewsFromParent_E@", "@B_android#view#ViewGroup#detachAllViewsFromParent_E@", "@B_android#view#ViewGroup#attachViewToParent_E@", "@B_android#view#ViewGroup#removeDetachedView_E@"], "Permissions": [], "Description": "Detaches a view from its parent. Detaching a view should be followed either by a call to @B_android#view#ViewGroup#attachViewToParent_E@ or a call to @B_android#view#ViewGroup#removeDetachedView_E@. Detachment should only be temporary; reattachment or removal should happen within the same drawing cycle as detachment. When a view is detached, its parent is null and cannot be retrieved by a call to @B_android#view#ViewGroup#getChildAt_E@.", "history": "Added in API level 1", "FullName": "protected void detachViewFromParent (View child)"}, "detachViewFromParent(int)": {"Returns": [], "Parameters": [["int", "int: the index of the child to detach"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#detachViewFromParent_E@", "@B_android#view#ViewGroup#detachAllViewsFromParent_E@", "@B_android#view#ViewGroup#detachViewsFromParent_E@", "@B_android#view#ViewGroup#attachViewToParent_E@", "@B_android#view#ViewGroup#removeDetachedView_E@"], "Permissions": [], "Description": "Detaches a view from its parent. Detaching a view should be followed either by a call to @B_android#view#ViewGroup#attachViewToParent_E@ or a call to @B_android#view#ViewGroup#removeDetachedView_E@. Detachment should only be temporary; reattachment or removal should happen within the same drawing cycle as detachment. When a view is detached, its parent is null and cannot be retrieved by a call to @B_android#view#ViewGroup#getChildAt_E@.", "history": "Added in API level 1", "FullName": "protected void detachViewFromParent (int index)"}, "setChildrenDrawingOrderEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the order of the children when drawing is determined by @B_android#view#ViewGroup#getChildDrawingOrder_E@, false otherwise"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#isChildrenDrawingOrderEnabled_E@", "@B_android#view#ViewGroup#getChildDrawingOrder_E@"], "Permissions": [], "Description": "Tells the ViewGroup whether to draw its children in the order defined by the method @B_android#view#ViewGroup#getChildDrawingOrder_E@. Note that @B_android#view#View#getZ_E@ reordering, done by @B_android#view#ViewGroup#dispatchDraw_E@, will override custom child ordering done via this method.", "history": "Added in API level 7", "FullName": "protected void setChildrenDrawingOrderEnabled (boolean enabled)"}, "requestChildFocus(android.view.View,android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child of this ViewParent that wants focus. This view will contain the focused view. It is not necessarily the view that actually has focus."], ["@B_android#view#View_E@", "View: The view that is a descendant of child that actually has focus"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child of this parent wants focus", "history": "Added in API level 1", "FullName": "public void requestChildFocus (View child, View focused)"}, "isMotionEventSplittingEnabled()": {"Returns": [["boolean", "true if MotionEvents dispatched to this ViewGroup can be split to multiple children."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if MotionEvents dispatched to this ViewGroup can be split to multiple children.", "history": "Added in API level 11", "FullName": "public boolean isMotionEventSplittingEnabled ()"}, "getChildStaticTransformation(android.view.View,android.view.animation.Transformation)": {"Returns": [["boolean", "true if the transformation was set, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: The child view whose static transform is being requested"], ["@B_android#view#animation#Transformation_E@", "Transformation: The Transformation which will hold the result"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setStaticTransformationsEnabled_E@"], "Permissions": [], "Description": "Sets t to be the static transformation of the child, if set, returning a boolean to indicate whether a static transform was set. The default implementation simply returns false; subclasses may override this method for different behavior. @B_android#view#ViewGroup#setStaticTransformationsEnabled_E@ must be set to true for this method to be called.", "history": "Added in API level 1", "FullName": "protected boolean getChildStaticTransformation (View child, Transformation t)"}, "detachViewsFromParent(int, int)": {"Returns": [], "Parameters": [["int", "int: the first index of the childrend range to detach"], ["int", "int: the number of children to detach"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#detachViewFromParent_E@", "@B_android#view#ViewGroup#detachAllViewsFromParent_E@", "@B_android#view#ViewGroup#attachViewToParent_E@", "@B_android#view#ViewGroup#removeDetachedView_E@"], "Permissions": [], "Description": "Detaches a range of views from their parents. Detaching a view should be followed either by a call to @B_android#view#ViewGroup#attachViewToParent_E@ or a call to @B_android#view#ViewGroup#removeDetachedView_E@. Detachment should only be temporary; reattachment or removal should happen within the same drawing cycle as detachment. When a view is detached, its parent is null and cannot be retrieved by a call to @B_android#view#ViewGroup#getChildAt_E@.", "history": "added in API level 1", "FullName": "protected void detachViewsFromParent (int start, int count)"}, "onLayout(boolean,int,int,int,int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "Added in API level 1", "FullName": "protected abstract void onLayout (boolean changed, int l, int t, int r, int b)"}, "clearFocus()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when this view wants to give up focus. If focus is cleared @B_android#view#View#onFocusChanged_E@ is called.", "history": "Added in API level 1", "FullName": "public void clearFocus ()"}, "requestChildRectangleOnScreen(android.view.View,android.graphics.Rect,boolean)": {"Returns": [["boolean", "Whether the group scrolled to handle the operation"]], "Parameters": [["@B_android#view#View_E@", "View: The direct child making the request."], ["@B_android#graphics#Rect_E@", "Rect: The rectangle in the child's coordinates the child wishes to be on the screen."], ["boolean", "boolean: True to forbid animated or delayed scrolling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child of this group wants a particular rectangle to be positioned onto the screen. @B_android#view#ViewGroup_E@s overriding this can trust that: child will be a direct child of this group rectangle will be in the child's content coordinates @B_android#view#ViewGroup_E@s overriding this should uphold the contract: nothing will change if the rectangle is already visible the view port will be scrolled only just enough to make the rectangle visible", "history": "Added in API level 1", "FullName": "public boolean requestChildRectangleOnScreen (View child, Rect rectangle, boolean immediate)"}, "onStopNestedScroll(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll operation ending. Perform cleanup after a nested scrolling operation. This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a @B_android#view#MotionEvent#ACTION_UP_E@ or @B_android#view#MotionEvent#ACTION_CANCEL_E@ event. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "Added in API level 21", "FullName": "public void onStopNestedScroll (View child)"}, "addViewInLayout(android.view.View,int,android.view.ViewGroup.LayoutParams,boolean)": {"Returns": [["boolean", "true if the child was added, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: the view to add to the group"], ["int", "int: the index at which the child must be added or -1 to add last"], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: the layout parameters to associate with the child"], ["boolean", "boolean: if true, calling this method will not trigger a layout request on child"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a view during layout. This is useful if in your onLayout() method, you need to add more views (as does the list view for example). If index is negative, it means put it at the end of the list.", "history": "Added in API level 1", "FullName": "protected boolean addViewInLayout (View child, int index, ViewGroup.LayoutParams params, boolean preventRequestLayout)"}, "isAlwaysDrawnWithCacheEnabled()": {"Returns": [["boolean", "true if the animation cache is enabled, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setAlwaysDrawnWithCacheEnabled_E@", "@B_android#view#ViewGroup#setChildrenDrawnWithCacheEnabled_E@", "@B_android#view#View#setDrawingCacheEnabled_E@"], "Permissions": [], "Description": "As of @B_android#os#Build#VERSION_CODES#M_E@, this property is ignored. Child views may no longer have their caching behavior disabled by parents. Indicates whether this ViewGroup will always try to draw its children using their drawing cache. By default this property is enabled.", "history": "Added in API level 1 Deprecated in API level 23", "FullName": "public boolean isAlwaysDrawnWithCacheEnabled ()"}, "drawChild(android.graphics.Canvas,android.view.View,long)": {"Returns": [["boolean", "True if an invalidate() was issued"]], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: The canvas on which to draw the child"], ["@B_android#view#View_E@", "View: Who to draw"], ["long", "long: The time at which draw is occurring"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Draw one child of this View Group. This method is responsible for getting the canvas in the right state. This includes clipping, translating so that the child's scrolled origin is at 0, 0, and applying any animation transformations.", "history": "Added in API level 1", "FullName": "protected boolean drawChild (Canvas canvas, View child, long drawingTime)"}, "getChildCount()": {"Returns": [["int", "a positive integer representing the number of children in the group"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the number of children in the group.", "history": "Added in API level 1", "FullName": "public int getChildCount ()"}, "shouldDelayChildPressedState()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if the pressed state should be delayed for children or descendants of this ViewGroup. Generally, this should be done for containers that can scroll, such as a List. This prevents the pressed state from appearing when the user is actually trying to scroll the content. The default implementation returns true for compatibility reasons. Subclasses that do not scroll should generally override this method and return false.", "history": "Added in API level 14", "FullName": "public boolean shouldDelayChildPressedState ()"}, "setTouchscreenBlocksFocus(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to enable blocking focus in the presence of a touchscreen"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set whether this ViewGroup should ignore focus requests for itself and its children. If this option is enabled and the ViewGroup or a descendant currently has focus, focus will proceed forward.", "history": "Added in API level 21", "FullName": "public void setTouchscreenBlocksFocus (boolean touchscreenBlocksFocus)"}, "dispatchUnhandledMove(android.view.View, int)": {"Returns": [["boolean", "True if the this view consumed this unhandled move."]], "Parameters": [["@B_android#view#View_E@", "View: The currently focused view."], ["int", "int: The direction focus wants to move. One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is the last chance for the focused view and its ancestors to respond to an arrow key. This is called when the focused view did not consume the key internally, nor could the view system find a new view in the requested direction to give focus to.", "history": "added in API level 1", "FullName": "public boolean dispatchUnhandledMove (View focused, int direction)"}, "findFocus()": {"Returns": [["@B_android#view#View_E@", "The view that currently has focus, or null if no focused view can be found."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the view in the hierarchy rooted at this view that currently has focus.", "history": "Added in API level 1", "FullName": "public View findFocus ()"}, "onNestedScroll(android.view.View,int,int,int,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The descendent view controlling the nested scroll"], ["int", "int: Horizontal scroll distance in pixels already consumed by target"], ["int", "int: Vertical scroll distance in pixels already consumed by target"], ["int", "int: Horizontal scroll distance in pixels not consumed by target"], ["int", "int: Vertical scroll distance in pixels not consumed by target"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll in progress. This method will be called when the ViewParent's current nested scrolling child view dispatches a nested scroll event. To receive calls to this method the ViewParent must have previously returned true for a call to @B_android#view#ViewParent#onStartNestedScroll_E@. Both the consumed and unconsumed portions of the scroll distance are reported to the ViewParent. An implementation may choose to use the consumed portion to match or chase scroll position of multiple child elements, for example. The unconsumed portion may be used to allow continuous dragging of multiple scrolling or draggable elements, such as scrolling a list within a vertical drawer where the drawer begins dragging once the edge of inner scrolling content is reached.", "history": "Added in API level 21", "FullName": "public void onNestedScroll (View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)"}, "isChildrenDrawingOrderEnabled()": {"Returns": [["boolean", "true if children drawing order is defined by @B_android#view#ViewGroup#getChildDrawingOrder_E@, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@", "@B_android#view#ViewGroup#getChildDrawingOrder_E@"], "Permissions": [], "Description": "Indicates whether the ViewGroup is drawing its children in the order defined by @B_android#view#ViewGroup#getChildDrawingOrder_E@.", "history": "Added in API level 7", "FullName": "protected boolean isChildrenDrawingOrderEnabled ()"}, "removeAllViews()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this method to remove all child views from the ViewGroup. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void removeAllViews ()"}, "isLayoutSuppressed()": {"Returns": [["boolean", "true if layout calls are currently suppressed, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether layout calls on this container are currently being suppressed, due to an earlier call to @B_android#view#ViewGroup#suppressLayout_E@.", "history": "Added in API level 29", "FullName": "public boolean isLayoutSuppressed ()"}, "removeView(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "@B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void removeView (View view)"}, "startActionModeForChild(android.view.View,android.view.ActionMode.Callback)": {"Returns": [["@B_android#view#ActionMode_E@", "The new action mode if it was started, null otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: The source view where the action mode was first invoked"], ["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: The callback that will handle lifecycle events for the action mode"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Start an action mode for the specified view with the default type @B_android#view#ActionMode#TYPE_PRIMARY_E@. In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, @B_android#view#ViewManager#addView_E@) then it should override this and start the action mode.", "history": "Added in API level 11", "FullName": "public ActionMode startActionModeForChild (View originalView, ActionMode.Callback callback)"}, "startActionModeForChild(android.view.View,android.view.ActionMode.Callback,int)": {"Returns": [["@B_android#view#ActionMode_E@", "The new action mode if it was started, null otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: The source view where the action mode was first invoked"], ["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: The callback that will handle lifecycle events for the action mode"], ["int", "int: One of @B_android#view#ActionMode#TYPE_PRIMARY_E@ or @B_android#view#ActionMode#TYPE_FLOATING_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Start an action mode of a specific type for the specified view. In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, @B_android#view#ViewManager#addView_E@) then it should override this and start the action mode.", "history": "Added in API level 23", "FullName": "public ActionMode startActionModeForChild (View originalView, ActionMode.Callback callback, int type)"}, "getAccessibilityClassName()": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the class name of this object to be used for accessibility purposes. Subclasses should only override this if they are implementing something that should be seen as a completely new class of view when used by accessibility, unrelated to the class it is deriving from. This is used to fill in @B_android#view#accessibility#AccessibilityNodeInfo#setClassName_E@.", "history": "Added in API level 23", "FullName": "public CharSequence getAccessibilityClassName ()"}, "getPersistentDrawingCache()": {"Returns": [["int", "one or a combination of @B_android#view#ViewGroup#PERSISTENT_NO_CACHE_E@, @B_android#view#ViewGroup#PERSISTENT_ANIMATION_CACHE_E@, @B_android#view#ViewGroup#PERSISTENT_SCROLLING_CACHE_E@ and @B_android#view#ViewGroup#PERSISTENT_ALL_CACHES_E@"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setPersistentDrawingCache_E@", "@B_android#view#ViewGroup#setAnimationCacheEnabled_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Returns an integer indicating what types of drawing caches are kept in memory.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public int getPersistentDrawingCache ()"}, "showContextMenuForChild(android.view.View)": {"Returns": [["boolean", "true if the context menu was shown, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: the source view where the context menu was first invoked"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Shows the context menu for the specified view or its ancestors. In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, @B_android#view#ViewManager#addView_E@) then it should override this and show the context menu.", "history": "Added in API level 1", "FullName": "public boolean showContextMenuForChild (View originalView)"}, "dispatchDrawableHotspotChanged(float, float)": {"Returns": [], "Parameters": [["float", "float: hotspot x coordinate"], ["float", "float: hotspot y coordinate"]], "Throws": [], "SeeAlso": ["@B_android#view#View#drawableHotspotChanged_E@"], "Permissions": [], "Description": "Dispatches drawable hotspot changes to child views that meet at least one of the following criteria: Returns false from both @B_android#view#View#isClickable_E@ and @B_android#view#View#isLongClickable_E@ Requests duplication of parent state via @B_android#view#View#setDuplicateParentStateEnabled_E@", "history": "added in API level 22", "FullName": "public void dispatchDrawableHotspotChanged (float x, float y)"}, "requestSendAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent)": {"Returns": [["boolean", "True if the event was sent."]], "Parameters": [["@B_android#view#View_E@", "View: The child which requests sending the event."], ["@B_android#view#accessibility#AccessibilityEvent_E@", "AccessibilityEvent: The event to be sent."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by a child to request from its parent to send an @B_android#view#accessibility#AccessibilityEvent_E@. The child has already populated a record for itself in the event and is delegating to its parent to send the event. The parent can optionally add a record for itself. Note: An accessibility event is fired by an individual view which populates the event with a record for its state and requests from its parent to perform the sending. The parent can optionally add a record for itself before dispatching the request to its parent. A parent can also choose not to respect the request for sending the event. The accessibility event is sent by the topmost view in the view tree.", "history": "Added in API level 14", "FullName": "public boolean requestSendAccessibilityEvent (View child, AccessibilityEvent event)"}, "addTouchables(java.util.ArrayList<android.view.View>)": {"Returns": [], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: Touchable views found so far"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself) to views.", "history": "Added in API level 1", "FullName": "public void addTouchables (ArrayList<View> views)"}, "requestTransparentRegion(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the view requesting the transparent region computation"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child wants the view hierarchy to gather and report transparent regions to the window compositor. Views that \"punch\" holes in the view hierarchy, such as SurfaceView can use this API to improve performance of the system. When no such a view is present in the hierarchy, this optimization in unnecessary and might slightly reduce the view hierarchy performance.", "history": "Added in API level 1", "FullName": "public void requestTransparentRegion (View child)"}, "offsetDescendantRectToMyCoords(android.view.View,android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: A descendant of this view"], ["@B_android#graphics#Rect_E@", "Rect: A rectangle defined in descendant's coordinate space."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Offset a rectangle that is in a descendant's coordinate space into our coordinate space.", "history": "Added in API level 1", "FullName": "public final void offsetDescendantRectToMyCoords (View descendant, Rect rect)"}, "onNestedScrollAccepted(android.view.View,android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: Direct child of this ViewParent containing target"], ["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["int", "int: Flags consisting of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@, @B_android#view#View#SCROLL_AXIS_VERTICAL_E@ or both"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to the successful claiming of a nested scroll operation. This method will be called after @B_android#view#ViewParent#onStartNestedScroll_E@ returns true. It offers an opportunity for the view and its superclasses to perform initial configuration for the nested scroll. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "Added in API level 21", "FullName": "public void onNestedScrollAccepted (View child, View target, int axes)"}, "offsetRectIntoDescendantCoords(android.view.View,android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: A descendant of this view"], ["@B_android#graphics#Rect_E@", "Rect: A rectangle defined in descendant's coordinate space."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Offset a rectangle that is in our coordinate space into an ancestor's coordinate space.", "history": "Added in API level 1", "FullName": "public final void offsetRectIntoDescendantCoords (View descendant, Rect rect)"}, "focusSearch(android.view.View,int)": {"Returns": [["@B_android#view#View_E@", "no returns description in source"]], "Parameters": [["@B_android#view#View_E@", "View: The view that currently has focus"], ["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT, or 0 for not applicable."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the nearest view in the specified direction that wants to take focus.", "history": "Added in API level 1", "FullName": "public View focusSearch (View focused, int direction)"}, "dispatchThawSelfOnly(android.util.SparseArray<android.os.Parcelable>)": {"Returns": [], "Parameters": [["@B_android#util#SparseArray_E@", "SparseArray: the container"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform dispatching of a @B_android#view#View#restoreHierarchyState_E@ to only this view, not to its children. For use when overriding @B_android#view#ViewGroup#dispatchRestoreInstanceState_E@ to allow subclasses to thaw their own state but not the state of their children.", "history": "Added in API level 1", "FullName": "protected void dispatchThawSelfOnly (SparseArray<Parcelable> container)"}, "onNestedFling(android.view.View,float,float,boolean)": {"Returns": [["boolean", "true if this parent consumed or otherwise reacted to the fling"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"], ["boolean", "boolean: true if the child consumed the fling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request a fling from a nested scroll. This method signifies that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling.", "history": "Added in API level 21", "FullName": "public boolean onNestedFling (View target, float velocityX, float velocityY, boolean consumed)"}, "setClipChildren(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to clip children to their bounds, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "By default, children are clipped to their bounds before drawing. This allows view groups to override this behavior for animations, etc.", "history": "Added in API level 1", "FullName": "public void setClipChildren (boolean clipChildren)"}, "childHasTransientStateChanged(android.view.View,boolean)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: Child view whose state has changed"], ["boolean", "boolean: true if this child has transient state"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child view has changed whether or not it is tracking transient state.", "history": "Added in API level 19", "FullName": "public void childHasTransientStateChanged (View child, boolean childHasTransientState)"}, "dispatchRestoreInstanceState(android.util.SparseArray<android.os.Parcelable>)": {"Returns": [], "Parameters": [["@B_android#util#SparseArray_E@", "SparseArray: The SparseArray which holds previously saved state."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by @B_android#view#View#restoreHierarchyState_E@ to retrieve the state for this view and its children. May be overridden to modify how restoring happens to a view's children; for example, some views may want to not store state for their children.", "history": "Added in API level 1", "FullName": "protected void dispatchRestoreInstanceState (SparseArray<Parcelable> container)"}, "getLayoutMode()": {"Returns": [["int", "the layout mode to use during layout operations"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setLayoutMode_E@"], "Permissions": [], "Description": "Returns the basis of alignment during layout operations on this ViewGroup: either @B_android#view#ViewGroup#LAYOUT_MODE_CLIP_BOUNDS_E@ or @B_android#view#ViewGroup#LAYOUT_MODE_OPTICAL_BOUNDS_E@. If no layoutMode was explicitly set, either programmatically or in an XML resource, the method returns the layoutMode of the view's parent ViewGroup if such a parent exists, otherwise the method returns a default value of @B_android#view#ViewGroup#LAYOUT_MODE_CLIP_BOUNDS_E@.", "history": "Added in API level 18", "FullName": "public int getLayoutMode ()"}, "addStatesFromChildren()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether this ViewGroup's drawable states also include its children's drawable states. This is used, for example, to make a group appear to be focused when its child EditText or button is focused.", "history": "Added in API level 1", "FullName": "public boolean addStatesFromChildren ()"}, "removeViews(int, int)": {"Returns": [], "Parameters": [["int", "int: the first position in the group of the range of views to remove"], ["int", "int: the number of views to remove"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes the specified range of views from the group. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "added in API level 1", "FullName": "public void removeViews (int start, int count)"}, "dispatchWindowFocusChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the window containing this view now has focus, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the window containing this view gains or loses window focus. ViewGroups should override to route to their children.", "history": "Added in API level 1", "FullName": "public void dispatchWindowFocusChanged (boolean hasFocus)"}, "ViewGroup(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public ViewGroup (Context context)"}, "removeDetachedView(android.view.View,boolean)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child to be definitely removed from the view hierarchy"], ["boolean", "boolean: if true and the view has an animation, the view is placed in the disappearing views list, otherwise, it is detached from the window"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#attachViewToParent_E@", "@B_android#view#ViewGroup#detachAllViewsFromParent_E@", "@B_android#view#ViewGroup#detachViewFromParent_E@"], "Permissions": [], "Description": "Finishes the removal of a detached view. This method will dispatch the detached from window event and notify the hierarchy change listener. This method is intended to be lightweight and makes no assumptions about whether the parent or child should be redrawn. Proper use of this method will include also making any appropriate @B_android#view#View#requestLayout_E@ or @B_android#view#View#invalidate_E@ calls. For example, callers can @B_android#view#View#post_E@ a @B_java#lang#Runnable_E@ which performs a @B_android#view#View#requestLayout_E@ on the next frame, after all detach/remove calls are finished, causing layout to be run prior to redrawing the view hierarchy.", "history": "Added in API level 1", "FullName": "protected void removeDetachedView (View child, boolean animate)"}, "getChildDrawingOrder(int)": {"Returns": [["int", "the container position of a child for this drawing order position."]], "Parameters": [["int", "int: the drawing order position."]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#getChildDrawingOrder_E@"], "Permissions": [], "Description": "Converts drawing order position to container position. Children are not necessarily drawn in the order in which they appear in the container. ViewGroups can enable a custom ordering via @B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@. This method returns the container position of a child that appears in the given position in the current drawing order.", "history": "Added in API level 29", "FullName": "public final int getChildDrawingOrder (int drawingPosition)"}, "onInterceptTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true to steal motion events from the children and have them dispatched to this ViewGroup through onTouchEvent(). The current target will receive an ACTION_CANCEL event, and no further messages will be delivered here."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event being dispatched down the hierarchy."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to intercept all touch screen motion events. This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point. Using this function takes some care, as it has a fairly complicated interaction with @B_android#view#View#onTouchEvent_E@, and using it requires implementing that method as well as this one in the correct way. Events will be received in the following order:", "history": "Added in API level 1", "FullName": "public boolean onInterceptTouchEvent (MotionEvent ev)"}, "cleanupLayoutState(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child on which to perform the cleanup"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Prevents the specified child to be laid out during the next layout pass.", "history": "Added in API level 1", "FullName": "protected void cleanupLayoutState (View child)"}, "clearDisappearingChildren()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes any pending animations for views that have been removed. Call this if you don't want animations for exiting views to stack up.", "history": "Added in API level 1", "FullName": "public void clearDisappearingChildren ()"}, "generateLayoutParams(android.util.AttributeSet)": {"Returns": [["@B_android#view#ViewGroup#LayoutParams_E@", "an instance of @B_android#view#ViewGroup#LayoutParams_E@ or one of its descendants"]], "Parameters": [["@B_android#util#AttributeSet_E@", "AttributeSet: the attributes to build the layout parameters from"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a new set of layout parameters based on the supplied attributes set.", "history": "Added in API level 1", "FullName": "public ViewGroup.LayoutParams generateLayoutParams (AttributeSet attrs)"}, "onCreateDrawableState(int)": {"Returns": [["int[]", "Returns an array holding the current @B_android#graphics#drawable#Drawable_E@ state of the view."]], "Parameters": [["int", "int: if non-zero, this is the number of extra entries you would like in the returned array in which you can place your own states."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Generate the new @B_android#graphics#drawable#Drawable_E@ state for this view. This is called by the view system when the cached Drawable state is determined to be invalid. To retrieve the current state, you should use @B_android#view#View#getDrawableState_E@.", "history": "Added in API level 1", "FullName": "protected int[] onCreateDrawableState (int extraSpace)"}, "notifySubtreeAccessibilityStateChanged(android.view.View,android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The direct child whose subtree has changed."], ["@B_android#view#View_E@", "View: The descendant view that changed. May not be null. This value must never be null."], ["int", "int: A bit mask of the types of changes that occurred. One or more of: AccessibilityEvent#CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION AccessibilityEvent#CONTENT_CHANGE_TYPE_SUBTREE AccessibilityEvent#CONTENT_CHANGE_TYPE_TEXT AccessibilityEvent#CONTENT_CHANGE_TYPE_UNDEFINED"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Notifies a view parent that the accessibility state of one of its descendants has changed and that the structure of the subtree is different.", "history": "Added in API level 19", "FullName": "public void notifySubtreeAccessibilityStateChanged (View child, View source, int changeType)"}, "startLayoutAnimation()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Runs the layout animation. Calling this method triggers a relayout of this view group.", "history": "Added in API level 1", "FullName": "public void startLayoutAnimation ()"}, "removeViewInLayout(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the view to remove from the group"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes a view during layout. This is useful if in your onLayout() method, you need to remove more views. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void removeViewInLayout (View view)"}, "getFocusedChild()": {"Returns": [["@B_android#view#View_E@", "the focused child or null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the focused child of this view, if any. The child may have focus or contain focus.", "history": "Added in API level 1", "FullName": "public View getFocusedChild ()"}, "dispatchKeyEvent(android.view.KeyEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a key event to the next view on the focus path. This path runs from the top of the view tree down to the currently focused view. If this view has focus, it will dispatch to itself. Otherwise it will dispatch the next node down the focus path. This method also fires any key listeners.", "history": "Added in API level 1", "FullName": "public boolean dispatchKeyEvent (KeyEvent event)"}, "getOverlay()": {"Returns": [["@B_android#view#ViewGroupOverlay_E@", "The ViewGroupOverlay object for this view."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroupOverlay_E@"], "Permissions": [], "Description": "Returns the ViewGroupOverlay for this view group, creating it if it does not yet exist. In addition to @B_android#view#ViewOverlay_E@'s support for drawables, @B_android#view#ViewGroupOverlay_E@ allows views to be added to the overlay. These views, like overlay drawables, are visual-only; they do not receive input events and should not be used as anything other than a temporary representation of a view in a parent container, such as might be used by an animation effect. Note: Overlays do not currently work correctly with @B_android#view#SurfaceView_E@ or @B_android#view#TextureView_E@; contents in overlays for these types of views may not display correctly.", "history": "Added in API level 18", "FullName": "public ViewGroupOverlay getOverlay ()"}, "onViewAdded(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the added child view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a new child is added to this ViewGroup. Overrides should always call super.onViewAdded.", "history": "Added in API level 23", "FullName": "public void onViewAdded (View child)"}, "setDescendantFocusability(int)": {"Returns": [], "Parameters": [["int", "int: one of @B_android#view#ViewGroup#FOCUS_BEFORE_DESCENDANTS_E@, @B_android#view#ViewGroup#FOCUS_AFTER_DESCENDANTS_E@, @B_android#view#ViewGroup#FOCUS_BLOCK_DESCENDANTS_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the descendant focusability of this view group. This defines the relationship between this view group and its descendants when looking for a view to take focus in @B_android#view#ViewGroup#requestFocus_E@.", "history": "Added in API level 1", "FullName": "public void setDescendantFocusability (int focusability)"}, "dispatchSetPressed(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: The new pressed state"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch setPressed to all of this View's children.", "history": "Added in API level 1", "FullName": "protected void dispatchSetPressed (boolean pressed)"}, "restoreDefaultFocus()": {"Returns": [["boolean", "Whether this view or one of its descendants actually took focus"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gives focus to the default-focus view in the view hierarchy that has this view as a root. If the default-focus view cannot be found, falls back to calling @B_android#view#View#requestFocus_E@.", "history": "Added in API level 26", "FullName": "public boolean restoreDefaultFocus ()"}, "dispatchUnhandledMove(android.view.View,int)": {"Returns": [["boolean", "True if the this view consumed this unhandled move."]], "Parameters": [["@B_android#view#View_E@", "View: The currently focused view."], ["int", "int: The direction focus wants to move. One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT. Value is @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_RIGHT_E@, or @B_android#view#View#FOCUS_DOWN_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is the last chance for the focused view and its ancestors to respond to an arrow key. This is called when the focused view did not consume the key internally, nor could the view system find a new view in the requested direction to give focus to.", "history": "Added in API level 1", "FullName": "public boolean dispatchUnhandledMove (View focused, int direction)"}, "getDescendantFocusability()": {"Returns": [["int", "one of @B_android#view#ViewGroup#FOCUS_BEFORE_DESCENDANTS_E@, @B_android#view#ViewGroup#FOCUS_AFTER_DESCENDANTS_E@, @B_android#view#ViewGroup#FOCUS_BLOCK_DESCENDANTS_E@."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the descendant focusability of this view group. The descendant focusability defines the relationship between this view group and its descendants when looking for a view to take focus in @B_android#view#ViewGroup#requestFocus_E@.", "history": "Added in API level 1", "FullName": "public int getDescendantFocusability ()"}, "layout(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Assign a size and position to a view and all of its descendants This is the second phase of the layout mechanism. (The first is measuring). In this phase, each parent calls layout on all of its children to position them. This is typically done using the child measurements that were stored in the measure pass(). Derived classes should not override this method. Derived classes with children should override onLayout. In that method, they should call layout on each of their children.", "history": "Added in API level 1", "FullName": "public final void layout (int l, int t, int r, int b)"}, "measureChildren(int,int)": {"Returns": [], "Parameters": [["int", "int: The width requirements for this view"], ["int", "int: The height requirements for this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask all of the children of this view to measure themselves, taking into account both the MeasureSpec requirements for this view and its padding. We skip children that are in the GONE state The heavy lifting is done in getChildMeasureSpec.", "history": "Added in API level 1", "FullName": "protected void measureChildren (int widthMeasureSpec, int heightMeasureSpec)"}, "isChildrenDrawnWithCacheEnabled()": {"Returns": [["boolean", "true if children should be drawn with their cache, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setAlwaysDrawnWithCacheEnabled_E@", "@B_android#view#ViewGroup#setChildrenDrawnWithCacheEnabled_E@"], "Permissions": [], "Description": "As of @B_android#os#Build#VERSION_CODES#M_E@, this property is ignored. Child views may no longer be forced to cache their rendering state by their parents. Use @B_android#view#View#setLayerType_E@ on individual Views instead. Indicates whether the ViewGroup is currently drawing its children using their drawing cache.", "history": "Added in API level 1 Deprecated in API level 23", "FullName": "protected boolean isChildrenDrawnWithCacheEnabled ()"}, "onRequestSendAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent)": {"Returns": [["boolean", "True if the event should be sent."]], "Parameters": [["@B_android#view#View_E@", "View: The child which requests sending the event."], ["@B_android#view#accessibility#AccessibilityEvent_E@", "AccessibilityEvent: The event to be sent."]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#requestSendAccessibilityEvent_E@"], "Permissions": [], "Description": "Called when a child has requested sending an @B_android#view#accessibility#AccessibilityEvent_E@ and gives an opportunity to its parent to augment the event. If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#onRequestSendAccessibilityEvent_E@ is responsible for handling this call.", "history": "Added in API level 14", "FullName": "public boolean onRequestSendAccessibilityEvent (View child, AccessibilityEvent event)"}, "removeViews(int,int)": {"Returns": [], "Parameters": [["int", "int: the first position in the group of the range of views to remove"], ["int", "int: the number of views to remove"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes the specified range of views from the group. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void removeViews (int start, int count)"}, "setLayoutAnimationListener(android.view.animation.Animation.AnimationListener)": {"Returns": [], "Parameters": [["@B_android#view#animation#Animation#AnimationListener_E@", "Animation.AnimationListener: the layout animation listener"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Specifies the animation listener to which layout animation events must be sent. Only @B_android#view#animation#Animation#AnimationListener#onAnimationStart_E@ and @B_android#view#animation#Animation#AnimationListener#onAnimationEnd_E@ are invoked.", "history": "Added in API level 1", "FullName": "public void setLayoutAnimationListener (Animation.AnimationListener animationListener)"}, "onLayout(boolean, int, int, int, int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "added in API level 1", "FullName": "protected abstract void onLayout (boolean changed, int l, int t, int r, int b)"}, "childDrawableStateChanged(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child whose drawable state has changed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If @B_android#view#ViewGroup#addStatesFromChildren_E@ is true, refreshes this group's drawable state (to include the states from its children).", "history": "Added in API level 1", "FullName": "public void childDrawableStateChanged (View child)"}, "onAttachedToWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before @B_android#view#View#onDraw_E@, however it may be called any time before the first onDraw -- including before or after @B_android#view#View#onMeasure_E@. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onAttachedToWindow ()"}, "addView(android.view.View,int,android.view.ViewGroup.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["int", "int: the position at which to add the child or -1 to add last"], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: the layout parameters to set on the child"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view with the specified layout parameters. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void addView (View child, int index, ViewGroup.LayoutParams params)"}, "getChildMeasureSpec(int,int,int)": {"Returns": [["int", "a MeasureSpec integer for the child"]], "Parameters": [["int", "int: The requirements for this view"], ["int", "int: The padding of this view for the current dimension and margins, if applicable"], ["int", "int: How big the child wants to be in the current dimension"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Does the hard part of measureChildren: figuring out the MeasureSpec to pass to a particular child. This method figures out the right MeasureSpec for one dimension (height or width) of one child view. The goal is to combine information from our MeasureSpec with the LayoutParams of the child to get the best possible results. For example, if the this view knows its size (because its MeasureSpec has a mode of EXACTLY), and the child has indicated in its LayoutParams that it wants to be the same size as the parent, the parent should ask the child to layout given an exact size.", "history": "Added in API level 1", "FullName": "public static int getChildMeasureSpec (int spec, int padding, int childDimension)"}, "dispatchDrawableHotspotChanged(float,float)": {"Returns": [], "Parameters": [["float", "float: hotspot x coordinate"], ["float", "float: hotspot y coordinate"]], "Throws": [], "SeeAlso": ["@B_android#view#View#drawableHotspotChanged_E@"], "Permissions": [], "Description": "Dispatches drawable hotspot changes to child views that meet at least one of the following criteria: Returns false from both @B_android#view#View#isClickable_E@ and @B_android#view#View#isLongClickable_E@ Requests duplication of parent state via @B_android#view#View#setDuplicateParentStateEnabled_E@", "history": "Added in API level 22", "FullName": "public void dispatchDrawableHotspotChanged (float x, float y)"}, "findViewsWithText(java.util.ArrayList<android.view.View>,java.lang.CharSequence,int)": {"Returns": [], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: The output list of matching Views."], ["@B_java#lang#CharSequence_E@", "CharSequence: The text to match against."], ["int", "int: Value is either 0 or a combination of @B_android#view#View#FIND_VIEWS_WITH_TEXT_E@, and @B_android#view#View#FIND_VIEWS_WITH_CONTENT_DESCRIPTION_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finds the Views that contain given text. The containment is case insensitive. The search is performed by either the text that the View renders or the content description that describes the view for accessibility purposes and the view does not render or both. Clients can specify how the search is to be performed via passing the @B_android#view#View#FIND_VIEWS_WITH_TEXT_E@ and @B_android#view#View#FIND_VIEWS_WITH_CONTENT_DESCRIPTION_E@ flags.", "history": "Added in API level 14", "FullName": "public void findViewsWithText (ArrayList<View> outViews, CharSequence text, int flags)"}, "dispatchVisibilityChanged(android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view whose visibility changed. Could be 'this' or an ancestor view. This value must never be null."], ["int", "int: The new visibility of changedView: @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@ or @B_android#view#View#GONE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a view visibility change down the view hierarchy. ViewGroups should override to route to their children.", "history": "Added in API level 8", "FullName": "protected void dispatchVisibilityChanged (View changedView, int visibility)"}, "detachAllViewsFromParent()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#detachViewFromParent_E@", "@B_android#view#ViewGroup#detachViewsFromParent_E@", "@B_android#view#ViewGroup#attachViewToParent_E@", "@B_android#view#ViewGroup#removeDetachedView_E@"], "Permissions": [], "Description": "Detaches all views from the parent. Detaching a view should be followed either by a call to @B_android#view#ViewGroup#attachViewToParent_E@ or a call to @B_android#view#ViewGroup#removeDetachedView_E@. Detachment should only be temporary; reattachment or removal should happen within the same drawing cycle as detachment. When a view is detached, its parent is null and cannot be retrieved by a call to @B_android#view#ViewGroup#getChildAt_E@.", "history": "Added in API level 1", "FullName": "protected void detachAllViewsFromParent ()"}, "invalidateChildInParent(int[],android.graphics.Rect)": {"Returns": [["@B_android#view#ViewParent_E@", "the parent of this ViewParent or null"]], "Parameters": [["int[]", "int: An array of 2 ints containing the left and top coordinates of the child to invalidate"], ["@B_android#graphics#Rect_E@", "Rect: The area within the child that is invalid"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#view#ViewGroup#onDescendantInvalidated_E@ instead to observe updates to draw state in descendants. Don't call or override this method. It is used for the implementation of the view hierarchy. This implementation returns null if this ViewGroup does not have a parent, if this ViewGroup is already fully invalidated or if the dirty rectangle does not intersect with this ViewGroup's bounds.", "history": "Added in API level 1", "FullName": "public ViewParent invalidateChildInParent (int[] location, Rect dirty)"}, "onInterceptHoverEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the view group would like to intercept the hover event and prevent its children from receiving it."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event that describes the hover."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to intercept hover events before they are handled by child views. This method is called before dispatching a hover event to a child of the view group or to the view group's own @B_android#view#View#onHoverEvent_E@ to allow the view group a chance to intercept the hover event. This method can also be used to watch all pointer motions that occur within the bounds of the view group even when the pointer is hovering over a child of the view group rather than over the view group itself. The view group can prevent its children from receiving hover events by implementing this method and returning true to indicate that it would like to intercept hover events. The view group must continuously return true from @B_android#view#ViewGroup#onInterceptHoverEvent_E@ for as long as it wishes to continue intercepting hover events from its children. Interception preserves the invariant that at most one view can be hovered at a time by transferring hover focus from the currently hovered child to the view group or vice-versa as needed. If this method returns true and a child is already hovered, then the child view will first receive a hover exit event and then the view group itself will receive a hover enter event in @B_android#view#View#onHoverEvent_E@. Likewise, if this method had previously returned true to intercept hover events and instead returns false while the pointer is hovering within the bounds of one of a child, then the view group will first receive a hover exit event in @B_android#view#View#onHoverEvent_E@ and then the hovered child will receive a hover enter event. The default implementation handles mouse hover on the scroll bars.", "history": "Added in API level 14", "FullName": "public boolean onInterceptHoverEvent (MotionEvent event)"}, "setMotionEventSplittingEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to allow MotionEvents to be split and dispatched to multiple child views. false to only allow one child view to be the target of any MotionEvent received by this ViewGroup."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable the splitting of MotionEvents to multiple children during touch event dispatch. This behavior is enabled by default for applications that target an SDK version of @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ or newer. When this option is enabled MotionEvents may be split and dispatched to different child views depending on where each pointer initially went down. This allows for user interactions such as scrolling two panes of content independently, chording of buttons, and performing independent gestures on different pieces of content.", "history": "Added in API level 11", "FullName": "public void setMotionEventSplittingEnabled (boolean split)"}, "getChildMeasureSpec(int, int, int)": {"Returns": [["int", "a MeasureSpec integer for the child"]], "Parameters": [["int", "int: The requirements for this view"], ["int", "int: The padding of this view for the current dimension and margins, if applicable"], ["int", "int: How big the child wants to be in the current dimension"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Does the hard part of measureChildren: figuring out the MeasureSpec to pass to a particular child. This method figures out the right MeasureSpec for one dimension (height or width) of one child view. The goal is to combine information from our MeasureSpec with the LayoutParams of the child to get the best possible results. For example, if the this view knows its size (because its MeasureSpec has a mode of EXACTLY), and the child has indicated in its LayoutParams that it wants to be the same size as the parent, the parent should ask the child to layout given an exact size.", "history": "added in API level 1", "FullName": "public static int getChildMeasureSpec (int spec, int padding, int childDimension)"}, "getLayoutAnimation()": {"Returns": [["@B_android#view#animation#LayoutAnimationController_E@", "the current animation controller"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the layout animation controller used to animate the group's children.", "history": "Added in API level 1", "FullName": "public LayoutAnimationController getLayoutAnimation ()"}, "recomputeViewAttributes(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View whose attributes have changed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tell view hierarchy that the global view attributes need to be re-evaluated.", "history": "Added in API level 1", "FullName": "public void recomputeViewAttributes (View child)"}, "hasTransientState()": {"Returns": [["boolean", "true if the view has transient state"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether the view is currently tracking transient state that the app should not need to concern itself with saving and restoring, but that the framework should take special note to preserve when possible. A view with transient state cannot be trivially rebound from an external data source, such as an adapter binding item views in a list. This may be because the view is performing an animation, tracking user selection of content, or similar.", "history": "Added in API level 16", "FullName": "public boolean hasTransientState ()"}, "checkLayoutParams(android.view.ViewGroup.LayoutParams)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "protected boolean checkLayoutParams (ViewGroup.LayoutParams p)"}, "canAnimate()": {"Returns": [["boolean", "true if the children can be animated, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether the view group has the ability to animate its children after the first layout.", "history": "Added in API level 1", "FullName": "protected boolean canAnimate ()"}, "onNestedPreFling(android.view.View, float, float)": {"Returns": [["boolean", "true if this parent consumed the fling ahead of the target view"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested fling before the target view consumes it. This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling parent is consuming motion as part of a @B_android#view#ViewParent#onNestedPreScroll_E@, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well.", "history": "added in API level 21", "FullName": "public boolean onNestedPreFling (View target, float velocityX, float velocityY)"}, "getLayoutAnimationListener()": {"Returns": [["@B_android#view#animation#Animation#AnimationListener_E@", "an @B_android#view#animation#Animation#AnimationListener_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the animation listener to which layout animation events are sent.", "history": "Added in API level 1", "FullName": "public Animation.AnimationListener getLayoutAnimationListener ()"}, "detachViewsFromParent(int,int)": {"Returns": [], "Parameters": [["int", "int: the first index of the childrend range to detach"], ["int", "int: the number of children to detach"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#detachViewFromParent_E@", "@B_android#view#ViewGroup#detachAllViewsFromParent_E@", "@B_android#view#ViewGroup#attachViewToParent_E@", "@B_android#view#ViewGroup#removeDetachedView_E@"], "Permissions": [], "Description": "Detaches a range of views from their parents. Detaching a view should be followed either by a call to @B_android#view#ViewGroup#attachViewToParent_E@ or a call to @B_android#view#ViewGroup#removeDetachedView_E@. Detachment should only be temporary; reattachment or removal should happen within the same drawing cycle as detachment. When a view is detached, its parent is null and cannot be retrieved by a call to @B_android#view#ViewGroup#getChildAt_E@.", "history": "Added in API level 1", "FullName": "protected void detachViewsFromParent (int start, int count)"}, "jumpDrawablesToCurrentState()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call @B_android#graphics#drawable#Drawable#jumpToCurrentState_E@ on all Drawable objects associated with this view. Also calls @B_android#animation#StateListAnimator#jumpToCurrentState_E@ if there is a StateListAnimator attached to this view. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 11", "FullName": "public void jumpDrawablesToCurrentState ()"}, "focusSearch(android.view.View, int)": {"Returns": [["@B_android#view#View_E@", "no returns description in source"]], "Parameters": [["@B_android#view#View_E@", "View: The view that currently has focus"], ["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT, or 0 for not applicable."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the nearest view in the specified direction that wants to take focus.", "history": "added in API level 1", "FullName": "public View focusSearch (View focused, int direction)"}, "onNestedPreScroll(android.view.View,int,int,int[])": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["int", "int: Horizontal scroll distance in pixels"], ["int", "int: Vertical scroll distance in pixels"], ["int[]", "int: Output. The horizontal and vertical scroll distance consumed by this parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll in progress before the target view consumes a portion of the scroll. When working with nested scrolling often the parent view may want an opportunity to consume the scroll before the nested scrolling child does. An example of this is a drawer that contains a scrollable list. The user will want to be able to scroll the list fully into view before the list itself begins scrolling. onNestedPreScroll is called when a nested scrolling child invokes @B_android#view#View#dispatchNestedPreScroll_E@. The implementation should report how any pixels of the scroll reported by dx, dy were consumed in the consumed array. Index 0 corresponds to dx and index 1 corresponds to dy. This parameter will never be null. Initial values for consumed[0] and consumed[1] will always be 0.", "history": "Added in API level 21", "FullName": "public void onNestedPreScroll (View target, int dx, int dy, int[] consumed)"}, "generateLayoutParams(android.view.ViewGroup.LayoutParams)": {"Returns": [["@B_android#view#ViewGroup#LayoutParams_E@", "an instance of @B_android#view#ViewGroup#LayoutParams_E@ or one of its descendants"]], "Parameters": [["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: The layout parameters to convert into a suitable set of layout parameters for this ViewGroup."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a safe set of layout parameters based on the supplied layout params. When a ViewGroup is passed a View whose layout params do not pass the test of @B_android#view#ViewGroup#checkLayoutParams_E@, this method is invoked. This method should return a new set of layout params suitable for this ViewGroup, possibly by copying the appropriate attributes from the specified set of layout params.", "history": "Added in API level 1", "FullName": "protected ViewGroup.LayoutParams generateLayoutParams (ViewGroup.LayoutParams p)"}, "addFocusables(java.util.ArrayList<android.view.View>,int,int)": {"Returns": [], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: Focusable views found so far or null if all we are interested is the number of focusables."], ["int", "int: The direction of the focus. Value is @B_android#view#View#FOCUS_BACKWARD_E@, @B_android#view#View#FOCUS_FORWARD_E@, @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_RIGHT_E@, or @B_android#view#View#FOCUS_DOWN_E@"], ["int", "int: The type of focusables to be added. Value is either 0 or a combination of @B_android#view#View#FOCUSABLES_ALL_E@, and @B_android#view#View#FOCUSABLES_TOUCH_MODE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views. This method adds all focusable views regardless if we are in touch mode or only views focusable in touch mode if we are in touch mode or only views that can take accessibility focus if accessibility is enabled depending on the focusable mode parameter.", "history": "Added in API level 4", "FullName": "public void addFocusables (ArrayList<View> views, int direction, int focusableMode)"}, "setChildrenDrawnWithCacheEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if children should be drawn with their cache, false otherwise"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setAlwaysDrawnWithCacheEnabled_E@", "@B_android#view#ViewGroup#isChildrenDrawnWithCacheEnabled_E@"], "Permissions": [], "Description": "As of @B_android#os#Build#VERSION_CODES#M_E@, this property is ignored. Child views may no longer be forced to cache their rendering state by their parents. Use @B_android#view#View#setLayerType_E@ on individual Views instead. Tells the ViewGroup to draw its children using their drawing cache. This property is ignored when @B_android#view#ViewGroup#isAlwaysDrawnWithCacheEnabled_E@ is true. A child's drawing cache will be used only if it has been enabled. Subclasses should call this method to start and stop using the drawing cache when they perform performance sensitive operations, like scrolling or animating.", "history": "Added in API level 1 Deprecated in API level 23", "FullName": "protected void setChildrenDrawnWithCacheEnabled (boolean enabled)"}, "clearChildFocus(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view that is giving up focus"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child of this parent is giving up focus", "history": "Added in API level 1", "FullName": "public void clearChildFocus (View child)"}, "resetResolvedTextDirection()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Reset resolved text direction. Will be resolved during a call to getResolvedTextDirection().", "history": "Since: API Level 14", "FullName": "protected void resetResolvedTextDirection ()"}, "dispatchVisibilityChanged(android.view.View, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view whose visibility changed. Could be 'this' or an ancestor view."], ["int", "int: The new visibility of changedView: @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@ or @B_android#view#View#GONE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a view visibility change down the view hierarchy. ViewGroups should override to route to their children.", "history": "added in API level 8", "FullName": "protected void dispatchVisibilityChanged (View changedView, int visibility)"}, "dispatchSaveInstanceState(android.util.SparseArray<android.os.Parcelable>)": {"Returns": [], "Parameters": [["@B_android#util#SparseArray_E@", "SparseArray: The SparseArray in which to save the view's state."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by @B_android#view#View#saveHierarchyState_E@ to store the state for this view and its children. May be overridden to modify how freezing happens to a view's children; for example, some views may want to not store state for their children.", "history": "Added in API level 1", "FullName": "protected void dispatchSaveInstanceState (SparseArray<Parcelable> container)"}, "dispatchDragEvent(android.view.DragEvent)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#view#DragEvent_E@", "DragEvent no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detects if this View is enabled and has a drag event listener. If both are true, then it calls the drag event listener with the @B_android#view#DragEvent_E@ it received. If the drag event listener returns true, then dispatchDragEvent() returns true. For all other cases, the method calls the @B_android#view#View#onDragEvent_E@ drag event handler method and returns its result. This ensures that a drag event is always consumed, even if the View does not have a drag event listener. However, if the View has a listener and the listener returns true, then onDragEvent() is not called.", "history": "Added in API level 11", "FullName": "public boolean dispatchDragEvent (DragEvent event)"}, "startViewTransition(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The View object to be kept visible even if it gets removed from its parent."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method tells the ViewGroup that the given View object, which should have this ViewGroup as its parent, should be kept around (re-displayed when the ViewGroup draws its children) even if it is removed from its parent. This allows animations, such as those used by @B_android#app#Fragment_E@ and @B_android#animation#LayoutTransition_E@ to animate the removal of views. A call to this method should always be accompanied by a later call to @B_android#view#ViewGroup#endViewTransition_E@, such as after an animation on the View has finished, so that the View finally gets removed.", "history": "Added in API level 11", "FullName": "public void startViewTransition (View view)"}, "attachLayoutAnimationParameters(android.view.View,android.view.ViewGroup.LayoutParams,int,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child to associate with animation parameters"], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: the child's layout parameters which hold the animation parameters"], ["int", "int: the index of the child in the view group"], ["int", "int: the number of children in the view group"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Subclasses should override this method to set layout animation parameters on the supplied child.", "history": "Added in API level 1", "FullName": "protected void attachLayoutAnimationParameters (View child, ViewGroup.LayoutParams params, int index, int count)"}, "requestFocus(int, android.graphics.Rect)": {"Returns": [["boolean", "Whether this view or one of its descendants actually took focus."]], "Parameters": [["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT"], ["@B_android#graphics#Rect_E@", "Rect: The rectangle (in this View's coordinate system) to give a finer grained hint about where focus is coming from. May be null if there is no hint."]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup_E@", "@B_android#view#ViewGroup#onRequestFocusInDescendants_E@"], "Permissions": [], "Description": "Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from. The rectangle can help give larger views a finer grained hint about where focus is coming from, and therefore, where to show selection, or forward focus change internally. A view will not actually take focus if it is not focusable (@B_android#view#View#isFocusable_E@ returns false), or if it is focusable and it is not focusable in touch mode (@B_android#view#View#isFocusableInTouchMode_E@) while the device is in touch mode. A View will not take focus if it is not visible. A View will not take focus if one of its parents has @B_android#view#ViewGroup#getDescendantFocusability_E@ equal to @B_android#view#ViewGroup#FOCUS_BLOCK_DESCENDANTS_E@. See also @B_android#view#View#focusSearch_E@, which is what you call to say that you have focus, and you want your parent to look for the next one. You may wish to override this method if your custom @B_android#view#View_E@ has an internal @B_android#view#View_E@ that it wishes to forward the request to. Looks for a view to give focus to respecting the setting specified by @B_android#view#ViewGroup#getDescendantFocusability_E@. Uses @B_android#view#ViewGroup#onRequestFocusInDescendants_E@ to find focus within the children of this group when appropriate.", "history": "added in API level 1", "FullName": "public boolean requestFocus (int direction, Rect previouslyFocusedRect)"}, "onStartNestedScroll(android.view.View,android.view.View,int)": {"Returns": [["boolean", "true if this ViewParent accepts the nested scroll operation"]], "Parameters": [["@B_android#view#View_E@", "View: Direct child of this ViewParent containing target"], ["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["int", "int: Flags consisting of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@, @B_android#view#View#SCROLL_AXIS_VERTICAL_E@ or both"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a descendant view initiating a nestable scroll operation, claiming the nested scroll operation if appropriate. This method will be called in response to a descendant view invoking @B_android#view#View#startNestedScroll_E@. Each parent up the view hierarchy will be given an opportunity to respond and claim the nested scrolling operation by returning true. This method may be overridden by ViewParent implementations to indicate when the view is willing to support a nested scrolling operation that is about to begin. If it returns true, this ViewParent will become the target view's nested scrolling parent for the duration of the scroll operation in progress. When the nested scroll is finished this ViewParent will receive a call to @B_android#view#ViewParent#onStopNestedScroll_E@.", "history": "Added in API level 21", "FullName": "public boolean onStartNestedScroll (View child, View target, int nestedScrollAxes)"}, "setTransitionGroup(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether or not the ViewGroup should be treated as a unit in Activity transitions. If false, the ViewGroup won't transition, only its children. If true, the entire ViewGroup will transition together."]], "Throws": [], "SeeAlso": ["@B_android#app#ActivityOptions#makeSceneTransitionAnimation_E@"], "Permissions": [], "Description": "Changes whether or not this ViewGroup should be treated as a single entity during Activity Transitions.", "history": "Added in API level 21", "FullName": "public void setTransitionGroup (boolean isTransitionGroup)"}, "onNestedPreFling(android.view.View,float,float)": {"Returns": [["boolean", "true if this parent consumed the fling ahead of the target view"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested fling before the target view consumes it. This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling parent is consuming motion as part of a @B_android#view#ViewParent#onNestedPreScroll_E@, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well.", "history": "Added in API level 21", "FullName": "public boolean onNestedPreFling (View target, float velocityX, float velocityY)"}, "onDetachedFromWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is detached from a window. At this point it no longer has a surface for drawing. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onDetachedFromWindow ()"}, "endViewTransition(android.view.View)": {"Returns": [["void", "view The View object that has been removed but is being kept around in the visible hierarchy by an earlier call to @B_android#view#ViewGroup#startViewTransition_E@."]], "Parameters": [["@B_android#view#View_E@", "View no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method should always be called following an earlier call to @B_android#view#ViewGroup#startViewTransition_E@. The given View is finally removed from its parent and will no longer be displayed. Note that this method does not perform the functionality of removing a view from its parent; it just discontinues the display of a View that has previously been removed.", "history": "Added in API level 11", "FullName": "public void endViewTransition (View view)"}, "debug(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "protected void debug (int depth)"}, "dispatchKeyEventPreIme(android.view.KeyEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a key event before it is processed by any input method associated with the view hierarchy. This can be used to intercept key events in special situations before the IME consumes them; a typical example would be handling the BACK key to update the application's UI instead of allowing the IME to see it and close itself.", "history": "Added in API level 3", "FullName": "public boolean dispatchKeyEventPreIme (KeyEvent event)"}, "addChildrenForAccessibility(java.util.ArrayList<android.view.View>)": {"Returns": [], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: The output list that will receive children for accessibility."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds the children of this View relevant for accessibility to the given list as output. Since some Views are not important for accessibility the added child views are not necessarily direct children of this view, rather they are the first level of descendants important for accessibility.", "history": "Added in API level 16", "FullName": "public void addChildrenForAccessibility (ArrayList<View> outChildren)"}, "dispatchApplyWindowInsets(android.view.WindowInsets)": {"Returns": [["@B_android#view#WindowInsets_E@", "The provided insets minus the insets that were consumed"]], "Parameters": [["@B_android#view#WindowInsets_E@", "WindowInsets: Insets to apply"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request to apply the given window insets to this view or another view in its subtree. This method should be called by clients wishing to apply insets corresponding to areas obscured by window decorations or overlays. This can include the status and navigation bars, action bars, input methods and more. New inset categories may be added in the future. The method returns the insets provided minus any that were applied by this view or its children. Clients wishing to provide custom behavior should override the @B_android#view#View#onApplyWindowInsets_E@ method or alternatively provide a @B_android#view#View#OnApplyWindowInsetsListener_E@ via the @B_android#view#View#setOnApplyWindowInsetsListener_E@ method. This method replaces the older @B_android#view#View#fitSystemWindows_E@ method.", "history": "Added in API level 20", "FullName": "public WindowInsets dispatchApplyWindowInsets (WindowInsets insets)"}, "isAnimationCacheEnabled()": {"Returns": [["boolean", "true if the animation cache is enabled, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setAnimationCacheEnabled_E@", "@B_android#view#View#setDrawingCacheEnabled_E@"], "Permissions": [], "Description": "As of @B_android#os#Build#VERSION_CODES#M_E@, this property is ignored. Caching behavior of children may be controlled through @B_android#view#View#setLayerType_E@. Indicates whether the children's drawing cache is used during a layout animation. By default, the drawing cache is enabled but this will prevent nested layout animations from working. To nest animations, you must disable the cache.", "history": "Added in API level 1 Deprecated in API level 23", "FullName": "public boolean isAnimationCacheEnabled ()"}, "setOnHierarchyChangeListener(android.view.ViewGroup.OnHierarchyChangeListener)": {"Returns": [], "Parameters": [["@B_android#view#ViewGroup#OnHierarchyChangeListener_E@", "ViewGroup.OnHierarchyChangeListener: the callback to invoke on hierarchy change"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when a child is added to or removed from this view.", "history": "Added in API level 1", "FullName": "public void setOnHierarchyChangeListener (ViewGroup.OnHierarchyChangeListener listener)"}, "setAnimationCacheEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to enable the animation cache, false otherwise"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#isAnimationCacheEnabled_E@", "@B_android#view#View#setDrawingCacheEnabled_E@"], "Permissions": [], "Description": "As of @B_android#os#Build#VERSION_CODES#M_E@, this property is ignored. Caching behavior of children may be controlled through @B_android#view#View#setLayerType_E@. Enables or disables the children's drawing cache during a layout animation. By default, the drawing cache is enabled but this will prevent nested layout animations from working. To nest animations, you must disable the cache.", "history": "Added in API level 1 Deprecated in API level 23", "FullName": "public void setAnimationCacheEnabled (boolean enabled)"}, "getClipToPadding()": {"Returns": [["boolean", "true if this ViewGroup clips children to its padding and resizes (but doesn't clip) any EdgeEffect to the padded region, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether this ViewGroup will clip its children to its padding, and resize (but not clip) any EdgeEffect to the padded region, if padding is present. By default, children are clipped to the padding of their parent Viewgroup. This clipping behavior is only enabled if padding is non-zero.", "history": "Added in API level 21", "FullName": "public boolean getClipToPadding ()"}, "measureChild(android.view.View,int,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child to measure"], ["int", "int: The width requirements for this view"], ["int", "int: The height requirements for this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding. The heavy lifting is done in getChildMeasureSpec.", "history": "Added in API level 1", "FullName": "protected void measureChild (View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)"}, "getChildVisibleRect(android.view.View,android.graphics.Rect,android.graphics.Point)": {"Returns": [["boolean", "true if the resulting rectangle is not empty, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: A child View, whose rectangular visible region we want to compute"], ["@B_android#graphics#Rect_E@", "Rect: The input rectangle, defined in the child coordinate system. Will be overwritten to contain the resulting visible rectangle, expressed in global (root) coordinates"], ["@B_android#graphics#Point_E@", "Point: The input coordinates of a point, defined in the child coordinate system. As with the r parameter, this will be overwritten to contain the global (root) coordinates of that point. A null value is valid (in case you are not interested in this result)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compute the visible part of a rectangular region defined in terms of a child view's coordinates. Returns the clipped visible part of the rectangle r, defined in the child's local coordinate system. r is modified by this method to contain the result, expressed in the global (root) coordinate system. The resulting rectangle is always axis aligned. If a rotation is applied to a node in the View hierarchy, the result is the axis-aligned bounding box of the visible rectangle.", "history": "Added in API level 1", "FullName": "public boolean getChildVisibleRect (View child, Rect r, Point offset)"}, "removeAllViewsInLayout()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by a ViewGroup subclass to remove child views from itself, when it must first know its size on screen before it can calculate how many child views it will render. An example is a Gallery or a ListView, which may \"have\" 50 children, but actually only render the number of children that can currently fit inside the object on screen. Do not call this method unless you are extending ViewGroup and understand the view measuring and layout pipeline. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void removeAllViewsInLayout ()"}, "getClipChildren()": {"Returns": [["boolean", "True if the group's children will be clipped to their bounds, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setClipChildren_E@"], "Permissions": [], "Description": "Returns whether this group's children are clipped to their bounds before drawing. The default value is true.", "history": "Added in API level 18", "FullName": "public boolean getClipChildren ()"}, "removeViewsInLayout(int,int)": {"Returns": [], "Parameters": [["int", "int: the index of the first view to remove from the group"], ["int", "int: the number of views to remove from the group"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes a range of views during layout. This is useful if in your onLayout() method, you need to remove more views. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void removeViewsInLayout (int start, int count)"}, "setPersistentDrawingCache(int)": {"Returns": [], "Parameters": [["int", "int: one or a combination of @B_android#view#ViewGroup#PERSISTENT_NO_CACHE_E@, @B_android#view#ViewGroup#PERSISTENT_ANIMATION_CACHE_E@, @B_android#view#ViewGroup#PERSISTENT_SCROLLING_CACHE_E@ and @B_android#view#ViewGroup#PERSISTENT_ALL_CACHES_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#getPersistentDrawingCache_E@", "@B_android#view#ViewGroup#setAnimationCacheEnabled_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Indicates what types of drawing caches should be kept in memory after they have been created.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public void setPersistentDrawingCache (int drawingCacheToKeep)"}, "ViewGroup(android.content.Context,android.util.AttributeSet)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["@B_android#util#AttributeSet_E@", "AttributeSet no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public ViewGroup (Context context, AttributeSet attrs)"}, "focusableViewAvailable(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view that has become newly focusable"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells the parent that a new focusable view has become available. This is to handle transitions from the case where there are no focusable views to the case where the first focusable view appears.", "history": "Added in API level 1", "FullName": "public void focusableViewAvailable (View v)"}, "dispatchGenericFocusedEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a generic motion event to the currently focused view. Do not call this method directly. Call @B_android#view#View#dispatchGenericMotionEvent_E@ instead.", "history": "Added in API level 14", "FullName": "protected boolean dispatchGenericFocusedEvent (MotionEvent event)"}, "hasFocus()": {"Returns": [["boolean", "true if this view has or contains focus"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has or contains focus", "history": "Added in API level 1", "FullName": "public boolean hasFocus ()"}, "onAnimationStart()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Invoked by a parent ViewGroup to notify the start of the animation currently associated with this view. If you override this method, always call super.onAnimationStart();", "history": "Added in API level 1", "FullName": "protected void onAnimationStart ()"}, "dispatchGenericPointerEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a generic motion event to the view under the first pointer. Do not call this method directly. Call @B_android#view#View#dispatchGenericMotionEvent_E@ instead.", "history": "Added in API level 14", "FullName": "protected boolean dispatchGenericPointerEvent (MotionEvent event)"}, "onResolvePointerIcon(android.view.MotionEvent,int)": {"Returns": [["@B_android#view#PointerIcon_E@", "no returns description in source"]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The MotionEvent from a mouse"], ["int", "int: The index of the pointer for which to retrieve the @B_android#view#PointerIcon_E@. This will be between 0 and @B_android#view#MotionEvent#getPointerCount_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the pointer icon for the motion event, or null if it doesn't specify the icon. The default implementation does not care the location or event types, but some subclasses may use it (such as WebViews).", "history": "Added in API level 24", "FullName": "public PointerIcon onResolvePointerIcon (MotionEvent event, int pointerIndex)"}, "dispatchKeyShortcutEvent(android.view.KeyEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatches a key shortcut event.", "history": "Added in API level 1", "FullName": "public boolean dispatchKeyShortcutEvent (KeyEvent event)"}, "showContextMenuForChild(android.view.View,float,float)": {"Returns": [["boolean", "true if the context menu was shown, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: the source view where the context menu was first invoked"], ["float", "float: the X coordinate in pixels relative to the original view to which the menu should be anchored, or @B_java#lang#Float#NaN_E@ to disable anchoring"], ["float", "float: the Y coordinate in pixels relative to the original view to which the menu should be anchored, or @B_java#lang#Float#NaN_E@ to disable anchoring"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Shows the context menu for the specified view or its ancestors anchored to the specified view-relative coordinate. In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, @B_android#view#ViewManager#addView_E@) then it should override this and show the context menu. If a subclass overrides this method it should also override @B_android#view#ViewParent#showContextMenuForChild_E@.", "history": "Added in API level 24", "FullName": "public boolean showContextMenuForChild (View originalView, float x, float y)"}, "dispatchPointerCaptureChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public void dispatchPointerCaptureChanged (boolean hasCapture)"}, "addView(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#generateDefaultLayoutParams_E@"], "Permissions": [], "Description": "Adds a child view. If no layout parameters are already set on the child, the default parameters for this ViewGroup are set on the child. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void addView (View child)"}, "drawableStateChanged()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown. If the View has a StateListAnimator, it will also be called to run necessary state change animations. Be sure to call through to the superclass when overriding this function. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void drawableStateChanged ()"}, "dispatchSystemUiVisibilityChanged(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch callbacks to @B_android#view#View#setOnSystemUiVisibilityChangeListener_E@ down the view hierarchy.", "history": "Added in API level 11", "FullName": "public void dispatchSystemUiVisibilityChanged (int visible)"}, "isTransitionGroup()": {"Returns": [["boolean", "True if the ViewGroup should be acted on together during an Activity transition. The default value is true when there is a non-null background or if @B_android#view#View#getTransitionName_E@ is not null or if a non-null @B_android#view#ViewOutlineProvider_E@ other than @B_android#view#ViewOutlineProvider#BACKGROUND_E@ was given to @B_android#view#View#setOutlineProvider_E@ and false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this ViewGroup should be considered as a single entity for removal when executing an Activity transition. If this is false, child elements will move individually during the transition.", "history": "Added in API level 21", "FullName": "public boolean isTransitionGroup ()"}, "dispatchCapturedPointerEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Pass a captured pointer event down to the focused view.", "history": "Added in API level 26", "FullName": "public boolean dispatchCapturedPointerEvent (MotionEvent event)"}, "dispatchProvideStructure(android.view.ViewStructure)": {"Returns": [], "Parameters": [["@B_android#view#ViewStructure_E@", "ViewStructure no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch creation of @B_android#view#ViewStructure_E@ down the hierarchy. This implementation adds in all child views of the view group, in addition to calling the default View implementation.", "history": "Added in API level 23", "FullName": "public void dispatchProvideStructure (ViewStructure structure)"}, "addKeyboardNavigationClusters(java.util.Collection<android.view.View>,int)": {"Returns": [], "Parameters": [["@B_java#util#Collection_E@", "Collection: Keyboard navigation cluster roots found so far This value must never be null."], ["int", "int: Direction to look"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds any keyboard navigation cluster roots that are descendants of this view (possibly including this view if it is a cluster root itself) to views.", "history": "Added in API level 26", "FullName": "public void addKeyboardNavigationClusters (Collection<View> views, int direction)"}, "dispatchTrackballEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Pass a trackball motion event down to the focused view.", "history": "Added in API level 1", "FullName": "public boolean dispatchTrackballEvent (MotionEvent event)"}, "setLayoutMode(int)": {"Returns": [], "Parameters": [["int", "int: the layout mode to use during layout operations"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#getLayoutMode_E@"], "Permissions": [], "Description": "Sets the basis of alignment during the layout of this ViewGroup. Valid values are either @B_android#view#ViewGroup#LAYOUT_MODE_CLIP_BOUNDS_E@ or @B_android#view#ViewGroup#LAYOUT_MODE_OPTICAL_BOUNDS_E@.", "history": "Added in API level 18", "FullName": "public void setLayoutMode (int layoutMode)"}, "removeViewsInLayout(int, int)": {"Returns": [], "Parameters": [["int", "int: the index of the first view to remove from the group"], ["int", "int: the number of views to remove from the group"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes a range of views during layout. This is useful if in your onLayout() method, you need to remove more views. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "added in API level 1", "FullName": "public void removeViewsInLayout (int start, int count)"}, "setChildrenDrawingCacheEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to enable the cache, false to dispose of it"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Enables or disables the drawing cache for each child of this view group.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "protected void setChildrenDrawingCacheEnabled (boolean enabled)"}, "addView(android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["int", "int: the position at which to add the child"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#generateDefaultLayoutParams_E@"], "Permissions": [], "Description": "Adds a child view. If no layout parameters are already set on the child, the default parameters for this ViewGroup are set on the child. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void addView (View child, int index)"}, "removeDetachedView(android.view.View, boolean)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child to be definitely removed from the view hierarchy"], ["boolean", "boolean: if true and the view has an animation, the view is placed in the disappearing views list, otherwise, it is detached from the window"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#attachViewToParent_E@", "@B_android#view#ViewGroup#detachAllViewsFromParent_E@", "@B_android#view#ViewGroup#detachViewFromParent_E@"], "Permissions": [], "Description": "Finishes the removal of a detached view. This method will dispatch the detached from window event and notify the hierarchy change listener. This method is intended to be lightweight and makes no assumptions about whether the parent or child should be redrawn. Proper use of this method will include also making any appropriate @B_android#view#View#requestLayout_E@ or @B_android#view#View#invalidate_E@ calls. For example, callers can @B_android#view#View#post_E@ a @B_java#lang#Runnable_E@ which performs a @B_android#view#View#requestLayout_E@ on the next frame, after all detach/remove calls are finished, causing layout to be run prior to redrawing the view hierarchy.", "history": "added in API level 1", "FullName": "protected void removeDetachedView (View child, boolean animate)"}, "bringChildToFront(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child to bring to the top of the z order"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change the z order of the child so it's on top of all other children. This ordering change may affect layout, if this container uses an order-dependent layout scheme (e.g., LinearLayout). Prior to @B_android#os#Build#VERSION_CODES#KITKAT_E@ this method should be followed by calls to @B_android#view#ViewParent#requestLayout_E@ and @B_android#view#View#invalidate_E@ on this parent to force the parent to redraw with the new child ordering.", "history": "Added in API level 1", "FullName": "public void bringChildToFront (View child)"}, "getChildAt(int)": {"Returns": [["@B_android#view#View_E@", "the view at the specified position or null if the position does not exist within the group"]], "Parameters": [["int", "int: the position at which to get the view from"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the view at the specified position in the group.", "history": "Added in API level 1", "FullName": "public View getChildAt (int index)"}, "scheduleLayoutAnimation()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Schedules the layout animation to be played after the next layout pass of this view group. This can be used to restart the layout animation when the content of the view group changes or when the activity is paused and resumed.", "history": "Added in API level 1", "FullName": "public void scheduleLayoutAnimation ()"}, "setClipToPadding(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to clip children to the padding of the group, and resize (but not clip) any EdgeEffect to the padded region. False otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets whether this ViewGroup will clip its children to its padding and resize (but not clip) any EdgeEffect to the padded region, if padding is present. By default, children are clipped to the padding of their parent ViewGroup. This clipping behavior is only enabled if padding is non-zero.", "history": "Added in API level 1", "FullName": "public void setClipToPadding (boolean clipToPadding)"}, "setAlwaysDrawnWithCacheEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to always draw with the drawing cache, false otherwise"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#isAlwaysDrawnWithCacheEnabled_E@", "@B_android#view#ViewGroup#setChildrenDrawnWithCacheEnabled_E@", "@B_android#view#View#setDrawingCacheEnabled_E@", "@B_android#view#View#setDrawingCacheQuality_E@"], "Permissions": [], "Description": "As of @B_android#os#Build#VERSION_CODES#M_E@, this property is ignored. Child views may no longer have their caching behavior disabled by parents. Indicates whether this ViewGroup will always try to draw its children using their drawing cache. This property can be set to true when the cache rendering is slightly different from the children's normal rendering. Renderings can be different, for instance, when the cache's quality is set to low. When this property is disabled, the ViewGroup will use the drawing cache of its children only when asked to. It's usually the task of subclasses to tell ViewGroup when to start using the drawing cache and when to stop using it.", "history": "Added in API level 1 Deprecated in API level 23", "FullName": "public void setAlwaysDrawnWithCacheEnabled (boolean always)"}, "getTouchscreenBlocksFocus()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check whether this ViewGroup should ignore focus requests for itself and its children.", "history": "Added in API level 21", "FullName": "public boolean getTouchscreenBlocksFocus ()"}, "dispatchSetActivated(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: The new activated state"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch setActivated to all of this View's children.", "history": "Added in API level 11", "FullName": "public void dispatchSetActivated (boolean activated)"}, "measureChildWithMargins(android.view.View,int,int,int,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child to measure"], ["int", "int: The width requirements for this view"], ["int", "int: Extra space that has been used up by the parent horizontally (possibly by other children of the parent)"], ["int", "int: The height requirements for this view"], ["int", "int: Extra space that has been used up by the parent vertically (possibly by other children of the parent)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding and margins. The child must have MarginLayoutParams The heavy lifting is done in getChildMeasureSpec.", "history": "Added in API level 1", "FullName": "protected void measureChildWithMargins (View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)"}, "suppressLayout(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells this ViewGroup to suppress all layout() calls until layout suppression is disabled with a later call to suppressLayout(false). When layout suppression is disabled, a requestLayout() call is sent if layout() was attempted while layout was being suppressed.", "history": "Added in API level 29", "FullName": "public void suppressLayout (boolean suppress)"}, "getNestedScrollAxes()": {"Returns": [["int", "Flags indicating the current axes of nested scrolling"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Return the current axes of nested scrolling for this ViewGroup. A ViewGroup returning something other than @B_android#view#View#SCROLL_AXIS_NONE_E@ is currently acting as a nested scrolling parent for one or more descendant views in the hierarchy.", "history": "Added in API level 21", "FullName": "public int getNestedScrollAxes ()"}, "getLayoutTransition()": {"Returns": [["@B_android#animation#LayoutTransition_E@", "LayoutTranstion The LayoutTransition object that will animated changes in layout. A value of null means no transition will run on layout changes."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the LayoutTransition object for this ViewGroup. If the LayoutTransition object is not null, changes in layout which occur because of children being added to or removed from the ViewGroup will be animated according to the animations defined in that LayoutTransition object. By default, the transition object is null (so layout changes are not animated).", "history": "Added in API level 11", "FullName": "public LayoutTransition getLayoutTransition ()"}, "updateViewLayout(android.view.View,android.view.ViewGroup.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View no parameter comment"], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public void updateViewLayout (View view, ViewGroup.LayoutParams params)"}, "dispatchWindowSystemUiVisiblityChanged(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch callbacks to @B_android#view#View#onWindowSystemUiVisibilityChanged_E@ down the view hierarchy.", "history": "Added in API level 16", "FullName": "public void dispatchWindowSystemUiVisiblityChanged (int visible)"}, "indexOfChild(android.view.View)": {"Returns": [["int", "a positive integer representing the position of the view in the group, or -1 if the view does not exist in the group"]], "Parameters": [["@B_android#view#View_E@", "View: the view for which to get the position"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the position in the group of the specified child view.", "history": "Added in API level 1", "FullName": "public int indexOfChild (View child)"}, "onViewRemoved(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the removed child view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child view is removed from this ViewGroup. Overrides should always call super.onViewRemoved.", "history": "Added in API level 23", "FullName": "public void onViewRemoved (View child)"}, "setStaticTransformationsEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True to enable static transformations on children, false otherwise."]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#getChildStaticTransformation_E@"], "Permissions": [], "Description": "When this property is set to true, this ViewGroup supports static transformations on children; this causes @B_android#view#ViewGroup#getChildStaticTransformation_E@ to be invoked when a child is drawn. Any subclass overriding @B_android#view#ViewGroup#getChildStaticTransformation_E@ should set this property to true.", "history": "Added in API level 3", "FullName": "protected void setStaticTransformationsEnabled (boolean enabled)"}, "dispatchFreezeSelfOnly(android.util.SparseArray<android.os.Parcelable>)": {"Returns": [], "Parameters": [["@B_android#util#SparseArray_E@", "SparseArray: the container"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform dispatching of a @B_android#view#View#saveHierarchyState_E@ freeze()} to only this view, not to its children. For use when overriding @B_android#view#ViewGroup#dispatchSaveInstanceState_E@ dispatchFreeze()} to allow subclasses to freeze their own state but not the state of their children.", "history": "Added in API level 1", "FullName": "protected void dispatchFreezeSelfOnly (SparseArray<Parcelable> container)"}, "hasFocusable()": {"Returns": [["boolean", "True if the view is focusable or if the view contains a focusable View, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view is focusable or if it contains a reachable View for which @B_android#view#View#hasFocusable_E@ returns true. A \"reachable hasFocusable()\" is a View whose parents do not block descendants focus. Only @B_android#view#View#VISIBLE_E@ views are considered focusable.", "history": "Added in API level 1", "FullName": "boolean hasFocusable ()"}, "addViewInLayout(android.view.View,int,android.view.ViewGroup.LayoutParams)": {"Returns": [["boolean", "true if the child was added, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: the view to add to the group"], ["int", "int: the index at which the child must be added or -1 to add last"], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: the layout parameters to associate with the child"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a view during layout. This is useful if in your onLayout() method, you need to add more views (as does the list view for example). If index is negative, it means put it at the end of the list.", "history": "Added in API level 1", "FullName": "protected boolean addViewInLayout (View child, int index, ViewGroup.LayoutParams params)"}, "setPadding(int, int, int, int)": {"Returns": [], "Parameters": [["int", "the left padding in pixels"], ["int", "the top padding in pixels"], ["int", "the right padding in pixels"], ["int", "the bottom padding in pixels"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the padding. The view may add on the space required to display the scrollbars, depending on the style and visibility of the scrollbars. So the values returned from @B_android#view#View#getPaddingLeft_E@, @B_android#view#View#getPaddingTop_E@, @B_android#view#View#getPaddingRight_E@ and @B_android#view#View#getPaddingBottom_E@ may be different from the values set in this call.", "history": "Since: API Level 1", "FullName": "public void setPadding (int left, int top, int right, int bottom)"}, "onDescendantInvalidated(android.view.View,android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: This value must never be null."], ["@B_android#view#View_E@", "View: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The target View has been invalidated, or has had a drawing property changed that requires the hierarchy to re-render. This method is called by the View hierarchy to signal ancestors that a View either needs to re-record its drawing commands, or drawing properties have changed. This is how Views schedule a drawing traversal. This signal is generally only dispatched for attached Views, since only they need to draw. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 26", "FullName": "public void onDescendantInvalidated (View child, View target)"}, "addView(android.view.View, int, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view with this ViewGroup's default layout parameters and the specified width and height. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "added in API level 1", "FullName": "public void addView (View child, int width, int height)"}, "removeViewAt(int)": {"Returns": [], "Parameters": [["int", "int: the position in the group of the view to remove"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes the view at the specified position in the group. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void removeViewAt (int index)"}, "generateDefaultLayoutParams()": {"Returns": [["@B_android#view#ViewGroup#LayoutParams_E@", "a set of default layout parameters or null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a set of default layout parameters. These parameters are requested when the View passed to @B_android#view#ViewGroup#addView_E@ has no layout parameters already set. If null is returned, an exception is thrown from addView.", "history": "Added in API level 1", "FullName": "protected ViewGroup.LayoutParams generateDefaultLayoutParams ()"}, "dispatchDisplayHint(int)": {"Returns": [], "Parameters": [["int", "int: A hint about whether or not this view is displayed: @B_android#view#View#VISIBLE_E@ or @B_android#view#View#INVISIBLE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a hint about whether this view is displayed. For instance, when a View moves out of the screen, it might receives a display hint indicating the view is not displayed. Applications should not rely on this hint as there is no guarantee that they will receive one.", "history": "Added in API level 8", "FullName": "public void dispatchDisplayHint (int hint)"}, "getChildDrawingOrder(int,int)": {"Returns": [["int", "the container position of a child for this drawing order position."]], "Parameters": [["int", "int no parameter comment"], ["int", "int: the drawing order position."]], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@", "@B_android#view#ViewGroup#isChildrenDrawingOrderEnabled_E@"], "Permissions": [], "Description": "Converts drawing order position to container position. Override this if you want to change the drawing order of children. By default, it returns drawingPosition. NOTE: In order for this method to be called, you must enable child ordering first by calling @B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@.", "history": "Added in API level 1", "FullName": "protected int getChildDrawingOrder (int childCount, int drawingPosition)"}, "addView(android.view.View,android.view.ViewGroup.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: the layout parameters to set on the child"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view with the specified layout parameters. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void addView (View child, ViewGroup.LayoutParams params)"}, "addView(android.view.View,int,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view with this ViewGroup's default layout parameters and the specified width and height. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void addView (View child, int width, int height)"}}, "Inheritance": ["@B_android#view#View_E@"], "ClassName": "android.view.ViewGroup", "ClassDesc": "A ViewGroup is a special view that can contain other views (called children.) The view group is the base class for layouts and views containers. This class also defines the @B_android#view#ViewGroup#LayoutParams_E@ class which serves as the base class for layouts parameters. Also see @B_android#view#ViewGroup#LayoutParams_E@ for layout attributes. Here is a complete implementation of a custom ViewGroup that implements a simple @B_android#widget#FrameLayout_E@ along with the ability to stack children in left and right gutters. If you are implementing XML layout attributes as shown in the example, this is the corresponding definition for them that would go in res/values/attrs.xml: Finally the layout manager can be used in an XML layout like so:"}