{"Functions": {"toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of the object. In general, the toString method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:", "history": "", "FullName": "String toString ()"}, "getItemId()": {"Returns": [["long", "The item's id if adapter has stable ids, @B_android#support#v7#widget#RecyclerView#NO_ID_E@ otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns The itemId represented by this ViewHolder.", "history": "added in version 22.0.0", "FullName": "long getItemId ()"}, "getPosition()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#ViewHolder#getLayoutPosition_E@", "@B_android#support#v7#widget#RecyclerView#ViewHolder#getAdapterPosition_E@"], "Permissions": [], "Description": "This method is deprecated because its meaning is ambiguous due to the async handling of adapter updates. Please use @B_android#support#v7#widget#RecyclerView#ViewHolder#getLayoutPosition_E@ or @B_android#support#v7#widget#RecyclerView#ViewHolder#getAdapterPosition_E@ depending on your use case.", "history": "added in version 22.0.0", "FullName": "int getPosition ()"}, "setIsRecyclable(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether this item is available to be recycled. Default value is true."]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#ViewHolder#isRecyclable_E@"], "Permissions": [], "Description": "Informs the recycler whether this item can be recycled. Views which are not recyclable will not be reused for other items until setIsRecyclable() is later set to true. Calls to setIsRecyclable() should always be paired (one call to setIsRecyclabe(false) should always be matched with a later call to setIsRecyclable(true)). Pairs of calls may be nested, as the state is internally reference-counted.", "history": "added in version 22.0.0", "FullName": "void setIsRecyclable (boolean recyclable)"}, "RecyclerView.ViewHolder(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "RecyclerView.ViewHolder (View itemView)"}, "getLayoutPosition()": {"Returns": [["int", "Returns the adapter position of the ViewHolder in the latest layout pass."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#ViewHolder#getAdapterPosition_E@"], "Permissions": [], "Description": "Returns the position of the ViewHolder in terms of the latest layout pass. This position is mostly used by RecyclerView components to be consistent while RecyclerView lazily processes adapter updates. For performance and animation reasons, RecyclerView batches all adapter updates until the next layout pass. This may cause mismatches between the Adapter position of the item and the position it had in the latest layout calculations. LayoutManagers should always call this method while doing calculations based on item positions. All methods in @B_android#support#v7#widget#RecyclerView#LayoutManager_E@, @B_android#support#v7#widget#RecyclerView#State_E@, @B_android#support#v7#widget#RecyclerView#Recycler_E@ that receive a position expect it to be the layout position of the item. If LayoutManager needs to call an external method that requires the adapter position of the item, it can use @B_android#support#v7#widget#RecyclerView#ViewHolder#getAdapterPosition_E@ or @B_android#support#v7#widget#RecyclerView#Recycler#convertPreLayoutPositionToPostLayout_E@.", "history": "added in version 22.0.0", "FullName": "int getLayoutPosition ()"}, "getItemViewType()": {"Returns": [["int", "The view type of this ViewHolder."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "int getItemViewType ()"}, "getAdapterPosition()": {"Returns": [["int", "The adapter position of the item if it still exists in the adapter. @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@ if item has been removed from the adapter, @B_android#support#v7#widget#RecyclerView#Adapter#notifyDataSetChanged_E@ has been called after the last layout pass or the ViewHolder has already been recycled."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the Adapter position of the item represented by this ViewHolder. Note that this might be different than the @B_android#support#v7#widget#RecyclerView#ViewHolder#getLayoutPosition_E@ if there are pending adapter updates but a new layout pass has not happened yet. RecyclerView does not handle any adapter updates until the next layout traversal. This may create temporary inconsistencies between what user sees on the screen and what adapter contents have. This inconsistency is not important since it will be less than 16ms but it might be a problem if you want to use ViewHolder position to access the adapter. Sometimes, you may need to get the exact adapter position to do some actions in response to user events. In that case, you should use this method which will calculate the Adapter position of the ViewHolder. Note that if you've called @B_android#support#v7#widget#RecyclerView#Adapter#notifyDataSetChanged_E@, until the next layout pass, the return value of this method will be @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@.", "history": "added in version 22.0.0", "FullName": "int getAdapterPosition ()"}, "getOldPosition()": {"Returns": [["int", "The previous adapter index of the Item represented by this ViewHolder or @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@ if old position does not exists or cleared (pre-layout is complete)."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "When LayoutManager supports animations, RecyclerView tracks 3 positions for ViewHolders to perform animations. If a ViewHolder was laid out in the previous onLayout call, old position will keep its adapter index in the previous layout.", "history": "added in version 22.0.0", "FullName": "int getOldPosition ()"}, "isRecyclable()": {"Returns": [["boolean", "true if this item is available to be recycled, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#ViewHolder#setIsRecyclable_E@"], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "boolean isRecyclable ()"}}, "Inheritance": ["java.lang.Object"], "ClassName": "android.support.v7.widget.RecyclerView.ViewHolder", "ClassDesc": "A ViewHolder describes an item view and metadata about its place within the RecyclerView. @B_android#support#v7#widget#RecyclerView#Adapter_E@ implementations should subclass ViewHolder and add fields for caching potentially expensive https:##developer#android#com@B_android#view#View#findViewById_E@ results. While @B_android#support#v7#widget#RecyclerView#LayoutParams_E@ belong to the @B_android#support#v7#widget#RecyclerView#LayoutManager_E@, @B_android#support#v7#widget#RecyclerView#ViewHolder_E@ belong to the adapter. Adapters should feel free to use their own custom ViewHolder implementations to store data that makes binding view contents easier. Implementations should assume that individual item views will hold strong references to ViewHolder objects and that RecyclerView instances may hold strong references to extra off-screen item views for caching purposes"}