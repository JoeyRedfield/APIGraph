{"Functions": {"resolveFunction(javax.xml.namespace.QName, int)": {"Returns": [["@B_javax#xml#xpath#XPathFunction_E@", "The function or null if no function named functionName with arity arguments exists."]], "Parameters": [["@B_javax#xml#namespace#QName_E@", "QName: The function name."], ["int", "int: The number of arguments that the returned function must accept."]], "Throws": [["@B_java#lang#NullPointerException_E@", "If functionName or arity is null."]], "SeeAlso": [], "Permissions": [], "Description": "Find a function in the set of available functions. If functionName or arity is null, then a NullPointerException is thrown.", "history": "added in API level 8", "FullName": "public abstract XPathFunction resolveFunction (QName functionName, int arity)"}, "resolveFunction(javax.xml.namespace.QName,int)": {"Returns": [["@B_javax#xml#xpath#XPathFunction_E@", "The function or null if no function named functionName with arity arguments exists."]], "Parameters": [["@B_javax#xml#namespace#QName_E@", "QName: The function name."], ["int", "int: The number of arguments that the returned function must accept."]], "Throws": [["@B_java#lang#NullPointerException_E@", "If functionName or arity is null."]], "SeeAlso": [], "Permissions": [], "Description": "Find a function in the set of available functions. If functionName or arity is null, then a NullPointerException is thrown.", "history": "Added in API level 8", "FullName": "public abstract XPathFunction resolveFunction (QName functionName, int arity)"}}, "Inheritance": [], "ClassName": "javax.xml.xpath.XPathFunctionResolver", "ClassDesc": "XPathFunctionResolver provides access to the set of user defined XPathFunctions. XPath functions are resolved by name and arity. The resolver is not needed for XPath built-in functions and the resolver In particular, the resolver is only called for functions in an another namespace (functions with an explicit prefix). This means that you cannot use the XPathFunctionResolver to implement specifications like If you wish to implement additional built-in functions, you will have to extend the underlying implementation directly."}