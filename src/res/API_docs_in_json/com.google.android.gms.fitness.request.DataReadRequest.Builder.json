{"Functions": {"bucketByActivitySegment(int, java.util.concurrent.TimeUnit)": {"Returns": [], "Parameters": [], "Throws": [["IllegalArgumentException", "if another bucket type is already specified in the request or if an invalid minDuration is specified"]], "SeeAlso": [], "Permissions": [], "Description": "Specifies bucket type as @B_com#google#android#gms#fitness#data#Bucket#TYPE_ACTIVITY_SEGMENT_E@, sets the minimum duration of each @B_com#google#android#gms#fitness#data#DataType#TYPE_ACTIVITY_SEGMENT_E@ for the bucket. An @B_com#google#android#gms#fitness#data#DataType#TYPE_ACTIVITY_SEGMENT_E@ represents a continuous time interval with a single activity value. In this case, each @B_com#google#android#gms#fitness#data#Bucket_E@ will represent an individual activity segment which lies inside the time interval of the request. For instance, if the user had two separate activity segments for walking, one for 1km and another for 2km, the result will be two buckets one with distance value of 1km and another with distance value of 2km. If no activity segments exist recorded for specific time intervals of the read query, a Bucket corresponding to activity type @B_com#google#android#gms#fitness#FitnessActivities#UNKNOWN_E@ will be used instead. For instance, if there is an activity segment for biking from time [20, 30] seconds and for running from time [40, 50] seconds, the result for a read query over [0, 60] will have the following buckets: Only activity segments of duration longer than minDuration are chosen for bucketing. By default, activity segments are chosen from the default data source. To use a specific data source, use @B_com#google#android#gms#fitness#request#DataReadRequest#Builder#bucketByActivitySegment_E@. Detailed data of the aggregate type(s) specified in the request over time interval of each bucket will be aggregated and returned. Each bucket will have one @B_com#google#android#gms#fitness#data#DataSet_E@ of aggregated data for each requested aggregate @B_com#google#android#gms#fitness#data#DataType_E@.", "history": "", "FullName": "public DataReadRequest.Builder bucketByActivitySegment (int minDuration, TimeUnit timeUnit)"}, "aggregate(com.google.android.gms.fitness.data.DataSource, com.google.android.gms.fitness.data.DataType)": {"Returns": [], "Parameters": [["@B_com#google#android#gms#fitness#data#DataSource_E@", "the data source we're reading for aggregate data"], ["@B_com#google#android#gms#fitness#data#DataType_E@", "the output data type that will be returned in the result"]], "Throws": [["IllegalStateException", "if the data source is already requested as detailed"], ["IllegalArgumentException", "if the input data type is not supported for aggregation or if the output aggregate data type is invalid"], ["NullPointerException", "if the data source is null"]], "SeeAlso": [], "Permissions": [], "Description": "Adds a specific data source we want aggregate data from for this request and also sets the output aggregate data type that will be returned. For a list of valid output aggregate data types for a given input data type see @B_com#google#android#gms#fitness#data#DataType#getAggregatesForInput_E@. Aggregation should be requested in conjunction with one of the bucketing strategies: by time, session or activity. At least one valid detailed data source or aggregate data source should be specified in the request. The resulting aggregated data can be queried via @B_com#google#android#gms#fitness#result#DataReadResult#getBuckets_E@ and @B_com#google#android#gms#fitness#data#Bucket#getDataSet_E@.", "history": "", "FullName": "public DataReadRequest.Builder aggregate (DataSource dataSource, DataType outputDataType)"}, "setTimeRange(long, long, java.util.concurrent.TimeUnit)": {"Returns": [], "Parameters": [["long", "a start time, in the given unit since epoch, inclusive"], ["long", "an end time, in the given unit since epoch, inclusive"], ["TimeUnit", "the unit of the start and end timestamps"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the time range for our query. Defined start and end times are required for every read query.", "history": "", "FullName": "public DataReadRequest.Builder setTimeRange (long start, long end, TimeUnit timeUnit)"}, "bucketByTime(int, java.util.concurrent.TimeUnit)": {"Returns": [], "Parameters": [], "Throws": [["IllegalArgumentException", "if another bucket type is already specified in the request or if an invalid duration is specified."]], "SeeAlso": [], "Permissions": [], "Description": "Specifies bucket type as @B_com#google#android#gms#fitness#data#Bucket#TYPE_TIME_E@ and sets the duration of each bucket. The detailed data from the Google Fit store across the time interval of the request is divided into sub-intervals of length duration, and aggregation is then performed over each sub-interval to return one @B_com#google#android#gms#fitness#data#Bucket_E@ of aggregated data per sub-interval. Aggregation is performed for data type(s) specified in the request. Each bucket will have one @B_com#google#android#gms#fitness#data#DataSet_E@ of aggregated data per requested aggregate @B_com#google#android#gms#fitness#data#DataType_E@.", "history": "", "FullName": "public DataReadRequest.Builder bucketByTime (int duration, TimeUnit timeUnit)"}, "setTimeRange(long, long)": {"Returns": [], "Parameters": [["long", "a start time, in milliseconds since epoch, inclusive"], ["long", "an end time, in milliseconds since epoch, inclusive"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the time range for our query. Defined start and end times are required for every read query.", "history": "", "FullName": "public DataReadRequest.Builder setTimeRange (long startTimeMillis, long endTimeMillis)"}, "aggregate(com.google.android.gms.fitness.data.DataType, com.google.android.gms.fitness.data.DataType)": {"Returns": [], "Parameters": [["@B_com#google#android#gms#fitness#data#DataType_E@", "the input data type we're aggregating"], ["@B_com#google#android#gms#fitness#data#DataType_E@", "the output data type that will be returned"]], "Throws": [["IllegalStateException", "if the data type is already requested as detailed"], ["IllegalArgumentException", "if the input data type is not supported for aggregation or if the output data type is invalid"], ["NullPointerException", "if the data type is null"]], "SeeAlso": [], "Permissions": [], "Description": "Adds the default data source for the given aggregate dataType to this request and sets the output aggregate data type to be returned. For a list of valid output aggregate data types for a given input data type see @B_com#google#android#gms#fitness#data#DataType#getAggregatesForInput_E@. The default data source is selected based on all available sources for the given data type, and may be averaged or filtered. Aggregation should be requested in conjunction with one of the bucketing strategy: by time, session or activity. At least one valid detailed data source or aggregate data source should be specified in the request This method can be used instead of @B_com#google#android#gms#fitness#request#DataReadRequest#Builder#aggregate_E@ when the application is not interested in a specific data source. The resulting aggregated data can be queried via @B_com#google#android#gms#fitness#result#DataReadResult#getBuckets_E@ and @B_com#google#android#gms#fitness#data#Bucket#getDataSet_E@.", "history": "", "FullName": "public DataReadRequest.Builder aggregate (DataType inputDataType, DataType outputDataType)"}, "bucketByActivityType(int, java.util.concurrent.TimeUnit)": {"Returns": [], "Parameters": [], "Throws": [["IllegalArgumentException", "if another bucket type is already specified in the request or if an invalid minDuration is specified."]], "SeeAlso": [], "Permissions": [], "Description": "Specifies bucket type as @B_com#google#android#gms#fitness#data#Bucket#TYPE_ACTIVITY_TYPE_E@, sets the minimum duration of each @B_com#google#android#gms#fitness#data#DataType#TYPE_ACTIVITY_SEGMENT_E@ for computing the buckets. In this case, each @B_com#google#android#gms#fitness#data#Bucket_E@ will represent an activity type, and be comprised of aggregated data over all individual activity segments of this activity which lie inside the time interval of the request. For instance, if the user had two separate activity segments of walking during the time interval, one for a distance of 1km and another for a distance of 2km, the result will be one activity bucket with a single aggregate data point for distance with a value of 3km. If no activity segments are recorded for specific time intervals of the read query, segments of type @B_com#google#android#gms#fitness#FitnessActivities#UNKNOWN_E@ will be added for these intervals and used to compute an aggregate bucket of activity type Unknown. Only activity segments of duration longer than minDuration are chosen for bucketing. By default, activity segments are chosen from the default data source. To use a specific data source, use @B_com#google#android#gms#fitness#request#DataReadRequest#Builder#bucketByActivitySegment_E@. Detailed data of the aggregate type(s) specified in the request over time interval of each bucket will be aggregated and returned. Each bucket will have one @B_com#google#android#gms#fitness#data#DataSet_E@ of aggregated data for each requested aggregate @B_com#google#android#gms#fitness#data#DataType_E@.", "history": "", "FullName": "public DataReadRequest.Builder bucketByActivityType (int minDuration, TimeUnit timeUnit)"}, "enableServerQueries()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Enable querying the Google Fit server to fetch query results, in case the local store doesn't have data for the full requested time range. Server results will be combined with local results into one DataSet. Note that querying the server adds latency, specially under poor network conditions. Also note that attempting to query the server when there is no network connection may result in a", "history": "", "FullName": "public DataReadRequest.Builder enableServerQueries ()"}, "DataReadRequest.Builder()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "public DataReadRequest.Builder ()"}, "read(com.google.android.gms.fitness.data.DataType)": {"Returns": [], "Parameters": [["@B_com#google#android#gms#fitness#data#DataType_E@", "the data type we're reading"]], "Throws": [["IllegalStateException", "if the data type is already requested as aggregate"], ["NullPointerException", "if the data type is null"]], "SeeAlso": [], "Permissions": [], "Description": "Adds the default data source to read for the given dataType to this request. The default data source is selected based on all available sources for the given data type, and may be averaged or filtered. At least one valid detailed data source or aggregate data source should be specified in the request. This method can be used instead of @B_com#google#android#gms#fitness#request#DataReadRequest#Builder#read_E@ when the application is not interested in a specific data source. The resulting unaggregated data can be queried via @B_com#google#android#gms#fitness#result#DataReadResult#getDataSet_E@.", "history": "", "FullName": "public DataReadRequest.Builder read (DataType dataType)"}, "read(com.google.android.gms.fitness.data.DataSource)": {"Returns": [], "Parameters": [["@B_com#google#android#gms#fitness#data#DataSource_E@", "the data source we're reading"]], "Throws": [["IllegalArgumentException", "if the data source is already requested as aggregate"], ["NullPointerException", "if the data source is null"]], "SeeAlso": [], "Permissions": [], "Description": "Adds a specific data source we want to read data from to this request. At least one valid detailed data source or aggregate data source should be specified in the request. The resulting unaggregated data can be queried via @B_com#google#android#gms#fitness#result#DataReadResult#getDataSet_E@.", "history": "", "FullName": "public DataReadRequest.Builder read (DataSource dataSource)"}, "bucketBySession(int, java.util.concurrent.TimeUnit)": {"Returns": [], "Parameters": [], "Throws": [["IllegalArgumentException", "if another bucket type is already specified in the request or if an invalid minDuration is specified"]], "SeeAlso": [], "Permissions": [], "Description": "Specifies bucket type as @B_com#google#android#gms#fitness#data#Bucket#TYPE_SESSION_E@ and sets the minimum duration of each @B_com#google#android#gms#fitness#data#Session_E@ for the bucket. A @B_com#google#android#gms#fitness#data#Session_E@ represents a time interval with associate meta data to store user-visible groups of related data. In this case, each bucket will signify a session which lies inside the time interval of the request. Detailed data of the aggregate type(s) specified in the request over time interval of each bucket will be aggregated and returned. Each bucket will have one @B_com#google#android#gms#fitness#data#DataSet_E@ of aggregated data for each requested aggregate @B_com#google#android#gms#fitness#data#DataType_E@..", "history": "", "FullName": "public DataReadRequest.Builder bucketBySession (int minDuration, TimeUnit timeUnit)"}, "bucketByActivitySegment(int, java.util.concurrent.TimeUnit, com.google.android.gms.fitness.data.DataSource)": {"Returns": [], "Parameters": [], "Throws": [["IllegalArgumentException", "if another bucket type is already specified in the request or if an invalid minDuration is specified"]], "SeeAlso": [], "Permissions": [], "Description": "Specifies bucket type as @B_com#google#android#gms#fitness#data#Bucket#TYPE_ACTIVITY_SEGMENT_E@, sets the minimum duration of each @B_com#google#android#gms#fitness#data#DataType#TYPE_ACTIVITY_SEGMENT_E@ for the bucket. An @B_com#google#android#gms#fitness#data#DataType#TYPE_ACTIVITY_SEGMENT_E@ represents a continuous time interval with a single activity value. In this case, each @B_com#google#android#gms#fitness#data#Bucket_E@ will represent an individual activity segment which lies inside the time interval of the request. For instance, if the user had two separate activity segments for walking, one for 1km and another for 2km, the result will be two buckets one with distance value of 1km and another with distance value of 2km. If no activity segments exist recorded for specific time intervals of the read query, a Bucket corresponding to activity type @B_com#google#android#gms#fitness#FitnessActivities#UNKNOWN_E@ will be added for each missing interval. For instance, if there is an activity segment for biking from time [20, 30] seconds and for running from time [40, 50] seconds, the result for a read query over [0, 60] will have the following buckets: Only activity segments of duration longer than minDuration are chosen for bucketing. The activity segments are chosen from the specified activityDataSource. To use the default activity data source, use @B_com#google#android#gms#fitness#request#DataReadRequest#Builder#bucketByActivitySegment_E@. Detailed data of the aggregate type(s) specified in the request over time interval of each bucket will be aggregated and returned. Each bucket will have one @B_com#google#android#gms#fitness#data#DataSet_E@ of aggregated data for each requested aggregate @B_com#google#android#gms#fitness#data#DataType_E@.", "history": "", "FullName": "public DataReadRequest.Builder bucketByActivitySegment (int minDuration, TimeUnit timeUnit, DataSource activityDataSource)"}, "setLimit(int)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Limits results to the latest limit data points. This parameter is ignored for aggregated queries. By default there is no limit. This method is useful to reduce the amount of sent data as well as to support scenarios like requesting the current (limit == 1 to get the latest value) weight or height.", "history": "", "FullName": "public DataReadRequest.Builder setLimit (int limit)"}, "build()": {"Returns": [], "Parameters": [], "Throws": [["IllegalStateException", "if the builder doesn't have enough state to create a valid request"]], "SeeAlso": [], "Permissions": [], "Description": "Finishes building and returns the request.", "history": "", "FullName": "public DataReadRequest build ()"}, "bucketByActivityType(int, java.util.concurrent.TimeUnit, com.google.android.gms.fitness.data.DataSource)": {"Returns": [], "Parameters": [], "Throws": [["IllegalArgumentException", "if another bucket type is already specified in the request or if an invalid minDuration is specified or if an invalid activity data source is specified."]], "SeeAlso": [], "Permissions": [], "Description": "Specifies bucket type as @B_com#google#android#gms#fitness#data#Bucket#TYPE_ACTIVITY_TYPE_E@, sets the minimum duration of each @B_com#google#android#gms#fitness#data#DataType#TYPE_ACTIVITY_SEGMENT_E@ for computing the buckets and sets the activity data source to be used to read activity segments from. In this case, each @B_com#google#android#gms#fitness#data#Bucket_E@ will represent an activity type, and be comprised of aggregated data over all individual activity segments of this activity which lie inside the time interval of the request. For instance, if the user had two separate activity segments of walking during the time interval, one for a distance of 1km and another for a distance of 2km, the result will be one activity bucket with a single aggregate data point for distance with a value of 3km. If no activity segments are recorded for specific time intervals of the read query, segments of type @B_com#google#android#gms#fitness#FitnessActivities#UNKNOWN_E@ will be added for these intervals and used to compute an aggregate bucket of activity type Unknown. Only activity segments of duration longer than minDuration are chosen for bucketing. The activity segments are chosen from the specified activityDataSource. To use the default activity segment data source use @B_com#google#android#gms#fitness#request#DataReadRequest#Builder#bucketByActivityType_E@. Detailed data of the aggregate type(s) specified in the request over time interval of each bucket will be aggregated and returned. Each bucket will have one @B_com#google#android#gms#fitness#data#DataSet_E@ of aggregated data for each requested aggregate @B_com#google#android#gms#fitness#data#DataType_E@.", "history": "", "FullName": "public DataReadRequest.Builder bucketByActivityType (int minDuration, TimeUnit timeUnit, DataSource activityDataSource)"}}, "Inheritance": ["java.lang.Object"], "ClassName": "com.google.android.gms.fitness.request.DataReadRequest.Builder", "ClassDesc": "Builder used to create new DataReadRequests."}