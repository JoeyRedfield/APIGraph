{"Functions": {"getRecords()": {"Returns": [["@B_android#nfc#NdefRecord_E@", "array of one or more NDEF records."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the NDEF Records inside this NDEF Message. An @B_android#nfc#NdefMessage_E@ always has one or more NDEF Records: so the following code to retrieve the first record is always safe (no need to check for null or array length >= 1):", "history": "Added in API level 9", "FullName": "public NdefRecord[] getRecords ()"}, "writeToParcel(android.os.Parcel, int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "added in API level 9", "FullName": "public void writeToParcel (Parcel dest, int flags)"}, "NdefMessage(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: raw bytes to parse"]], "Throws": [["@B_android#nfc#FormatException_E@", "if the data cannot be parsed"]], "SeeAlso": [], "Permissions": [], "Description": "Construct an NDEF Message by parsing raw bytes. Strict validation of the NDEF binary structure is performed: there must be at least one record, every record flag must be correct, and the total length of the message must match the length of the input data. This parser can handle chunked records, and converts them into logical @B_android#nfc#NdefRecord_E@s within the message. Once the input data has been parsed to one or more logical records, basic validation of the tnf, type, id, and payload fields of each record is performed, as per the documentation on on @B_android#nfc#NdefRecord#NdefRecord_E@ If either strict validation of the binary format fails, or basic validation during record construction fails, a @B_android#nfc#FormatException_E@ is thrown Deep inspection of the type, id and payload fields of each record is not performed, so it is possible to parse input that has a valid binary format and confirms to the basic validation requirements of @B_android#nfc#NdefRecord#NdefRecord_E@, but fails more strict requirements as specified by the NFC Forum. It is safe to re-use the data byte array after construction: this constructor will make an internal copy of all necessary fields.", "history": "Added in API level 9", "FullName": "public NdefMessage (byte[] data)"}, "getByteArrayLength()": {"Returns": [["int", "length of this NDEF Message when written to bytes with @B_android#nfc#NdefMessage#toByteArray_E@"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#nfc#NdefMessage#toByteArray_E@"], "Permissions": [], "Description": "Return the length of this NDEF Message if it is written to a byte array with @B_android#nfc#NdefMessage#toByteArray_E@. An NDEF Message can be formatted to bytes in different ways depending on chunking, SR, and ID flags, so the length returned by this method may not be equal to the length of the original byte array used to construct this NDEF Message. However it will always be equal to the length of the byte array produced by @B_android#nfc#NdefMessage#toByteArray_E@.", "history": "Added in API level 16", "FullName": "public int getByteArrayLength ()"}, "NdefMessage(android.nfc.NdefRecord[])": {"Returns": [], "Parameters": [["@B_android#nfc#NdefRecord_E@", "NdefRecord: one or more records"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Construct an NDEF Message from one or more NDEF Records.", "history": "Added in API level 9", "FullName": "public NdefMessage (NdefRecord[] records)"}, "describeContents()": {"Returns": [["int", "a bitmask indicating the set of special object types marshaled by this Parcelable object instance. Value is either 0 or @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Describe the kinds of special objects contained in this Parcelable instance's marshaled representation. For example, if the object will include a file descriptor in the output of @B_android#os#Parcelable#writeToParcel_E@, the return value of this method must include the @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@ bit.", "history": "Added in API level 9", "FullName": "public int describeContents ()"}, "toByteArray()": {"Returns": [["byte[]", "NDEF Message in binary format"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#nfc#NdefMessage#getByteArrayLength_E@"], "Permissions": [], "Description": "Return this NDEF Message as raw bytes. The NDEF Message is formatted as per the NDEF 1.0 specification, and the byte array is suitable for network transmission or storage in an NFC Forum NDEF compatible tag. This method will not chunk any records, and will always use the short record (SR) format and omit the identifier field when possible.", "history": "Added in API level 9", "FullName": "public byte[] toByteArray ()"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of the object. In general, the toString method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:", "history": "Added in API level 9", "FullName": "public String toString ()"}, "NdefMessage(android.nfc.NdefRecord,android.nfc.NdefRecord...)": {"Returns": [], "Parameters": [["@B_android#nfc#NdefRecord_E@", "NdefRecord: first record (mandatory)"], ["@B_android#nfc#NdefRecord_E@", "NdefRecord: additional records (optional)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Construct an NDEF Message from one or more NDEF Records.", "history": "Added in API level 16", "FullName": "public NdefMessage (NdefRecord record, NdefRecord... records)"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if this object is the same as the obj argument; false otherwise."]], "Parameters": [["@B_java#lang#Object_E@", "Object: the reference object with which to compare."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the specified NDEF Message contains identical NDEF Records.", "history": "Added in API level 9", "FullName": "public boolean equals (Object obj)"}, "writeToParcel(android.os.Parcel,int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@. Value is either 0 or a combination of @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "Added in API level 9", "FullName": "public void writeToParcel (Parcel dest, int flags)"}, "hashCode()": {"Returns": [["int", "a hash code value for this object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by @B_java#util#HashMap_E@. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the @B_java#lang#Object#equals_E@ method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java\u2122 programming language.)", "history": "Added in API level 9", "FullName": "public int hashCode ()"}}, "Inheritance": [], "ClassName": "android.nfc.NdefMessage", "ClassDesc": "Represents an immutable NDEF Message. NDEF (NFC Data Exchange Format) is a light-weight binary format, used to encapsulate typed data. It is specified by the NFC Forum, for transmission and storage with NFC, however it is transport agnostic. NDEF defines messages and records. An NDEF Record contains typed data, such as MIME-type media, a URI, or a custom application payload. An NDEF Message is a container for one or more NDEF Records. When an Android device receives an NDEF Message (for example by reading an NFC tag) it processes it through a dispatch mechanism to determine an activity to launch. The type of the first record in the message has special importance for message dispatch, so design this record carefully. Use @B_android#nfc#NdefMessage#NdefMessage_E@ to construct an NDEF Message from binary data, or @B_android#nfc#NdefMessage#NdefMessage_E@ to construct from one or more @B_android#nfc#NdefRecord_E@s. @B_android#nfc#NdefMessage_E@ and @B_android#nfc#NdefRecord_E@ implementations are always available, even on Android devices that do not have NFC hardware. @B_android#nfc#NdefRecord_E@s are intended to be immutable (and thread-safe), however they may contain mutable fields. So take care not to modify mutable fields passed into constructors, or modify mutable fields obtained by getter methods, unless such modification is explicitly marked as safe."}