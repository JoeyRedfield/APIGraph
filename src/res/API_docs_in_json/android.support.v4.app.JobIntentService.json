{"Functions": {"JobIntentService()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default empty constructor.", "history": "added in version 26.0.0-beta2", "FullName": "JobIntentService ()"}, "onCreate()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system when the service is first created. Do not call this method directly.", "history": "", "FullName": "void onCreate ()"}, "onDestroy()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system to notify a Service that it is no longer used and is being removed. The service should clean up any resources it holds (threads, registered receivers, etc) at this point. Upon return, there will be no more calls in to this Service object and it is effectively dead. Do not call this method directly.", "history": "", "FullName": "void onDestroy ()"}, "onHandleWork(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent describing the work to now be processed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called serially for each work dispatched to and processed by the service. This method is called on a background thread, so you can do long blocking operations here. Upon returning, that work will be considered complete and either the next pending work dispatched here or the overall service destroyed now that it has nothing else to do. Be aware that when running as a job, you are limited by the maximum job execution time and any single or total sequential items of work that exceeds that limit will cause the service to be stopped while in progress and later restarted with the last unfinished work. (There is currently no limit on execution duration when running as a pre-O plain Service.)", "history": "added in version 26.0.0-beta2", "FullName": "void onHandleWork (Intent intent)"}, "onStartCommand(android.content.Intent, int, int)": {"Returns": [["int", "The return value indicates what semantics the system should use for the service's current started state. It may be one of the constants associated with the @B_android#app#Service#START_CONTINUATION_MASK_E@ bits."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent supplied to @B_android#content#Context#startService_E@, as given. This may be null if the service is being restarted after its process has gone away, and it had previously returned anything except @B_android#app#Service#START_STICKY_COMPATIBILITY_E@."], ["int", "int: Additional data about this start request."], ["int", "int: A unique integer representing this specific request to start. Use with @B_android#app#Service#stopSelfResult_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Processes start commands when running as a pre-O service, enqueueing them to be later dispatched in @B_android#support#v4#app#JobIntentService#onHandleWork_E@.", "history": "", "FullName": "int onStartCommand (Intent intent, int flags, int startId)"}, "onBind(android.content.Intent)": {"Returns": [["@B_android#os#IBinder_E@", "Return an IBinder through which clients can call on to the service."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent that was used to bind to this service, as given to @B_android#content#Context#bindService_E@. Note that any extras that were included with the Intent at that point will not be seen here."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the IBinder for the @B_android#app#job#JobServiceEngine_E@ when running as a JobService on O and later platforms.", "history": "added in version 26.0.0-beta2", "FullName": "IBinder onBind (Intent intent)"}, "onStopCurrentWork()": {"Returns": [["boolean", "True to indicate to the JobManager whether you'd like to reschedule this work, false to drop this and all following work. Regardless of the value returned, your service must stop executing or the system will ultimately kill it. The default implementation returns true, and that is most likely what you want to return as well (so no work gets lost)."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This will be called if the JobScheduler has decided to stop this job. The job for this service does not have any constraints specified, so this will only generally happen if the service exceeds the job's maximum execution time.", "history": "added in version 26.0.0-beta2", "FullName": "boolean onStopCurrentWork ()"}}, "Inheritance": ["java.lang.Object", "https:##developer#android#com@B_android#content#Context_E@", "https:##developer#android#com@B_android#content#ContextWrapper_E@", "https:##developer#android#com@B_android#app#Service_E@"], "ClassName": "android.support.v4.app.JobIntentService", "ClassDesc": "Helper for processing work that has been enqueued for a job/service. When running on https:##developer#android#com@B_android#os#Build#VERSION_CODES#O_E@ or later, the work will be dispatched as a job via https:##developer#android#com@B_android#app#job#JobScheduler#enqueue_E@. When running on older versions of the platform, it will use https:##developer#android#com@B_android#content#Context#startService_E@. You must publish your subclass in your manifest for the system to interact with. This should be published as a https:##developer#android#com@B_android#app#job#JobService_E@, as described for that class, since on O and later platforms it will be executed that way. Use @B_android#support#v4#app#JobIntentService#enqueueWork_E@ to enqueue new work to be dispatched to and handled by your service. It will be executed in @B_android#support#v4#app#JobIntentService#onHandleWork_E@. You do not need to use @B_android#support#v4#content#WakefulBroadcastReceiver_E@ when using this class. When running on https:##developer#android#com@B_android#os#Build#VERSION_CODES#O_E@, the JobScheduler will take care of wake locks for you (holding a wake lock from the time you enqueue work until the job has been dispatched and while it is running). When running on previous versions of the platform, this wake lock handling is emulated in the class here by directly calling the PowerManager; this means the application must request the @B_android#Manifest#permission#WAKE_LOCK_E@ permission. There are a few important differences in behavior when running on https:##developer#android#com@B_android#os#Build#VERSION_CODES#O_E@ or later as a Job vs. pre-O: When running as a pre-O service, the act of enqueueing work will generally start the service immediately, regardless of whether the device is dozing or in other conditions. When running as a Job, it will be subject to standard JobScheduler policies for a Job with a https:##developer#android#com@B_android#app#job#JobInfo#Builder#setOverrideDeadline_E@ of 0: the job will not run while the device is dozing, it may get delayed more than a service if the device is under strong memory pressure with lots of demand to run jobs. When running as a pre-O service, the normal service execution semantics apply: the service can run indefinitely, though the longer it runs the more likely the system will be to outright kill its process, and under memory pressure one should expect the process to be killed even of recently started services. When running as a Job, the typical https:##developer#android#com@B_android#app#job#JobService_E@ execution time limit will apply, after which the job will be stopped (cleanly, not by killing the process) and rescheduled to continue its execution later. Job are generally not killed when the system is under memory pressure, since the number of concurrent jobs is adjusted based on the memory state of the device. Here is an example implementation of this class:"}