{"Functions": {"unregisterActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks)": {"Returns": [], "Parameters": [["@B_android#app#Application#ActivityLifecycleCallbacks_E@", "Application.ActivityLifecycleCallbacks: The callback instance to unregister This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#registerActivityLifecycleCallbacks_E@"], "Permissions": [], "Description": "Unregister an @B_android#app#Application#ActivityLifecycleCallbacks_E@ previously registered with @B_android#app#Activity#registerActivityLifecycleCallbacks_E@. It will not receive any further callbacks.", "history": "Added in API level 29", "FullName": "public void unregisterActivityLifecycleCallbacks (Application.ActivityLifecycleCallbacks callback)"}, "startActivities(android.content.Intent[],android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intents to start."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. This value may be null."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Activity#startActivities_E@", "@B_android#app#Activity#startActivityForResult_E@"], "Permissions": [], "Description": "Launch a new activity. You will not receive any information about when the activity exits. This implementation overrides the base version, providing information about the activity performing the launch. Because of this additional information, the @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@ launch flag is not required; if not specified, the new activity will be added to the task of the caller. This method throws @B_android#content#ActivityNotFoundException_E@ if there was no Activity found to run the given Intent.", "history": "Added in API level 16", "FullName": "public void startActivities (Intent[] intents, Bundle options)"}, "dispatchTrackballEvent(android.view.MotionEvent)": {"Returns": [["boolean", "boolean Return true if this event was consumed."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The trackball event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to process trackball events. You can override this to intercept all trackball events before they are dispatched to the window. Be sure to call this implementation for trackball events that should be handled normally.", "history": "Added in API level 1", "FullName": "public boolean dispatchTrackballEvent (MotionEvent ev)"}, "onProvideReferrer()": {"Returns": [["@B_android#net#Uri_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Override to generate the desired referrer for the content currently being shown by the app. The default implementation returns null, meaning the referrer will simply be the android-app: of the package name of this activity. Return a non-null Uri to have that supplied as the @B_android#content#Intent#EXTRA_REFERRER_E@ of any activities started from it.", "history": "Added in API level 23", "FullName": "public Uri onProvideReferrer ()"}, "setImmersive(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#isImmersive_E@", "@B_android#content#pm#ActivityInfo_E@"], "Permissions": [], "Description": "Adjust the current immersive mode setting. Note that changing this value will have no effect on the activity's @B_android#content#pm#ActivityInfo_E@ structure; that is, if android:immersive is set to true in the application's manifest entry for this activity, the @B_android#content#pm#ActivityInfo#flags_E@ member will always have its @B_android#content#pm#ActivityInfo#FLAG_IMMERSIVE_E@ bit set.", "history": "Added in API level 18", "FullName": "public void setImmersive (boolean i)"}, "managedQuery(android.net.Uri,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String)": {"Returns": [["@B_android#database#Cursor_E@", "The Cursor that was returned by query()."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The URI of the content provider to query."], ["@B_java#lang#String_E@", "String: List of columns to return."], ["@B_java#lang#String_E@", "String: SQL WHERE clause."], ["@B_java#lang#String_E@", "String: The arguments to selection, if any ?s are pesent"], ["@B_java#lang#String_E@", "String: SQL ORDER BY clause."]], "Throws": [], "SeeAlso": ["@B_android#content#ContentResolver#query_E@", "@B_android#app#Activity#startManagingCursor_E@"], "Permissions": [], "Description": "Use @B_android#content#CursorLoader_E@ instead. Wrapper around @B_android#content#ContentResolver#query_E@ that gives the resulting @B_android#database#Cursor_E@ to call @B_android#app#Activity#startManagingCursor_E@ so that the activity will manage its lifecycle for you. If you are targeting @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ or later, consider instead using @B_android#app#LoaderManager_E@ instead, available via @B_android#app#Activity#getLoaderManager_E@. @B_android#database#Cursor#close_E@ on a cursor obtained using this method, because the activity will do that for you at the appropriate time. However, if you call @B_android#app#Activity#stopManagingCursor_E@ on a cursor from a managed query, the system will not automatically close the cursor and, in that case, you must call @B_android#database#Cursor#close_E@.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public final Cursor managedQuery (Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)"}, "getTaskId()": {"Returns": [["int", "Task identifier, an opaque integer."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the identifier of the task this activity is in. This identifier will remain the same for the lifetime of the activity.", "history": "Added in API level 1", "FullName": "public int getTaskId ()"}, "hasWindowFocus()": {"Returns": [["boolean", "True if this activity's main window currently has window focus."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onWindowAttributesChanged_E@"], "Permissions": [], "Description": "Returns true if this activity's main window currently has window focus. Note that this is not the same as the view itself having focus.", "history": "Added in API level 3", "FullName": "public boolean hasWindowFocus ()"}, "findViewById(int)": {"Returns": [["T", "a view with given ID if found, or null otherwise"]], "Parameters": [["int", "int: the ID to search for"]], "Throws": [], "SeeAlso": ["@B_android#view#View#findViewById_E@", "@B_android#app#Activity#requireViewById_E@"], "Permissions": [], "Description": "Finds a view that was identified by the android:id XML attribute that was processed in @B_android#app#Activity#onCreate_E@.", "history": "Added in API level 1", "FullName": "public T findViewById (int id)"}, "getLocalClassName()": {"Returns": [["@B_java#lang#String_E@", "The local class name. This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns class name for this activity with the package prefix removed. This is the default name used to read and write settings.", "history": "Added in API level 1", "FullName": "public String getLocalClassName ()"}, "onConfigurationChanged(android.content.res.Configuration)": {"Returns": [], "Parameters": [["@B_android#content#res#Configuration_E@", "Configuration: The new device configuration. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system when the device configuration changes while your activity is running. Note that this will only be called if you have selected configurations you would like to handle with the @B_android#R#attr#configChanges_E@ attribute in your manifest. If any configuration change occurs that is not selected to be reported by that attribute, then instead of reporting it the system will stop and restart the activity (to have it launched with the new configuration). At the time that this function has been called, your Resources object will have been updated to return resource values matching the new configuration.", "history": "Added in API level 1", "FullName": "public void onConfigurationChanged (Configuration newConfig)"}, "setContentTransitionManager(android.transition.TransitionManager)": {"Returns": [], "Parameters": [["@B_android#transition#TransitionManager_E@", "TransitionManager: The TransitionManager to use for scene changes."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the @B_android#transition#TransitionManager_E@ to use for default transitions in this window. Requires @B_android#view#Window#FEATURE_CONTENT_TRANSITIONS_E@.", "history": "Added in API level 21", "FullName": "public void setContentTransitionManager (TransitionManager tm)"}, "onBackPressed()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the activity has detected the user's press of the back key. The default implementation simply finishes the current activity, but you can override this to do whatever you want.", "history": "Added in API level 5", "FullName": "public void onBackPressed ()"}, "onCreate(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: If the activity is being re-initialized after previously being shut down then this Bundle contains the data it most recently supplied in @B_android#app#Activity#onSaveInstanceState_E@. Note: Otherwise it is null. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onStart_E@", "@B_android#app#Activity#onSaveInstanceState_E@", "@B_android#app#Activity#onRestoreInstanceState_E@", "@B_android#app#Activity#onPostCreate_E@"], "Permissions": [], "Description": "Called when the activity is starting. This is where most initialization should go: calling @B_android#app#Activity#setContentView_E@ to inflate the activity's UI, using @B_android#app#Activity#findViewById_E@ to programmatically interact with widgets in the UI, calling @B_android#app#Activity#managedQuery_E@ to retrieve cursors for data being displayed, etc. You can call @B_android#app#Activity#finish_E@ from within this function, in which case onDestroy() will be immediately called after @B_android#app#Activity#onCreate_E@ without any of the rest of the activity lifecycle (@B_android#app#Activity#onStart_E@, @B_android#app#Activity#onResume_E@, @B_android#app#Activity#onPause_E@, etc) executing. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. This method must be called from the If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onCreate (Bundle savedInstanceState)"}, "onKeyMultiple(int, int, android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["int", "int: Number of pairs as returned by event.getRepeatCount()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyMultiple_E@: always returns false (doesn't handle the event).", "history": "added in API level 1", "FullName": "public boolean onKeyMultiple (int keyCode, int repeatCount, KeyEvent event)"}, "onProvideAssistContent(android.app.assist.AssistContent)": {"Returns": [], "Parameters": [["@B_android#app#assist#AssistContent_E@", "AssistContent: The assist content to return."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the user is requesting an assist, to provide references to content related to the current activity. Before being called, the outContent Intent is filled with the base Intent of the activity (the Intent returned by @B_android#app#Activity#getIntent_E@). The Intent's extras are stripped of any types that are not valid for @B_android#os#PersistableBundle_E@ or non-framework Parcelables, and the flags @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@ and @B_android#content#Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION_E@ are cleared from the Intent. Custom implementation may adjust the content intent to better reflect the top-level context of the activity, and fill in its ClipData with additional content of interest that the user is currently viewing. For example, an image gallery application that has launched in to an activity allowing the user to swipe through pictures should modify the intent to reference the current image they are looking it; such an application when showing a list of pictures should add a ClipData that has references to all of the pictures currently visible on screen.", "history": "Added in API level 23", "FullName": "public void onProvideAssistContent (AssistContent outContent)"}, "onSearchRequested()": {"Returns": [["boolean", "true if search launched, false if activity refuses (blocks)"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onSearchRequested_E@"], "Permissions": [], "Description": "Called when the user signals the desire to start a search.", "history": "Added in API level 1", "FullName": "public boolean onSearchRequested ()"}, "onTopResumedActivityChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if it's the topmost resumed activity in the system, false otherwise. A call with this as true will always be followed by another one with false."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onResume_E@", "@B_android#app#Activity#onPause_E@", "@B_android#app#Activity#onWindowFocusChanged_E@"], "Permissions": [], "Description": "Called when activity gets or loses the top resumed position in the system. Starting with @B_android#os#Build#VERSION_CODES#Q_E@ multiple activities can be resumed at the same time in multi-window and multi-display modes. This callback should be used instead of @B_android#app#Activity#onResume_E@ as an indication that the activity can try to open exclusive-access devices like camera. It will always be delivered after the activity was resumed and before it is paused. In some cases it might be skipped and activity can go straight from @B_android#app#Activity#onResume_E@ to @B_android#app#Activity#onPause_E@ without receiving the top resumed state.", "history": "Added in API level 29", "FullName": "public void onTopResumedActivityChanged (boolean isTopResumedActivity)"}, "dispatchTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "boolean Return true if this event was consumed."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The touch screen event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to process touch screen events. You can override this to intercept all touch screen events before they are dispatched to the window. Be sure to call this implementation for touch screen events that should be handled normally.", "history": "Added in API level 1", "FullName": "public boolean dispatchTouchEvent (MotionEvent ev)"}, "onPanelClosed(int,android.view.Menu)": {"Returns": [], "Parameters": [["int", "int: The panel that is being displayed."], ["@B_android#view#Menu_E@", "Menu: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#Window#Callback#onPanelClosed_E@ for activities. This calls through to @B_android#app#Activity#onOptionsMenuClosed_E@ method for the @B_android#view#Window#FEATURE_OPTIONS_PANEL_E@ panel, so that subclasses of Activity don't need to deal with feature codes. For context menus (@B_android#view#Window#FEATURE_CONTEXT_MENU_E@), the @B_android#app#Activity#onContextMenuClosed_E@ will be called.", "history": "Added in API level 1", "FullName": "public void onPanelClosed (int featureId, Menu menu)"}, "onUserInteraction()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onUserLeaveHint_E@"], "Permissions": [], "Description": "Called whenever a key, touch, or trackball event is dispatched to the activity. Implement this method if you wish to know that the user has interacted with the device in some way while your activity is running. This callback and @B_android#app#Activity#onUserLeaveHint_E@ are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notification. All calls to your activity's @B_android#app#Activity#onUserLeaveHint_E@ callback will be accompanied by calls to @B_android#app#Activity#onUserInteraction_E@. This ensures that your activity will be told of relevant user activity such as pulling down the notification pane and touching an item there. Note that this callback will be invoked for the touch down action that begins a touch gesture, but may not be invoked for the touch-moved and touch-up actions that follow.", "history": "Added in API level 3", "FullName": "public void onUserInteraction ()"}, "onKeyMultiple(int,int,android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["int", "int: Number of pairs as returned by event.getRepeatCount()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyMultiple_E@: always returns false (doesn't handle the event).", "history": "Added in API level 1", "FullName": "public boolean onKeyMultiple (int keyCode, int repeatCount, KeyEvent event)"}, "onDetachedFromWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#onDetachedFromWindow_E@"], "Permissions": [], "Description": "Called when the main window associated with the activity has been detached from the window manager. See @B_android#view#View#onDetachedFromWindow_E@ for more information.", "history": "Added in API level 5", "FullName": "public void onDetachedFromWindow ()"}, "requestShowKeyboardShortcuts()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request the Keyboard Shortcuts screen to show up. This will trigger @B_android#app#Activity#onProvideKeyboardShortcuts_E@ to retrieve the shortcuts for the foreground activity.", "history": "Added in API level 24", "FullName": "public final void requestShowKeyboardShortcuts ()"}, "onKeyDown(int,android.view.KeyEvent)": {"Returns": [["boolean", "Return true to prevent this event from being propagated further, or false to indicate that you have not handled this event and it should continue to be propagated."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onKeyUp_E@", "@B_android#view#KeyEvent_E@"], "Permissions": [], "Description": "Called when a key was pressed down and not handled by any of the views inside of the activity. So, for example, key presses while the cursor is inside a TextView will not trigger the event (unless it is a navigation to another object) because TextView handles its own key presses. If the focused view didn't want this event, this method is called. The default implementation takes care of @B_android#view#KeyEvent#KEYCODE_BACK_E@ by calling @B_android#app#Activity#onBackPressed_E@, though the behavior varies based on the application compatibility mode: for @B_android#os#Build#VERSION_CODES#ECLAIR_E@ or later applications, it will set up the dispatch to call @B_android#app#Activity#onKeyUp_E@ where the action will be performed; for earlier applications, it will perform the action immediately in on-down, as those versions of the platform behaved. Other additional default key handling may be performed if configured with @B_android#app#Activity#setDefaultKeyMode_E@.", "history": "Added in API level 1", "FullName": "public boolean onKeyDown (int keyCode, KeyEvent event)"}, "createPendingResult(int,android.content.Intent,int)": {"Returns": [["@B_android#app#PendingIntent_E@", "Returns an existing or new PendingIntent matching the given parameters. May return null only if @B_android#app#PendingIntent#FLAG_NO_CREATE_E@ has been supplied."]], "Parameters": [["int", "int: Private request code for the sender that will be associated with the result data when it is returned. The sender can not modify this value, allowing you to identify incoming results."], ["@B_android#content#Intent_E@", "Intent: Default data to supply in the result, which may be modified by the sender. This value must never be null."], ["int", "int: May be @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, or any of the flags as supported by @B_android#content#Intent#fillIn_E@ to control which unspecified parts of the intent that can be supplied when the actual send happens. Value is either 0 or a combination of @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@, @B_android#content#Intent#FILL_IN_ACTION_E@, @B_android#content#Intent#FILL_IN_DATA_E@, @B_android#content#Intent#FILL_IN_CATEGORIES_E@, @B_android#content#Intent#FILL_IN_COMPONENT_E@, @B_android#content#Intent#FILL_IN_PACKAGE_E@, @B_android#content#Intent#FILL_IN_SOURCE_BOUNDS_E@, @B_android#content#Intent#FILL_IN_SELECTOR_E@, and @B_android#content#Intent#FILL_IN_CLIP_DATA_E@"]], "Throws": [], "SeeAlso": ["@B_android#app#PendingIntent_E@"], "Permissions": [], "Description": "Create a new PendingIntent object which you can hand to others for them to use to send result data back to your @B_android#app#Activity#onActivityResult_E@ callback. The created object will be either one-shot (becoming invalid after a result is sent back) or multiple (allowing any number of results to be sent through it).", "history": "Added in API level 1", "FullName": "public PendingIntent createPendingResult (int requestCode, Intent data, int flags)"}, "onRestoreInstanceState(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: the data most recently supplied in @B_android#app#Activity#onSaveInstanceState_E@. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreate_E@", "@B_android#app#Activity#onPostCreate_E@", "@B_android#app#Activity#onResume_E@", "@B_android#app#Activity#onSaveInstanceState_E@"], "Permissions": [], "Description": "This method is called after @B_android#app#Activity#onStart_E@ when the activity is being re-initialized from a previously saved state, given here in @B_android#app#Activity#onCreate_E@ to restore their state, but it is sometimes convenient to do it here after all of the initialization has been done or to allow subclasses to decide whether to use your default implementation. The default implementation of this method performs a restore of any view state that had previously been frozen by @B_android#app#Activity#onSaveInstanceState_E@. This method is called between @B_android#app#Activity#onStart_E@ and @B_android#app#Activity#onPostCreate_E@. This method is called only when recreating an activity; the method isn't invoked if @B_android#app#Activity#onStart_E@ is called for any other reason.", "history": "Added in API level 1", "FullName": "protected void onRestoreInstanceState (Bundle savedInstanceState)"}, "onWindowAttributesChanged(android.view.WindowManager.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#WindowManager#LayoutParams_E@", "WindowManager.LayoutParams no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called whenever the current window attributes change.", "history": "Added in API level 1", "FullName": "public void onWindowAttributesChanged (WindowManager.LayoutParams params)"}, "onMenuItemSelected(int, android.view.MenuItem)": {"Returns": [["boolean", "boolean Return true to finish processing of selection, or false to perform the normal menu handling (calling its Runnable or sending a Message to its target Handler)."]], "Parameters": [["int", "int: The panel that the menu is in."], ["@B_android#view#MenuItem_E@", "MenuItem: The menu item that was selected."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#Window#Callback#onMenuItemSelected_E@ for activities. This calls through to the new @B_android#app#Activity#onOptionsItemSelected_E@ method for the @B_android#view#Window#FEATURE_OPTIONS_PANEL_E@ panel, so that subclasses of Activity don't need to deal with feature codes.", "history": "added in API level 1", "FullName": "public boolean onMenuItemSelected (int featureId, MenuItem item)"}, "getVoiceInteractor()": {"Returns": [["@B_android#app#VoiceInteractor_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the active @B_android#app#VoiceInteractor_E@ that the user is going through to interact with this activity.", "history": "Added in API level 23", "FullName": "public VoiceInteractor getVoiceInteractor ()"}, "setTurnScreenOn(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to turn on the screen; false otherwise."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#setShowWhenLocked_E@", "@B_android#R#attr#turnScreenOn_E@", "@B_android#R#attr#showWhenLocked_E@"], "Permissions": [], "Description": "Specifies whether the screen should be turned on when the @B_android#app#Activity_E@ is resumed. Normally an activity will be transitioned to the stopped state if it is started while the screen if off, but with this flag set the activity will cause the screen to turn on if the activity will be visible and resumed due to the screen coming on. The screen will not be turned on if the activity won't be visible after the screen is turned on. This flag is normally used in conjunction with the @B_android#R#attr#showWhenLocked_E@ flag to make sure the activity is visible after the screen is turned on when the lockscreen is up. In addition, if this flag is set and the activity calls @B_android#app#KeyguardManager#requestDismissKeyguard_E@ the screen will turn on.", "history": "Added in API level 27", "FullName": "public void setTurnScreenOn (boolean turnScreenOn)"}, "getTitle()": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public final CharSequence getTitle ()"}, "onTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true if you have consumed the event, false if you haven't. The default implementation always returns false."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The touch screen event being processed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a touch screen event was not handled by any of the views under it. This is most useful to process touch events that happen outside of your window bounds, where there is no view to receive it.", "history": "Added in API level 1", "FullName": "public boolean onTouchEvent (MotionEvent event)"}, "setTheme(int)": {"Returns": [], "Parameters": [["int", "int: The style resource describing the theme."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the base theme for this context. Note that this should be called before any views are instantiated in the Context (for example before calling @B_android#app#Activity#setContentView_E@ or @B_android#view#LayoutInflater#inflate_E@).", "history": "Added in API level 1", "FullName": "public void setTheme (int resid)"}, "onKeyLongPress(int, android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyLongPress_E@: always returns false (doesn't handle the event).", "history": "added in API level 5", "FullName": "public boolean onKeyLongPress (int keyCode, KeyEvent event)"}, "setTitle(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change the title associated with this activity. If this is a top-level activity, the title for its window will change. If it is an embedded activity, the parent can do whatever it wants with it.", "history": "Added in API level 1", "FullName": "public void setTitle (int titleId)"}, "onCreateDialog(int, android.os.Bundle)": {"Returns": [["@B_android#app#Dialog_E@", "The dialog. If you return null, the dialog will not be created."]], "Parameters": [["int", "int: The id of the dialog."], ["@B_android#os#Bundle_E@", "Bundle: The dialog arguments provided to @B_android#app#Activity#showDialog_E@."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onPrepareDialog_E@", "@B_android#app#Activity#showDialog_E@", "@B_android#app#Activity#dismissDialog_E@", "@B_android#app#Activity#removeDialog_E@"], "Permissions": [], "Description": "Use the new @B_android#app#DialogFragment_E@ class with @B_android#app#FragmentManager_E@ instead; this is also available on older platforms through the Android compatibility package. Callback for creating dialogs that are managed (saved and restored) for you by the activity. The default implementation calls through to @B_android#app#Activity#onCreateDialog_E@ for compatibility. If you are targeting @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ or later, consider instead using a @B_android#app#DialogFragment_E@ instead. If you use @B_android#app#Activity#showDialog_E@, the activity will call through to this method the first time, and hang onto it thereafter. Any dialog that is created by this method will automatically be saved and restored for you, including whether it is showing. If you would like the activity to manage saving and restoring dialogs for you, you should override this method and handle any ids that are passed to @B_android#app#Activity#showDialog_E@. If you would like an opportunity to prepare your dialog before it is shown, override @B_android#app#Activity#onPrepareDialog_E@.", "history": "added in API level 8", "FullName": "protected Dialog onCreateDialog (int id, Bundle args)"}, "onWindowStartingActionMode(android.view.ActionMode.Callback)": {"Returns": [["@B_android#view#ActionMode_E@", "The new action mode, or null if the activity does not want to provide special handling for this action mode. (It will be handled by the system.)"]], "Parameters": [["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: The callback that should control the new action mode"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Give the Activity a chance to control the UI for an action mode requested by the system. Note: If you are looking for a notification callback that an action mode has been started for this activity, see @B_android#app#Activity#onActionModeStarted_E@.", "history": "Added in API level 11", "FullName": "public ActionMode onWindowStartingActionMode (ActionMode.Callback callback)"}, "isFinishing()": {"Returns": [["boolean", "If the activity is finishing, returns true; else returns false."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#finish_E@"], "Permissions": [], "Description": "Check to see whether this activity is in the process of finishing, either because you called @B_android#app#Activity#finish_E@ on it or someone else has requested that it finished. This is often used in @B_android#app#Activity#onPause_E@ to determine whether the activity is simply pausing or completely finishing.", "history": "Added in API level 1", "FullName": "public boolean isFinishing ()"}, "onPictureInPictureModeChanged(boolean,android.content.res.Configuration)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the activity is in picture-in-picture mode."], ["@B_android#content#res#Configuration_E@", "Configuration: The new configuration of the activity with the state ."]], "Throws": [], "SeeAlso": ["@B_android#R#attr#supportsPictureInPicture_E@"], "Permissions": [], "Description": "Called by the system when the activity changes to and from picture-in-picture mode. This method provides the same configuration that will be sent in the following @B_android#app#Activity#onConfigurationChanged_E@ call after the activity enters this mode.", "history": "Added in API level 26", "FullName": "public void onPictureInPictureModeChanged (boolean isInPictureInPictureMode, Configuration newConfig)"}, "getSearchEvent()": {"Returns": [["@B_android#view#SearchEvent_E@", "SearchEvent The SearchEvent that triggered the @B_android#app#Activity#onSearchRequested_E@ callback."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "During the onSearchRequested() callbacks, this function will return the @B_android#view#SearchEvent_E@ that triggered the callback, if it exists.", "history": "Added in API level 23", "FullName": "public final SearchEvent getSearchEvent ()"}, "onAttachFragment(android.app.Fragment)": {"Returns": [], "Parameters": [["@B_android#app#Fragment_E@", "Fragment no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use https:##developer#android#com@B_android#support#v4#app#FragmentActivity#onAttachFragment_E@ Called when a Fragment is being attached to this activity, immediately after the call to its @B_android#app#Fragment#onAttach_E@ method and before @B_android#app#Fragment#onCreate_E@.", "history": "Added in API level 11 Deprecated in API level 28", "FullName": "public void onAttachFragment (Fragment fragment)"}, "setExitSharedElementCallback(android.app.SharedElementCallback)": {"Returns": [], "Parameters": [["@B_android#app#SharedElementCallback_E@", "SharedElementCallback: Used to manipulate shared element transitions on the launching Activity."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "When @B_android#app#ActivityOptions#makeSceneTransitionAnimation_E@ was used to start an Activity, @B_android#view#Window#FEATURE_ACTIVITY_TRANSITIONS_E@.", "history": "Added in API level 21", "FullName": "public void setExitSharedElementCallback (SharedElementCallback callback)"}, "setFeatureDrawableResource(int, int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience for calling @B_android#view#Window#setFeatureDrawableResource_E@.", "history": "added in API level 1", "FullName": "public final void setFeatureDrawableResource (int featureId, int resId)"}, "startActivityFromChild(android.app.Activity,android.content.Intent,int,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity making the call. This value must never be null."], ["@B_android#content#Intent_E@", "Intent: The intent to start."], ["int", "int: Reply request code. < 0 if reply is not requested."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. This value may be null."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Activity#startActivity_E@", "@B_android#app#Activity#startActivityForResult_E@"], "Permissions": [], "Description": "This is called when a child activity of this one calls its @B_android#app#Activity#startActivity_E@ or @B_android#app#Activity#startActivityForResult_E@ method. This method throws @B_android#content#ActivityNotFoundException_E@ if there was no Activity found to run the given Intent.", "history": "Added in API level 16", "FullName": "public void startActivityFromChild (Activity child, Intent intent, int requestCode, Bundle options)"}, "showDialog(int, android.os.Bundle)": {"Returns": [["boolean", "Returns true if the Dialog was created; false is returned if it is not created because @B_android#app#Activity#onCreateDialog_E@ returns false."]], "Parameters": [["int", "int: The id of the managed dialog."], ["@B_android#os#Bundle_E@", "Bundle: Arguments to pass through to the dialog. These will be saved and restored for you. Note that if the dialog is already created, @B_android#app#Activity#onCreateDialog_E@ will not be called with the new arguments but @B_android#app#Activity#onPrepareDialog_E@ will be. If you need to rebuild the dialog, call @B_android#app#Activity#removeDialog_E@ first."]], "Throws": [], "SeeAlso": ["@B_android#app#Dialog_E@", "@B_android#app#Activity#onCreateDialog_E@", "@B_android#app#Activity#onPrepareDialog_E@", "@B_android#app#Activity#dismissDialog_E@", "@B_android#app#Activity#removeDialog_E@"], "Permissions": [], "Description": "Use the new @B_android#app#DialogFragment_E@ class with @B_android#app#FragmentManager_E@ instead; this is also available on older platforms through the Android compatibility package. Show a dialog managed by this activity. A call to @B_android#app#Activity#onCreateDialog_E@ will be made with the same id the first time this is called for a given id. From thereafter, the dialog will be automatically saved and restored. If you are targeting @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ or later, consider instead using a @B_android#app#DialogFragment_E@ instead. Each time a dialog is shown, @B_android#app#Activity#onPrepareDialog_E@ will be made to provide an opportunity to do any timely preparation.", "history": "added in API level 8", "FullName": "public final boolean showDialog (int id, Bundle args)"}, "setFeatureDrawableAlpha(int, int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience for calling @B_android#view#Window#setFeatureDrawableAlpha_E@.", "history": "added in API level 1", "FullName": "public final void setFeatureDrawableAlpha (int featureId, int alpha)"}, "onProvideAssistData(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the user is requesting an assist, to build a full @B_android#content#Intent#ACTION_ASSIST_E@ Intent with all of the context of the current application. You can override this method to place into the bundle anything you would like to appear in the @B_android#content#Intent#EXTRA_ASSIST_CONTEXT_E@ part of the assist Intent. This function will be called after any global assist callbacks that had been registered with @B_android#app#Application#registerOnProvideAssistDataListener_E@.", "history": "Added in API level 18", "FullName": "public void onProvideAssistData (Bundle data)"}, "startActivityFromFragment(android.app.Fragment,android.content.Intent,int,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#app#Fragment_E@", "Fragment: The fragment making the call. This value must never be null."], ["@B_android#content#Intent_E@", "Intent: The intent to start."], ["int", "int: Reply request code. < 0 if reply is not requested."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. This value may be null."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Fragment#startActivity_E@", "@B_android#app#Fragment#startActivityForResult_E@"], "Permissions": [], "Description": "Use https:##developer#android#com@B_android#support#v4#app#FragmentActivity#startActivityFromFragment_E@ This is called when a Fragment in this activity calls its @B_android#app#Fragment#startActivity_E@ or @B_android#app#Fragment#startActivityForResult_E@ method. This method throws @B_android#content#ActivityNotFoundException_E@ if there was no Activity found to run the given Intent.", "history": "Added in API level 16 Deprecated in API level 28", "FullName": "public void startActivityFromFragment (Fragment fragment, Intent intent, int requestCode, Bundle options)"}, "onCreatePanelMenu(int, android.view.Menu)": {"Returns": [["boolean", "boolean You must return true for the panel to be displayed; if you return false it will not be shown."]], "Parameters": [["int", "int: The panel being created."], ["@B_android#view#Menu_E@", "Menu: The menu inside the panel."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#Window#Callback#onCreatePanelMenu_E@ for activities. This calls through to the new @B_android#app#Activity#onCreateOptionsMenu_E@ method for the @B_android#view#Window#FEATURE_OPTIONS_PANEL_E@ panel, so that subclasses of Activity don't need to deal with feature codes.", "history": "added in API level 1", "FullName": "public boolean onCreatePanelMenu (int featureId, Menu menu)"}, "onTrackballEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true if you have consumed the event, false if you haven't. The default implementation always returns false."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The trackball event being processed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the trackball was moved and not handled by any of the views inside of the activity. So, for example, if the trackball moves while focus is on a button, you will receive a call here because buttons do not normally do anything with trackball events. The call here happens before trackball movements are converted to DPAD key events, which then get sent back to the view hierarchy, and will be processed at the point for things like focus navigation.", "history": "Added in API level 1", "FullName": "public boolean onTrackballEvent (MotionEvent event)"}, "onWindowFocusChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether the window of this activity has focus."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#hasWindowFocus_E@", "@B_android#app#Activity#onResume_E@", "@B_android#view#View#onWindowFocusChanged_E@", "@B_android#app#Activity#onTopResumedActivityChanged_E@"], "Permissions": [], "Description": "Called when the current @B_android#view#Window_E@ of the activity gains or loses focus. This is the best indicator of whether this activity is the entity with which the user actively interacts. The default implementation clears the key tracking state, so should always be called. Note that this provides information about global focus state, which is managed independently of activity lifecycle. As such, while focus changes will generally have some relation to lifecycle changes (an activity that is stopped will not generally get window focus), you should not rely on any particular order between the callbacks here and those in the other lifecycle methods such as @B_android#app#Activity#onResume_E@. As a general rule, however, a foreground activity will have window focus... unless it has displayed other dialogs or popups that take input focus, in which case the activity itself will not have focus when the other windows have it. Likewise, the system may display system-level windows (such as the status bar notification panel or a system alert) which will temporarily take window input focus without pausing the foreground activity. Starting with @B_android#os#Build#VERSION_CODES#Q_E@ there can be multiple resumed activities at the same time in multi-window mode, so resumed state does not guarantee window focus even if there are no overlays above. If the intent is to know when an activity is the topmost active, the one the user interacted with last among all activities but not including non-activity windows like dialogs and popups, then @B_android#app#Activity#onTopResumedActivityChanged_E@ should be used. On platform versions prior to @B_android#os#Build#VERSION_CODES#Q_E@, @B_android#app#Activity#onResume_E@ is the best indicator.", "history": "Added in API level 1", "FullName": "public void onWindowFocusChanged (boolean hasFocus)"}, "startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#IntentSender_E@", "IntentSender: The IntentSender to launch."], ["int", "int: If >= 0, this code will be returned in onActivityResult() when the activity exits."], ["@B_android#content#Intent_E@", "Intent: If non-null, this will be provided as the intent parameter to @B_android#content#IntentSender#sendIntent_E@. This value may be null."], ["int", "int: Intent flags in the original IntentSender that you would like to change."], ["int", "int: Desired values for any bits set in flagsMask"], ["int", "int: Always set to 0."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. If options have also been supplied by the IntentSender, options given here will override any that conflict with those given by the IntentSender."]], "Throws": [["@B_android#content#IntentSender#SendIntentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#app#Activity#startActivityForResult_E@, but allowing you to use a IntentSender to describe the activity to be started. If the IntentSender is for an activity, that activity will be started as if you had called the regular @B_android#app#Activity#startActivityForResult_E@ here; otherwise, its associated action will be executed (such as sending a broadcast) as if you had called @B_android#content#IntentSender#sendIntent_E@ on it.", "history": "Added in API level 16", "FullName": "public void startIntentSenderForResult (IntentSender intent, int requestCode, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)"}, "enterPictureInPictureMode(android.app.PictureInPictureParams)": {"Returns": [["boolean", "true if the system successfully put this activity into picture-in-picture mode or was already in picture-in-picture mode (see @B_android#app#Activity#isInPictureInPictureMode_E@). If the device does not support picture-in-picture, return false."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#R#attr#supportsPictureInPicture_E@", "@B_android#app#PictureInPictureParams_E@"], "Permissions": [], "Description": "Puts the activity in picture-in-picture mode if possible in the current system state. The set parameters in will be combined with the parameters from prior calls to @B_android#app#Activity#setPictureInPictureParams_E@. The system may disallow entering picture-in-picture in various cases, including when the activity is not visible, if the screen is locked or if the user has an activity pinned.", "history": "Added in API level 26", "FullName": "public boolean enterPictureInPictureMode (PictureInPictureParams params)"}, "onCreateView(android.view.View,java.lang.String,android.content.Context,android.util.AttributeSet)": {"Returns": [["@B_android#view#View_E@", "This value may be null."]], "Parameters": [["@B_android#view#View_E@", "View: This value may be null."], ["@B_java#lang#String_E@", "String: This value must never be null."], ["@B_android#content#Context_E@", "Context: This value must never be null."], ["@B_android#util#AttributeSet_E@", "AttributeSet: This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#view#LayoutInflater#createView_E@", "@B_android#view#Window#getLayoutInflater_E@"], "Permissions": [], "Description": "Standard implementation of @B_android#view#LayoutInflater#Factory2#onCreateView_E@ used when inflating with the LayoutInflater returned by @B_android#content#Context#getSystemService_E@. This implementation handles", "history": "Added in API level 11", "FullName": "public View onCreateView (View parent, String name, Context context, AttributeSet attrs)"}, "onCreate(android.os.Bundle,android.os.PersistableBundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: if the activity is being re-initialized after previously being shut down then this Bundle contains the data it most recently supplied in @B_android#app#Activity#onSaveInstanceState_E@. Note: Otherwise it is null. This value may be null."], ["@B_android#os#PersistableBundle_E@", "PersistableBundle: if the activity is being re-initialized after previously being shut down or powered off then this Bundle contains the data it most recently supplied to outPersistentState in @B_android#app#Activity#onSaveInstanceState_E@. Note: Otherwise it is null. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreate_E@", "@B_android#app#Activity#onStart_E@", "@B_android#app#Activity#onSaveInstanceState_E@", "@B_android#app#Activity#onRestoreInstanceState_E@", "@B_android#app#Activity#onPostCreate_E@"], "Permissions": [], "Description": "Same as @B_android#app#Activity#onCreate_E@ but called for those activities created with the attribute @B_android#R#attr#persistableMode_E@ set to persistAcrossReboots.", "history": "Added in API level 21", "FullName": "public void onCreate (Bundle savedInstanceState, PersistableBundle persistentState)"}, "setResult(int, android.content.Intent)": {"Returns": [], "Parameters": [["int", "int: The result code to propagate back to the originating activity, often RESULT_CANCELED or RESULT_OK"], ["@B_android#content#Intent_E@", "Intent: The data to propagate back to the originating activity."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity_E@", "@B_android#app#Activity#setResult_E@"], "Permissions": [], "Description": "Call this to set the result that your activity will return to its caller. As of @B_android#os#Build#VERSION_CODES#GINGERBREAD_E@, the Intent you supply here can have @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@ and/or @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@ set. This will grant the Activity receiving the result access to the specific URIs in the Intent. Access will remain until the Activity has finished (it will remain across the hosting process being killed and other temporary destruction) and will be added to any existing set of URI permissions it already holds.", "history": "added in API level 1", "FullName": "public final void setResult (int resultCode, Intent data)"}, "openOptionsMenu()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Programmatically opens the options menu. If the options menu is already open, this method does nothing.", "history": "Added in API level 1", "FullName": "public void openOptionsMenu ()"}, "isChangingConfigurations()": {"Returns": [["boolean", "If the activity is being torn down in order to be recreated with a new configuration, returns true; else returns false."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check to see whether this activity is in the process of being destroyed in order to be recreated with a new configuration. This is often used in @B_android#app#Activity#onStop_E@ to determine whether the state needs to be cleaned up or will be passed on to the next instance of the activity via @B_android#app#Activity#onRetainNonConfigurationInstance_E@.", "history": "Added in API level 11", "FullName": "public boolean isChangingConfigurations ()"}, "onLocalVoiceInteractionStarted()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Callback to indicate that @B_android#app#Activity#startLocalVoiceInteraction_E@ has resulted in a voice interaction session being started. You can now retrieve a voice interactor using @B_android#app#Activity#getVoiceInteractor_E@.", "history": "Added in API level 24", "FullName": "public void onLocalVoiceInteractionStarted ()"}, "setProgressBarIndeterminate(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether the horizontal progress bar should be indeterminate."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "No longer supported starting in API 21. Sets whether the horizontal progress bar in the title should be indeterminate (the circular is always indeterminate). In order for the progress bar to be shown, the feature must be requested via @B_android#app#Activity#requestWindowFeature_E@.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public final void setProgressBarIndeterminate (boolean indeterminate)"}, "onSearchRequested(android.view.SearchEvent)": {"Returns": [["boolean", "Returns true if search launched, and false if the activity does not respond to search. The default implementation always returns true, except when in @B_android#content#res#Configuration#UI_MODE_TYPE_TELEVISION_E@ mode where it returns false."]], "Parameters": [["@B_android#view#SearchEvent_E@", "SearchEvent: The @B_android#view#SearchEvent_E@ that signaled this search. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#app#SearchManager_E@"], "Permissions": [], "Description": "This hook is called when the user signals the desire to start a search. You can use this function as a simple way to launch the search UI, in response to a menu item, search button, or other widgets within your activity. Unless overidden, calling this function is the same as calling @B_android#app#Activity#startSearch_E@, which launches search for the current activity as specified in its manifest, see @B_android#app#SearchManager_E@. You can override this function to force global search, e.g. in response to a dedicated search key, or to block search entirely (by simply returning false). Note: when running in a @B_android#content#res#Configuration#UI_MODE_TYPE_TELEVISION_E@ or @B_android#content#res#Configuration#UI_MODE_TYPE_WATCH_E@, the default implementation changes to simply return false and you must supply your own custom implementation if you want to support search.", "history": "Added in API level 23", "FullName": "public boolean onSearchRequested (SearchEvent searchEvent)"}, "onStop()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onRestart_E@", "@B_android#app#Activity#onResume_E@", "@B_android#app#Activity#onSaveInstanceState_E@", "@B_android#app#Activity#onDestroy_E@"], "Permissions": [], "Description": "Called when you are no longer visible to the user. You will next receive either @B_android#app#Activity#onRestart_E@, @B_android#app#Activity#onDestroy_E@, or nothing, depending on later user activity. This is a good place to stop refreshing UI, running animations and other visual things. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onStop ()"}, "getFragmentManager()": {"Returns": [["@B_android#app#FragmentManager_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use https:##developer#android#com@B_android#support#v4#app#FragmentActivity#getSupportFragmentManager_E@ Return the FragmentManager for interacting with fragments associated with this activity.", "history": "Added in API level 11 Deprecated in API level 28", "FullName": "public FragmentManager getFragmentManager ()"}, "setFeatureDrawableUri(int, android.net.Uri)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["@B_android#net#Uri_E@", "Uri no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience for calling @B_android#view#Window#setFeatureDrawableUri_E@.", "history": "added in API level 1", "FullName": "public final void setFeatureDrawableUri (int featureId, Uri uri)"}, "getCurrentFocus()": {"Returns": [["@B_android#view#View_E@", "View The current View with focus or null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#getWindow_E@", "@B_android#view#Window#getCurrentFocus_E@"], "Permissions": [], "Description": "Calls @B_android#view#Window#getCurrentFocus_E@ on the Window of this Activity to return the currently focused view.", "history": "Added in API level 1", "FullName": "public View getCurrentFocus ()"}, "Activity()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public Activity ()"}, "closeOptionsMenu()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Progammatically closes the options menu. If the options menu is already closed, this method does nothing.", "history": "Added in API level 1", "FullName": "public void closeOptionsMenu ()"}, "onKeyDown(int, android.view.KeyEvent)": {"Returns": [["boolean", "Return true to prevent this event from being propagated further, or false to indicate that you have not handled this event and it should continue to be propagated."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onKeyUp_E@", "@B_android#view#KeyEvent_E@"], "Permissions": [], "Description": "Called when a key was pressed down and not handled by any of the views inside of the activity. So, for example, key presses while the cursor is inside a TextView will not trigger the event (unless it is a navigation to another object) because TextView handles its own key presses. If the focused view didn't want this event, this method is called. The default implementation takes care of @B_android#view#KeyEvent#KEYCODE_BACK_E@ by calling @B_android#app#Activity#onBackPressed_E@, though the behavior varies based on the application compatibility mode: for @B_android#os#Build#VERSION_CODES#ECLAIR_E@ or later applications, it will set up the dispatch to call @B_android#app#Activity#onKeyUp_E@ where the action will be performed; for earlier applications, it will perform the action immediately in on-down, as those versions of the platform behaved. Other additional default key handling may be performed if configured with @B_android#app#Activity#setDefaultKeyMode_E@.", "history": "added in API level 1", "FullName": "public boolean onKeyDown (int keyCode, KeyEvent event)"}, "getApplication()": {"Returns": [["@B_android#app#Application_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the application that owns this activity.", "history": "Added in API level 1", "FullName": "public final Application getApplication ()"}, "getCallingActivity()": {"Returns": [["@B_android#content#ComponentName_E@", "The ComponentName of the activity that will receive your reply, or null if none."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the name of the activity that invoked this activity. This is who the data in @B_android#app#Activity#setResult_E@ will be sent to. You can use this information to validate that the recipient is allowed to receive the data. Note: if the calling activity is not expecting a result (that is it did not use the @B_android#app#Activity#startActivityForResult_E@ form that includes a request code), then the calling package will be null.", "history": "Added in API level 1", "FullName": "public ComponentName getCallingActivity ()"}, "startActivity(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to start."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Activity#startActivity_E@", "@B_android#app#Activity#startActivityForResult_E@"], "Permissions": [], "Description": "Same as @B_android#app#Activity#startActivity_E@ with no options specified.", "history": "Added in API level 1", "FullName": "public void startActivity (Intent intent)"}, "runOnUiThread(java.lang.Runnable)": {"Returns": [], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: the action to run on the UI thread"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Runs the specified action on the UI thread. If the current thread is the UI thread, then the action is executed immediately. If the current thread is not the UI thread, the action is posted to the event queue of the UI thread.", "history": "Added in API level 1", "FullName": "public final void runOnUiThread (Runnable action)"}, "onVisibleBehindCanceled()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#requestVisibleBehind_E@"], "Permissions": [], "Description": "This method's functionality is no longer supported as of @B_android#os#Build#VERSION_CODES#O_E@ and will be removed in a future release. Called when a translucent activity over this activity is becoming opaque or another activity is being launched. Activities that override this method must call super.onVisibleBehindCanceled() or a SuperNotCalledException will be thrown. When this method is called the activity has 500 msec to release any resources it may be using while visible in the background. If the activity has not returned from this method in 500 msec the system will destroy the activity and kill the process in order to recover the resources for another process. Otherwise @B_android#app#Activity#onStop_E@ will be called following return. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 21 Deprecated in API level 26", "FullName": "public void onVisibleBehindCanceled ()"}, "setFeatureDrawable(int,android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["@B_android#graphics#drawable#Drawable_E@", "Drawable no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience for calling @B_android#view#Window#setFeatureDrawable_E@.", "history": "Added in API level 1", "FullName": "public final void setFeatureDrawable (int featureId, Drawable drawable)"}, "isChild()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Is this activity embedded inside of another activity?", "history": "Added in API level 1", "FullName": "public final boolean isChild ()"}, "onSaveInstanceState(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: Bundle in which to place your saved state. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreate_E@", "@B_android#app#Activity#onRestoreInstanceState_E@", "@B_android#app#Activity#onPause_E@"], "Permissions": [], "Description": "Called to retrieve per-instance state from an activity before being killed so that the state can be restored in @B_android#app#Activity#onCreate_E@ or @B_android#app#Activity#onRestoreInstanceState_E@ (the @B_android#os#Bundle_E@ populated by this method will be passed to both). This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via @B_android#app#Activity#onCreate_E@ or @B_android#app#Activity#onRestoreInstanceState_E@. Do not confuse this method with activity lifecycle callbacks such as @B_android#app#Activity#onPause_E@, which is always called when the user no longer actively interacts with an activity, or @B_android#app#Activity#onStop_E@ which is called when activity becomes invisible. One example of when @B_android#app#Activity#onPause_E@ and @B_android#app#Activity#onStop_E@ is called and not this method is when a user navigates back from activity B to activity A: there is no need to call @B_android#app#Activity#onSaveInstanceState_E@ on B because that particular instance will never be restored, so the system avoids calling it. An example when @B_android#app#Activity#onPause_E@ is called and not @B_android#app#Activity#onSaveInstanceState_E@ is when activity B is launched in front of activity A: the system may avoid calling @B_android#app#Activity#onSaveInstanceState_E@ on activity A if it isn't killed during the lifetime of B since the state of the user interface of A will stay intact. The default implementation takes care of most of the UI per-instance state for you by calling @B_android#view#View#onSaveInstanceState_E@ on each view in the hierarchy that has an id, and by saving the id of the currently focused view (all of which is restored by the default implementation of @B_android#app#Activity#onRestoreInstanceState_E@). If you override this method to save additional information not captured by each individual view, you will likely want to call through to the default implementation, otherwise be prepared to save all of the state of each view yourself. If called, this method will occur after @B_android#app#Activity#onStop_E@ for applications targeting platforms starting with @B_android#os#Build#VERSION_CODES#P_E@. For applications targeting earlier platform versions this method will occur before @B_android#app#Activity#onStop_E@ and there are no guarantees about whether it will occur before or after @B_android#app#Activity#onPause_E@.", "history": "Added in API level 1", "FullName": "protected void onSaveInstanceState (Bundle outState)"}, "isTaskRoot()": {"Returns": [["boolean", "True if this is the root activity, else false."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return whether this activity is the root of a task. The root is the first activity in a task.", "history": "Added in API level 1", "FullName": "public boolean isTaskRoot ()"}, "getSystemService(java.lang.String)": {"Returns": [["@B_java#lang#Object_E@", "The service or null if the name does not exist."]], "Parameters": [["@B_java#lang#String_E@", "String: Value is @B_android#content#Context#POWER_SERVICE_E@, @B_android#content#Context#WINDOW_SERVICE_E@, @B_android#content#Context#LAYOUT_INFLATER_SERVICE_E@, @B_android#content#Context#ACCOUNT_SERVICE_E@, @B_android#content#Context#ACTIVITY_SERVICE_E@, @B_android#content#Context#ALARM_SERVICE_E@, @B_android#content#Context#NOTIFICATION_SERVICE_E@, @B_android#content#Context#ACCESSIBILITY_SERVICE_E@, @B_android#content#Context#CAPTIONING_SERVICE_E@, @B_android#content#Context#KEYGUARD_SERVICE_E@, @B_android#content#Context#LOCATION_SERVICE_E@, @B_android#content#Context#SEARCH_SERVICE_E@, @B_android#content#Context#SENSOR_SERVICE_E@, android.content.Context.SENSOR_PRIVACY_SERVICE, @B_android#content#Context#STORAGE_SERVICE_E@, @B_android#content#Context#STORAGE_STATS_SERVICE_E@, @B_android#content#Context#WALLPAPER_SERVICE_E@, android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE, @B_android#content#Context#VIBRATOR_SERVICE_E@, @B_android#content#Context#CONNECTIVITY_SERVICE_E@, @B_android#content#Context#IPSEC_SERVICE_E@, android.content.Context.TEST_NETWORK_SERVICE, @B_android#content#Context#NETWORK_STATS_SERVICE_E@, @B_android#content#Context#WIFI_SERVICE_E@, @B_android#content#Context#WIFI_AWARE_SERVICE_E@, @B_android#content#Context#WIFI_P2P_SERVICE_E@, android.content.Context.WIFI_SCANNING_SERVICE, @B_android#content#Context#WIFI_RTT_RANGING_SERVICE_E@, @B_android#content#Context#NSD_SERVICE_E@, @B_android#content#Context#AUDIO_SERVICE_E@, @B_android#content#Context#FINGERPRINT_SERVICE_E@, @B_android#content#Context#BIOMETRIC_SERVICE_E@, @B_android#content#Context#MEDIA_ROUTER_SERVICE_E@, @B_android#content#Context#TELEPHONY_SERVICE_E@, @B_android#content#Context#TELEPHONY_SUBSCRIPTION_SERVICE_E@, @B_android#content#Context#CARRIER_CONFIG_SERVICE_E@, @B_android#content#Context#TELECOM_SERVICE_E@, @B_android#content#Context#CLIPBOARD_SERVICE_E@, @B_android#content#Context#INPUT_METHOD_SERVICE_E@, @B_android#content#Context#TEXT_SERVICES_MANAGER_SERVICE_E@, @B_android#content#Context#TEXT_CLASSIFICATION_SERVICE_E@, @B_android#content#Context#APPWIDGET_SERVICE_E@, android.content.Context.ROLLBACK_SERVICE, @B_android#content#Context#DROPBOX_SERVICE_E@, @B_android#content#Context#DEVICE_POLICY_SERVICE_E@, @B_android#content#Context#UI_MODE_SERVICE_E@, @B_android#content#Context#DOWNLOAD_SERVICE_E@, @B_android#content#Context#NFC_SERVICE_E@, @B_android#content#Context#BLUETOOTH_SERVICE_E@, @B_android#content#Context#USB_SERVICE_E@, @B_android#content#Context#LAUNCHER_APPS_SERVICE_E@, @B_android#content#Context#INPUT_SERVICE_E@, @B_android#content#Context#DISPLAY_SERVICE_E@, @B_android#content#Context#USER_SERVICE_E@, @B_android#content#Context#RESTRICTIONS_SERVICE_E@, @B_android#content#Context#APP_OPS_SERVICE_E@, @B_android#content#Context#ROLE_SERVICE_E@, @B_android#content#Context#CAMERA_SERVICE_E@, @B_android#content#Context#PRINT_SERVICE_E@, @B_android#content#Context#CONSUMER_IR_SERVICE_E@, @B_android#content#Context#TV_INPUT_SERVICE_E@, @B_android#content#Context#USAGE_STATS_SERVICE_E@, @B_android#content#Context#MEDIA_SESSION_SERVICE_E@, @B_android#content#Context#BATTERY_SERVICE_E@, @B_android#content#Context#JOB_SCHEDULER_SERVICE_E@, @B_android#content#Context#MEDIA_PROJECTION_SERVICE_E@, @B_android#content#Context#MIDI_SERVICE_E@, android.content.Context.RADIO_SERVICE, @B_android#content#Context#HARDWARE_PROPERTIES_SERVICE_E@, @B_android#content#Context#SHORTCUT_SERVICE_E@, @B_android#content#Context#SYSTEM_HEALTH_SERVICE_E@, @B_android#content#Context#COMPANION_DEVICE_SERVICE_E@, @B_android#content#Context#CROSS_PROFILE_APPS_SERVICE_E@, or android.content.Context.PERMISSION_SERVICE This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the handle to a system-level service by name. The class of the returned object varies by the requested name. Currently available names are: Note: System services obtained via this API may be closely associated with the Context in which they are obtained from. In general, do not share the service objects between various different contexts (Activities, Applications, Services, Providers, etc.) Note: Instant apps, for which @B_android#content#pm#PackageManager#isInstantApp_E@ returns true, don't have access to the following system services: @B_android#content#Context#DEVICE_POLICY_SERVICE_E@, @B_android#content#Context#FINGERPRINT_SERVICE_E@, @B_android#content#Context#KEYGUARD_SERVICE_E@, @B_android#content#Context#SHORTCUT_SERVICE_E@, @B_android#content#Context#USB_SERVICE_E@, @B_android#content#Context#WALLPAPER_SERVICE_E@, @B_android#content#Context#WIFI_P2P_SERVICE_E@, @B_android#content#Context#WIFI_SERVICE_E@, @B_android#content#Context#WIFI_AWARE_SERVICE_E@. For these services this method will return null. Generally, if you are running as an instant app you should always check whether the result of this method is null. Note: When implementing this method, keep in mind that new services can be added on newer Android releases, so if you're looking for just the explicit names mentioned above, make sure to return null when you don't recognize the name \u2014 if you throw a @B_java#lang#RuntimeException_E@ exception instead, you're app might break on new Android releases.", "history": "Added in API level 1", "FullName": "public Object getSystemService (String name)"}, "isInMultiWindowMode()": {"Returns": [["boolean", "True if the activity is in multi-window mode."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#R#attr#resizeableActivity_E@"], "Permissions": [], "Description": "Returns true if the activity is currently in multi-window mode.", "history": "Added in API level 24", "FullName": "public boolean isInMultiWindowMode ()"}, "onCreateOptionsMenu(android.view.Menu)": {"Returns": [["boolean", "You must return true for the menu to be displayed; if you return false it will not be shown."]], "Parameters": [["@B_android#view#Menu_E@", "Menu: The options menu in which you place your items."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onPrepareOptionsMenu_E@", "@B_android#app#Activity#onOptionsItemSelected_E@"], "Permissions": [], "Description": "Initialize the contents of the Activity's standard options menu. You should place your menu items in to This is only called once, the first time the options menu is displayed. To update the menu every time it is displayed, see @B_android#app#Activity#onPrepareOptionsMenu_E@. The default implementation populates the menu with standard system menu items. These are placed in the @B_android#view#Menu#CATEGORY_SYSTEM_E@ group so that they will be correctly ordered with application-defined menu items. Deriving classes should always call through to the base implementation. You can safely hold on to When you add items to the menu, you can implement the Activity's @B_android#app#Activity#onOptionsItemSelected_E@ method to handle them there.", "history": "Added in API level 1", "FullName": "public boolean onCreateOptionsMenu (Menu menu)"}, "getLoaderManager()": {"Returns": [["@B_android#app#LoaderManager_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use https:##developer#android#com@B_android#support#v4#app#FragmentActivity#getSupportLoaderManager_E@ Return the LoaderManager for this activity, creating it if needed.", "history": "Added in API level 11 Deprecated in API level 28", "FullName": "public LoaderManager getLoaderManager ()"}, "getRequestedOrientation()": {"Returns": [["int", "Returns an orientation constant as used in @B_android#content#pm#ActivityInfo#screenOrientation_E@. Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_UNSPECIFIED_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_LANDSCAPE_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_PORTRAIT_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_USER_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_BEHIND_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_SENSOR_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_NOSENSOR_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_SENSOR_LANDSCAPE_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_SENSOR_PORTRAIT_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_REVERSE_LANDSCAPE_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_REVERSE_PORTRAIT_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_FULL_SENSOR_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_USER_LANDSCAPE_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_USER_PORTRAIT_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_FULL_USER_E@, or @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_LOCKED_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the current requested orientation of the activity. This will either be the orientation requested in its component's manifest, or the last requested orientation given to @B_android#app#Activity#setRequestedOrientation_E@.", "history": "Added in API level 1", "FullName": "public int getRequestedOrientation ()"}, "onPostCreate(android.os.Bundle,android.os.PersistableBundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: The data most recently supplied in @B_android#app#Activity#onSaveInstanceState_E@ This value may be null."], ["@B_android#os#PersistableBundle_E@", "PersistableBundle: The data caming from the PersistableBundle first saved in @B_android#app#Activity#onSaveInstanceState_E@. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreate_E@"], "Permissions": [], "Description": "This is the same as @B_android#app#Activity#onPostCreate_E@ but is called for activities created with the attribute @B_android#R#attr#persistableMode_E@ set to persistAcrossReboots.", "history": "Added in API level 21", "FullName": "public void onPostCreate (Bundle savedInstanceState, PersistableBundle persistentState)"}, "onMenuItemSelected(int,android.view.MenuItem)": {"Returns": [["boolean", "boolean Return true to finish processing of selection, or false to perform the normal menu handling (calling its Runnable or sending a Message to its target Handler)."]], "Parameters": [["int", "int: The panel that the menu is in."], ["@B_android#view#MenuItem_E@", "MenuItem: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#Window#Callback#onMenuItemSelected_E@ for activities. This calls through to the new @B_android#app#Activity#onOptionsItemSelected_E@ method for the @B_android#view#Window#FEATURE_OPTIONS_PANEL_E@ panel, so that subclasses of Activity don't need to deal with feature codes.", "history": "Added in API level 1", "FullName": "public boolean onMenuItemSelected (int featureId, MenuItem item)"}, "onRetainNonConfigurationInstance()": {"Returns": [["@B_java#lang#Object_E@", "any Object holding the desired state to propagate to the next activity instance"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the system, as part of destroying an activity due to a configuration change, when it is known that a new instance will immediately be created for the new configuration. You can return any object you like here, including the activity instance itself, which can later be retrieved by calling @B_android#app#Activity#getLastNonConfigurationInstance_E@ in the new activity instance. If you are targeting @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ or later, consider instead using a @B_android#app#Fragment_E@ with @B_android#app#Fragment#setRetainInstance_E@. This function is called purely as an optimization, and you must not rely on it being called. When it is called, a number of guarantees will be made to help optimize configuration switching: The function will be called between @B_android#app#Activity#onStop_E@ and @B_android#app#Activity#onDestroy_E@. A new instance of the activity will always be immediately created after this one's @B_android#app#Activity#onDestroy_E@ is called. In particular, no messages will be dispatched during this time (when the returned object does not have an activity to be associated with). The object you return here will always be available from the @B_android#app#Activity#getLastNonConfigurationInstance_E@ method of the following activity instance as described there. These guarantees are designed so that an activity can use this API to propagate extensive state from the old to new activity instance, from loaded bitmaps, to network connections, to evenly actively running threads. Note that you should not propagate any data that may change based on the configuration, including any data loaded from resources such as strings, layouts, or drawables. The guarantee of no message handling during the switch to the next activity simplifies use with active objects. For example if your retained state is an @B_android#os#AsyncTask_E@ you are guaranteed that its call back functions (like @B_android#os#AsyncTask#onPostExecute_E@) will not be called from the call here until you execute the next instance's @B_android#app#Activity#onCreate_E@. (Note however that there is of course no such guarantee for @B_android#os#AsyncTask#doInBackground_E@ since that is running in a separate thread.) @B_android#app#Fragment_E@ API @B_android#app#Fragment#setRetainInstance_E@ instead; this is also available on older platforms through the Android support libraries.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public Object onRetainNonConfigurationInstance ()"}, "setContentView(android.view.View,android.view.ViewGroup.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The desired content to display."], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: Layout parameters for the view."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#setContentView_E@"], "Permissions": [], "Description": "Set the activity content to an explicit view. This view is placed directly into the activity's view hierarchy. It can itself be a complex view hierarchy.", "history": "Added in API level 1", "FullName": "public void setContentView (View view, ViewGroup.LayoutParams params)"}, "onCreateView(java.lang.String,android.content.Context,android.util.AttributeSet)": {"Returns": [["@B_android#view#View_E@", "This value may be null."]], "Parameters": [["@B_java#lang#String_E@", "String: This value must never be null."], ["@B_android#content#Context_E@", "Context: This value must never be null."], ["@B_android#util#AttributeSet_E@", "AttributeSet: This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#view#LayoutInflater#createView_E@", "@B_android#view#Window#getLayoutInflater_E@"], "Permissions": [], "Description": "Standard implementation of @B_android#view#LayoutInflater#Factory#onCreateView_E@ used when inflating with the LayoutInflater returned by @B_android#content#Context#getSystemService_E@. This implementation does nothing and is for pre-@B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ apps. Newer apps should use @B_android#app#Activity#onCreateView_E@.", "history": "Added in API level 1", "FullName": "public View onCreateView (String name, Context context, AttributeSet attrs)"}, "onPanelClosed(int, android.view.Menu)": {"Returns": [], "Parameters": [["int", "int: The panel that is being displayed."], ["@B_android#view#Menu_E@", "Menu: If onCreatePanelView() returned null, this is the Menu being displayed in the panel."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#Window#Callback#onPanelClosed_E@ for activities. This calls through to @B_android#app#Activity#onOptionsMenuClosed_E@ method for the @B_android#view#Window#FEATURE_OPTIONS_PANEL_E@ panel, so that subclasses of Activity don't need to deal with feature codes. For context menus (@B_android#view#Window#FEATURE_CONTEXT_MENU_E@), the @B_android#app#Activity#onContextMenuClosed_E@ will be called.", "history": "added in API level 1", "FullName": "public void onPanelClosed (int featureId, Menu menu)"}, "setInheritShowWhenLocked(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to show the @B_android#app#Activity_E@ on top of the lock screen when this activity has another activity behind it with the showWhenLock attribute set; false otherwise."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#setShowWhenLocked_E@", "@B_android#R#attr#inheritShowWhenLocked_E@"], "Permissions": [], "Description": "Specifies whether this @B_android#app#Activity_E@ should be shown on top of the lock screen whenever the lockscreen is up and this activity has another activity behind it with the showWhenLock attribute set. That is, this activity is only visible on the lock screen if there is another activity with the showWhenLock attribute visible at the same time on the lock screen. A use case for this is permission dialogs, that should only be visible on the lock screen if their requesting activity is also visible. This value can be set as a manifest attribute using android.R.attr#inheritShowWhenLocked.", "history": "Added in API level 29", "FullName": "public void setInheritShowWhenLocked (boolean inheritShowWhenLocked)"}, "onPrepareOptionsMenu(android.view.Menu)": {"Returns": [["boolean", "You must return true for the menu to be displayed; if you return false it will not be shown."]], "Parameters": [["@B_android#view#Menu_E@", "Menu: The options menu as last shown or first initialized by onCreateOptionsMenu()."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreateOptionsMenu_E@"], "Permissions": [], "Description": "Prepare the Screen's standard options menu to be displayed. This is called right before the menu is shown, every time it is shown. You can use this method to efficiently enable/disable items or otherwise dynamically modify the contents. The default implementation updates the system menu items based on the activity's state. Deriving classes should always call through to the base class implementation.", "history": "Added in API level 1", "FullName": "public boolean onPrepareOptionsMenu (Menu menu)"}, "onTitleChanged(java.lang.CharSequence, int)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "protected void onTitleChanged (CharSequence title, int color)"}, "finishActivityFromChild(android.app.Activity, int)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity making the call.This value must never be null."], ["int", "int: Request code that had been used to start the activity."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when a child activity of this one calls its finishActivity().", "history": "added in API level 1", "FullName": "public void finishActivityFromChild (Activity child, int requestCode)"}, "startActivityFromChild(android.app.Activity,android.content.Intent,int)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity making the call. This value must never be null."], ["@B_android#content#Intent_E@", "Intent: The intent to start."], ["int", "int: Reply request code. < 0 if reply is not requested."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Activity#startActivity_E@", "@B_android#app#Activity#startActivityForResult_E@"], "Permissions": [], "Description": "Same as calling @B_android#app#Activity#startActivityFromChild_E@ with no options.", "history": "Added in API level 1", "FullName": "public void startActivityFromChild (Activity child, Intent intent, int requestCode)"}, "showAssist(android.os.Bundle)": {"Returns": [["boolean", "Returns true if the assistant was successfully invoked, else false. For example false will be returned if the caller is not the current top activity."]], "Parameters": [["@B_android#os#Bundle_E@", "Bundle no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask to have the current assistant shown to the user. This only works if the calling activity is the current foreground activity. It is the same as calling @B_android#service#voice#VoiceInteractionService#showSession_E@ and requesting all of the possible context. The receiver will always see @B_android#service#voice#VoiceInteractionSession#SHOW_SOURCE_APPLICATION_E@ set.", "history": "Added in API level 23", "FullName": "public boolean showAssist (Bundle args)"}, "getMediaController()": {"Returns": [["@B_android#media#session#MediaController_E@", "The controller which should receive events."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#setMediaController_E@"], "Permissions": [], "Description": "Gets the controller which should be receiving media key and volume events while this activity is in the foreground.", "history": "Added in API level 21", "FullName": "public final MediaController getMediaController ()"}, "dismissKeyboardShortcutsHelper()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dismiss the Keyboard Shortcuts screen.", "history": "Added in API level 24", "FullName": "public final void dismissKeyboardShortcutsHelper ()"}, "setVrModeEnabled(boolean,android.content.ComponentName)": {"Returns": [], "Parameters": [["boolean", "boolean: true to enable this mode."], ["@B_android#content#ComponentName_E@", "ComponentName: the name of the component to use as a @B_android#service#vr#VrListenerService_E@ while VR mode is enabled. This value must never be null."]], "Throws": [["@B_android#content#pm#PackageManager#NameNotFoundException_E@", "if the given component to run as a @B_android#service#vr#VrListenerService_E@ is not installed, or has not been enabled in user settings."]], "SeeAlso": ["@B_android#content#pm#PackageManager_E@", "@B_android#service#vr#VrListenerService_E@", "@B_android#provider#Settings_E@", "@B_android#R#attr#enableVrMode_E@"], "Permissions": [], "Description": "Enable or disable virtual reality (VR) mode for this Activity. VR mode is a hint to Android system to switch to a mode optimized for VR applications while this Activity has user focus. It is recommended that applications additionally declare @B_android#R#attr#enableVrMode_E@ in their manifest to allow for smooth activity transitions when switching between VR activities. If the requested @B_android#service#vr#VrListenerService_E@ component is not available, VR mode will not be started. Developers can handle this case as follows:", "history": "Added in API level 24", "FullName": "public void setVrModeEnabled (boolean enabled, ComponentName requestedComponent)"}, "onActivityReenter(int, android.content.Intent)": {"Returns": [], "Parameters": [["int", "int: The integer result code returned by the child activity through its setResult()."], ["@B_android#content#Intent_E@", "Intent: An Intent, which can return result data to the caller (various data can be attached to Intent \"extras\")."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when an activity you launched with an activity transition exposes this Activity through a returning activity transition, giving you the resultCode and any additional data from it. This method will only be called if the activity set a result code other than @B_android#app#Activity#RESULT_CANCELED_E@ and it supports activity transitions with @B_android#view#Window#FEATURE_ACTIVITY_TRANSITIONS_E@. The purpose of this function is to let the called Activity send a hint about its state so that this underlying Activity can prepare to be exposed. A call to this method does not guarantee that the called Activity has or will be exiting soon. It only indicates that it will expose this Activity's Window and it has some data to pass to prepare it.", "history": "added in API level 21", "FullName": "public void onActivityReenter (int resultCode, Intent data)"}, "startIntentSenderForResult(android.content.IntentSender,int,android.content.Intent,int,int,int)": {"Returns": [], "Parameters": [["@B_android#content#IntentSender_E@", "IntentSender: The IntentSender to launch."], ["int", "int: If >= 0, this code will be returned in onActivityResult() when the activity exits."], ["@B_android#content#Intent_E@", "Intent: If non-null, this will be provided as the intent parameter to @B_android#content#IntentSender#sendIntent_E@. This value may be null."], ["int", "int: Intent flags in the original IntentSender that you would like to change."], ["int", "int: Desired values for any bits set in flagsMask"], ["int", "int: Always set to 0."]], "Throws": [["@B_android#content#IntentSender#SendIntentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Same as calling @B_android#app#Activity#startIntentSenderForResult_E@ with no options.", "history": "Added in API level 5", "FullName": "public void startIntentSenderForResult (IntentSender intent, int requestCode, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)"}, "onGetDirectActions(android.os.CancellationSignal,java.util.function.Consumer<java.util.List<android.app.DirectAction>>)": {"Returns": [], "Parameters": [["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress. This value must never be null."], ["@B_java#util#function#Consumer_E@", "Consumer: The callback to send the action list. The actions list cannot contain null elements. You can call this on any thread. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the list of direct actions supported by the app. You should return the list of actions that could be executed in the current context, which is in the current state of the app. If the actions that could be executed by the app changes you should report that via calling @B_android#app#VoiceInteractor#notifyDirectActionsChanged_E@. To get the voice interactor you need to call @B_android#app#Activity#getVoiceInteractor_E@ which would return non null only if there is an ongoing voice interaction session. You an also detect when the voice interactor is no longer valid because the voice interaction session that is backing is finished by calling @B_android#app#VoiceInteractor#registerOnDestroyedCallback_E@. This method will be called only after @B_android#app#Activity#onStart_E@ is being called and before @B_android#app#Activity#onStop_E@ is being called. You should pass to the callback the currently supported direct actions which cannot be null or contain null elements. You should return the action list as soon as possible to ensure the consumer, for example the assistant, is as responsive as possible which would improve user experience of your app.", "history": "Added in API level 29", "FullName": "public void onGetDirectActions (CancellationSignal cancellationSignal, Consumer<List<DirectAction>> callback)"}, "recreate()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Cause this Activity to be recreated with a new instance. This results in essentially the same flow as when the Activity is created due to a configuration change -- the current instance will go through its lifecycle to @B_android#app#Activity#onDestroy_E@ and a new instance then created after it.", "history": "Added in API level 11", "FullName": "public void recreate ()"}, "onNavigateUpFromChild(android.app.Activity)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity making the call."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when a child activity of this one attempts to navigate up. The default implementation simply calls onNavigateUp() on this activity (the parent).", "history": "Added in API level 16", "FullName": "public boolean onNavigateUpFromChild (Activity child)"}, "onKeyShortcut(int,android.view.KeyEvent)": {"Returns": [["boolean", "True if the key shortcut was handled."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a key shortcut event is not handled by any of the views in the Activity. Override this method to implement global key shortcuts for the Activity. Key shortcuts can also be implemented by setting the @B_android#view#MenuItem#setShortcut_E@ property of menu items.", "history": "Added in API level 11", "FullName": "public boolean onKeyShortcut (int keyCode, KeyEvent event)"}, "addContentView(android.view.View,android.view.ViewGroup.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The desired content to display."], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: Layout parameters for the view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add an additional content view to the activity. Added after any existing ones in the activity -- existing views are NOT removed.", "history": "Added in API level 1", "FullName": "public void addContentView (View view, ViewGroup.LayoutParams params)"}, "releaseInstance()": {"Returns": [["boolean", "Returns true if the activity was in a state that it has started the process of destroying its current instance; returns false if for any reason this could not be done: it is currently visible to the user, it is already being destroyed, it is being finished, it hasn't yet saved its state, etc."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask that the local app instance of this activity be released to free up its memory. This is asking for the activity to be destroyed, but does", "history": "Added in API level 21", "FullName": "public boolean releaseInstance ()"}, "requestDragAndDropPermissions(android.view.DragEvent)": {"Returns": [["@B_android#view#DragAndDropPermissions_E@", "The @B_android#view#DragAndDropPermissions_E@ object used to control access to the content URIs. Null if no content URIs are associated with the event or if permissions could not be granted."]], "Parameters": [["@B_android#view#DragEvent_E@", "DragEvent: Drag event"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create @B_android#view#DragAndDropPermissions_E@ object bound to this activity and controlling the access permissions for content URIs associated with the @B_android#view#DragEvent_E@.", "history": "Added in API level 24", "FullName": "public DragAndDropPermissions requestDragAndDropPermissions (DragEvent event)"}, "navigateUpTo(android.content.Intent)": {"Returns": [["boolean", "true if up navigation successfully reached the activity indicated by upIntent and upIntent was delivered to it. false if an instance of the indicated activity could not be found and this activity was simply finished normally."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: An intent representing the target destination for up navigation"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Navigate from this activity to the activity specified by upIntent, finishing this activity in the process. If the activity indicated by upIntent already exists in the task's history, this activity and all others before the indicated activity in the history stack will be finished. If the indicated activity does not appear in the history stack, this will finish each activity in this task until the root activity of the task is reached, resulting in an \"in-app home\" behavior. This can be useful in apps with a complex navigation hierarchy when an activity may be reached by a path not passing through a canonical parent activity. This method should be used when performing up navigation from within the same task as the destination. If up navigation should cross tasks in some cases, see @B_android#app#Activity#shouldUpRecreateTask_E@.", "history": "Added in API level 16", "FullName": "public boolean navigateUpTo (Intent upIntent)"}, "getWindowManager()": {"Returns": [["@B_android#view#WindowManager_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the window manager for showing custom windows.", "history": "Added in API level 1", "FullName": "public WindowManager getWindowManager ()"}, "setEnterSharedElementCallback(android.app.SharedElementCallback)": {"Returns": [], "Parameters": [["@B_android#app#SharedElementCallback_E@", "SharedElementCallback: Used to manipulate shared element transitions on the launched Activity."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "When @B_android#app#ActivityOptions#makeSceneTransitionAnimation_E@ was used to start an Activity, @B_android#view#Window#FEATURE_ACTIVITY_TRANSITIONS_E@.", "history": "Added in API level 21", "FullName": "public void setEnterSharedElementCallback (SharedElementCallback callback)"}, "setRequestedOrientation(int)": {"Returns": [], "Parameters": [["int", "int: An orientation constant as used in @B_android#content#pm#ActivityInfo#screenOrientation_E@. Value is android.content.pm.ActivityInfo.SCREEN_ORIENTATION_UNSET, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_UNSPECIFIED_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_LANDSCAPE_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_PORTRAIT_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_USER_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_BEHIND_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_SENSOR_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_NOSENSOR_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_SENSOR_LANDSCAPE_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_SENSOR_PORTRAIT_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_REVERSE_LANDSCAPE_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_REVERSE_PORTRAIT_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_FULL_SENSOR_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_USER_LANDSCAPE_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_USER_PORTRAIT_E@, @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_FULL_USER_E@, or @B_android#content#pm#ActivityInfo#SCREEN_ORIENTATION_LOCKED_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change the desired orientation of this activity. If the activity is currently in the foreground or otherwise impacting the screen orientation, the screen will immediately be changed (possibly causing the activity to be restarted). Otherwise, this will be used the next time the activity is visible.", "history": "Added in API level 1", "FullName": "public void setRequestedOrientation (int requestedOrientation)"}, "setVolumeControlStream(int)": {"Returns": [], "Parameters": [["int", "int: The type of the audio stream whose volume should be changed by the hardware volume controls."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Suggests an audio stream whose volume should be changed by the hardware volume controls. The suggested audio stream will be tied to the window of this Activity. Volume requests which are received while the Activity is in the foreground will affect this stream. It is not guaranteed that the hardware volume controls will always change this stream's volume (for example, if a call is in progress, its stream's volume may be changed instead). To reset back to the default, use @B_android#media#AudioManager#USE_DEFAULT_STREAM_TYPE_E@.", "history": "Added in API level 1", "FullName": "public final void setVolumeControlStream (int streamType)"}, "finishAfterTransition()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#ActivityOptions#makeSceneTransitionAnimation_E@"], "Permissions": [], "Description": "Reverses the Activity Scene entry Transition and triggers the calling Activity to reverse its exit Transition. When the exit Transition completes, @B_android#app#Activity#finish_E@ is called. If no entry Transition was used, finish() is called immediately and the Activity exit Transition is run.", "history": "Added in API level 21", "FullName": "public void finishAfterTransition ()"}, "triggerSearch(java.lang.String, android.os.Bundle)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The query to trigger. If empty, the request will be ignored."], ["@B_android#os#Bundle_E@", "Bundle: An application can insert application-specific context here, in order to improve quality or specificity of its own searches. This data will be returned with SEARCH intent(s). Null if no extra data is required. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Similar to @B_android#app#Activity#startSearch_E@, but actually fires off the search query after invoking the search dialog. Made available for testing purposes.", "history": "added in API level 5", "FullName": "public void triggerSearch (String query, Bundle appSearchData)"}, "setProgressBarVisibility(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether to show the progress bars in the title."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "No longer supported starting in API 21. Sets the visibility of the progress bar in the title. In order for the progress bar to be shown, the feature must be requested via @B_android#app#Activity#requestWindowFeature_E@.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public final void setProgressBarVisibility (boolean visible)"}, "onPictureInPictureModeChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the activity is in picture-in-picture mode."]], "Throws": [], "SeeAlso": ["@B_android#R#attr#supportsPictureInPicture_E@"], "Permissions": [], "Description": "Use @B_android#app#Activity#onPictureInPictureModeChanged_E@ instead. Called by the system when the activity changes to and from picture-in-picture mode.", "history": "Added in API level 24 Deprecated in API level 26", "FullName": "public void onPictureInPictureModeChanged (boolean isInPictureInPictureMode)"}, "startActivityForResult(android.content.Intent,int)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to start."], ["int", "int: If >= 0, this code will be returned in onActivityResult() when the activity exits."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Activity#startActivity_E@"], "Permissions": [], "Description": "Same as calling @B_android#app#Activity#startActivityForResult_E@ with no options.", "history": "Added in API level 1", "FullName": "public void startActivityForResult (Intent intent, int requestCode)"}, "dump(java.lang.String,java.io.FileDescriptor,java.io.PrintWriter,java.lang.String[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Desired prefix to prepend at each line of output. This value must never be null."], ["@B_java#io#FileDescriptor_E@", "FileDescriptor: The raw file descriptor that the dump is being sent to. This value may be null."], ["@B_java#io#PrintWriter_E@", "PrintWriter: The PrintWriter to which you should dump your state. This will be closed for you after you return. This value must never be null."], ["@B_java#lang#String_E@", "String: additional arguments to the dump request. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Print the Activity's state into the given stream. This gets invoked if you run \"adb shell dumpsys activity <activity_component_name>\".", "history": "Added in API level 11", "FullName": "public void dump (String prefix, FileDescriptor fd, PrintWriter writer, String[] args)"}, "startActivities(android.content.Intent[])": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intents to start."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Activity#startActivities_E@", "@B_android#app#Activity#startActivityForResult_E@"], "Permissions": [], "Description": "Same as @B_android#app#Activity#startActivities_E@ with no options specified.", "history": "Added in API level 11", "FullName": "public void startActivities (Intent[] intents)"}, "isVoiceInteraction()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check whether this activity is running as part of a voice interaction with the user. If true, it should perform its interaction with the user through the @B_android#app#VoiceInteractor_E@ returned by @B_android#app#Activity#getVoiceInteractor_E@.", "history": "Added in API level 23", "FullName": "public boolean isVoiceInteraction ()"}, "onContentChanged()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This hook is called whenever the content view of the screen changes (due to a call to @B_android#view#Window#setContentView_E@ or @B_android#view#Window#addContentView_E@).", "history": "Added in API level 1", "FullName": "public void onContentChanged ()"}, "dispatchKeyEvent(android.view.KeyEvent)": {"Returns": [["boolean", "boolean Return true if this event was consumed."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to process key events. You can override this to intercept all key events before they are dispatched to the window. Be sure to call this implementation for key events that should be handled normally.", "history": "Added in API level 1", "FullName": "public boolean dispatchKeyEvent (KeyEvent event)"}, "enterPictureInPictureMode()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#enterPictureInPictureMode_E@", "@B_android#R#attr#supportsPictureInPicture_E@"], "Permissions": [], "Description": "Puts the activity in picture-in-picture mode if possible in the current system state. Any prior calls to @B_android#app#Activity#setPictureInPictureParams_E@ will still apply when entering picture-in-picture through this call.", "history": "Added in API level 24 Deprecated in API level 26", "FullName": "public void enterPictureInPictureMode ()"}, "attachBaseContext(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The new base context for this wrapper."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the base context for this ContextWrapper. All calls will then be delegated to the base context. Throws IllegalStateException if a base context has already been set.", "history": "Added in API level 1", "FullName": "protected void attachBaseContext (Context newBase)"}, "onNavigateUp()": {"Returns": [["boolean", "true if Up navigation completed successfully and this Activity was finished, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is called whenever the user chooses to navigate Up within your application's activity hierarchy from the action bar. If the attribute @B_android#R#attr#parentActivityName_E@ was specified in the manifest for this activity or an activity-alias to it, default Up navigation will be handled automatically. If any activity along the parent chain requires extra Intent arguments, the Activity subclass should override the method @B_android#app#Activity#onPrepareNavigateUpTaskStack_E@ to supply those arguments. See See the @B_android#app#TaskStackBuilder_E@ class and the Activity methods @B_android#app#Activity#getParentActivityIntent_E@, @B_android#app#Activity#shouldUpRecreateTask_E@, and @B_android#app#Activity#navigateUpTo_E@ for help implementing custom Up navigation. The AppNavigation sample application in the Android SDK is also available for reference.", "history": "Added in API level 16", "FullName": "public boolean onNavigateUp ()"}, "getComponentName()": {"Returns": [["@B_android#content#ComponentName_E@", "Returns the complete component name for this activity"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the complete component name of this activity.", "history": "Added in API level 1", "FullName": "public ComponentName getComponentName ()"}, "startLocalVoiceInteraction(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: a Bundle of private arguments to the current voice interaction service"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Starts a local voice interaction session. When ready, @B_android#app#Activity#onLocalVoiceInteractionStarted_E@ is called. You can pass a bundle of private options to the registered voice interaction service.", "history": "Added in API level 24", "FullName": "public void startLocalVoiceInteraction (Bundle privateOptions)"}, "onPrepareDialog(int,android.app.Dialog,android.os.Bundle)": {"Returns": [], "Parameters": [["int", "int: The id of the managed dialog."], ["@B_android#app#Dialog_E@", "Dialog: The dialog."], ["@B_android#os#Bundle_E@", "Bundle: The dialog arguments provided to @B_android#app#Activity#showDialog_E@."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreateDialog_E@", "@B_android#app#Activity#showDialog_E@", "@B_android#app#Activity#dismissDialog_E@", "@B_android#app#Activity#removeDialog_E@"], "Permissions": [], "Description": "Use the new @B_android#app#DialogFragment_E@ class with @B_android#app#FragmentManager_E@ instead; this is also available on older platforms through the Android compatibility package. Provides an opportunity to prepare a managed dialog before it is being shown. The default implementation calls through to @B_android#app#Activity#onPrepareDialog_E@ for compatibility. Override this if you need to update a managed dialog based on the state of the application each time it is shown. For example, a time picker dialog might want to be updated with the current time. You should call through to the superclass's implementation. The default implementation will set this Activity as the owner activity on the Dialog.", "history": "Added in API level 8 Deprecated in API level 15", "FullName": "protected void onPrepareDialog (int id, Dialog dialog, Bundle args)"}, "onCreateDialog(int,android.os.Bundle)": {"Returns": [["@B_android#app#Dialog_E@", "The dialog. If you return null, the dialog will not be created."]], "Parameters": [["int", "int: The id of the dialog."], ["@B_android#os#Bundle_E@", "Bundle: The dialog arguments provided to @B_android#app#Activity#showDialog_E@."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onPrepareDialog_E@", "@B_android#app#Activity#showDialog_E@", "@B_android#app#Activity#dismissDialog_E@", "@B_android#app#Activity#removeDialog_E@"], "Permissions": [], "Description": "Use the new @B_android#app#DialogFragment_E@ class with @B_android#app#FragmentManager_E@ instead; this is also available on older platforms through the Android compatibility package. Callback for creating dialogs that are managed (saved and restored) for you by the activity. The default implementation calls through to @B_android#app#Activity#onCreateDialog_E@ for compatibility. If you are targeting @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ or later, consider instead using a @B_android#app#DialogFragment_E@ instead. If you use @B_android#app#Activity#showDialog_E@, the activity will call through to this method the first time, and hang onto it thereafter. Any dialog that is created by this method will automatically be saved and restored for you, including whether it is showing. If you would like the activity to manage saving and restoring dialogs for you, you should override this method and handle any ids that are passed to @B_android#app#Activity#showDialog_E@. If you would like an opportunity to prepare your dialog before it is shown, override @B_android#app#Activity#onPrepareDialog_E@.", "history": "Added in API level 8 Deprecated in API level 15", "FullName": "protected Dialog onCreateDialog (int id, Bundle args)"}, "setPictureInPictureParams(android.app.PictureInPictureParams)": {"Returns": [], "Parameters": [["@B_android#app#PictureInPictureParams_E@", "PictureInPictureParams: the new parameters for the picture-in-picture. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Updates the properties of the picture-in-picture activity, or sets it to be used later when @B_android#app#Activity#enterPictureInPictureMode_E@ is called.", "history": "Added in API level 26", "FullName": "public void setPictureInPictureParams (PictureInPictureParams params)"}, "shouldShowRequestPermissionRationale(java.lang.String)": {"Returns": [["boolean", "Whether you can show permission rationale UI."]], "Parameters": [["@B_java#lang#String_E@", "String: A permission your app wants to request. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#ContextWrapper#checkSelfPermission_E@", "@B_android#app#Activity#requestPermissions_E@", "@B_android#app#Activity#onRequestPermissionsResult_E@"], "Permissions": [], "Description": "Gets whether you should show UI with rationale for requesting a permission. You should do this only if you do not have the permission and the context in which the permission is requested does not clearly communicate to the user what would be the benefit from granting this permission. For example, if you write a camera app, requesting the camera permission would be expected by the user and no rationale for why it is requested is needed. If however, the app needs location for tagging photos then a non-tech savvy user may wonder how location is related to taking photos. In this case you may choose to show UI with rationale of requesting this permission.", "history": "Added in API level 23", "FullName": "public boolean shouldShowRequestPermissionRationale (String permission)"}, "startActivityIfNeeded(android.content.Intent,int,android.os.Bundle)": {"Returns": [["boolean", "If a new activity was launched then true is returned; otherwise false is returned and you must handle the Intent yourself."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to start. This value must never be null."], ["int", "int: If >= 0, this code will be returned in onActivityResult() when the activity exits, as described in @B_android#app#Activity#startActivityForResult_E@."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#startActivity_E@", "@B_android#app#Activity#startActivityForResult_E@"], "Permissions": [], "Description": "A special variation to launch an activity only if a new activity instance is needed to handle the given Intent. In other words, this is just like @B_android#app#Activity#startActivityForResult_E@ except: if you are using the @B_android#content#Intent#FLAG_ACTIVITY_SINGLE_TOP_E@ flag, or singleTask or singleTop @B_android#R#styleable#AndroidManifestActivity_launchMode_E@, and the activity that handles @B_android#app#Activity#onNewIntent_E@ this function will return and you can handle the Intent yourself. This function can only be called from a top-level activity; if it is called from a child activity, a runtime exception will be thrown.", "history": "Added in API level 16", "FullName": "public boolean startActivityIfNeeded (Intent intent, int requestCode, Bundle options)"}, "startNextMatchingActivity(android.content.Intent)": {"Returns": [["boolean", "Returns a boolean indicating whether there was another Activity to start: true if there was a next activity to start, false if there wasn't. In general, if true is returned you will then want to call finish() on yourself."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to dispatch to the next activity. For correct behavior, this must be the same as the Intent that started your own activity; the only changes you can make are to the extras inside of it. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as calling @B_android#app#Activity#startNextMatchingActivity_E@ with no options.", "history": "Added in API level 1", "FullName": "public boolean startNextMatchingActivity (Intent intent)"}, "unregisterForContextMenu(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view that should stop showing a context menu."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#registerForContextMenu_E@"], "Permissions": [], "Description": "Prevents a context menu to be shown for the given view. This method will remove the @B_android#view#View#OnCreateContextMenuListener_E@ on the view.", "history": "Added in API level 1", "FullName": "public void unregisterForContextMenu (View view)"}, "onPrepareDialog(int,android.app.Dialog)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["@B_android#app#Dialog_E@", "Dialog no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Old no-arguments version of @B_android#app#Activity#onPrepareDialog_E@.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "protected void onPrepareDialog (int id, Dialog dialog)"}, "startIntentSenderFromChild(android.app.Activity,android.content.IntentSender,int,android.content.Intent,int,int,int)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity no parameter comment"], ["@B_android#content#IntentSender_E@", "IntentSender no parameter comment"], ["int", "int no parameter comment"], ["@B_android#content#Intent_E@", "Intent no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [["@B_android#content#IntentSender#SendIntentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Same as calling @B_android#app#Activity#startIntentSenderFromChild_E@ with no options.", "history": "Added in API level 5", "FullName": "public void startIntentSenderFromChild (Activity child, IntentSender intent, int requestCode, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)"}, "startPostponedEnterTransition()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begin postponed transitions after @B_android#app#Activity#postponeEnterTransition_E@ was called. If postponeEnterTransition() was called, you must call startPostponedEnterTransition() to have your Activity start drawing.", "history": "Added in API level 21", "FullName": "public void startPostponedEnterTransition ()"}, "navigateUpToFromChild(android.app.Activity,android.content.Intent)": {"Returns": [["boolean", "true if up navigation successfully reached the activity indicated by upIntent and upIntent was delivered to it. false if an instance of the indicated activity could not be found and this activity was simply finished normally."]], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity making the call."], ["@B_android#content#Intent_E@", "Intent: An intent representing the target destination for up navigation"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when a child activity of this one calls its @B_android#app#Activity#navigateUpTo_E@ method. The default implementation simply calls navigateUpTo(upIntent) on this activity (the parent).", "history": "Added in API level 16", "FullName": "public boolean navigateUpToFromChild (Activity child, Intent upIntent)"}, "setFinishOnTouchOutside(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets whether this activity is finished when touched outside its window's bounds.", "history": "Added in API level 11", "FullName": "public void setFinishOnTouchOutside (boolean finish)"}, "requireViewById(int)": {"Returns": [["T", "a view with given ID This value will never be null."]], "Parameters": [["int", "int: the ID to search for"]], "Throws": [], "SeeAlso": ["@B_android#view#View#requireViewById_E@", "@B_android#app#Activity#findViewById_E@"], "Permissions": [], "Description": "Finds a view that was identified by the android:id XML attribute that was processed in @B_android#app#Activity#onCreate_E@, or throws an IllegalArgumentException if the ID is invalid, or there is no matching view in the hierarchy.", "history": "Added in API level 28", "FullName": "public final T requireViewById (int id)"}, "onKeyUp(int,android.view.KeyEvent)": {"Returns": [["boolean", "Return true to prevent this event from being propagated further, or false to indicate that you have not handled this event and it should continue to be propagated."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onKeyDown_E@", "@B_android#view#KeyEvent_E@"], "Permissions": [], "Description": "Called when a key was released and not handled by any of the views inside of the activity. So, for example, key presses while the cursor is inside a TextView will not trigger the event (unless it is a navigation to another object) because TextView handles its own key presses. The default implementation handles KEYCODE_BACK to stop the activity and go back.", "history": "Added in API level 1", "FullName": "public boolean onKeyUp (int keyCode, KeyEvent event)"}, "onPostCreate(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: If the activity is being re-initialized after previously being shut down then this Bundle contains the data it most recently supplied in @B_android#app#Activity#onSaveInstanceState_E@. Note: Otherwise it is null. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreate_E@"], "Permissions": [], "Description": "Called when activity start-up is complete (after @B_android#app#Activity#onStart_E@ and @B_android#app#Activity#onRestoreInstanceState_E@ have been called). Applications will generally not implement this method; it is intended for system classes to do final initialization after application code has run. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onPostCreate (Bundle savedInstanceState)"}, "startManagingCursor(android.database.Cursor)": {"Returns": [], "Parameters": [["@B_android#database#Cursor_E@", "Cursor: The Cursor to be managed."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#managedQuery_E@", "@B_android#app#Activity#stopManagingCursor_E@"], "Permissions": [], "Description": "Use the new @B_android#content#CursorLoader_E@ class with @B_android#app#LoaderManager_E@ instead; this is also available on older platforms through the Android compatibility package. This method allows the activity to take care of managing the given @B_android#database#Cursor_E@'s lifecycle for you based on the activity's lifecycle. That is, when the activity is stopped it will automatically call @B_android#database#Cursor#deactivate_E@ on the given Cursor, and when it is later restarted it will call @B_android#database#Cursor#requery_E@ for you. When the activity is destroyed, all managed Cursors will be closed automatically. If you are targeting @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ or later, consider instead using @B_android#app#LoaderManager_E@ instead, available via @B_android#app#Activity#getLoaderManager_E@. @B_android#database#Cursor#close_E@ on cursor obtained from @B_android#app#Activity#managedQuery_E@, because the activity will do that for you at the appropriate time. However, if you call @B_android#app#Activity#stopManagingCursor_E@ on a cursor from a managed query, the system will not automatically close the cursor and, in that case, you must call @B_android#database#Cursor#close_E@.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public void startManagingCursor (Cursor c)"}, "onCreateDescription()": {"Returns": [["@B_java#lang#CharSequence_E@", "A description of what the user is doing. It should be short and sweet (only a few words)."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onSaveInstanceState_E@", "@B_android#app#Activity#onStop_E@"], "Permissions": [], "Description": "Generate a new description for this activity. This method is called before stopping the activity and can, if desired, return some textual description of its current state to be displayed to the user. The default implementation returns null, which will cause you to inherit the description from the previous activity. If all activities return null, generally the label of the top activity will be used as the description.", "history": "Added in API level 1", "FullName": "public CharSequence onCreateDescription ()"}, "getCallingPackage()": {"Returns": [["@B_java#lang#String_E@", "The package of the activity that will receive your reply, or null if none."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the name of the package that invoked this activity. This is who the data in @B_android#app#Activity#setResult_E@ will be sent to. You can use this information to validate that the recipient is allowed to receive the data. Note: if the calling activity is not expecting a result (that is it did not use the @B_android#app#Activity#startActivityForResult_E@ form that includes a request code), then the calling package will be null. Note: prior to @B_android#os#Build#VERSION_CODES#JELLY_BEAN_MR2_E@, the result from this method was unstable. If the process hosting the calling package was no longer running, it would return null instead of the proper package name. You can use @B_android#app#Activity#getCallingActivity_E@ and retrieve the package name from that instead.", "history": "Added in API level 1", "FullName": "public String getCallingPackage ()"}, "onPrepareNavigateUpTaskStack(android.app.TaskStackBuilder)": {"Returns": [], "Parameters": [["@B_android#app#TaskStackBuilder_E@", "TaskStackBuilder: A TaskStackBuilder that has been populated with Intents by onCreateNavigateUpTaskStack."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Prepare the synthetic task stack that will be generated during Up navigation from a different task. This method receives the @B_android#app#TaskStackBuilder_E@ with the constructed series of Intents as generated by @B_android#app#Activity#onCreateNavigateUpTaskStack_E@. If any extra data should be added to these intents before launching the new task, the application should override this method and add that data here.", "history": "Added in API level 16", "FullName": "public void onPrepareNavigateUpTaskStack (TaskStackBuilder builder)"}, "setMediaController(android.media.session.MediaController)": {"Returns": [], "Parameters": [["@B_android#media#session#MediaController_E@", "MediaController: The controller for the session which should receive media keys and volume changes."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets a @B_android#media#session#MediaController_E@ to send media keys and volume changes to. The controller will be tied to the window of this Activity. Media key and volume events which are received while the Activity is in the foreground will be forwarded to the controller and used to invoke transport controls or adjust the volume. This may be used instead of or in addition to @B_android#app#Activity#setVolumeControlStream_E@ to affect a specific session instead of a specific stream. It is not guaranteed that the hardware volume controls will always change this session's volume (for example, if a call is in progress, its stream's volume may be changed instead). To reset back to the default use null as the controller.", "history": "Added in API level 21", "FullName": "public final void setMediaController (MediaController controller)"}, "isInPictureInPictureMode()": {"Returns": [["boolean", "True if the activity is in picture-in-picture mode."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#R#attr#supportsPictureInPicture_E@"], "Permissions": [], "Description": "Returns true if the activity is currently in picture-in-picture mode.", "history": "Added in API level 24", "FullName": "public boolean isInPictureInPictureMode ()"}, "onProvideKeyboardShortcuts(java.util.List<android.view.KeyboardShortcutGroup>,android.view.Menu,int)": {"Returns": [], "Parameters": [["@B_java#util#List_E@", "List: The data list to populate with shortcuts."], ["@B_android#view#Menu_E@", "Menu: The current menu, which may be null. This value may be null."], ["int", "int: The id for the connected device the shortcuts should be provided for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when Keyboard Shortcuts are requested for the current window.", "history": "Added in API level 24", "FullName": "public void onProvideKeyboardShortcuts (List<KeyboardShortcutGroup> data, Menu menu, int deviceId)"}, "isActivityTransitionRunning()": {"Returns": [["boolean", "true if a transition is currently running on this activity, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether there are any activity transitions currently running on this activity. A return value of true can mean that either an enter or exit transition is running, including whether the background of the activity is animating as a part of that transition.", "history": "Added in API level 26", "FullName": "public boolean isActivityTransitionRunning ()"}, "getContentScene()": {"Returns": [["@B_android#transition#Scene_E@", "Current Scene being shown or null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the @B_android#transition#Scene_E@ representing this window's current content. Requires @B_android#view#Window#FEATURE_CONTENT_TRANSITIONS_E@. This method will return null if the current content is not represented by a Scene.", "history": "Added in API level 21", "FullName": "public Scene getContentScene ()"}, "onStateNotSaved()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "starting with @B_android#os#Build#VERSION_CODES#P_E@ onSaveInstanceState is called after @B_android#app#Activity#onStop_E@, so this hint isn't accurate anymore: you should consider your state not saved in between onStart and onStop callbacks inclusively. Called when an @B_android#app#Activity#onResume_E@ is coming up, prior to other pre-resume callbacks such as @B_android#app#Activity#onNewIntent_E@ and @B_android#app#Activity#onActivityResult_E@. This is primarily intended to give the activity a hint that its state is no longer saved -- it will generally be called after @B_android#app#Activity#onSaveInstanceState_E@ and prior to the activity being resumed/started again.", "history": "Added in API level 23 Deprecated in API level 29", "FullName": "public void onStateNotSaved ()"}, "onCreateThumbnail(android.graphics.Bitmap,android.graphics.Canvas)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#graphics#Bitmap_E@", "Bitmap no parameter comment"], ["@B_android#graphics#Canvas_E@", "Canvas no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Method doesn't do anything and will be removed in the future.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public boolean onCreateThumbnail (Bitmap outBitmap, Canvas canvas)"}, "onPause()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onResume_E@", "@B_android#app#Activity#onSaveInstanceState_E@", "@B_android#app#Activity#onStop_E@"], "Permissions": [], "Description": "Called as part of the activity lifecycle when the user no longer actively interacts with the activity, but it is still visible on screen. The counterpart to @B_android#app#Activity#onResume_E@. When activity B is launched in front of activity A, this callback will be invoked on A. B will not be created until A's @B_android#app#Activity#onPause_E@ returns, so be sure to not do anything lengthy here. This callback is mostly used for saving any persistent state the activity is editing, to present a \"edit in place\" model to the user and making sure nothing is lost if there are not enough resources to start the new activity without first killing this one. This is also a good place to stop things that consume a noticeable amount of CPU in order to make the switch to the next activity as fast as possible. On platform versions prior to @B_android#os#Build#VERSION_CODES#Q_E@ this is also a good place to try to close exclusive-access devices or to release access to singleton resources. Starting with @B_android#os#Build#VERSION_CODES#Q_E@ there can be multiple resumed activities in the system at the same time, so @B_android#app#Activity#onTopResumedActivityChanged_E@ should be used for that purpose instead. If an activity is launched on top, after receiving this call you will usually receive a following call to @B_android#app#Activity#onStop_E@ (after the next activity has been resumed and displayed above). However in some cases there will be a direct call back to @B_android#app#Activity#onResume_E@ without going through the stopped state. An activity can also rest in paused state in some cases when in multi-window mode, still visible to user. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onPause ()"}, "getTitleColor()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public final int getTitleColor ()"}, "requestWindowFeature(int)": {"Returns": [["boolean", "Returns true if the requested feature is supported and now enabled."]], "Parameters": [["int", "int: The desired feature as defined in @B_android#view#Window_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#Window#requestFeature_E@"], "Permissions": [], "Description": "Enable extended window features. This is a convenience for calling @B_android#view#Window#requestFeature_E@.", "history": "Added in API level 1", "FullName": "public final boolean requestWindowFeature (int featureId)"}, "stopManagingCursor(android.database.Cursor)": {"Returns": [], "Parameters": [["@B_android#database#Cursor_E@", "Cursor: The Cursor that was being managed."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#startManagingCursor_E@"], "Permissions": [], "Description": "Use the new @B_android#content#CursorLoader_E@ class with @B_android#app#LoaderManager_E@ instead; this is also available on older platforms through the Android compatibility package. Given a Cursor that was previously given to @B_android#app#Activity#startManagingCursor_E@, stop the activity's management of that cursor. will not automatically close the cursor and you must call @B_android#database#Cursor#close_E@.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public void stopManagingCursor (Cursor c)"}, "startActionMode(android.view.ActionMode.Callback)": {"Returns": [["@B_android#view#ActionMode_E@", "The ActionMode that was started, or null if it was canceled"]], "Parameters": [["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: Callback that will manage lifecycle events for this action mode"]], "Throws": [], "SeeAlso": ["@B_android#view#ActionMode_E@"], "Permissions": [], "Description": "Start an action mode of the default type @B_android#view#ActionMode#TYPE_PRIMARY_E@.", "history": "Added in API level 11", "FullName": "public ActionMode startActionMode (ActionMode.Callback callback)"}, "openContextMenu(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view to show the context menu for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Programmatically opens the context menu for a particular view. The view should have been added via @B_android#app#Activity#registerForContextMenu_E@.", "history": "Added in API level 1", "FullName": "public void openContextMenu (View view)"}, "onCreateDialog(int)": {"Returns": [["@B_android#app#Dialog_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Old no-arguments version of @B_android#app#Activity#onCreateDialog_E@.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "protected Dialog onCreateDialog (int id)"}, "onMenuOpened(int, android.view.Menu)": {"Returns": [["boolean", "The default implementation returns true."]], "Parameters": [["int", "int: The panel that the menu is in."], ["@B_android#view#Menu_E@", "Menu: The menu that is opened."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a panel's menu is opened by the user. This may also be called when the menu is changing from one type to another (for example, from the icon menu to the expanded menu).", "history": "added in API level 1", "FullName": "public boolean onMenuOpened (int featureId, Menu menu)"}, "onOptionsItemSelected(android.view.MenuItem)": {"Returns": [["boolean", "boolean Return false to allow normal menu processing to proceed, true to consume it here."]], "Parameters": [["@B_android#view#MenuItem_E@", "MenuItem: The menu item that was selected. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreateOptionsMenu_E@"], "Permissions": [], "Description": "This hook is called whenever an item in your options menu is selected. The default implementation simply returns false to have the normal processing happen (calling the item's Runnable or sending a message to its Handler as appropriate). You can use this method for any items for which you would like to do processing without those other facilities. Derived classes should call through to the base class for it to perform the default menu handling.", "history": "Added in API level 1", "FullName": "public boolean onOptionsItemSelected (MenuItem item)"}, "finishActivity(int)": {"Returns": [], "Parameters": [["int", "int: The request code of the activity that you had given to startActivityForResult(). If there are multiple activities started with this request code, they will all be finished."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Force finish another activity that you had previously started with @B_android#app#Activity#startActivityForResult_E@.", "history": "Added in API level 1", "FullName": "public void finishActivity (int requestCode)"}, "onActionModeStarted(android.view.ActionMode)": {"Returns": [], "Parameters": [["@B_android#view#ActionMode_E@", "ActionMode: The new action mode."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Notifies the Activity that an action mode has been started. Activity subclasses overriding this method should call the superclass implementation. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 11", "FullName": "public void onActionModeStarted (ActionMode mode)"}, "onNewIntent(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The new intent that was started for the activity."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#getIntent_E@", "@B_android#app#Activity#setIntent_E@", "@B_android#app#Activity#onResume_E@"], "Permissions": [], "Description": "This is called for activities that set launchMode to \"singleTop\" in their package, or if a client used the @B_android#content#Intent#FLAG_ACTIVITY_SINGLE_TOP_E@ flag when calling @B_android#app#Activity#startActivity_E@. In either case, when the activity is re-launched while at the top of the activity stack instead of a new instance of the activity being started, onNewIntent() will be called on the existing instance with the Intent that was used to re-launch it. An activity can never receive a new intent in the resumed state. You can count on @B_android#app#Activity#onResume_E@ being called after this method, though not necessarily immediately after the completion this callback. If the activity was resumed, it will be paused and new intent will be delivered, followed by @B_android#app#Activity#onResume_E@. If the activity wasn't in the resumed state, then new intent can be delivered immediately, with @B_android#app#Activity#onResume_E@ called sometime later when activity becomes active again. Note that @B_android#app#Activity#getIntent_E@ still returns the original Intent. You can use @B_android#app#Activity#setIntent_E@ to update it to this new Intent.", "history": "Added in API level 1", "FullName": "protected void onNewIntent (Intent intent)"}, "finishAffinity()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finish this activity as well as all activities immediately below it in the current task that have the same affinity. This is typically used when an application can be launched on to another task (such as from an ACTION_VIEW of a content type it understands) and the user has used the up navigation to switch out of the current task and in to its own task. In this case, if the user has navigated down into any other activities of the second application, all of those should be removed from the original task as part of the task switch. Note that this finish does not allow you to deliver results to the previous activity, and an exception will be thrown if you are trying to do so.", "history": "Added in API level 16", "FullName": "public void finishAffinity ()"}, "requestPermissions(java.lang.String[],int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The requested permissions. Must me non-null and not empty. This value must never be null."], ["int", "int: Application specific request code to match with a result reported to @B_android#app#Activity#onRequestPermissionsResult_E@. Should be >= 0."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if requestCode is negative."]], "SeeAlso": ["@B_android#app#Activity#onRequestPermissionsResult_E@", "@B_android#content#ContextWrapper#checkSelfPermission_E@", "@B_android#app#Activity#shouldShowRequestPermissionRationale_E@"], "Permissions": [], "Description": "Requests permissions to be granted to this application. These permissions must be requested in your manifest, they should not be granted to your app, and they should have protection level @B_android#content#pm#PermissionInfo#PROTECTION_DANGEROUS_E@, regardless whether they are declared by the platform or a third-party app. Normal permissions @B_android#content#pm#PermissionInfo#PROTECTION_NORMAL_E@ are granted at install time if requested in the manifest. Signature permissions @B_android#content#pm#PermissionInfo#PROTECTION_SIGNATURE_E@ are granted at install time if requested in the manifest and the signature of your app matches the signature of the app declaring the permissions. If your app does not have the requested permissions the user will be presented with UI for accepting them. After the user has accepted or rejected the requested permissions you will receive a callback on @B_android#app#Activity#onRequestPermissionsResult_E@ reporting whether the permissions were granted or not. Note that requesting a permission does not guarantee it will be granted and your app should be able to run without having this permission. This method may start an activity allowing the user to choose which permissions to grant and which to reject. Hence, you should be prepared that your activity may be paused and resumed. Further, granting some permissions may require a restart of you application. In such a case, the system will recreate the activity stack before delivering the result to @B_android#app#Activity#onRequestPermissionsResult_E@. When checking whether you have a permission you should use @B_android#content#ContextWrapper#checkSelfPermission_E@. Calling this API for permissions already granted to your app would show UI to the user to decide whether the app can still hold these permissions. This can be useful if the way your app uses data guarded by the permissions changes significantly. You cannot request a permission if your activity sets @B_android#R#styleable#AndroidManifestActivity_noHistory_E@ to true because in this case the activity would not receive result callbacks including @B_android#app#Activity#onRequestPermissionsResult_E@. The", "history": "Added in API level 23", "FullName": "public final void requestPermissions (String[] permissions, int requestCode)"}, "isLocalVoiceInteractionSupported()": {"Returns": [["boolean", "whether the current voice interaction service supports local voice interaction"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Queries whether the currently enabled voice interaction service supports returning a voice interactor for use by the activity. This is valid only for the duration of the activity.", "history": "Added in API level 24", "FullName": "public boolean isLocalVoiceInteractionSupported ()"}, "onOptionsMenuClosed(android.view.Menu)": {"Returns": [], "Parameters": [["@B_android#view#Menu_E@", "Menu: The options menu as last shown or first initialized by onCreateOptionsMenu()."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This hook is called whenever the options menu is being closed (either by the user canceling the menu with the back/menu button, or when an item is selected).", "history": "Added in API level 1", "FullName": "public void onOptionsMenuClosed (Menu menu)"}, "onGenericMotionEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true if you have consumed the event, false if you haven't. The default implementation always returns false."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The generic motion event being processed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a generic motion event was not handled by any of the views inside of the activity. Generic motion events describe joystick movements, mouse hovers, track pad touches, scroll wheel movements and other input events. The @B_android#view#MotionEvent#getSource_E@ of the motion event specifies the class of input that was received. Implementations of this method must examine the bits in the source before processing the event. The following code example shows how this is done. Generic motion events with source class @B_android#view#InputDevice#SOURCE_CLASS_POINTER_E@ are delivered to the view under the pointer. All other generic motion events are delivered to the focused view. See @B_android#view#View#onGenericMotionEvent_E@ for an example of how to handle this event.", "history": "Added in API level 12", "FullName": "public boolean onGenericMotionEvent (MotionEvent event)"}, "onRestart()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onStop_E@", "@B_android#app#Activity#onStart_E@", "@B_android#app#Activity#onResume_E@"], "Permissions": [], "Description": "Called after @B_android#app#Activity#onStop_E@ when the current activity is being re-displayed to the user (the user has navigated back to it). It will be followed by @B_android#app#Activity#onStart_E@ and then @B_android#app#Activity#onResume_E@. For activities that are using raw @B_android#database#Cursor_E@ objects (instead of creating them through @B_android#app#Activity#managedQuery_E@, this is usually the place where the cursor should be requeried (because you had deactivated it in @B_android#app#Activity#onStop_E@. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onRestart ()"}, "setFeatureDrawableUri(int,android.net.Uri)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["@B_android#net#Uri_E@", "Uri no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience for calling @B_android#view#Window#setFeatureDrawableUri_E@.", "history": "Added in API level 1", "FullName": "public final void setFeatureDrawableUri (int featureId, Uri uri)"}, "setTitle(java.lang.CharSequence)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change the title associated with this activity. If this is a top-level activity, the title for its window will change. If it is an embedded activity, the parent can do whatever it wants with it.", "history": "Added in API level 1", "FullName": "public void setTitle (CharSequence title)"}, "setProgress(int)": {"Returns": [], "Parameters": [["int", "int: The progress for the progress bar. Valid ranges are from 0 to 10000 (both inclusive). If 10000 is given, the progress bar will be completely filled and will fade out."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "No longer supported starting in API 21. Sets the progress for the progress bars in the title. In order for the progress bar to be shown, the feature must be requested via @B_android#app#Activity#requestWindowFeature_E@.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public final void setProgress (int progress)"}, "reportFullyDrawn()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Report to the system that your app is now fully drawn, purely for diagnostic purposes (calling it does not impact the visible behavior of the activity). This is only used to help instrument application launch times, so that the app can report when it is fully in a usable state; without this, the only thing the system itself can determine is the point at which the activity's window is first drawn and displayed. To participate in app launch time measurement, you should always call this method after first launch (when @B_android#app#Activity#onCreate_E@ is called), at the point where you have entirely drawn your UI and populated with all of the significant data. You can safely call this method any time after first launch as well, in which case it will simply be ignored.", "history": "Added in API level 19", "FullName": "public void reportFullyDrawn ()"}, "showLockTaskEscapeMessage()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Shows the user the system defined message for telling the user how to exit lock task mode. The task containing this activity must be in lock task mode at the time of this call for the message to be displayed.", "history": "Added in API level 23", "FullName": "public void showLockTaskEscapeMessage ()"}, "onRestoreInstanceState(android.os.Bundle,android.os.PersistableBundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: the data most recently supplied in @B_android#app#Activity#onSaveInstanceState_E@ or null. This value may be null."], ["@B_android#os#PersistableBundle_E@", "PersistableBundle: the data most recently supplied in @B_android#app#Activity#onSaveInstanceState_E@ or null. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onRestoreInstanceState_E@", "@B_android#app#Activity#onCreate_E@", "@B_android#app#Activity#onPostCreate_E@", "@B_android#app#Activity#onResume_E@", "@B_android#app#Activity#onSaveInstanceState_E@"], "Permissions": [], "Description": "This is the same as @B_android#app#Activity#onRestoreInstanceState_E@ but is called for activities created with the attribute @B_android#R#attr#persistableMode_E@ set to persistAcrossReboots. The @B_android#os#PersistableBundle_E@ passed came from the restored PersistableBundle first saved in @B_android#app#Activity#onSaveInstanceState_E@. This method is called between @B_android#app#Activity#onStart_E@ and @B_android#app#Activity#onPostCreate_E@. If this method is called @B_android#app#Activity#onRestoreInstanceState_E@ will not be called. At least one of savedInstanceState or persistentState will not be null.", "history": "Added in API level 21", "FullName": "public void onRestoreInstanceState (Bundle savedInstanceState, PersistableBundle persistentState)"}, "getLastNonConfigurationInstance()": {"Returns": [["@B_java#lang#Object_E@", "the object previously returned by @B_android#app#Activity#onRetainNonConfigurationInstance_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the non-configuration instance data that was previously returned by @B_android#app#Activity#onRetainNonConfigurationInstance_E@. This will be available from the initial @B_android#app#Activity#onCreate_E@ and @B_android#app#Activity#onStart_E@ calls to the new instance, allowing you to extract any useful dynamic state from the previous instance. Note that the data you retrieve here should only be used as an optimization for handling configuration changes. You should always be able to handle getting a null pointer back, and an activity must still be able to restore itself to its previous state (through the normal @B_android#app#Activity#onSaveInstanceState_E@ mechanism) even if this function returns null. @B_android#app#Fragment_E@ API @B_android#app#Fragment#setRetainInstance_E@ instead; this is also available on older platforms through the Android support libraries.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public Object getLastNonConfigurationInstance ()"}, "setFeatureDrawableAlpha(int,int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience for calling @B_android#view#Window#setFeatureDrawableAlpha_E@.", "history": "Added in API level 1", "FullName": "public final void setFeatureDrawableAlpha (int featureId, int alpha)"}, "stopLocalVoiceInteraction()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request to terminate the current voice interaction that was previously started using @B_android#app#Activity#startLocalVoiceInteraction_E@. When the interaction is terminated, @B_android#app#Activity#onLocalVoiceInteractionStopped_E@ will be called.", "history": "Added in API level 24", "FullName": "public void stopLocalVoiceInteraction ()"}, "setActionBar(android.widget.Toolbar)": {"Returns": [], "Parameters": [["@B_android#widget#Toolbar_E@", "Toolbar: Toolbar to set as the Activity's action bar, or null to clear it This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a @B_android#widget#Toolbar_E@ to act as the @B_android#app#ActionBar_E@ for this Activity window. When set to a non-null value the @B_android#app#Activity#getActionBar_E@ method will return an @B_android#app#ActionBar_E@ object that can be used to control the given toolbar as if it were a traditional window decor action bar. The toolbar's menu will be populated with the Activity's options menu and the navigation button will be wired through the standard @B_android#R#id#home_E@ menu select action. In order to use a Toolbar within the Activity's window content the application must not request the window feature @B_android#view#Window#FEATURE_ACTION_BAR_E@.", "history": "Added in API level 21", "FullName": "public void setActionBar (Toolbar toolbar)"}, "startSearch(java.lang.String,boolean,android.os.Bundle,boolean)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Any non-null non-empty string will be inserted as pre-entered text in the search query box. This value may be null."], ["boolean", "boolean: If true, the initial query will be preselected, which means that any further typing will replace it. This is useful for cases where an entire pre-formed query is being inserted. If false, the selection point will be placed at the end of the inserted query. This is useful when the inserted query is text that the user entered, and the user would expect to be able to keep typing. This parameter is only meaningful if initialQuery is a non-empty string."], ["@B_android#os#Bundle_E@", "Bundle: An application can insert application-specific context here, in order to improve quality or specificity of its own searches. This data will be returned with SEARCH intent(s). Null if no extra data is required. This value may be null."], ["boolean", "boolean: If false, this will only launch the search that has been specifically defined by the application (which is usually defined as a local search). If no default search is defined in the current application or activity, global search will be launched. If true, this will always launch a platform-global (e.g. web-based) search instead."]], "Throws": [], "SeeAlso": ["@B_android#app#SearchManager_E@", "@B_android#app#Activity#onSearchRequested_E@"], "Permissions": [], "Description": "This hook is called to launch the search UI. It is typically called from onSearchRequested(), either directly from Activity.onSearchRequested() or from an overridden version in any given Activity. If your goal is simply to activate search, it is preferred to call onSearchRequested(), which may have been overridden elsewhere in your Activity. If your goal is to inject specific data such as context data, it is preferred to Note: when running in a @B_android#content#res#Configuration#UI_MODE_TYPE_WATCH_E@, use of this API is not supported.", "history": "Added in API level 1", "FullName": "public void startSearch (String initialQuery, boolean selectInitialQuery, Bundle appSearchData, boolean globalSearch)"}, "dismissDialog(int)": {"Returns": [], "Parameters": [["int", "int: The id of the managed dialog."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the id was not previously shown via @B_android#app#Activity#showDialog_E@."]], "SeeAlso": ["@B_android#app#Activity#onCreateDialog_E@", "@B_android#app#Activity#onPrepareDialog_E@", "@B_android#app#Activity#showDialog_E@", "@B_android#app#Activity#removeDialog_E@"], "Permissions": [], "Description": "Use the new @B_android#app#DialogFragment_E@ class with @B_android#app#FragmentManager_E@ instead; this is also available on older platforms through the Android compatibility package. Dismiss a dialog that was previously shown via @B_android#app#Activity#showDialog_E@.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public final void dismissDialog (int id)"}, "onPerformDirectAction(java.lang.String,android.os.Bundle,android.os.CancellationSignal,java.util.function.Consumer<android.os.Bundle>)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The ID for the action you previously reported via @B_android#app#Activity#onGetDirectActions_E@. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: Any additional arguments provided by the caller that are specific to the given action. This value must never be null."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress. This value must never be null."], ["@B_java#util#function#Consumer_E@", "Consumer: The callback to provide the result back to the caller. You can call this on any thread. The result bundle is action specific. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onGetDirectActions_E@"], "Permissions": [], "Description": "This is called to perform an action previously defined by the app. Apps also have access to @B_android#app#Activity#getVoiceInteractor_E@ to follow up on the action.", "history": "Added in API level 29", "FullName": "public void onPerformDirectAction (String actionId, Bundle arguments, CancellationSignal cancellationSignal, Consumer<Bundle> resultListener)"}, "onSaveInstanceState(android.os.Bundle,android.os.PersistableBundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: Bundle in which to place your saved state. This value must never be null."], ["@B_android#os#PersistableBundle_E@", "PersistableBundle: State which will be saved across reboots. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onSaveInstanceState_E@", "@B_android#app#Activity#onCreate_E@", "@B_android#app#Activity#onRestoreInstanceState_E@", "@B_android#app#Activity#onPause_E@"], "Permissions": [], "Description": "This is the same as @B_android#app#Activity#onSaveInstanceState_E@ but is called for activities created with the attribute @B_android#R#attr#persistableMode_E@ set to persistAcrossReboots. The @B_android#os#PersistableBundle_E@ passed in will be saved and presented in @B_android#app#Activity#onCreate_E@ the first time that this activity is restarted following the next device reboot.", "history": "Added in API level 21", "FullName": "public void onSaveInstanceState (Bundle outState, PersistableBundle outPersistentState)"}, "onCreateNavigateUpTaskStack(android.app.TaskStackBuilder)": {"Returns": [], "Parameters": [["@B_android#app#TaskStackBuilder_E@", "TaskStackBuilder: An empty TaskStackBuilder - the application should add intents representing the desired task stack"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Define the synthetic task stack that will be generated during Up navigation from a different task. The default implementation of this method adds the parent chain of this activity as specified in the manifest to the supplied @B_android#app#TaskStackBuilder_E@. Applications may choose to override this method to construct the desired task stack in a different way. This method will be invoked by the default implementation of @B_android#app#Activity#onNavigateUp_E@ if @B_android#app#Activity#shouldUpRecreateTask_E@ returns true when supplied with the intent returned by @B_android#app#Activity#getParentActivityIntent_E@. Applications that wish to supply extra Intent parameters to the parent stack defined by the manifest should override @B_android#app#Activity#onPrepareNavigateUpTaskStack_E@.", "history": "Added in API level 16", "FullName": "public void onCreateNavigateUpTaskStack (TaskStackBuilder builder)"}, "onMultiWindowModeChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the activity is in multi-window mode."]], "Throws": [], "SeeAlso": ["@B_android#R#attr#resizeableActivity_E@"], "Permissions": [], "Description": "Use @B_android#app#Activity#onMultiWindowModeChanged_E@ instead. Called by the system when the activity changes from fullscreen mode to multi-window mode and visa-versa.", "history": "Added in API level 24 Deprecated in API level 26", "FullName": "public void onMultiWindowModeChanged (boolean isInMultiWindowMode)"}, "getActionBar()": {"Returns": [["@B_android#app#ActionBar_E@", "The Activity's ActionBar, or null if it does not have one."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a reference to this activity's ActionBar.", "history": "Added in API level 11", "FullName": "public ActionBar getActionBar ()"}, "setContentView(int)": {"Returns": [], "Parameters": [["int", "int: Resource ID to be inflated."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#setContentView_E@"], "Permissions": [], "Description": "Set the activity content from a layout resource. The resource will be inflated, adding all top-level views to the activity.", "history": "Added in API level 1", "FullName": "public void setContentView (int layoutResID)"}, "startIntentSender(android.content.IntentSender,android.content.Intent,int,int,int,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#IntentSender_E@", "IntentSender: The IntentSender to launch."], ["@B_android#content#Intent_E@", "Intent: If non-null, this will be provided as the intent parameter to @B_android#content#IntentSender#sendIntent_E@. This value may be null."], ["int", "int: Intent flags in the original IntentSender that you would like to change."], ["int", "int: Desired values for any bits set in flagsMask"], ["int", "int: Always set to 0."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. If options have also been supplied by the IntentSender, options given here will override any that conflict with those given by the IntentSender."]], "Throws": [["@B_android#content#IntentSender#SendIntentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#app#Activity#startActivity_E@, but taking a IntentSender to start; see @B_android#app#Activity#startIntentSenderForResult_E@ for more information.", "history": "Added in API level 16", "FullName": "public void startIntentSender (IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)"}, "startActivityFromFragment(android.app.Fragment,android.content.Intent,int)": {"Returns": [], "Parameters": [["@B_android#app#Fragment_E@", "Fragment: The fragment making the call. This value must never be null."], ["@B_android#content#Intent_E@", "Intent: The intent to start."], ["int", "int: Reply request code. < 0 if reply is not requested."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Fragment#startActivity_E@", "@B_android#app#Fragment#startActivityForResult_E@"], "Permissions": [], "Description": "Use https:##developer#android#com@B_android#support#v4#app#FragmentActivity#startActivityFromFragment_E@ Same as calling @B_android#app#Activity#startActivityFromFragment_E@ with no options.", "history": "Added in API level 11 Deprecated in API level 28", "FullName": "public void startActivityFromFragment (Fragment fragment, Intent intent, int requestCode)"}, "onMenuOpened(int,android.view.Menu)": {"Returns": [["boolean", "The default implementation returns true."]], "Parameters": [["int", "int: The panel that the menu is in."], ["@B_android#view#Menu_E@", "Menu: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a panel's menu is opened by the user. This may also be called when the menu is changing from one type to another (for example, from the icon menu to the expanded menu).", "history": "Added in API level 1", "FullName": "public boolean onMenuOpened (int featureId, Menu menu)"}, "onTitleChanged(java.lang.CharSequence,int)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "protected void onTitleChanged (CharSequence title, int color)"}, "getIntent()": {"Returns": [["@B_android#content#Intent_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the intent that started this activity.", "history": "Added in API level 1", "FullName": "public Intent getIntent ()"}, "finish()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this when your activity is done and should be closed. The ActivityResult is propagated back to whoever launched you via onActivityResult().", "history": "Added in API level 1", "FullName": "public void finish ()"}, "showDialog(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use the new @B_android#app#DialogFragment_E@ class with @B_android#app#FragmentManager_E@ instead; this is also available on older platforms through the Android compatibility package. Simple version of @B_android#app#Activity#showDialog_E@ that does not take any arguments. Simply calls @B_android#app#Activity#showDialog_E@ with null arguments.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public final void showDialog (int id)"}, "isDestroyed()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the final @B_android#app#Activity#onDestroy_E@ call has been made on the Activity, so this instance is now dead.", "history": "Added in API level 17", "FullName": "public boolean isDestroyed ()"}, "shouldUpRecreateTask(android.content.Intent)": {"Returns": [["boolean", "true if navigating up should recreate a new task stack, false if the same task should be used for the destination"]], "Parameters": [["@B_android#content#Intent_E@", "Intent: An intent representing the target destination for up navigation"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the app should recreate the task when navigating 'up' from this activity by using targetIntent. If this method returns false the app can trivially call @B_android#app#Activity#navigateUpTo_E@ using the same parameters to correctly perform up navigation. If this method returns false, the app should synthesize a new task stack by using @B_android#app#TaskStackBuilder_E@ or another similar mechanism to perform up navigation.", "history": "Added in API level 16", "FullName": "public boolean shouldUpRecreateTask (Intent targetIntent)"}, "registerActivityLifecycleCallbacks(android.app.Application.ActivityLifecycleCallbacks)": {"Returns": [], "Parameters": [["@B_android#app#Application#ActivityLifecycleCallbacks_E@", "Application.ActivityLifecycleCallbacks: The callback instance to register This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register an @B_android#app#Application#ActivityLifecycleCallbacks_E@ instance that receives lifecycle callbacks for only this Activity. In relation to any @B_android#app#Application#registerActivityLifecycleCallbacks_E@, the callbacks registered here will always occur nested within those callbacks. This means: Pre events will first be sent to Application registered callbacks, then to callbacks registered here. @B_android#app#Application#ActivityLifecycleCallbacks#onActivityCreated_E@, @B_android#app#Application#ActivityLifecycleCallbacks#onActivityStarted_E@, and @B_android#app#Application#ActivityLifecycleCallbacks#onActivityResumed_E@ will be sent first to Application registered callbacks, then to callbacks registered here. For all other events, callbacks registered here will be sent first. Post events will first be sent to callbacks registered here, then to Application registered callbacks. If multiple callbacks are registered here, they receive events in a first in (up through @B_android#app#Application#ActivityLifecycleCallbacks#onActivityPostResumed_E@, last out ordering. It is strongly recommended to register this in the constructor of your Activity to ensure you get all available callbacks. As this callback is associated with only this Activity, it is not usually necessary to @B_android#app#Activity#unregisterActivityLifecycleCallbacks_E@ it unless you specifically do not want to receive further lifecycle callbacks.", "history": "Added in API level 29", "FullName": "public void registerActivityLifecycleCallbacks (Application.ActivityLifecycleCallbacks callback)"}, "onDestroy()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onPause_E@", "@B_android#app#Activity#onStop_E@", "@B_android#app#Activity#finish_E@", "@B_android#app#Activity#isFinishing_E@"], "Permissions": [], "Description": "Perform any final cleanup before an activity is destroyed. This can happen either because the activity is finishing (someone called @B_android#app#Activity#finish_E@ on it), or because the system is temporarily destroying this instance of the activity to save space. You can distinguish between these two scenarios with the @B_android#app#Activity#isFinishing_E@ method. Note: do not count on this method being called as a place for saving data! For example, if an activity is editing data in a content provider, those edits should be committed in either @B_android#app#Activity#onPause_E@ or @B_android#app#Activity#onSaveInstanceState_E@, not here. This method is usually implemented to free resources like threads that are associated with an activity, so that a destroyed activity does not leave such things around while the rest of its application is still running. There are situations where the system will simply kill the activity's hosting process without calling this method (or any others) in it, so it should not be used to do things that are intended to remain around after the process goes away. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onDestroy ()"}, "onPreparePanel(int,android.view.View,android.view.Menu)": {"Returns": [["boolean", "boolean You must return true for the panel to be displayed; if you return false it will not be shown."]], "Parameters": [["int", "int: The panel that is being displayed."], ["@B_android#view#View_E@", "View: This value may be null."], ["@B_android#view#Menu_E@", "Menu: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#Window#Callback#onPreparePanel_E@ for activities. This calls through to the new @B_android#app#Activity#onPrepareOptionsMenu_E@ method for the @B_android#view#Window#FEATURE_OPTIONS_PANEL_E@ panel, so that subclasses of Activity don't need to deal with feature codes.", "history": "Added in API level 1", "FullName": "public boolean onPreparePanel (int featureId, View view, Menu menu)"}, "isVoiceInteractionRoot()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#app#Activity#isVoiceInteraction_E@, but only returns true if this is also the root of a voice interaction. That is, returns true if this activity was directly started by the voice interaction service as the initiation of a voice interaction. Otherwise, for example if it was started by another activity while under voice interaction, returns false.", "history": "Added in API level 23", "FullName": "public boolean isVoiceInteractionRoot ()"}, "onLowMemory()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the overall system is running low on memory, and actively running processes should trim their memory usage. While the exact point at which this will be called is not defined, generally it will happen when all background process have been killed. That is, before reaching the point of killing processes hosting service and foreground UI that we would like to avoid killing. You should implement this method to release any caches or other unnecessary resources you may be holding on to. The system will perform a garbage collection for you after returning from this method. Preferably, you should implement @B_android#content#ComponentCallbacks2#onTrimMemory_E@ from @B_android#content#ComponentCallbacks2_E@ to incrementally unload your resources based on various levels of memory demands. That API is available for API level 14 and higher, so you should only use this @B_android#content#ComponentCallbacks#onLowMemory_E@ method as a fallback for older versions, which can be treated the same as @B_android#content#ComponentCallbacks2#onTrimMemory_E@ with the @B_android#content#ComponentCallbacks2#TRIM_MEMORY_COMPLETE_E@ level.", "history": "Added in API level 1", "FullName": "public void onLowMemory ()"}, "onCreateContextMenu(android.view.ContextMenu,android.view.View,android.view.ContextMenu.ContextMenuInfo)": {"Returns": [], "Parameters": [["@B_android#view#ContextMenu_E@", "ContextMenu: The context menu that is being built"], ["@B_android#view#View_E@", "View: The view for which the context menu is being built"], ["@B_android#view#ContextMenu#ContextMenuInfo_E@", "ContextMenu.ContextMenuInfo: Extra information about the item for which the context menu should be shown. This information will vary depending on the class of v."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a context menu for the view is about to be shown. Unlike @B_android#app#Activity#onCreateOptionsMenu_E@, this will be called every time the context menu is about to be shown and should be populated for the view (or item inside the view for @B_android#widget#AdapterView_E@ subclasses, this can be found in the menuInfo)). Use @B_android#app#Activity#onContextItemSelected_E@ to know when an item has been selected. It is not safe to hold onto the context menu after this method returns.", "history": "Added in API level 1", "FullName": "public void onCreateContextMenu (ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo)"}, "startLockTask()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#stopLockTask_E@", "@B_android#R#attr#lockTaskMode_E@"], "Permissions": [], "Description": "Request to put this activity in a mode where the user is locked to a restricted set of applications. If @B_android#app#admin#DevicePolicyManager#isLockTaskPermitted_E@ returns true for this component, the current task will be launched directly into LockTask mode. Only apps whitelisted by @B_android#app#admin#DevicePolicyManager#setLockTaskPackages_E@ can be launched while LockTask mode is active. The user will not be able to leave this mode until this activity calls @B_android#app#Activity#stopLockTask_E@. Calling this method while the device is already in LockTask mode has no effect. Otherwise, the current task will be launched into screen pinning mode. In this case, the system will prompt the user with a dialog requesting permission to use this mode. The user can exit at any time through instructions shown on the request dialog. Calling @B_android#app#Activity#stopLockTask_E@ will also terminate this mode. @B_android#app#Activity#onResume_E@ and @B_android#app#Activity#onPause_E@.", "history": "Added in API level 21", "FullName": "public void startLockTask ()"}, "getPreferences(int)": {"Returns": [["@B_android#content#SharedPreferences_E@", "Returns the single SharedPreferences instance that can be used to retrieve and modify the preference values."]], "Parameters": [["int", "int: Operating mode. Use @B_android#content#Context#MODE_PRIVATE_E@ for the default operation. Value is either 0 or a combination of @B_android#content#Context#MODE_PRIVATE_E@, @B_android#content#Context#MODE_WORLD_READABLE_E@, @B_android#content#Context#MODE_WORLD_WRITEABLE_E@, and @B_android#content#Context#MODE_MULTI_PROCESS_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a @B_android#content#SharedPreferences_E@ object for accessing preferences that are private to this activity. This simply calls the underlying @B_android#content#ContextWrapper#getSharedPreferences_E@ method by passing in this activity's class name as the preferences name.", "history": "Added in API level 1", "FullName": "public SharedPreferences getPreferences (int mode)"}, "getLayoutInflater()": {"Returns": [["@B_android#view#LayoutInflater_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience for calling @B_android#view#Window#getLayoutInflater_E@.", "history": "Added in API level 1", "FullName": "public LayoutInflater getLayoutInflater ()"}, "onTrimMemory(int)": {"Returns": [], "Parameters": [["int", "int: The context of the trim, giving a hint of the amount of trimming the application may like to perform. Value is @B_android#content#ComponentCallbacks2#TRIM_MEMORY_COMPLETE_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_MODERATE_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_BACKGROUND_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_UI_HIDDEN_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_RUNNING_CRITICAL_E@, @B_android#content#ComponentCallbacks2#TRIM_MEMORY_RUNNING_LOW_E@, or @B_android#content#ComponentCallbacks2#TRIM_MEMORY_RUNNING_MODERATE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the operating system has determined that it is a good time for a process to trim unneeded memory from its process. This will happen for example when it goes in the background and there is not enough memory to keep as many background processes running as desired. You should never compare to exact values of the level, since new intermediate values may be added -- you will typically want to compare if the value is greater or equal to a level you are interested in. To retrieve the processes current trim level at any point, you can use @B_android#app#ActivityManager#getMyMemoryState_E@.", "history": "Added in API level 14", "FullName": "public void onTrimMemory (int level)"}, "onRequestPermissionsResult(int,java.lang.String[],int[])": {"Returns": [], "Parameters": [["int", "int: The request code passed in @B_android#app#Activity#requestPermissions_E@."], ["@B_java#lang#String_E@", "String: The requested permissions. Never null. This value must never be null."], ["int[]", "int: The grant results for the corresponding permissions which is either @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@. Never null. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#requestPermissions_E@"], "Permissions": [], "Description": "Callback for the result from requesting permissions. This method is invoked for every call on @B_android#app#Activity#requestPermissions_E@.", "history": "Added in API level 23", "FullName": "public void onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults)"}, "setContentView(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The desired content to display."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#setContentView_E@"], "Permissions": [], "Description": "Set the activity content to an explicit view. This view is placed directly into the activity's view hierarchy. It can itself be a complex view hierarchy. When calling this method, the layout parameters of the specified view are ignored. Both the width and the height of the view are set by default to @B_android#view#ViewGroup#LayoutParams#MATCH_PARENT_E@. To use your own layout parameters, invoke @B_android#app#Activity#setContentView_E@ instead.", "history": "Added in API level 1", "FullName": "public void setContentView (View view)"}, "setVisible(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Control whether this activity's main window is visible. This is intended only for the special case of an activity that is not going to show a UI itself, but can't just finish prior to onResume() because it needs to wait for a service binding or such. Setting this to false allows you to prevent your UI from being shown during that time. The default value for this is taken from the @B_android#R#attr#windowNoDisplay_E@ attribute of the activity's theme.", "history": "Added in API level 3", "FullName": "public void setVisible (boolean visible)"}, "onChildTitleChanged(android.app.Activity,java.lang.CharSequence)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity no parameter comment"], ["@B_java#lang#CharSequence_E@", "CharSequence no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "protected void onChildTitleChanged (Activity childActivity, CharSequence title)"}, "finishFromChild(android.app.Activity)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity making the call."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#finish_E@"], "Permissions": [], "Description": "This is called when a child activity of this one calls its @B_android#app#Activity#finish_E@ method. The default implementation simply calls finish() on this activity (the parent), finishing the entire group.", "history": "Added in API level 1", "FullName": "public void finishFromChild (Activity child)"}, "overridePendingTransition(int,int)": {"Returns": [], "Parameters": [["int", "int: A resource ID of the animation resource to use for the incoming activity. Use 0 for no animation."], ["int", "int: A resource ID of the animation resource to use for the outgoing activity. Use 0 for no animation."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call immediately after one of the flavors of @B_android#app#Activity#startActivity_E@ or @B_android#app#Activity#finish_E@ to specify an explicit transition animation to perform next. As of @B_android#os#Build#VERSION_CODES#JELLY_BEAN_E@ an alternative to using this with starting activities is to supply the desired animation information through a @B_android#app#ActivityOptions_E@ bundle to @B_android#app#Activity#startActivity_E@ or a related function. This allows you to specify a custom animation even when starting an activity from outside the context of the current top activity.", "history": "Added in API level 5", "FullName": "public void overridePendingTransition (int enterAnim, int exitAnim)"}, "onCreatePanelMenu(int,android.view.Menu)": {"Returns": [["boolean", "boolean You must return true for the panel to be displayed; if you return false it will not be shown."]], "Parameters": [["int", "int: The panel being created."], ["@B_android#view#Menu_E@", "Menu: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#Window#Callback#onCreatePanelMenu_E@ for activities. This calls through to the new @B_android#app#Activity#onCreateOptionsMenu_E@ method for the @B_android#view#Window#FEATURE_OPTIONS_PANEL_E@ panel, so that subclasses of Activity don't need to deal with feature codes.", "history": "Added in API level 1", "FullName": "public boolean onCreatePanelMenu (int featureId, Menu menu)"}, "getVolumeControlStream()": {"Returns": [["int", "The suggested audio stream type whose volume should be changed by the hardware volume controls."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#setVolumeControlStream_E@"], "Permissions": [], "Description": "Gets the suggested audio stream whose volume should be changed by the hardware volume controls.", "history": "Added in API level 1", "FullName": "public final int getVolumeControlStream ()"}, "onWindowDismissed()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a window is dismissed. This informs the callback that the window is gone, and it should finish itself.", "history": "", "FullName": "public abstract void onWindowDismissed ()"}, "getWindow()": {"Returns": [["@B_android#view#Window_E@", "Window The current window, or null if the activity is not visual."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the current @B_android#view#Window_E@ for the activity. This can be used to directly access parts of the Window API that are not available through Activity/Screen.", "history": "Added in API level 1", "FullName": "public Window getWindow ()"}, "startActivityForResult(android.content.Intent,int,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to start."], ["int", "int: If >= 0, this code will be returned in onActivityResult() when the activity exits."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. This value may be null."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Activity#startActivity_E@"], "Permissions": [], "Description": "Launch an activity for which you would like a result when it finished. When this activity exits, your onActivityResult() method will be called with the given requestCode. Using a negative requestCode is the same as calling @B_android#app#Activity#startActivity_E@ (the activity is not launched as a sub-activity). Note that this method should only be used with Intent protocols that are defined to return a result. In other protocols (such as @B_android#content#Intent#ACTION_MAIN_E@ or @B_android#content#Intent#ACTION_VIEW_E@), you may not get the result when you expect. For example, if the activity you are launching uses @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@, it will not run in your task and thus you will immediately receive a cancel result. As a special case, if you call startActivityForResult() with a requestCode >= 0 during the initial onCreate(Bundle savedInstanceState)/onResume() of your activity, then your window will not be displayed until a result is returned back from the started activity. This is to avoid visible flickering when redirecting to another activity. This method throws @B_android#content#ActivityNotFoundException_E@ if there was no Activity found to run the given Intent.", "history": "Added in API level 16", "FullName": "public void startActivityForResult (Intent intent, int requestCode, Bundle options)"}, "requestPermissions(java.lang.String[], int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The requested permissions. Must me non-null and not empty."], ["int", "int: Application specific request code to match with a result reported to @B_android#app#Activity#onRequestPermissionsResult_E@. Should be >= 0."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if requestCode is negative."]], "SeeAlso": ["@B_android#app#Activity#onRequestPermissionsResult_E@", "@B_android#content#ContextWrapper#checkSelfPermission_E@", "@B_android#app#Activity#shouldShowRequestPermissionRationale_E@"], "Permissions": [], "Description": "Requests permissions to be granted to this application. These permissions must be requested in your manifest, they should not be granted to your app, and they should have protection level @B_android#content#pm#PermissionInfo_E@, regardless whether they are declared by the platform or a third-party app. Normal permissions @B_android#content#pm#PermissionInfo#PROTECTION_NORMAL_E@ are granted at install time if requested in the manifest. Signature permissions @B_android#content#pm#PermissionInfo#PROTECTION_SIGNATURE_E@ are granted at install time if requested in the manifest and the signature of your app matches the signature of the app declaring the permissions. If your app does not have the requested permissions the user will be presented with UI for accepting them. After the user has accepted or rejected the requested permissions you will receive a callback on @B_android#app#Activity#onRequestPermissionsResult_E@ reporting whether the permissions were granted or not. Note that requesting a permission does not guarantee it will be granted and your app should be able to run without having this permission. This method may start an activity allowing the user to choose which permissions to grant and which to reject. Hence, you should be prepared that your activity may be paused and resumed. Further, granting some permissions may require a restart of you application. In such a case, the system will recreate the activity stack before delivering the result to @B_android#app#Activity#onRequestPermissionsResult_E@. When checking whether you have a permission you should use @B_android#content#ContextWrapper#checkSelfPermission_E@. Calling this API for permissions already granted to your app would show UI to the user to decide whether the app can still hold these permissions. This can be useful if the way your app uses data guarded by the permissions changes significantly. You cannot request a permission if your activity sets @B_android#R#styleable#AndroidManifestActivity_noHistory_E@ to true because in this case the activity would not receive result callbacks including @B_android#app#Activity#onRequestPermissionsResult_E@. The", "history": "added in API level 23", "FullName": "public final void requestPermissions (String[] permissions, int requestCode)"}, "finishAndRemoveTask()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this when your activity is done and should be closed and the task should be completely removed as a part of finishing the root activity of the task.", "history": "Added in API level 21", "FullName": "public void finishAndRemoveTask ()"}, "showDialog(int,android.os.Bundle)": {"Returns": [["boolean", "Returns true if the Dialog was created; false is returned if it is not created because @B_android#app#Activity#onCreateDialog_E@ returns false."]], "Parameters": [["int", "int: The id of the managed dialog."], ["@B_android#os#Bundle_E@", "Bundle: Arguments to pass through to the dialog. These will be saved and restored for you. Note that if the dialog is already created, @B_android#app#Activity#onCreateDialog_E@ will not be called with the new arguments but @B_android#app#Activity#onPrepareDialog_E@ will be. If you need to rebuild the dialog, call @B_android#app#Activity#removeDialog_E@ first."]], "Throws": [], "SeeAlso": ["@B_android#app#Dialog_E@", "@B_android#app#Activity#onCreateDialog_E@", "@B_android#app#Activity#onPrepareDialog_E@", "@B_android#app#Activity#dismissDialog_E@", "@B_android#app#Activity#removeDialog_E@"], "Permissions": [], "Description": "Use the new @B_android#app#DialogFragment_E@ class with @B_android#app#FragmentManager_E@ instead; this is also available on older platforms through the Android compatibility package. Show a dialog managed by this activity. A call to @B_android#app#Activity#onCreateDialog_E@ will be made with the same id the first time this is called for a given id. From thereafter, the dialog will be automatically saved and restored. If you are targeting @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ or later, consider instead using a @B_android#app#DialogFragment_E@ instead. Each time a dialog is shown, @B_android#app#Activity#onPrepareDialog_E@ will be made to provide an opportunity to do any timely preparation.", "history": "Added in API level 8 Deprecated in API level 15", "FullName": "public final boolean showDialog (int id, Bundle args)"}, "requestVisibleBehind(boolean)": {"Returns": [["boolean", "the resulting visibiity state. If true the activity will remain visible beyond @B_android#app#Activity#onPause_E@ if the next activity is translucent or not fullscreen. If false then the activity may not count on being visible behind other translucent activities, and must stop any media playback and release resources. Returning false may occur in lieu of a call to @B_android#app#Activity#onVisibleBehindCanceled_E@ so the return value must be checked."]], "Parameters": [["boolean", "boolean: true to notify the system that the activity wishes to be visible behind other translucent activities, false to indicate otherwise. Resources must be released when passing false to this method."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onVisibleBehindCanceled_E@"], "Permissions": [], "Description": "This method's functionality is no longer supported as of @B_android#os#Build#VERSION_CODES#O_E@ and will be removed in a future release. Activities that want to remain visible behind a translucent activity above them must call this method anytime between the start of @B_android#app#Activity#onResume_E@ and the return from @B_android#app#Activity#onPause_E@. If this call is successful then the activity will remain visible after @B_android#app#Activity#onPause_E@ is called, and is allowed to continue playing media in the background. The actions of this call are reset each time that this activity is brought to the front. That is, every time @B_android#app#Activity#onResume_E@ is called the activity will be assumed to not have requested visible behind. Therefore, if you want this activity to continue to be visible in the background you must call this method again. Only fullscreen opaque activities may make this call. I.e. this call is a nop for dialog and translucent activities. Under all circumstances, the activity must stop playing and release resources prior to or within a call to @B_android#app#Activity#onVisibleBehindCanceled_E@ or if this call returns false. False will be returned any time this method is called between the return of onPause and the next call to onResume.", "history": "Added in API level 21 Deprecated in API level 26", "FullName": "public boolean requestVisibleBehind (boolean visible)"}, "onEnterAnimationComplete()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Activities cannot draw during the period that their windows are animating in. In order to know when it is safe to begin drawing they can override this method which will be called when the entering animation has completed.", "history": "Added in API level 21", "FullName": "public void onEnterAnimationComplete ()"}, "onContextItemSelected(android.view.MenuItem)": {"Returns": [["boolean", "boolean Return false to allow normal context menu processing to proceed, true to consume it here."]], "Parameters": [["@B_android#view#MenuItem_E@", "MenuItem: The context menu item that was selected. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This hook is called whenever an item in a context menu is selected. The default implementation simply returns false to have the normal processing happen (calling the item's Runnable or sending a message to its Handler as appropriate). You can use this method for any items for which you would like to do processing without those other facilities. Use @B_android#view#MenuItem#getMenuInfo_E@ to get extra information set by the View that added this menu item. Derived classes should call through to the base class for it to perform the default menu handling.", "history": "Added in API level 1", "FullName": "public boolean onContextItemSelected (MenuItem item)"}, "finishActivityFromChild(android.app.Activity,int)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity making the call. This value must never be null."], ["int", "int: Request code that had been used to start the activity."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when a child activity of this one calls its finishActivity().", "history": "Added in API level 1", "FullName": "public void finishActivityFromChild (Activity child, int requestCode)"}, "dispatchKeyShortcutEvent(android.view.KeyEvent)": {"Returns": [["boolean", "True if this event was consumed."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key shortcut event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to process a key shortcut event. You can override this to intercept all key shortcut events before they are dispatched to the window. Be sure to call this implementation for key shortcut events that should be handled normally.", "history": "Added in API level 11", "FullName": "public boolean dispatchKeyShortcutEvent (KeyEvent event)"}, "closeContextMenu()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Programmatically closes the most recently opened context menu, if showing.", "history": "Added in API level 3", "FullName": "public void closeContextMenu ()"}, "onLocalVoiceInteractionStopped()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Callback to indicate that the local voice interaction has stopped either because it was requested through a call to @B_android#app#Activity#stopLocalVoiceInteraction_E@ or because it was canceled by the user. The previously acquired @B_android#app#VoiceInteractor_E@ is no longer valid after this.", "history": "Added in API level 24", "FullName": "public void onLocalVoiceInteractionStopped ()"}, "onActionModeFinished(android.view.ActionMode)": {"Returns": [], "Parameters": [["@B_android#view#ActionMode_E@", "ActionMode: The action mode that just finished."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Notifies the activity that an action mode has finished. Activity subclasses overriding this method should call the superclass implementation. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 11", "FullName": "public void onActionModeFinished (ActionMode mode)"}, "onAttachedToWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#onAttachedToWindow_E@"], "Permissions": [], "Description": "Called when the main window associated with the activity has been attached to the window manager. See @B_android#view#View#onAttachedToWindow_E@ for more information.", "history": "Added in API level 5", "FullName": "public void onAttachedToWindow ()"}, "getMaxNumPictureInPictureActions()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of actions that will be displayed in the picture-in-picture UI when the user interacts with the activity currently in picture-in-picture mode. This number may change if the global configuration changes (ie. if the device is plugged into an external display), but will always be larger than three.", "history": "Added in API level 26", "FullName": "public int getMaxNumPictureInPictureActions ()"}, "setTaskDescription(android.app.ActivityManager.TaskDescription)": {"Returns": [], "Parameters": [["@B_android#app#ActivityManager#TaskDescription_E@", "ActivityManager.TaskDescription: The TaskDescription properties that describe the task with this activity"]], "Throws": [], "SeeAlso": ["@B_android#app#ActivityManager#getRecentTasks_E@", "@B_android#app#ActivityManager#TaskDescription_E@"], "Permissions": [], "Description": "Sets information describing the task with this activity for presentation inside the Recents System UI. When @B_android#app#ActivityManager#getRecentTasks_E@ is called, the activities of each task are traversed in order from the topmost activity to the bottommost. The traversal continues for each property until a suitable value is found. For each task the taskDescription will be returned in @B_android#app#ActivityManager#TaskDescription_E@.", "history": "Added in API level 21", "FullName": "public void setTaskDescription (ActivityManager.TaskDescription taskDescription)"}, "setIntent(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The new Intent object to return from getIntent"]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#getIntent_E@", "@B_android#app#Activity#onNewIntent_E@"], "Permissions": [], "Description": "Change the intent returned by @B_android#app#Activity#getIntent_E@. This holds a reference to the given intent; it does not copy it. Often used in conjunction with @B_android#app#Activity#onNewIntent_E@.", "history": "Added in API level 1", "FullName": "public void setIntent (Intent newIntent)"}, "dispatchGenericMotionEvent(android.view.MotionEvent)": {"Returns": [["boolean", "boolean Return true if this event was consumed."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The generic motion event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to process generic motion events. You can override this to intercept all generic motion events before they are dispatched to the window. Be sure to call this implementation for generic motion events that should be handled normally.", "history": "Added in API level 12", "FullName": "public boolean dispatchGenericMotionEvent (MotionEvent ev)"}, "startActivityIfNeeded(android.content.Intent, int)": {"Returns": [["boolean", "If a new activity was launched then true is returned; otherwise false is returned and you must handle the Intent yourself."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to start.This value must never be null."], ["int", "int: If >= 0, this code will be returned in onActivityResult() when the activity exits, as described in @B_android#app#Activity#startActivityForResult_E@."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#startActivity_E@", "@B_android#app#Activity#startActivityForResult_E@"], "Permissions": [], "Description": "Same as calling @B_android#app#Activity#startActivityIfNeeded_E@ with no options.", "history": "added in API level 1", "FullName": "public boolean startActivityIfNeeded (Intent intent, int requestCode)"}, "stopLockTask()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#startLockTask_E@", "@B_android#R#attr#lockTaskMode_E@", "@B_android#app#ActivityManager#getLockTaskModeState_E@"], "Permissions": [], "Description": "Stop the current task from being locked. Called to end the LockTask or screen pinning mode started by @B_android#app#Activity#startLockTask_E@. This can only be called by activities that have called @B_android#app#Activity#startLockTask_E@ previously. @B_android#app#admin#DevicePolicyManager#setLockTaskPackages_E@.", "history": "Added in API level 21", "FullName": "public void stopLockTask ()"}, "onPrepareDialog(int, android.app.Dialog)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["@B_android#app#Dialog_E@", "Dialog no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Old no-arguments version of @B_android#app#Activity#onPrepareDialog_E@.", "history": "added in API level 1", "FullName": "protected void onPrepareDialog (int id, Dialog dialog)"}, "onCreatePanelView(int)": {"Returns": [["@B_android#view#View_E@", "view The top-level view to place in the panel."]], "Parameters": [["int", "int: Which panel is being created."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#Window#Callback#onCreatePanelView_E@ for activities. This simply returns null so that all panel sub-windows will have the default menu behavior.", "history": "Added in API level 1", "FullName": "public View onCreatePanelView (int featureId)"}, "setShowWhenLocked(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to show the @B_android#app#Activity_E@ on top of the lock screen; false otherwise."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#setTurnScreenOn_E@", "@B_android#R#attr#turnScreenOn_E@", "@B_android#R#attr#showWhenLocked_E@"], "Permissions": [], "Description": "Specifies whether an @B_android#app#Activity_E@ should be shown on top of the lock screen whenever the lockscreen is up and the activity is resumed. Normally an activity will be transitioned to the stopped state if it is started while the lockscreen is up, but with this flag set the activity will remain in the resumed state visible on-top of the lock screen. This value can be set as a manifest attribute using @B_android#R#attr#showWhenLocked_E@.", "history": "Added in API level 27", "FullName": "public void setShowWhenLocked (boolean showWhenLocked)"}, "onActivityResult(int, int, android.content.Intent)": {"Returns": [], "Parameters": [["int", "int: The integer request code originally supplied to startActivityForResult(), allowing you to identify who this result came from."], ["int", "int: The integer result code returned by the child activity through its setResult()."], ["@B_android#content#Intent_E@", "Intent: An Intent, which can return result data to the caller (various data can be attached to Intent \"extras\")."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#startActivityForResult_E@", "@B_android#app#Activity#createPendingResult_E@", "@B_android#app#Activity#setResult_E@"], "Permissions": [], "Description": "Called when an activity you launched exits, giving you the requestCode you started it with, the resultCode it returned, and any additional data from it. The @B_android#app#Activity#RESULT_CANCELED_E@ if the activity explicitly returned that, didn't return any result, or crashed during its operation. You will receive this call immediately before onResume() when your activity is re-starting. This method is never invoked if your activity sets @B_android#R#styleable#AndroidManifestActivity_noHistory_E@ to true.", "history": "added in API level 1", "FullName": "protected void onActivityResult (int requestCode, int resultCode, Intent data)"}, "getMenuInflater()": {"Returns": [["@B_android#view#MenuInflater_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a @B_android#view#MenuInflater_E@ with this context.", "history": "Added in API level 1", "FullName": "public MenuInflater getMenuInflater ()"}, "getReferrer()": {"Returns": [["@B_android#net#Uri_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return information about who launched this activity. If the launching Intent contains an @B_android#content#Intent#EXTRA_REFERRER_E@, that will be returned as-is; otherwise, if known, an @B_android#content#Intent#URI_ANDROID_APP_SCHEME_E@ referrer URI containing the package name that started the Intent will be returned. This may return null if no referrer can be identified -- it is neither explicitly specified, nor is it known which application package was involved. If called while inside the handling of @B_android#app#Activity#onNewIntent_E@, this function will return the referrer that submitted that new intent to the activity. Otherwise, it always returns the referrer of the original Intent. Note that this is not a security feature -- you can not trust the referrer information, applications can spoof it.", "history": "Added in API level 22", "FullName": "public Uri getReferrer ()"}, "onKeyShortcut(int, android.view.KeyEvent)": {"Returns": [["boolean", "True if the key shortcut was handled."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a key shortcut event is not handled by any of the views in the Activity. Override this method to implement global key shortcuts for the Activity. Key shortcuts can also be implemented by setting the @B_android#view#MenuItem#setShortcut_E@ property of menu items.", "history": "added in API level 11", "FullName": "public boolean onKeyShortcut (int keyCode, KeyEvent event)"}, "startActivityIfNeeded(android.content.Intent,int)": {"Returns": [["boolean", "If a new activity was launched then true is returned; otherwise false is returned and you must handle the Intent yourself."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to start. This value must never be null."], ["int", "int: If >= 0, this code will be returned in onActivityResult() when the activity exits, as described in @B_android#app#Activity#startActivityForResult_E@."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#startActivity_E@", "@B_android#app#Activity#startActivityForResult_E@"], "Permissions": [], "Description": "Same as calling @B_android#app#Activity#startActivityIfNeeded_E@ with no options.", "history": "Added in API level 1", "FullName": "public boolean startActivityIfNeeded (Intent intent, int requestCode)"}, "setResult(int)": {"Returns": [], "Parameters": [["int", "int: The result code to propagate back to the originating activity, often RESULT_CANCELED or RESULT_OK"]], "Throws": [], "SeeAlso": ["@B_android#app#Activity_E@", "@B_android#app#Activity#setResult_E@"], "Permissions": [], "Description": "Call this to set the result that your activity will return to its caller.", "history": "Added in API level 1", "FullName": "public final void setResult (int resultCode)"}, "startActivity(android.content.Intent,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to start."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. This value may be null."]], "Throws": [["", "android.content.ActivityNotFoundException"]], "SeeAlso": ["@B_android#app#Activity#startActivity_E@", "@B_android#app#Activity#startActivityForResult_E@"], "Permissions": [], "Description": "Launch a new activity. You will not receive any information about when the activity exits. This implementation overrides the base version, providing information about the activity performing the launch. Because of this additional information, the @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@ launch flag is not required; if not specified, the new activity will be added to the task of the caller. This method throws @B_android#content#ActivityNotFoundException_E@ if there was no Activity found to run the given Intent.", "history": "Added in API level 16", "FullName": "public void startActivity (Intent intent, Bundle options)"}, "onMultiWindowModeChanged(boolean,android.content.res.Configuration)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the activity is in multi-window mode."], ["@B_android#content#res#Configuration_E@", "Configuration: The new configuration of the activity with the state ."]], "Throws": [], "SeeAlso": ["@B_android#R#attr#resizeableActivity_E@"], "Permissions": [], "Description": "Called by the system when the activity changes from fullscreen mode to multi-window mode and visa-versa. This method provides the same configuration that will be sent in the following @B_android#app#Activity#onConfigurationChanged_E@ call after the activity enters this mode.", "history": "Added in API level 26", "FullName": "public void onMultiWindowModeChanged (boolean isInMultiWindowMode, Configuration newConfig)"}, "onPostResume()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onResume_E@"], "Permissions": [], "Description": "Called when activity resume is complete (after @B_android#app#Activity#onResume_E@ has been called). Applications will generally not implement this method; it is intended for system classes to do final setup after application resume code has run. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onPostResume ()"}, "registerForContextMenu(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view that should show a context menu."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#unregisterForContextMenu_E@"], "Permissions": [], "Description": "Registers a context menu to be shown for the given view (multiple views can show the context menu). This method will set the @B_android#view#View#OnCreateContextMenuListener_E@ on the view to this activity, so @B_android#app#Activity#onCreateContextMenu_E@ will be called when it is time to show the context menu.", "history": "Added in API level 1", "FullName": "public void registerForContextMenu (View view)"}, "setDefaultKeyMode(int)": {"Returns": [], "Parameters": [["int", "int: The desired default key mode constant. Value is @B_android#app#Activity#DEFAULT_KEYS_DISABLE_E@, @B_android#app#Activity#DEFAULT_KEYS_DIALER_E@, @B_android#app#Activity#DEFAULT_KEYS_SHORTCUT_E@, @B_android#app#Activity#DEFAULT_KEYS_SEARCH_LOCAL_E@, or @B_android#app#Activity#DEFAULT_KEYS_SEARCH_GLOBAL_E@"]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onKeyDown_E@"], "Permissions": [], "Description": "Select the default key handling for this activity. This controls what will happen to key events that are not otherwise handled. The default mode (@B_android#app#Activity#DEFAULT_KEYS_DISABLE_E@) will simply drop them on the floor. Other modes allow you to launch the dialer (@B_android#app#Activity#DEFAULT_KEYS_DIALER_E@), execute a shortcut in your options menu without requiring the menu key be held down (@B_android#app#Activity#DEFAULT_KEYS_SHORTCUT_E@), or launch a search (@B_android#app#Activity#DEFAULT_KEYS_SEARCH_LOCAL_E@ and @B_android#app#Activity#DEFAULT_KEYS_SEARCH_GLOBAL_E@). Note that the mode selected here does not impact the default handling of system keys, such as the \"back\" and \"menu\" keys, and your activity and its views always get a first chance to receive and handle all application keys.", "history": "Added in API level 1", "FullName": "public final void setDefaultKeyMode (int mode)"}, "overridePendingTransition(int, int)": {"Returns": [], "Parameters": [["int", "int: A resource ID of the animation resource to use for the incoming activity. Use 0 for no animation."], ["int", "int: A resource ID of the animation resource to use for the outgoing activity. Use 0 for no animation."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call immediately after one of the flavors of @B_android#app#Activity#startActivity_E@ or @B_android#app#Activity#finish_E@ to specify an explicit transition animation to perform next. As of @B_android#os#Build#VERSION_CODES#JELLY_BEAN_E@ an alternative to using this with starting activities is to supply the desired animation information through a @B_android#app#ActivityOptions_E@ bundle to @B_android#app#Activity#startActivity_E@ or a related function. This allows you to specify a custom animation even when starting an activity from outside the context of the current top activity.", "history": "added in API level 5", "FullName": "public void overridePendingTransition (int enterAnim, int exitAnim)"}, "getParentActivityIntent()": {"Returns": [["@B_android#content#Intent_E@", "a new Intent targeting the defined parent of this activity or null if there is no valid parent."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Obtain an @B_android#content#Intent_E@ that will launch an explicit target activity specified by this activity's logical parent. The logical parent is named in the application's manifest by the @B_android#R#attr#parentActivityName_E@ attribute. Activity subclasses may override this method to modify the Intent returned by super.getParentActivityIntent() or to implement a different mechanism of retrieving the parent intent entirely.", "history": "Added in API level 16", "FullName": "public Intent getParentActivityIntent ()"}, "dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent)": {"Returns": [["boolean", "boolean Return true if event population was completed."]], "Parameters": [["@B_android#view#accessibility#AccessibilityEvent_E@", "AccessibilityEvent: The event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to process population of @B_android#view#accessibility#AccessibilityEvent_E@s.", "history": "Added in API level 4", "FullName": "public boolean dispatchPopulateAccessibilityEvent (AccessibilityEvent event)"}, "onUserLeaveHint()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onUserInteraction_E@", "@B_android#content#Intent_E@"], "Permissions": [], "Description": "Called as part of the activity lifecycle when an activity is about to go into the background as the result of user choice. For example, when the user presses the Home key, @B_android#app#Activity#onUserLeaveHint_E@ will be called, but when an incoming phone call causes the in-call Activity to be automatically brought to the foreground, @B_android#app#Activity#onUserLeaveHint_E@ will not be called on the activity being interrupted. In cases when it is invoked, this method is called right before the activity's @B_android#app#Activity#onPause_E@ callback. This callback and @B_android#app#Activity#onUserInteraction_E@ are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notification.", "history": "Added in API level 3", "FullName": "protected void onUserLeaveHint ()"}, "startIntentSender(android.content.IntentSender,android.content.Intent,int,int,int)": {"Returns": [], "Parameters": [["@B_android#content#IntentSender_E@", "IntentSender: The IntentSender to launch."], ["@B_android#content#Intent_E@", "Intent: If non-null, this will be provided as the intent parameter to @B_android#content#IntentSender#sendIntent_E@. This value may be null."], ["int", "int: Intent flags in the original IntentSender that you would like to change."], ["int", "int: Desired values for any bits set in flagsMask"], ["int", "int: Always set to 0."]], "Throws": [["@B_android#content#IntentSender#SendIntentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Same as calling @B_android#app#Activity#startIntentSender_E@ with no options.", "history": "Added in API level 5", "FullName": "public void startIntentSender (IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)"}, "onContextMenuClosed(android.view.Menu)": {"Returns": [], "Parameters": [["@B_android#view#Menu_E@", "Menu: The context menu that is being closed. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This hook is called whenever the context menu is being closed (either by the user canceling the menu with the back/menu button, or when an item is selected).", "history": "Added in API level 1", "FullName": "public void onContextMenuClosed (Menu menu)"}, "getParent()": {"Returns": [["@B_android#app#Activity_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the parent activity if this view is an embedded child.", "history": "Added in API level 1", "FullName": "public final Activity getParent ()"}, "onActivityResult(int,int,android.content.Intent)": {"Returns": [], "Parameters": [["int", "int: The integer request code originally supplied to startActivityForResult(), allowing you to identify who this result came from."], ["int", "int: The integer result code returned by the child activity through its setResult()."], ["@B_android#content#Intent_E@", "Intent: An Intent, which can return result data to the caller (various data can be attached to Intent \"extras\")."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#startActivityForResult_E@", "@B_android#app#Activity#createPendingResult_E@", "@B_android#app#Activity#setResult_E@"], "Permissions": [], "Description": "Called when an activity you launched exits, giving you the requestCode you started it with, the resultCode it returned, and any additional data from it. The @B_android#app#Activity#RESULT_CANCELED_E@ if the activity explicitly returned that, didn't return any result, or crashed during its operation. You will receive this call immediately before onResume() when your activity is re-starting. This method is never invoked if your activity sets @B_android#R#styleable#AndroidManifestActivity_noHistory_E@ to true.", "history": "Added in API level 1", "FullName": "protected void onActivityResult (int requestCode, int resultCode, Intent data)"}, "postponeEnterTransition()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Postpone the entering activity transition when Activity was started with @B_android#app#ActivityOptions#makeSceneTransitionAnimation_E@. This method gives the Activity the ability to delay starting the entering and shared element transitions until all data is loaded. Until then, the Activity won't draw into its window, leaving the window transparent. This may also cause the returning animation to be delayed until data is ready. This method should be called in @B_android#app#Activity#onCreate_E@ or in @B_android#app#Activity#onActivityReenter_E@. @B_android#app#Activity#startPostponedEnterTransition_E@ must be called to allow the Activity to start the transitions. If the Activity did not use @B_android#app#ActivityOptions#makeSceneTransitionAnimation_E@, then this method does nothing.", "history": "Added in API level 21", "FullName": "public void postponeEnterTransition ()"}, "getChangingConfigurations()": {"Returns": [["int", "Returns a bit field of the configuration parameters that are changing, as defined by the @B_android#content#res#Configuration_E@ class."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If this activity is being destroyed because it can not handle a configuration parameter being changed (and thus its @B_android#app#Activity#onConfigurationChanged_E@ method is not being called), then you can use this method to discover the set of changes that have occurred while in the process of being destroyed. Note that there is no guarantee that these will be accurate (other changes could have happened at any time), so you should only use this as an optimization hint.", "history": "Added in API level 1", "FullName": "public int getChangingConfigurations ()"}, "onStart()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreate_E@", "@B_android#app#Activity#onStop_E@", "@B_android#app#Activity#onResume_E@"], "Permissions": [], "Description": "Called after @B_android#app#Activity#onCreate_E@ \u2014 or after @B_android#app#Activity#onRestart_E@ when the activity had been stopped, but is now again being displayed to the user. It will usually be followed by @B_android#app#Activity#onResume_E@. This is a good place to begin drawing visual elements, running animations, etc. You can call @B_android#app#Activity#finish_E@ from within this function, in which case @B_android#app#Activity#onStop_E@ will be immediately called after @B_android#app#Activity#onStart_E@ without the lifecycle transitions in-between (@B_android#app#Activity#onResume_E@, @B_android#app#Activity#onPause_E@, etc) executing. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onStart ()"}, "moveTaskToBack(boolean)": {"Returns": [["boolean", "If the task was moved (or it was already at the back) true is returned, else false."]], "Parameters": [["boolean", "boolean: If false then this only works if the activity is the root of a task; if true it will work for any activity in a task."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Move the task containing this activity to the back of the activity stack. The activity's order within the task is unchanged.", "history": "Added in API level 1", "FullName": "public boolean moveTaskToBack (boolean nonRoot)"}, "onWindowStartingActionMode(android.view.ActionMode.Callback,int)": {"Returns": [["@B_android#view#ActionMode_E@", "This value may be null."]], "Parameters": [["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: Callback to control the lifecycle of this action mode"], ["int", "int: One of @B_android#view#ActionMode#TYPE_PRIMARY_E@ or @B_android#view#ActionMode#TYPE_FLOATING_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when an action mode is being started for this window. Gives the callback an opportunity to handle the action mode in its own unique and beautiful way. If this method returns null the system can choose a way to present the mode or choose not to start the mode at all.", "history": "Added in API level 23", "FullName": "public ActionMode onWindowStartingActionMode (ActionMode.Callback callback, int type)"}, "setTitleColor(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use action bar styles instead. Change the color of the title associated with this activity. This method is deprecated starting in API Level 11 and replaced by action bar styles. For information on styling the Action Bar, read the", "history": "Added in API level 1 Deprecated in API level 21", "FullName": "public void setTitleColor (int textColor)"}, "startIntentSenderFromChild(android.app.Activity,android.content.IntentSender,int,android.content.Intent,int,int,int,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity no parameter comment"], ["@B_android#content#IntentSender_E@", "IntentSender no parameter comment"], ["int", "int no parameter comment"], ["@B_android#content#Intent_E@", "Intent no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"], ["@B_android#os#Bundle_E@", "Bundle: This value may be null."]], "Throws": [["@B_android#content#IntentSender#SendIntentException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#app#Activity#startActivityFromChild_E@, but taking a IntentSender; see @B_android#app#Activity#startIntentSenderForResult_E@ for more information.", "history": "Added in API level 16", "FullName": "public void startIntentSenderFromChild (Activity child, IntentSender intent, int requestCode, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)"}, "startActionMode(android.view.ActionMode.Callback,int)": {"Returns": [["@B_android#view#ActionMode_E@", "The ActionMode that was started, or null if it was canceled"]], "Parameters": [["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: Callback that will manage lifecycle events for this action mode"], ["int", "int: One of @B_android#view#ActionMode#TYPE_PRIMARY_E@ or @B_android#view#ActionMode#TYPE_FLOATING_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#ActionMode_E@"], "Permissions": [], "Description": "Start an action mode of the given type.", "history": "Added in API level 23", "FullName": "public ActionMode startActionMode (ActionMode.Callback callback, int type)"}, "isImmersive()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#setImmersive_E@", "@B_android#content#pm#ActivityInfo_E@"], "Permissions": [], "Description": "Bit indicating that this activity is \"immersive\" and should not be interrupted by notifications if possible. This value is initially set by the manifest property android:immersive but may be changed at runtime by @B_android#app#Activity#setImmersive_E@.", "history": "Added in API level 18", "FullName": "public boolean isImmersive ()"}, "setSecondaryProgress(int)": {"Returns": [], "Parameters": [["int", "int: The secondary progress for the progress bar. Valid ranges are from 0 to 10000 (both inclusive)."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "No longer supported starting in API 21. Sets the secondary progress for the progress bar in the title. This progress is drawn between the primary progress (set via @B_android#app#Activity#setProgress_E@ and the background. It can be ideal for media scenarios such as showing the buffering progress while the default progress shows the play progress. In order for the progress bar to be shown, the feature must be requested via @B_android#app#Activity#requestWindowFeature_E@.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public final void setSecondaryProgress (int secondaryProgress)"}, "setProgressBarIndeterminateVisibility(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether to show the progress bars in the title."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "No longer supported starting in API 21. Sets the visibility of the indeterminate progress bar in the title. In order for the progress bar to be shown, the feature must be requested via @B_android#app#Activity#requestWindowFeature_E@.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public final void setProgressBarIndeterminateVisibility (boolean visible)"}, "onResume()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onRestoreInstanceState_E@", "@B_android#app#Activity#onRestart_E@", "@B_android#app#Activity#onPostResume_E@", "@B_android#app#Activity#onPause_E@", "@B_android#app#Activity#onTopResumedActivityChanged_E@"], "Permissions": [], "Description": "Called after @B_android#app#Activity#onRestoreInstanceState_E@, @B_android#app#Activity#onRestart_E@, or @B_android#app#Activity#onPause_E@, for your activity to start interacting with the user. This is an indicator that the activity became active and ready to receive input. It is on top of an activity stack and visible to user. On platform versions prior to @B_android#os#Build#VERSION_CODES#Q_E@ this is also a good place to try to open exclusive-access devices or to get access to singleton resources. Starting with @B_android#os#Build#VERSION_CODES#Q_E@ there can be multiple resumed activities in the system simultaneously, so @B_android#app#Activity#onTopResumedActivityChanged_E@ should be used for that purpose instead. Derived classes must call through to the super class's implementation of this method. If they do not, an exception will be thrown. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onResume ()"}, "onKeyUp(int, android.view.KeyEvent)": {"Returns": [["boolean", "Return true to prevent this event from being propagated further, or false to indicate that you have not handled this event and it should continue to be propagated."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onKeyDown_E@", "@B_android#view#KeyEvent_E@"], "Permissions": [], "Description": "Called when a key was released and not handled by any of the views inside of the activity. So, for example, key presses while the cursor is inside a TextView will not trigger the event (unless it is a navigation to another object) because TextView handles its own key presses. The default implementation handles KEYCODE_BACK to stop the activity and go back.", "history": "added in API level 1", "FullName": "public boolean onKeyUp (int keyCode, KeyEvent event)"}, "getContentTransitionManager()": {"Returns": [["@B_android#transition#TransitionManager_E@", "This window's content TransitionManager or null if none is set."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the @B_android#transition#TransitionManager_E@ responsible for default transitions in this window. Requires @B_android#view#Window#FEATURE_CONTENT_TRANSITIONS_E@. This method will return non-null after content has been initialized (e.g. by using @B_android#app#Activity#setContentView_E@) if @B_android#view#Window#FEATURE_CONTENT_TRANSITIONS_E@ has been granted.", "history": "Added in API level 21", "FullName": "public TransitionManager getContentTransitionManager ()"}, "onKeyLongPress(int,android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": ["_E@", "@B_android#view#KeyEvent#Callback#onKeyLongPress_E@"], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyLongPress_E@: always returns false (doesn't handle the event). To receive this callback, you must return true from onKeyDown for the current event stream.", "history": "Added in API level 5", "FullName": "public boolean onKeyLongPress (int keyCode, KeyEvent event)"}, "invalidateOptionsMenu()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Declare that the options menu has changed, so should be recreated. The @B_android#app#Activity#onCreateOptionsMenu_E@ method will be called the next time it needs to be displayed.", "history": "Added in API level 11", "FullName": "public void invalidateOptionsMenu ()"}, "onApplyThemeResource(android.content.res.Resources.Theme,int,boolean)": {"Returns": [], "Parameters": [["@B_android#content#res#Resources#Theme_E@", "Resources.Theme: the theme being modified"], ["int", "int: the style resource being applied to theme"], ["boolean", "boolean: true if this is the first time a style is being applied to theme"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by @B_android#view#ContextThemeWrapper#setTheme_E@ and @B_android#view#ContextThemeWrapper#getTheme_E@ to apply a theme resource to the current Theme object. May be overridden to change the default (simple) behavior. This method will not be called in multiple threads simultaneously.", "history": "Added in API level 1", "FullName": "protected void onApplyThemeResource (Resources.Theme theme, int resid, boolean first)"}, "startNextMatchingActivity(android.content.Intent,android.os.Bundle)": {"Returns": [["boolean", "Returns a boolean indicating whether there was another Activity to start: true if there was a next activity to start, false if there wasn't. In general, if true is returned you will then want to call finish() on yourself."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to dispatch to the next activity. For correct behavior, this must be the same as the Intent that started your own activity; the only changes you can make are to the extras inside of it. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Special version of starting an activity, for use when you are replacing other activity components. You can use this to hand the Intent off to the next Activity that can handle it. You typically call this in @B_android#app#Activity#onCreate_E@ with the Intent returned by @B_android#app#Activity#getIntent_E@.", "history": "Added in API level 16", "FullName": "public boolean startNextMatchingActivity (Intent intent, Bundle options)"}, "triggerSearch(java.lang.String,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The query to trigger. If empty, the request will be ignored."], ["@B_android#os#Bundle_E@", "Bundle: An application can insert application-specific context here, in order to improve quality or specificity of its own searches. This data will be returned with SEARCH intent(s). Null if no extra data is required. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Similar to @B_android#app#Activity#startSearch_E@, but actually fires off the search query after invoking the search dialog. Made available for testing purposes.", "history": "Added in API level 5", "FullName": "public void triggerSearch (String query, Bundle appSearchData)"}, "setFeatureDrawableResource(int,int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience for calling @B_android#view#Window#setFeatureDrawableResource_E@.", "history": "Added in API level 1", "FullName": "public final void setFeatureDrawableResource (int featureId, int resId)"}, "onActivityReenter(int,android.content.Intent)": {"Returns": [], "Parameters": [["int", "int: The integer result code returned by the child activity through its setResult()."], ["@B_android#content#Intent_E@", "Intent: An Intent, which can return result data to the caller (various data can be attached to Intent \"extras\")."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when an activity you launched with an activity transition exposes this Activity through a returning activity transition, giving you the resultCode and any additional data from it. This method will only be called if the activity set a result code other than @B_android#app#Activity#RESULT_CANCELED_E@ and it supports activity transitions with @B_android#view#Window#FEATURE_ACTIVITY_TRANSITIONS_E@. The purpose of this function is to let the called Activity send a hint about its state so that this underlying Activity can prepare to be exposed. A call to this method does not guarantee that the called Activity has or will be exiting soon. It only indicates that it will expose this Activity's Window and it has some data to pass to prepare it.", "history": "Added in API level 21", "FullName": "public void onActivityReenter (int resultCode, Intent data)"}, "takeKeyEvents(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": ["@B_android#view#Window#takeKeyEvents_E@"], "Permissions": [], "Description": "Request that key events come to this activity. Use this if your activity has no views with focus, but the activity still wants a chance to process key events.", "history": "Added in API level 1", "FullName": "public void takeKeyEvents (boolean get)"}, "setResult(int,android.content.Intent)": {"Returns": [], "Parameters": [["int", "int: The result code to propagate back to the originating activity, often RESULT_CANCELED or RESULT_OK"], ["@B_android#content#Intent_E@", "Intent: The data to propagate back to the originating activity."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity_E@", "@B_android#app#Activity#setResult_E@"], "Permissions": [], "Description": "Call this to set the result that your activity will return to its caller. As of @B_android#os#Build#VERSION_CODES#GINGERBREAD_E@, the Intent you supply here can have @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@ and/or @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@ set. This will grant the Activity receiving the result access to the specific URIs in the Intent. Access will remain until the Activity has finished (it will remain across the hosting process being killed and other temporary destruction) and will be added to any existing set of URI permissions it already holds.", "history": "Added in API level 1", "FullName": "public final void setResult (int resultCode, Intent data)"}, "removeDialog(int)": {"Returns": [], "Parameters": [["int", "int: The id of the managed dialog."]], "Throws": [], "SeeAlso": ["@B_android#app#Activity#onCreateDialog_E@", "@B_android#app#Activity#onPrepareDialog_E@", "@B_android#app#Activity#showDialog_E@", "@B_android#app#Activity#dismissDialog_E@"], "Permissions": [], "Description": "Use the new @B_android#app#DialogFragment_E@ class with @B_android#app#FragmentManager_E@ instead; this is also available on older platforms through the Android compatibility package. Removes any internal references to a dialog managed by this Activity. If the dialog is showing, it will dismiss it as part of the clean up. This can be useful if you know that you will never show a dialog again and want to avoid the overhead of saving and restoring it in the future. As of @B_android#os#Build#VERSION_CODES#GINGERBREAD_E@, this function will not throw an exception if you try to remove an ID that does not currently have an associated dialog.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public final void removeDialog (int id)"}}, "Inheritance": ["@B_android#content#Context_E@", "@B_android#content#ContextWrapper_E@", "@B_android#view#ContextThemeWrapper_E@"], "ClassName": "android.app.Activity", "ClassDesc": "An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with @B_android#app#Activity#setContentView_E@. While activities are often presented to the user as full-screen windows, they can also be used in other ways: as floating windows (via a theme with @B_android#R#attr#windowIsFloating_E@ set), @B_android#app#Activity#onCreate_E@ is where you initialize your activity. Most importantly, here you will usually call @B_android#app#Activity#setContentView_E@ with a layout resource defining your UI, and using @B_android#app#Activity#findViewById_E@ to retrieve the widgets in that UI that you need to interact with programmatically. @B_android#app#Activity#onPause_E@ is where you deal with the user pausing active interaction with the activity. Any changes made by the user should at this point be committed (usually to the @B_android#content#ContentProvider_E@ holding the data). In this state the activity is still visible on screen. To be of use with @B_android#content#Context#startActivity_E@, all activity classes must have a corresponding @B_android#R#styleable#AndroidManifestActivity_E@ declaration in their package's AndroidManifest.xml. Topics covered here: The https:##developer#android#com@B_android#support#v4#app#FragmentActivity_E@ subclass can make use of the https:##developer#android#com@B_android#support#v4#app#Fragment_E@ class to better modularize their code, build more sophisticated user interfaces for larger screens, and help scale their application between small and large screens. For more information about using fragments, read the Activities in the system are managed as An activity has essentially four states: If an activity is in the foreground of the screen (at the highest position of the topmost stack), it is active or running. This is usually the activity that the user is currently interacting with. If an activity has lost focus but is still presented to the user, it is visible. It is possible if a new non-full-sized or transparent activity has focus on top of your activity, another activity has higher position in multi-window mode, or the activity itself is not focusable in current windowing mode. Such activity is completely alive (it maintains all state and member information and remains attached to the window manager). If an activity is completely obscured by another activity, it is stopped or hidden. It still retains all state and member information, however, it is no longer visible to the user so its window is hidden and it will often be killed by the system when memory is needed elsewhere. The system can drop the activity from memory by either asking it to finish, or simply killing its process, making it destroyed. When it is displayed again to the user, it must be completely restarted and restored to its previous state. The following diagram shows the important state paths of an Activity. The square rectangles represent callback methods you can implement to perform operations when the Activity moves between states. The colored ovals are major states the Activity can be in. There are three key loops you may be interested in monitoring within your activity: The @B_android#app#Activity#onCreate_E@ through to a single final call to @B_android#app#Activity#onDestroy_E@. An activity will do all setup of \"global\" state in onCreate(), and release all remaining resources in onDestroy(). For example, if it has a thread running in the background to download data from the network, it may create that thread in onCreate() and then stop the thread in onDestroy(). The @B_android#app#Activity#onStart_E@ until a corresponding call to @B_android#app#Activity#onStop_E@. During this time the user can see the activity on-screen, though it may not be in the foreground and interacting with the user. Between these two methods you can maintain resources that are needed to show the activity to the user. For example, you can register a @B_android#content#BroadcastReceiver_E@ in onStart() to monitor for changes that impact your UI, and unregister it in onStop() when the user no longer sees what you are displaying. The onStart() and onStop() methods can be called multiple times, as the activity becomes visible and hidden to the user. The @B_android#app#Activity#onResume_E@ until a corresponding call to @B_android#app#Activity#onPause_E@. During this time the activity is in visible, active and interacting with the user. An activity can frequently go between the resumed and paused states -- for example when the device goes to sleep, when an activity result is delivered, when a new intent is delivered -- so the code in these methods should be fairly lightweight. The entire lifecycle of an activity is defined by the following Activity methods. All of these are hooks that you can override to do appropriate work when the activity changes state. All activities will implement @B_android#app#Activity#onCreate_E@ to do their initial setup; many will also implement @B_android#app#Activity#onPause_E@ to commit changes to data and prepare to pause interacting with the user, and @B_android#app#Activity#onStop_E@ to handle no longer being visible on screen. You should always call up to your superclass when implementing these methods. In general the movement through an activity's lifecycle looks like this: Note the \"Killable\" column in the above table -- for those methods that are marked as being killable, after that method returns the process hosting the activity may be killed by the system at any time without another line of its code being executed. Because of this, you should use the @B_android#app#Activity#onPause_E@ method to write any persistent data (such as user edits) to storage. In addition, the method @B_android#app#Activity#onSaveInstanceState_E@ is called before placing the activity in such a background state, allowing you to save away any dynamic instance state in your activity into the given Bundle, to be later received in @B_android#app#Activity#onCreate_E@ if the activity needs to be re-created. See the @B_android#app#Activity#onPause_E@ instead of @B_android#app#Activity#onSaveInstanceState_E@ because the latter is not part of the lifecycle callbacks, so will not be called in every situation as described in its documentation. Be aware that these semantics will change slightly between applications targeting platforms starting with @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@ vs. those targeting prior platforms. Starting with Honeycomb, an application is not in the killable state until its @B_android#app#Activity#onStop_E@ has returned. This impacts when @B_android#app#Activity#onSaveInstanceState_E@ may be called (it may be safely called after @B_android#app#Activity#onPause_E@) and allows an application to safely wait until @B_android#app#Activity#onStop_E@ to save persistent state. For applications targeting platforms starting with @B_android#os#Build#VERSION_CODES#P_E@ @B_android#app#Activity#onSaveInstanceState_E@ will always be called after @B_android#app#Activity#onStop_E@, so an application may safely perform fragment transactions in @B_android#app#Activity#onStop_E@ and will be able to save persistent state later. For those methods that are not marked as being killable, the activity's process will not be killed by the system starting from the time the method is called and continuing after it returns. Thus an activity is in the killable state, for example, between after onStop() to the start of onResume(). Keep in mind that under extreme memory pressure the system can kill the application process at any time. If the configuration of the device (as defined by the @B_android#content#res#Configuration_E@ class) changes, then anything displaying a user interface will need to update to match that configuration. Because Activity is the primary mechanism for interacting with the user, it includes special support for handling configuration changes. Unless you specify otherwise, a configuration change (such as a change in screen orientation, language, input devices, etc) will cause your current activity to be destroyed, going through the normal activity lifecycle process of @B_android#app#Activity#onPause_E@, @B_android#app#Activity#onStop_E@, and @B_android#app#Activity#onDestroy_E@ as appropriate. If the activity had been in the foreground or visible to the user, once @B_android#app#Activity#onDestroy_E@ is called in that instance then a new instance of the activity will be created, with whatever savedInstanceState the previous instance had generated from @B_android#app#Activity#onSaveInstanceState_E@. This is done because any application resource, including layout files, can change based on any configuration value. Thus the only safe way to handle a configuration change is to re-retrieve all resources, including layouts, drawables, and strings. Because activities must already know how to save their state and re-create themselves from that state, this is a convenient way to have an activity restart itself with a new configuration. In some special cases, you may want to bypass restarting of your activity based on one or more types of configuration changes. This is done with the @B_android#R#attr#configChanges_E@ attribute in its manifest. For any types of configuration changes you say that you handle there, you will receive a call to your current activity's @B_android#app#Activity#onConfigurationChanged_E@ method instead of being restarted. If a configuration change involves any that you do not handle, however, the activity will still be restarted and @B_android#app#Activity#onConfigurationChanged_E@ will not be called. The @B_android#app#Activity#startActivity_E@ method is used to start a new activity, which will be placed at the top of the activity stack. It takes a single argument, an @B_android#content#Intent_E@, which describes the activity to be executed. Sometimes you want to get a result back from an activity when it ends. For example, you may start an activity that lets the user pick a person in a list of contacts; when it ends, it returns the person that was selected. To do this, you call the @B_android#app#Activity#startActivityForResult_E@ version with a second integer parameter identifying the call. The result will come back through your @B_android#app#Activity#onActivityResult_E@ method. When an activity exits, it can call @B_android#app#Activity#setResult_E@ to return data back to its parent. It must always supply a result code, which can be the standard results RESULT_CANCELED, RESULT_OK, or any custom values starting at RESULT_FIRST_USER. In addition, it can optionally return back an Intent containing any additional data it wants. All of this information appears back on the parent's Activity.onActivityResult(), along with the integer identifier it originally supplied. If a child activity fails for any reason (such as crashing), the parent activity will receive a result with the code RESULT_CANCELED. There are generally two kinds of persistent state that an activity will deal with: shared document-like data (typically stored in a SQLite database using a For content provider data, we suggest that activities use an \"edit in place\" user model. That is, any edits a user makes are effectively made immediately without requiring an additional confirmation step. Supporting this model is generally a simple matter of following two rules: When creating a new document, the backing database entry or file for it is created immediately. For example, if the user chooses to write a new email, a new entry for that email is created as soon as they start entering data, so that if they go to any other activity after that point this email will now appear in the list of drafts. When an activity's onPause() method is called, it should commit to the backing content provider or file any changes the user has made. This ensures that those changes will be seen by any other activity that is about to run. You will probably want to commit your data even more aggressively at key times during your activity's lifecycle: for example before starting a new activity, before finishing your own activity, when the user switches between input fields, etc. This model is designed to prevent data loss when a user is navigating between activities, and allows the system to safely kill an activity (because system resources are needed somewhere else) at any time after it has been stopped (or paused on platform versions before @B_android#os#Build#VERSION_CODES#HONEYCOMB_E@). Note this implies that the user pressing BACK from your activity does not mean \"cancel\" -- it means to leave the activity with its current contents saved away. Canceling edits in an activity must be provided through some other mechanism, such as an explicit \"revert\" or \"undo\" option. See the The Activity class also provides an API for managing internal persistent state associated with an activity. This can be used, for example, to remember the user's preferred initial display in a calendar (day view or week view) or the user's default home page in a web browser. Activity persistent state is managed with the method @B_android#app#Activity#getPreferences_E@, allowing you to retrieve and modify a set of name/value pairs associated with the activity. To use preferences that are shared across multiple application components (activities, receivers, services, providers), you can use the underlying @B_android#content#Context#getSharedPreferences_E@ method to retrieve a preferences object stored under a specific name. (Note that it is not possible to share settings data across application packages -- for that you will need a content provider.) Here is an excerpt from a calendar activity that stores the user's preferred view mode in its persistent settings: The ability to start a particular Activity can be enforced when it is declared in its manifest's @B_android#R#styleable#AndroidManifestActivity_E@ tag. By doing so, other applications will need to declare a corresponding @B_android#R#styleable#AndroidManifestUsesPermission_E@ element in their own manifest to be able to start that activity. When starting an Activity you can set @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@ and/or @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@ on the Intent. This will grant the Activity access to the specific URIs in the Intent. Access will remain until the Activity has finished (it will remain across the hosting process being killed and other temporary destruction). As of @B_android#os#Build#VERSION_CODES#GINGERBREAD_E@, if the Activity was already created and a new Intent is being delivered to @B_android#app#Activity#onNewIntent_E@, any newly granted URI permissions will be added to the existing ones it holds. See the The Android system attempts to keep an application process around for as long as possible, but eventually will need to remove old processes when memory runs low. As described in Sometimes an Activity may need to do a long-running operation that exists independently of the activity lifecycle itself. An example may be a camera application that allows you to upload a picture to a web site. The upload may take a long time, and the application should allow the user to leave the application while it is executing. To accomplish this, your Activity should start a @B_android#app#Service_E@ in which the upload takes place. This allows the system to properly prioritize your process (considering it to be more important than other non-visible applications) for the duration of the upload, independent of whether the original activity is paused, stopped, or finished."}