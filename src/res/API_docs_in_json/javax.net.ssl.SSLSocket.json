{"Functions": {"SSLSocket(java.lang.String,int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: name of the host with which to connect, or null for the loopback address."], ["int", "int: number of the server's port"]], "Throws": [["@B_java#io#IOException_E@", "if an I/O error occurs when creating the socket"], ["@B_java#lang#SecurityException_E@", "if a security manager exists and its checkConnect method doesn't allow the operation."], ["@B_java#net#UnknownHostException_E@", "if the host is not known"], ["@B_java#lang#IllegalArgumentException_E@", "if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive."]], "SeeAlso": ["@B_java#lang#SecurityManager#checkConnect_E@"], "Permissions": [], "Description": "Used only by subclasses. Constructs a TCP connection to a named host at a specified port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.", "history": "Added in API level 1", "FullName": "protected SSLSocket (String host, int port)"}, "SSLSocket(java.net.InetAddress,int)": {"Returns": [], "Parameters": [["@B_java#net#InetAddress_E@", "InetAddress: the server's host"], ["int", "int: its port"]], "Throws": [["@B_java#io#IOException_E@", "if an I/O error occurs when creating the socket"], ["@B_java#lang#SecurityException_E@", "if a security manager exists and its checkConnect method doesn't allow the operation."], ["@B_java#lang#IllegalArgumentException_E@", "if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive."], ["@B_java#lang#NullPointerException_E@", "if address is null."]], "SeeAlso": ["@B_java#lang#SecurityManager#checkConnect_E@"], "Permissions": [], "Description": "Used only by subclasses. Constructs a TCP connection to a server at a specified address and port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.", "history": "Added in API level 1", "FullName": "protected SSLSocket (InetAddress address, int port)"}, "SSLSocket(java.net.InetAddress, int)": {"Returns": [], "Parameters": [["@B_java#net#InetAddress_E@", "InetAddress: the server's host"], ["int", "int: its port"]], "Throws": [["@B_java#io#IOException_E@", "if an I/O error occurs when creating the socket"], ["@B_java#lang#SecurityException_E@", "if a security manager exists and its checkConnect method doesn't allow the operation."], ["@B_java#lang#IllegalArgumentException_E@", "if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive."], ["@B_java#lang#NullPointerException_E@", "if address is null."]], "SeeAlso": ["@B_java#lang#SecurityManager#checkConnect_E@"], "Permissions": [], "Description": "Used only by subclasses. Constructs a TCP connection to a server at a specified address and port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.", "history": "added in API level 1", "FullName": "protected SSLSocket (InetAddress address, int port)"}, "getSupportedProtocols()": {"Returns": [["@B_java#lang#String_E@", "an array of protocols supported"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the names of the protocols which could be enabled for use on an SSL connection.", "history": "Added in API level 1", "FullName": "public abstract String[] getSupportedProtocols ()"}, "startHandshake()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", "on a network level error"]], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#addHandshakeCompletedListener_E@"], "Permissions": [], "Description": "Starts an SSL handshake on this connection. Common reasons include a need to use new encryption keys, to change cipher suites, or to initiate a new session. To force complete reauthentication, the current session could be invalidated before starting this handshake. If data has already been sent on the connection, it continues to flow during this handshake. When the handshake completes, this will be signaled with an event. This method is synchronous for the initial handshake on a connection and returns when the negotiated handshake is complete. Some protocols may not support multiple handshakes on an existing socket and may throw an IOException.", "history": "Added in API level 1", "FullName": "public abstract void startHandshake ()"}, "setEnableSessionCreation(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true indicates that sessions may be created; this is the default. false indicates that an existing session must be resumed"]], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#getEnableSessionCreation_E@"], "Permissions": [], "Description": "Controls whether new SSL sessions may be established by this socket. If session creations are not allowed, and there are no existing sessions to resume, there will be no successful handshaking.", "history": "Added in API level 1", "FullName": "public abstract void setEnableSessionCreation (boolean flag)"}, "setEnabledProtocols(java.lang.String[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Names of all the protocols to enable."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when one or more of the protocols named by the parameter is not supported or when the protocols parameter is null."]], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#getEnabledProtocols_E@"], "Permissions": [], "Description": "Sets the protocol versions enabled for use on this connection. The protocols must have been listed by getSupportedProtocols() as being supported. Following a successful call to this method, only protocols listed in the protocols parameter are enabled for use. Because of the way the protocol version is negotiated, connections will only be able to use a member of the lowest set of contiguous enabled protocol versions. For example, enabling TLSv1.2 and TLSv1 will result in connections only being able to use TLSv1.", "history": "Added in API level 1", "FullName": "public abstract void setEnabledProtocols (String[] protocols)"}, "SSLSocket()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Used only by subclasses. Constructs an uninitialized, unconnected TCP socket.", "history": "Added in API level 1", "FullName": "protected SSLSocket ()"}, "getApplicationProtocol()": {"Returns": [["@B_java#lang#String_E@", "null if it has not yet been determined if application protocols might be used for this connection, an empty String if application protocols values will not be used, or a non-empty application protocol String if a value was successfully negotiated."]], "Parameters": [], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the most recent application protocol value negotiated for this connection. If supported by the underlying SSL/TLS implementation, application name negotiation mechanisms such as", "history": "Added in API level 29", "FullName": "public String getApplicationProtocol ()"}, "SSLSocket(java.lang.String, int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: name of the host with which to connect, or null for the loopback address."], ["int", "int: number of the server's port"]], "Throws": [["@B_java#io#IOException_E@", "if an I/O error occurs when creating the socket"], ["@B_java#lang#SecurityException_E@", "if a security manager exists and its checkConnect method doesn't allow the operation."], ["@B_java#net#UnknownHostException_E@", "if the host is not known"], ["@B_java#lang#IllegalArgumentException_E@", "if the port parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive."]], "SeeAlso": ["@B_java#lang#SecurityManager#checkConnect_E@"], "Permissions": [], "Description": "Used only by subclasses. Constructs a TCP connection to a named host at a specified port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.", "history": "added in API level 1", "FullName": "protected SSLSocket (String host, int port)"}, "setWantClientAuth(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: set to true if client authentication is requested, or false if no client authentication is desired."]], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#getWantClientAuth_E@", "@B_javax#net#ssl#SSLSocket#setNeedClientAuth_E@", "@B_javax#net#ssl#SSLSocket#getNeedClientAuth_E@", "@B_javax#net#ssl#SSLSocket#setUseClientMode_E@"], "Permissions": [], "Description": "Configures the socket to A socket's client authentication setting is one of the following: client authentication required client authentication requested no client authentication desired Unlike @B_javax#net#ssl#SSLSocket#setNeedClientAuth_E@, if this option is set and the client chooses not to provide authentication information about itself, Calling this method overrides any previous setting made by this method or @B_javax#net#ssl#SSLSocket#setNeedClientAuth_E@.", "history": "Added in API level 1", "FullName": "public abstract void setWantClientAuth (boolean want)"}, "getHandshakeApplicationProtocolSelector()": {"Returns": [["@B_java#util#function#BiFunction_E@", "the callback function, or null if none has been set."]], "Parameters": [], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": [], "Permissions": [], "Description": "Retrieves the callback function that selects an application protocol value during a SSL/TLS handshake. See @B_javax#net#ssl#SSLSocket#setHandshakeApplicationProtocolSelector_E@ for the function's type parameters.", "history": "Added in API level 29", "FullName": "public BiFunction<SSLSocket, List<String>, String> getHandshakeApplicationProtocolSelector ()"}, "SSLSocket(java.lang.String,int,java.net.InetAddress,int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: name of the host with which to connect, or null for the loopback address."], ["int", "int: number of the server's port"], ["@B_java#net#InetAddress_E@", "InetAddress: the client's address the socket is bound to, or null for the anyLocal address."], ["int", "int: the client's port the socket is bound to, or zero for a system selected free port."]], "Throws": [["@B_java#io#IOException_E@", "if an I/O error occurs when creating the socket"], ["@B_java#lang#SecurityException_E@", "if a security manager exists and its checkConnect method doesn't allow the operation."], ["@B_java#net#UnknownHostException_E@", "if the host is not known"], ["@B_java#lang#IllegalArgumentException_E@", "if the port parameter or clientPort parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive."]], "SeeAlso": ["@B_java#lang#SecurityManager#checkConnect_E@"], "Permissions": [], "Description": "Used only by subclasses. Constructs an SSL connection to a named host at a specified port, binding the client side of the connection a given address and port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.", "history": "Added in API level 1", "FullName": "protected SSLSocket (String host, int port, InetAddress clientAddress, int clientPort)"}, "getEnabledProtocols()": {"Returns": [["@B_java#lang#String_E@", "an array of protocols"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#setEnabledProtocols_E@"], "Permissions": [], "Description": "Returns the names of the protocol versions which are currently enabled for use on this connection.", "history": "Added in API level 1", "FullName": "public abstract String[] getEnabledProtocols ()"}, "shutdownInput()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Unsupported for SSL because reading from an SSL socket may require writing to the network.", "history": "Added in API level 1", "FullName": "public void shutdownInput ()"}, "getSession()": {"Returns": [["@B_javax#net#ssl#SSLSession_E@", "the SSLSession"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the SSL Session in use by this connection. These can be long lived, and frequently correspond to an entire login session for some user. The session specifies a particular cipher suite which is being actively used by all connections in that session, as well as the identities of the session's client and server. This method will initiate the initial handshake if necessary and then block until the handshake has been established. If an error occurs during the initial handshake, this method returns an invalid session object which reports an invalid cipher suite of \"SSL_NULL_WITH_NULL_NULL\".", "history": "Added in API level 1", "FullName": "public abstract SSLSession getSession ()"}, "getHandshakeApplicationProtocol()": {"Returns": [["@B_java#lang#String_E@", "null if it has not yet been determined if application protocols might be used for this handshake, an empty String if application protocols values will not be used, or a non-empty application protocol String if a value was successfully negotiated."]], "Parameters": [], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the application protocol value negotiated on a SSL/TLS handshake currently in progress. Like @B_javax#net#ssl#SSLSocket#getHandshakeSession_E@, a connection may be in the middle of a handshake. The application protocol may or may not yet be available.", "history": "Added in API level 29", "FullName": "public String getHandshakeApplicationProtocol ()"}, "addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)": {"Returns": [], "Parameters": [["@B_javax#net#ssl#HandshakeCompletedListener_E@", "HandshakeCompletedListener: the HandShake Completed event listener"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the argument is null."]], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#startHandshake_E@", "@B_javax#net#ssl#SSLSocket#removeHandshakeCompletedListener_E@"], "Permissions": [], "Description": "Registers an event listener to receive notifications that an SSL handshake has completed on this connection.", "history": "Added in API level 1", "FullName": "public abstract void addHandshakeCompletedListener (HandshakeCompletedListener listener)"}, "setHandshakeApplicationProtocolSelector(java.util.function.BiFunction<javax.net.ssl.SSLSocket,java.util.List<java.lang.String>,java.lang.String>)": {"Returns": [], "Parameters": [["@B_java#util#function#BiFunction_E@", "BiFunction: the callback function, or null to de-register."]], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": [], "Permissions": [], "Description": "Registers a callback function that selects an application protocol value for a SSL/TLS handshake. The function overrides any values supplied using @B_javax#net#ssl#SSLParameters#setApplicationProtocols_E@ and it supports the following type parameters:", "history": "Added in API level 29", "FullName": "public void setHandshakeApplicationProtocolSelector (BiFunction<SSLSocket, List<String>, String> selector)"}, "SSLSocket(java.net.InetAddress,int,java.net.InetAddress,int)": {"Returns": [], "Parameters": [["@B_java#net#InetAddress_E@", "InetAddress: the server's host"], ["int", "int: its port"], ["@B_java#net#InetAddress_E@", "InetAddress: the client's address the socket is bound to, or null for the anyLocal address."], ["int", "int: the client's port the socket is bound to, or zero for a system selected free port."]], "Throws": [["@B_java#io#IOException_E@", "if an I/O error occurs when creating the socket"], ["@B_java#lang#SecurityException_E@", "if a security manager exists and its checkConnect method doesn't allow the operation."], ["@B_java#lang#IllegalArgumentException_E@", "if the port parameter or clientPort parameter is outside the specified range of valid port values, which is between 0 and 65535, inclusive."], ["@B_java#lang#NullPointerException_E@", "if address is null."]], "SeeAlso": ["@B_java#lang#SecurityManager#checkConnect_E@"], "Permissions": [], "Description": "Used only by subclasses. Constructs an SSL connection to a server at a specified address and TCP port, binding the client side of the connection a given address and port. This acts as the SSL client. If there is a security manager, its checkConnect method is called with the host address and port as its arguments. This could result in a SecurityException.", "history": "Added in API level 1", "FullName": "protected SSLSocket (InetAddress address, int port, InetAddress clientAddress, int clientPort)"}, "getEnableSessionCreation()": {"Returns": [["boolean", "true indicates that sessions may be created; this is the default. false indicates that an existing session must be resumed"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#setEnableSessionCreation_E@"], "Permissions": [], "Description": "Returns true if new SSL sessions may be established by this socket.", "history": "Added in API level 1", "FullName": "public abstract boolean getEnableSessionCreation ()"}, "getEnabledCipherSuites()": {"Returns": [["@B_java#lang#String_E@", "an array of cipher suite names"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#getSupportedCipherSuites_E@", "@B_javax#net#ssl#SSLSocket#setEnabledCipherSuites_E@"], "Permissions": [], "Description": "Returns the names of the SSL cipher suites which are currently enabled for use on this connection. When an SSLSocket is first created, all enabled cipher suites support a minimum quality of service. Thus, in some environments this value might be empty. Even if a suite has been enabled, it might never be used. (For example, the peer does not support it, the requisite certificates (and private keys) for the suite are not available, or an anonymous suite is enabled but authentication is required.", "history": "Added in API level 1", "FullName": "public abstract String[] getEnabledCipherSuites ()"}, "getWantClientAuth()": {"Returns": [["boolean", "true if client authentication is requested, or false if no client authentication is desired."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#setNeedClientAuth_E@", "@B_javax#net#ssl#SSLSocket#getNeedClientAuth_E@", "@B_javax#net#ssl#SSLSocket#setWantClientAuth_E@", "@B_javax#net#ssl#SSLSocket#setUseClientMode_E@"], "Permissions": [], "Description": "Returns true if the socket will", "history": "Added in API level 1", "FullName": "public abstract boolean getWantClientAuth ()"}, "setUseClientMode(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the socket should start its handshaking in \"client\" mode"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if a mode change is attempted after the initial handshake has begun."]], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#getUseClientMode_E@"], "Permissions": [], "Description": "Configures the socket to use client (or server) mode when handshaking. This method must be called before any handshaking occurs. Once handshaking has begun, the mode can not be reset for the life of this socket. Servers normally authenticate themselves, and clients are not required to do so.", "history": "Added in API level 1", "FullName": "public abstract void setUseClientMode (boolean mode)"}, "setNeedClientAuth(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: set to true if client authentication is required, or false if no client authentication is desired."]], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#getNeedClientAuth_E@", "@B_javax#net#ssl#SSLSocket#setWantClientAuth_E@", "@B_javax#net#ssl#SSLSocket#getWantClientAuth_E@", "@B_javax#net#ssl#SSLSocket#setUseClientMode_E@"], "Permissions": [], "Description": "Configures the socket to A socket's client authentication setting is one of the following: client authentication required client authentication requested no client authentication desired Unlike @B_javax#net#ssl#SSLSocket#setWantClientAuth_E@, if this option is set and the client chooses not to provide authentication information about itself, Calling this method overrides any previous setting made by this method or @B_javax#net#ssl#SSLSocket#setWantClientAuth_E@.", "history": "Added in API level 1", "FullName": "public abstract void setNeedClientAuth (boolean need)"}, "setEnabledCipherSuites(java.lang.String[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Names of all the cipher suites to enable"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when one or more of the ciphers named by the parameter is not supported, or when the parameter is null."]], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#getSupportedCipherSuites_E@", "@B_javax#net#ssl#SSLSocket#getEnabledCipherSuites_E@"], "Permissions": [], "Description": "Sets the cipher suites enabled for use on this connection. Each cipher suite in the suites parameter must have been listed by getSupportedCipherSuites(), or the method will fail. Following a successful call to this method, only suites listed in the suites parameter are enabled for use. See @B_javax#net#ssl#SSLSocket#getEnabledCipherSuites_E@ for more information on why a specific ciphersuite may never be used on a connection.", "history": "Added in API level 1", "FullName": "public abstract void setEnabledCipherSuites (String[] suites)"}, "shutdownOutput()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Unsupported for SSL because writing to an SSL socket may require reading from the network.", "history": "Added in API level 1", "FullName": "public void shutdownOutput ()"}, "getUseClientMode()": {"Returns": [["boolean", "true if the socket should do handshaking in \"client\" mode"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#setUseClientMode_E@"], "Permissions": [], "Description": "Returns true if the socket is set to use client mode when handshaking.", "history": "Added in API level 1", "FullName": "public abstract boolean getUseClientMode ()"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of this socket."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Converts this socket to a String.", "history": "Added in API level 1", "FullName": "public String toString ()"}, "getSSLParameters()": {"Returns": [["@B_javax#net#ssl#SSLParameters_E@", "the SSLParameters in effect for this SSLSocket."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the SSLParameters in effect for this SSLSocket. The ciphersuites and protocols of the returned SSLParameters are always non-null.", "history": "Added in API level 9", "FullName": "public SSLParameters getSSLParameters ()"}, "getSupportedCipherSuites()": {"Returns": [["@B_java#lang#String_E@", "an array of cipher suite names"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#getEnabledCipherSuites_E@", "@B_javax#net#ssl#SSLSocket#setEnabledCipherSuites_E@"], "Permissions": [], "Description": "Returns the names of the cipher suites which could be enabled for use on this connection. Normally, only a subset of these will actually be enabled by default, since this list may include cipher suites which do not meet quality of service requirements for those defaults. Such cipher suites might be useful in specialized applications. Applications should not blindly enable all supported cipher suites. The supported cipher suites can include signaling cipher suite values that can cause connection problems if enabled inappropriately. The proper way to use this method is to either check if a specific cipher suite is supported via Arrays.asList(getSupportedCipherSuites()).contains(...) or to filter a desired list of cipher suites to only the supported ones via desiredSuiteSet.retainAll(Arrays.asList(getSupportedCipherSuites())).", "history": "Added in API level 1", "FullName": "public abstract String[] getSupportedCipherSuites ()"}, "setSSLParameters(javax.net.ssl.SSLParameters)": {"Returns": [], "Parameters": [["@B_javax#net#ssl#SSLParameters_E@", "SSLParameters: the parameters"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the setEnabledCipherSuites() or the setEnabledProtocols() call fails"]], "SeeAlso": [], "Permissions": [], "Description": "Applies SSLParameters to this socket. This means: If params.getCipherSuites() is non-null, setEnabledCipherSuites() is called with that value. If params.getProtocols() is non-null, setEnabledProtocols() is called with that value. If params.getNeedClientAuth() or params.getWantClientAuth() return true, setNeedClientAuth(true) and setWantClientAuth(true) are called, respectively; otherwise setWantClientAuth(false) is called. If params.getServerNames() is non-null, the socket will configure its server names with that value. If params.getSNIMatchers() is non-null, the socket will configure its SNI matchers with that value.", "history": "Added in API level 9", "FullName": "public void setSSLParameters (SSLParameters params)"}, "getHandshakeSession()": {"Returns": [["@B_javax#net#ssl#SSLSession_E@", "null if this instance is not currently handshaking, or if the current handshake has not progressed far enough to create a basic SSLSession. Otherwise, this method returns the SSLSession currently being negotiated."]], "Parameters": [], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine_E@", "@B_javax#net#ssl#SSLSession_E@", "@B_javax#net#ssl#ExtendedSSLSession_E@", "@B_javax#net#ssl#X509ExtendedKeyManager_E@", "@B_javax#net#ssl#X509ExtendedTrustManager_E@"], "Permissions": [], "Description": "Returns the SSLSession being constructed during a SSL/TLS handshake. TLS protocols may negotiate parameters that are needed when using an instance of this class, but before the SSLSession has been completely initialized and made available via getSession. For example, the list of valid signature algorithms may restrict the type of certificates that can used during TrustManager decisions, or the maximum TLS fragment packet sizes can be resized to better support the network environment. This method provides early access to the SSLSession being constructed. Depending on how far the handshake has progressed, some data may not yet be available for use. For example, if a remote server will be sending a Certificate chain, but that chain has yet not been processed, the getPeerCertificates method of SSLSession will throw a SSLPeerUnverifiedException. Once that chain has been processed, getPeerCertificates will return the proper value. Unlike @B_javax#net#ssl#SSLSocket#getSession_E@, this method does not initiate the initial handshake and does not block until handshaking is complete.", "history": "Added in API level 24", "FullName": "public SSLSession getHandshakeSession ()"}, "getNeedClientAuth()": {"Returns": [["boolean", "true if client authentication is required, or false if no client authentication is desired."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#setNeedClientAuth_E@", "@B_javax#net#ssl#SSLSocket#setWantClientAuth_E@", "@B_javax#net#ssl#SSLSocket#getWantClientAuth_E@", "@B_javax#net#ssl#SSLSocket#setUseClientMode_E@"], "Permissions": [], "Description": "Returns true if the socket will", "history": "Added in API level 1", "FullName": "public abstract boolean getNeedClientAuth ()"}, "removeHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)": {"Returns": [], "Parameters": [["@B_javax#net#ssl#HandshakeCompletedListener_E@", "HandshakeCompletedListener: the HandShake Completed event listener"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the listener is not registered, or the argument is null."]], "SeeAlso": ["@B_javax#net#ssl#SSLSocket#addHandshakeCompletedListener_E@"], "Permissions": [], "Description": "Removes a previously registered handshake completion listener.", "history": "Added in API level 1", "FullName": "public abstract void removeHandshakeCompletedListener (HandshakeCompletedListener listener)"}}, "Inheritance": ["@B_java#net#Socket_E@"], "ClassName": "javax.net.ssl.SSLSocket", "ClassDesc": "This class extends Sockets and provides secure socket using protocols such as the \"Secure Sockets Layer\" (SSL) or IETF \"Transport Layer Security\" (TLS) protocols. Such sockets are normal stream sockets, but they add a layer of security protections over the underlying network transport protocol, such as TCP. Those protections include: Integrity Protection. SSL protects against modification of messages by an active wiretapper. Authentication. In most modes, SSL provides peer authentication. Servers are usually authenticated, and clients may be authenticated as requested by servers. Confidentiality (Privacy Protection). In most modes, SSL encrypts data being sent between client and server. This protects the confidentiality of data, so that passive wiretappers won't see sensitive data such as financial information or personal information of many kinds. These kinds of protection are specified by a \"cipher suite\", which is a combination of cryptographic algorithms used by a given SSL connection. During the negotiation process, the two endpoints must agree on a ciphersuite that is available in both environments. If there is no such suite in common, no SSL connection can be established, and no data can be exchanged. The cipher suite used is established by a negotiation process called \"handshaking\". The goal of this process is to create or rejoin a \"session\", which may protect many connections over time. After handshaking has completed, you can access session attributes by using the getSession method. The initial handshake on this connection can be initiated in one of three ways: calling startHandshake which explicitly begins handshakes, or any attempt to read or write application data on this socket causes an implicit handshake, or a call to getSession tries to set up a session if there is no currently valid session, and an implicit handshake is done. If handshaking fails for any reason, the SSLSocket is closed, and no further communications can be done. There are two groups of cipher suites which you will need to know about when managing cipher suites: Supported cipher suites: all the suites which are supported by the SSL implementation. This list is reported using getSupportedCipherSuites. Enabled cipher suites, which may be fewer than the full set of supported suites. This group is set using the setEnabledCipherSuites method, and queried using the getEnabledCipherSuites method. Initially, a default set of cipher suites will be enabled on a new socket that represents the minimum suggested configuration. Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default. Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a ciphersuite be selected. When SSLSockets are first created, no handshaking is done so that applications may first set their communication preferences: what cipher suites to use, whether the socket should be in client or server mode, etc. However, security is always provided by the time that application data is sent over the connection. You may register to receive event notification of handshake completion. This involves the use of two additional classes. HandshakeCompletedEvent objects are passed to HandshakeCompletedListener instances, which are registered by users of this API. SSLSockets are created by SSLSocketFactorys, or by accepting a connection from a SSLServerSocket. A SSL socket must choose to operate in the client or server mode. This will determine who begins the handshaking process, as well as which messages should be sent by each party. Each connection must have one client and one server, or handshaking will not progress properly. Once the initial handshaking has started, a socket can not switch between client and server modes, even when performing renegotiations. SSLSocket instances obtained from default @B_javax#net#ssl#SSLSocketFactory_E@, @B_javax#net#ssl#SSLServerSocketFactory_E@, and @B_javax#net#ssl#SSLContext_E@ are configured as follows: Client socket: Server socket: Methods that operate with cipher suite names (for example, @B_javax#net#ssl#SSLSocket#getSupportedCipherSuites_E@, @B_javax#net#ssl#SSLSocket#setEnabledCipherSuites_E@) have used standard names for cipher suites since API Level 9, as listed in the table below. Prior to API Level 9, non-standard (OpenSSL) names had been used (see the table following this table). NOTE: PSK cipher suites are enabled by default only if the SSLContext through which the socket was created has been initialized with a PSKKeyManager. API Levels 1 to 8 use OpenSSL names for cipher suites. The table below lists these OpenSSL names and their corresponding standard names used in API Levels 9 and newer."}