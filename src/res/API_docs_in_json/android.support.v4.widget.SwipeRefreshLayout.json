{"Functions": {"isNestedScrollingEnabled()": {"Returns": [["boolean", "true if nested scrolling is enabled"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if nested scrolling is enabled for this view. If nested scrolling is enabled and this View class implementation supports it, this view will act as a nested scrolling child view when applicable, forwarding data about the scroll operation in progress to a compatible and cooperating nested scrolling parent.", "history": "", "FullName": "boolean isNestedScrollingEnabled ()"}, "setProgressBackgroundColorSchemeResource(int)": {"Returns": [], "Parameters": [["int", "int: Resource id of the color."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the background color of the progress spinner disc.", "history": "added in version 22.0.0", "FullName": "void setProgressBackgroundColorSchemeResource (int colorRes)"}, "hasNestedScrollingParent()": {"Returns": [["boolean", "whether this view has a nested scrolling parent"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has a nested scrolling parent. The presence of a nested scrolling parent indicates that this view has initiated a nested scroll and it was accepted by an ancestor view further up the view hierarchy.", "history": "", "FullName": "boolean hasNestedScrollingParent ()"}, "requestDisallowInterceptTouchEvent(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the child does not want the parent to intercept touch events."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child does not want this parent and its ancestors to intercept touch events with @B_android#view#ViewGroup#onInterceptTouchEvent_E@. This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel.", "history": "", "FullName": "void requestDisallowInterceptTouchEvent (boolean b)"}, "dispatchNestedScroll(int, int, int, int, int[])": {"Returns": [["boolean", "true if the event was dispatched, false if it could not be dispatched."]], "Parameters": [["int", "int: Horizontal distance in pixels consumed by this view during this scroll step"], ["int", "int: Vertical distance in pixels consumed by this view during this scroll step"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress. Implementations of views that support nested scrolling should call this to report info about a scroll in progress to the current nested scrolling parent. If a nested scroll is not currently in progress or nested scrolling is not @B_android#view#View#isNestedScrollingEnabled_E@ for this view this method does nothing. Compatible View implementations should also call @B_android#view#View#dispatchNestedPreScroll_E@ before consuming a component of the scroll event themselves.", "history": "", "FullName": "boolean dispatchNestedScroll (int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)"}, "getNestedScrollAxes()": {"Returns": [["int", "Flags indicating the current axes of nested scrolling"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the current axes of nested scrolling for this ViewGroup. A ViewGroup returning something other than @B_android#view#View#SCROLL_AXIS_NONE_E@ is currently acting as a nested scrolling parent for one or more descendant views in the hierarchy.", "history": "", "FullName": "int getNestedScrollAxes ()"}, "setColorSchemeResources(int...)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the color resources used in the progress animation from color resources. The first color will also be the color of the bar that grows in response to a user swipe gesture.", "history": "added in version 22.0.0", "FullName": "void setColorSchemeResources (int... colorResIds)"}, "onStopNestedScroll(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll operation ending. Perform cleanup after a nested scrolling operation. This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a @B_android#view#MotionEvent#ACTION_UP_E@ or @B_android#view#MotionEvent#ACTION_CANCEL_E@ event. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "", "FullName": "void onStopNestedScroll (View target)"}, "setNestedScrollingEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to enable nested scrolling, false to disable"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable nested scrolling for this view. If this property is set to true the view will be permitted to initiate nested scrolling operations with a compatible parent view in the current hierarchy. If this view does not implement nested scrolling this will have no effect. Disabling nested scrolling while a nested scroll is in progress has the effect of @B_android#view#View#stopNestedScroll_E@ the nested scroll.", "history": "", "FullName": "void setNestedScrollingEnabled (boolean enabled)"}, "SwipeRefreshLayout(android.content.Context)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Simple constructor to use when creating a SwipeRefreshLayout from code.", "history": "added in version 22.0.0", "FullName": "SwipeRefreshLayout (Context context)"}, "onLayout(boolean, int, int, int, int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "added in version 22.0.0", "FullName": "void onLayout (boolean changed, int left, int top, int right, int bottom)"}, "onInterceptTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true to steal motion events from the children and have them dispatched to this ViewGroup through onTouchEvent(). The current target will receive an ACTION_CANCEL event, and no further messages will be delivered here."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event being dispatched down the hierarchy."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to intercept all touch screen motion events. This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point. Using this function takes some care, as it has a fairly complicated interaction with @B_android#view#View#onTouchEvent_E@, and using it requires implementing that method as well as this one in the correct way. Events will be received in the following order:", "history": "", "FullName": "boolean onInterceptTouchEvent (MotionEvent ev)"}, "getProgressViewEndOffset()": {"Returns": [["int", "The offset in pixels from the top of this view at which the progress spinner should come to rest after a successful swipe gesture."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 25.0.0", "FullName": "int getProgressViewEndOffset ()"}, "isRefreshing()": {"Returns": [["boolean", "Whether the SwipeRefreshWidget is actively showing refresh progress."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "boolean isRefreshing ()"}, "onMeasure(int, int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "added in version 22.0.0", "FullName": "void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "dispatchNestedFling(float, float, boolean)": {"Returns": [["boolean", "true if the nested scrolling parent consumed or otherwise reacted to the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"], ["boolean", "boolean: true if the child consumed the fling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent. This method should be used to indicate that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling.", "history": "", "FullName": "boolean dispatchNestedFling (float velocityX, float velocityY, boolean consumed)"}, "onDetachedFromWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is detached from a window. At this point it no longer has a surface for drawing.", "history": "", "FullName": "void onDetachedFromWindow ()"}, "dispatchNestedPreScroll(int, int, int[], int[])": {"Returns": [["boolean", "true if the parent consumed some or all of the scroll delta"]], "Parameters": [["int", "int: Horizontal scroll distance in pixels"], ["int", "int: Vertical scroll distance in pixels"], ["int[]", "int: Output. If not null, consumed[0] will contain the consumed component of dx and consumed[1] the consumed dy."], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress before this view consumes any portion of it. Nested pre-scroll events are to nested scroll events what touch intercept is to touch. dispatchNestedPreScroll offers an opportunity for the parent view in a nested scrolling operation to consume some or all of the scroll operation before the child view consumes it.", "history": "", "FullName": "boolean dispatchNestedPreScroll (int dx, int dy, int[] consumed, int[] offsetInWindow)"}, "onNestedPreFling(android.view.View, float, float)": {"Returns": [["boolean", "true if this parent consumed the fling ahead of the target view"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested fling before the target view consumes it. This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling parent is consuming motion as part of a @B_android#view#ViewParent#onNestedPreScroll_E@, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well.", "history": "", "FullName": "boolean onNestedPreFling (View target, float velocityX, float velocityY)"}, "setEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if this view is enabled, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the enabled state of this view. The interpretation of the enabled state varies by subclass.", "history": "", "FullName": "void setEnabled (boolean enabled)"}, "setRefreshing(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether or not the view should show refresh progress."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Notify the widget that refresh state has changed. Do not call this when refresh is triggered by a swipe gesture.", "history": "added in version 22.0.0", "FullName": "void setRefreshing (boolean refreshing)"}, "canChildScrollUp()": {"Returns": [["boolean", "Whether it is possible for the child view of this layout to scroll up. Override this if the child view is a custom view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "boolean canChildScrollUp ()"}, "setSize(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "One of DEFAULT, or LARGE.", "history": "added in version 22.0.0", "FullName": "void setSize (int size)"}, "setDistanceToTriggerSync(int)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the distance to trigger a sync in dips", "history": "added in version 22.0.0", "FullName": "void setDistanceToTriggerSync (int distance)"}, "getChildDrawingOrder(int, int)": {"Returns": [["int", "The index of the child to draw this iteration."]], "Parameters": [["int", "int no parameter comment"], ["int", "int: The current iteration."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the index of the child to draw for this iteration. Override this if you want to change the drawing order of children. By default, it returns i. NOTE: In order for this method to be called, you must enable child ordering first by calling @B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@.", "history": "", "FullName": "int getChildDrawingOrder (int childCount, int i)"}, "setProgressViewEndTarget(boolean, int)": {"Returns": [], "Parameters": [["boolean", "boolean: Set to true if there is no view at a higher z-order than where the progress spinner is set to appear. Setting it to true will cause indicator to be scaled up rather than clipped."], ["int", "int: The offset in pixels from the top of this view at which the progress spinner should come to rest after a successful swipe gesture."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The refresh indicator resting position is always positioned near the top of the refreshing content. This position is a consistent location, but can be adjusted in either direction based on whether or not there is a toolbar or actionbar present.", "history": "added in version 22.0.0", "FullName": "void setProgressViewEndTarget (boolean scale, int end)"}, "setColorSchemeColors(int...)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the colors used in the progress animation. The first color will also be the color of the bar that grows in response to a user swipe gesture.", "history": "added in version 22.0.0", "FullName": "void setColorSchemeColors (int... colors)"}, "onTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle touch screen motion events. If this method is used to detect click actions, it is recommended that the actions be performed by implementing and calling @B_android#view#View#performClick_E@. This will ensure consistent system behavior, including: obeying click sound preferences dispatching OnClickListener calls handling @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_CLICK_E@ when accessibility features are enabled", "history": "", "FullName": "boolean onTouchEvent (MotionEvent ev)"}, "setProgressViewOffset(boolean, int, int)": {"Returns": [], "Parameters": [["boolean", "boolean: Set to true if there is no view at a higher z-order than where the progress spinner is set to appear. Setting it to true will cause indicator to be scaled up rather than clipped."], ["int", "int: The offset in pixels from the top of this view at which the progress spinner should appear."], ["int", "int: The offset in pixels from the top of this view at which the progress spinner should come to rest after a successful swipe gesture."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The refresh indicator starting and resting position is always positioned near the top of the refreshing content. This position is a consistent location, but can be adjusted in either direction based on whether or not there is a toolbar or actionbar present. start.", "history": "added in version 22.0.0", "FullName": "void setProgressViewOffset (boolean scale, int start, int end)"}, "getProgressViewStartOffset()": {"Returns": [["int", "The offset in pixels from the top of this view at which the progress spinner should appear."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 25.0.0", "FullName": "int getProgressViewStartOffset ()"}, "setProgressBackgroundColorSchemeColor(int)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the background color of the progress spinner disc.", "history": "added in version 22.0.0", "FullName": "void setProgressBackgroundColorSchemeColor (int color)"}, "setColorScheme(int...)": {"Returns": [], "Parameters": [["int...", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#support#v4#widget#SwipeRefreshLayout#setColorSchemeResources_E@", "history": "added in version 22.0.0", "FullName": "void setColorScheme (int... colors)"}, "setProgressBackgroundColor(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#support#v4#widget#SwipeRefreshLayout#setProgressBackgroundColorSchemeResource_E@", "history": "added in version 22.0.0", "FullName": "void setProgressBackgroundColor (int colorRes)"}, "stopNestedScroll()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Stop a nested scroll in progress. Calling this method when a nested scroll is not currently in progress is harmless.", "history": "", "FullName": "void stopNestedScroll ()"}, "startNestedScroll(int)": {"Returns": [["boolean", "true if a cooperative parent was found and nested scrolling has been enabled for the current gesture."]], "Parameters": [["int", "int: Flags consisting of a combination of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@ and/or @B_android#view#View#SCROLL_AXIS_VERTICAL_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begin a nestable scroll operation along the given axes. A view starting a nested scroll promises to abide by the following contract: The view will call startNestedScroll upon initiating a scroll operation. In the case of a touch scroll this corresponds to the initial @B_android#view#MotionEvent#ACTION_DOWN_E@. In the case of touch scrolling the nested scroll will be terminated automatically in the same manner as @B_android#view#ViewParent#requestDisallowInterceptTouchEvent_E@. In the event of programmatic scrolling the caller must explicitly call @B_android#view#View#stopNestedScroll_E@ to indicate the end of the nested scroll. If startNestedScroll returns true, a cooperative parent was found. If it returns false the caller may ignore the rest of this contract until the next scroll. Calling startNestedScroll while a nested scroll is already in progress will return true. At each incremental step of the scroll the caller should invoke @B_android#view#View#dispatchNestedPreScroll_E@ once it has calculated the requested scrolling delta. If it returns true the nested scrolling parent at least partially consumed the scroll and the caller should adjust the amount it scrolls by. After applying the remainder of the scroll delta the caller should invoke @B_android#view#View#dispatchNestedScroll_E@, passing both the delta consumed and the delta unconsumed. A nested scrolling parent may treat these values differently. See @B_android#view#ViewParent#onNestedScroll_E@.", "history": "", "FullName": "boolean startNestedScroll (int axes)"}, "getProgressCircleDiameter()": {"Returns": [["int", "Diameter in pixels of the progress circle view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the diameter of the progress circle that is displayed as part of the swipe to refresh layout.", "history": "added in version 22.0.0", "FullName": "int getProgressCircleDiameter ()"}, "dispatchNestedPreFling(float, float)": {"Returns": [["boolean", "true if a nested scrolling parent consumed the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent before it is processed by this view. Nested pre-fling events are to nested fling events what touch intercept is to touch and what nested pre-scroll is to nested scroll. dispatchNestedPreFling offsets an opportunity for the parent view in a nested fling to fully consume the fling before the child view consumes it. If this method returns true, a nested parent view consumed the fling and this view should not scroll as a result. For a better user experience, only one view in a nested scrolling chain should consume the fling at a time. If a parent view consumed the fling this method will return false. Custom view implementations should account for this in two ways: If a custom view is paged and needs to settle to a fixed page-point, do not call dispatchNestedPreFling; consume the fling and settle to a valid position regardless. If a nested parent does consume the fling, this view should not scroll at all, even to settle back to a valid idle position. Views should also not offer fling velocities to nested parent views along an axis where scrolling is not currently supported; a @B_android#widget#ScrollView_E@ should not offer a horizontal fling velocity to its parents since scrolling along that axis is not permitted and carrying velocity along that motion does not make sense.", "history": "", "FullName": "boolean dispatchNestedPreFling (float velocityX, float velocityY)"}}, "Inheritance": ["java.lang.Object", "https:##developer#android#com@B_android#view#View_E@", "https:##developer#android#com@B_android#view#ViewGroup_E@"], "ClassName": "android.support.v4.widget.SwipeRefreshLayout", "ClassDesc": "The SwipeRefreshLayout should be used whenever the user can refresh the contents of a view via a vertical swipe gesture. The activity that instantiates this view should add an OnRefreshListener to be notified whenever the swipe to refresh gesture is completed. The SwipeRefreshLayout will notify the listener each and every time the gesture is completed again; the listener is responsible for correctly determining when to actually initiate a refresh of its content. If the listener determines there should not be a refresh, it must call setRefreshing(false) to cancel any visual indication of a refresh. If an activity wishes to show just the progress animation, it should call setRefreshing(true). To disable the gesture and progress animation, call setEnabled(false) on the view. This layout should be made the parent of the view that will be refreshed as a result of the gesture and can only support one direct child. This view will also be made the target of the gesture and will be forced to match both the width and the height supplied in this layout. The SwipeRefreshLayout does not provide accessibility events; instead, a menu item must be provided to allow refresh of the content wherever this gesture is used."}