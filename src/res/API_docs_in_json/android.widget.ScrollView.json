{"Functions": {"executeKeyEvent(android.view.KeyEvent)": {"Returns": [["boolean", "Return true if the event was handled, else false."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to execute."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.", "history": "Added in API level 1", "FullName": "public boolean executeKeyEvent (KeyEvent event)"}, "fullScroll(int)": {"Returns": [["boolean", "true if the key event is consumed by this method, false otherwise"]], "Parameters": [["int", "int: the scroll direction: @B_android#view#View#FOCUS_UP_E@ to go the top of the view or @B_android#view#View#FOCUS_DOWN_E@ to go the bottom"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handles scrolling in response to a \"home/end\" shortcut press. This method will scroll the view to the top or bottom and give the focus to the topmost/bottommost component in the new visible area. If no component is a good candidate for focus, this scrollview reclaims the focus.", "history": "Added in API level 1", "FullName": "public boolean fullScroll (int direction)"}, "computeScroll()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary. This will typically be done if the child is animating a scroll using a @B_android#widget#Scroller_E@ object.", "history": "Added in API level 1", "FullName": "public void computeScroll ()"}, "onRequestFocusInDescendants(int,android.graphics.Rect)": {"Returns": [["boolean", "Whether focus was taken."]], "Parameters": [["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT"], ["@B_android#graphics#Rect_E@", "Rect: The rectangle (in this View's coordinate system) to give a finer grained hint about where focus is coming from. May be null if there is no hint."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "When looking for focus in children of a scroll view, need to be a little more careful not to give focus to something that is scrolled off screen. This is more expensive than the default @B_android#view#ViewGroup_E@ implementation, otherwise this behavior might have been made the default.", "history": "Added in API level 1", "FullName": "protected boolean onRequestFocusInDescendants (int direction, Rect previouslyFocusedRect)"}, "getTopFadingEdgeStrength()": {"Returns": [["float", "the intensity of the top fade as a float between 0.0f and 1.0f"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the strength, or intensity, of the top faded edge. The strength is a value between 0.0 (no fade) and 1.0 (full fade). The default implementation returns 0.0 or 1.0 but no value in between. Subclasses should override this method to provide a smoother fade transition when scrolling occurs.", "history": "Added in API level 1", "FullName": "protected float getTopFadingEdgeStrength ()"}, "onMeasure(int, int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "added in API level 1", "FullName": "protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "measureChild(android.view.View, int, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child to measure"], ["int", "int: The width requirements for this view"], ["int", "int: The height requirements for this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding. The heavy lifting is done in getChildMeasureSpec.", "history": "added in API level 1", "FullName": "protected void measureChild (View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)"}, "draw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: The Canvas to which the View is rendered."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Manually render this view (and all of its children) to the given Canvas. The view must have already done a full layout before this function is called. When implementing a view, implement @B_android#view#View#onDraw_E@ instead of overriding this method. If you do need to override this method, call the superclass version. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "public void draw (Canvas canvas)"}, "requestDisallowInterceptTouchEvent(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the child does not want the parent to intercept touch events."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child does not want this parent and its ancestors to intercept touch events with @B_android#view#ViewGroup#onInterceptTouchEvent_E@. This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel.", "history": "Added in API level 1", "FullName": "public void requestDisallowInterceptTouchEvent (boolean disallowIntercept)"}, "isSmoothScrollingEnabled()": {"Returns": [["boolean", "Whether arrow scrolling will animate its transition."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public boolean isSmoothScrollingEnabled ()"}, "ScrollView(android.content.Context,android.util.AttributeSet,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["@B_android#util#AttributeSet_E@", "AttributeSet no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public ScrollView (Context context, AttributeSet attrs, int defStyleAttr)"}, "onNestedScrollAccepted(android.view.View,android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: Direct child of this ViewParent containing target"], ["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["int", "int: Flags consisting of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@, @B_android#view#View#SCROLL_AXIS_VERTICAL_E@ or both"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to the successful claiming of a nested scroll operation. This method will be called after @B_android#view#ViewParent#onStartNestedScroll_E@ returns true. It offers an opportunity for the view and its superclasses to perform initial configuration for the nested scroll. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "Added in API level 21", "FullName": "public void onNestedScrollAccepted (View child, View target, int axes)"}, "getMaxScrollAmount()": {"Returns": [["int", "The maximum amount this scroll view will scroll in response to an arrow event."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public int getMaxScrollAmount ()"}, "smoothScrollBy(int, int)": {"Returns": [], "Parameters": [["int", "int: the number of pixels to scroll by on the X axis"], ["int", "int: the number of pixels to scroll by on the Y axis"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#view#View#scrollBy_E@, but scroll smoothly instead of immediately.", "history": "added in API level 1", "FullName": "public final void smoothScrollBy (int dx, int dy)"}, "onNestedFling(android.view.View,float,float,boolean)": {"Returns": [["boolean", "true if this parent consumed or otherwise reacted to the fling"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"], ["boolean", "boolean: true if the child consumed the fling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request a fling from a nested scroll. This method signifies that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling.", "history": "Added in API level 21", "FullName": "public boolean onNestedFling (View target, float velocityX, float velocityY, boolean consumed)"}, "onGenericMotionEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The generic motion event being processed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle generic motion events. Generic motion events describe joystick movements, mouse hovers, track pad touches, scroll wheel movements and other input events. The @B_android#view#MotionEvent#getSource_E@ of the motion event specifies the class of input that was received. Implementations of this method must examine the bits in the source before processing the event. The following code example shows how this is done. Generic motion events with source class @B_android#view#InputDevice#SOURCE_CLASS_POINTER_E@ are delivered to the view under the pointer. All other generic motion events are delivered to the focused view.", "history": "Added in API level 12", "FullName": "public boolean onGenericMotionEvent (MotionEvent event)"}, "ScrollView(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public ScrollView (Context context)"}, "setOverScrollMode(int)": {"Returns": [], "Parameters": [["int", "int: The new over-scroll mode for this view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the over-scroll mode for this view. Valid over-scroll modes are @B_android#view#View#OVER_SCROLL_ALWAYS_E@ (default), @B_android#view#View#OVER_SCROLL_IF_CONTENT_SCROLLS_E@ (allow over-scrolling only if the view content is larger than the container), or @B_android#view#View#OVER_SCROLL_NEVER_E@. Setting the over-scroll mode of a view will have an effect only if the view is capable of scrolling.", "history": "added in API level 9", "FullName": "public void setOverScrollMode (int mode)"}, "scrollToDescendant(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the View to scroll to This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Scrolls the view to the given child.", "history": "Added in API level 29", "FullName": "public void scrollToDescendant (View child)"}, "setBottomEdgeEffectColor(int)": {"Returns": [], "Parameters": [["int", "int: The color for the bottom edge effect."]], "Throws": [], "SeeAlso": ["@B_android#widget#ScrollView#setTopEdgeEffectColor_E@", "@B_android#widget#ScrollView#setEdgeEffectColor_E@", "@B_android#widget#ScrollView#getTopEdgeEffectColor_E@", "@B_android#widget#ScrollView#getBottomEdgeEffectColor_E@"], "Permissions": [], "Description": "Sets the bottom edge effect color.", "history": "Added in API level 29", "FullName": "public void setBottomEdgeEffectColor (int color)"}, "performAccessibilityAction(int, android.os.Bundle)": {"Returns": [["", "Whether the action was performed."]], "Parameters": [["int", "The action to perform."], ["@B_android#os#Bundle_E@", "Optional action arguments."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Performs the specified accessibility action on the view. For possible accessibility actions look at @B_android#view#accessibility#AccessibilityNodeInfo_E@. If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#performAccessibilityAction_E@ is responsible for handling this call. The default implementation will delegate @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_SCROLL_BACKWARD_E@ and @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_SCROLL_FORWARD_E@ to nested scrolling parents if @B_android#view#View#isNestedScrollingEnabled_E@ on this view.", "history": "Added in API level 16", "FullName": "public boolean performAccessibilityAction (int action, Bundle arguments)"}, "onOverScrolled(int, int, boolean, boolean)": {"Returns": [], "Parameters": [["int", "int: New X scroll value in pixels"], ["int", "int: New Y scroll value in pixels"], ["boolean", "boolean: True if scrollX was clamped to an over-scroll boundary"], ["boolean", "boolean: True if scrollY was clamped to an over-scroll boundary"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by @B_android#view#View#overScrollBy_E@ to respond to the results of an over-scroll operation.", "history": "added in API level 9", "FullName": "protected void onOverScrolled (int scrollX, int scrollY, boolean clampedX, boolean clampedY)"}, "computeVerticalScrollRange()": {"Returns": [["int", "the total vertical range represented by the vertical scrollbar The default range is the drawing height of this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The scroll range of a scroll view is the overall height of all of its children.", "history": "Added in API level 1", "FullName": "protected int computeVerticalScrollRange ()"}, "addView(android.view.View, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["int", "int: the position at which to add the child"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view. If no layout parameters are already set on the child, the default parameters for this ViewGroup are set on the child. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "added in API level 1", "FullName": "public void addView (View child, int index)"}, "measureChildWithMargins(android.view.View,int,int,int,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child to measure"], ["int", "int: The width requirements for this view"], ["int", "int: Extra space that has been used up by the parent horizontally (possibly by other children of the parent)"], ["int", "int: The height requirements for this view"], ["int", "int: Extra space that has been used up by the parent vertically (possibly by other children of the parent)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding and margins. The child must have MarginLayoutParams The heavy lifting is done in getChildMeasureSpec.", "history": "Added in API level 1", "FullName": "protected void measureChildWithMargins (View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)"}, "onOverScrolled(int,int,boolean,boolean)": {"Returns": [], "Parameters": [["int", "int: New X scroll value in pixels"], ["int", "int: New Y scroll value in pixels"], ["boolean", "boolean: True if scrollX was clamped to an over-scroll boundary"], ["boolean", "boolean: True if scrollY was clamped to an over-scroll boundary"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by @B_android#view#View#overScrollBy_E@ to respond to the results of an over-scroll operation.", "history": "Added in API level 9", "FullName": "protected void onOverScrolled (int scrollX, int scrollY, boolean clampedX, boolean clampedY)"}, "onTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle touch screen motion events. If this method is used to detect click actions, it is recommended that the actions be performed by implementing and calling @B_android#view#View#performClick_E@. This will ensure consistent system behavior, including: obeying click sound preferences dispatching OnClickListener calls handling @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_CLICK_E@ when accessibility features are enabled", "history": "Added in API level 1", "FullName": "public boolean onTouchEvent (MotionEvent ev)"}, "pageScroll(int)": {"Returns": [["boolean", "true if the key event is consumed by this method, false otherwise"]], "Parameters": [["int", "int: the scroll direction: @B_android#view#View#FOCUS_UP_E@ to go one page up or @B_android#view#View#FOCUS_DOWN_E@ to go one page down"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handles scrolling in response to a \"page up/down\" shortcut press. This method will scroll the view by one page up or down and give the focus to the topmost/bottommost component in the new visible area. If no component is a good candidate for focus, this scrollview reclaims the focus.", "history": "Added in API level 1", "FullName": "public boolean pageScroll (int direction)"}, "onSaveInstanceState()": {"Returns": [["@B_android#os#Parcelable_E@", "Returns a Parcelable object containing the view's current dynamic state, or null if there is nothing interesting to save."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected Parcelable onSaveInstanceState ()"}, "smoothScrollTo(int,int)": {"Returns": [], "Parameters": [["int", "int: the position where to scroll on the X axis"], ["int", "int: the position where to scroll on the Y axis"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#widget#ScrollView#scrollTo_E@, but scroll smoothly instead of immediately.", "history": "Added in API level 1", "FullName": "public final void smoothScrollTo (int x, int y)"}, "computeScrollDeltaToGetChildRectOnScreen(android.graphics.Rect)": {"Returns": [["int", "The scroll delta."]], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: The rect."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compute the amount to scroll in the Y direction in order to get a rectangle completely on the screen (or, if taller than the screen, at least the first screen size chunk of it).", "history": "Added in API level 1", "FullName": "protected int computeScrollDeltaToGetChildRectOnScreen (Rect rect)"}, "addView(android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["int", "int: the position at which to add the child"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view. If no layout parameters are already set on the child, the default parameters for this ViewGroup are set on the child. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void addView (View child, int index)"}, "ScrollView(android.content.Context,android.util.AttributeSet,int,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["@B_android#util#AttributeSet_E@", "AttributeSet no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 21", "FullName": "public ScrollView (Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)"}, "ScrollView(android.content.Context,android.util.AttributeSet)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["@B_android#util#AttributeSet_E@", "AttributeSet no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public ScrollView (Context context, AttributeSet attrs)"}, "onMeasure(int,int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "Added in API level 1", "FullName": "protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "requestLayout()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this when something has changed which has invalidated the layout of this view. This will schedule a layout pass of the view tree. This should not be called while the view hierarchy is currently in a layout pass (@B_android#view#View#isInLayout_E@. If layout is happening, the request may be honored at the end of the current layout pass (and then layout will run again) or after the current frame is drawn and the next layout occurs. Subclasses which override this method should call the superclass method to handle possible request-during-layout errors correctly. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "public void requestLayout ()"}, "onLayout(boolean,int,int,int,int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "Added in API level 1", "FullName": "protected void onLayout (boolean changed, int l, int t, int r, int b)"}, "onSizeChanged(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: Current width of this view."], ["int", "int: Current height of this view."], ["int", "int: Old width of this view."], ["int", "int: Old height of this view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0.", "history": "added in API level 1", "FullName": "protected void onSizeChanged (int w, int h, int oldw, int oldh)"}, "fling(int)": {"Returns": [], "Parameters": [["int", "int: The initial velocity in the Y direction. Positive numbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Fling the scroll view", "history": "Added in API level 1", "FullName": "public void fling (int velocityY)"}, "dispatchKeyEvent(android.view.KeyEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a key event to the next view on the focus path. This path runs from the top of the view tree down to the currently focused view. If this view has focus, it will dispatch to itself. Otherwise it will dispatch the next node down the focus path. This method also fires any key listeners.", "history": "Added in API level 1", "FullName": "public boolean dispatchKeyEvent (KeyEvent event)"}, "requestChildRectangleOnScreen(android.view.View,android.graphics.Rect,boolean)": {"Returns": [["boolean", "Whether the group scrolled to handle the operation"]], "Parameters": [["@B_android#view#View_E@", "View: The direct child making the request."], ["@B_android#graphics#Rect_E@", "Rect: The rectangle in the child's coordinates the child wishes to be on the screen."], ["boolean", "boolean: True to forbid animated or delayed scrolling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child of this group wants a particular rectangle to be positioned onto the screen. @B_android#view#ViewGroup_E@s overriding this can trust that: child will be a direct child of this group rectangle will be in the child's content coordinates @B_android#view#ViewGroup_E@s overriding this should uphold the contract: nothing will change if the rectangle is already visible the view port will be scrolled only just enough to make the rectangle visible", "history": "Added in API level 1", "FullName": "public boolean requestChildRectangleOnScreen (View child, Rect rectangle, boolean immediate)"}, "onStopNestedScroll(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll operation ending. Perform cleanup after a nested scrolling operation. This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a @B_android#view#MotionEvent#ACTION_UP_E@ or @B_android#view#MotionEvent#ACTION_CANCEL_E@ event. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "Added in API level 21", "FullName": "public void onStopNestedScroll (View target)"}, "onStartNestedScroll(android.view.View,android.view.View,int)": {"Returns": [["boolean", "true if this ViewParent accepts the nested scroll operation"]], "Parameters": [["@B_android#view#View_E@", "View: Direct child of this ViewParent containing target"], ["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["int", "int: Flags consisting of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@, @B_android#view#View#SCROLL_AXIS_VERTICAL_E@ or both"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a descendant view initiating a nestable scroll operation, claiming the nested scroll operation if appropriate. This method will be called in response to a descendant view invoking @B_android#view#View#startNestedScroll_E@. Each parent up the view hierarchy will be given an opportunity to respond and claim the nested scrolling operation by returning true. This method may be overridden by ViewParent implementations to indicate when the view is willing to support a nested scrolling operation that is about to begin. If it returns true, this ViewParent will become the target view's nested scrolling parent for the duration of the scroll operation in progress. When the nested scroll is finished this ViewParent will receive a call to @B_android#view#ViewParent#onStopNestedScroll_E@.", "history": "Added in API level 21", "FullName": "public boolean onStartNestedScroll (View child, View target, int nestedScrollAxes)"}, "computeVerticalScrollOffset()": {"Returns": [["int", "the vertical offset of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compute the vertical offset of the vertical scrollbar's thumb within the horizontal range. This value is used to compute the position of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#view#View#computeVerticalScrollRange_E@ and @B_android#view#View#computeVerticalScrollExtent_E@. The default offset is the scroll offset of this view.", "history": "Added in API level 1", "FullName": "protected int computeVerticalScrollOffset ()"}, "onLayout(boolean, int, int, int, int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "added in API level 1", "FullName": "protected void onLayout (boolean changed, int l, int t, int r, int b)"}, "shouldDelayChildPressedState()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if the pressed state should be delayed for children or descendants of this ViewGroup. Generally, this should be done for containers that can scroll, such as a List. This prevents the pressed state from appearing when the user is actually trying to scroll the content. The default implementation returns true for compatibility reasons. Subclasses that do not scroll should generally override this method and return false.", "history": "Added in API level 14", "FullName": "public boolean shouldDelayChildPressedState ()"}, "scrollTo(int,int)": {"Returns": [], "Parameters": [["int", "int: the x position to scroll to"], ["int", "int: the y position to scroll to"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated. This version also clamps the scrolling to the bounds of our child.", "history": "Added in API level 1", "FullName": "public void scrollTo (int x, int y)"}, "setSmoothScrollingEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: whether arrow scrolling will animate its transition"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set whether arrow scrolling will animate its transition.", "history": "Added in API level 1", "FullName": "public void setSmoothScrollingEnabled (boolean smoothScrollingEnabled)"}, "onSizeChanged(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: Current width of this view."], ["int", "int: Current height of this view."], ["int", "int: Old width of this view."], ["int", "int: Old height of this view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0.", "history": "Added in API level 1", "FullName": "protected void onSizeChanged (int w, int h, int oldw, int oldh)"}, "smoothScrollBy(int,int)": {"Returns": [], "Parameters": [["int", "int: the number of pixels to scroll by on the X axis"], ["int", "int: the number of pixels to scroll by on the Y axis"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#view#View#scrollBy_E@, but scroll smoothly instead of immediately.", "history": "Added in API level 1", "FullName": "public final void smoothScrollBy (int dx, int dy)"}, "onDetachedFromWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is detached from a window. At this point it no longer has a surface for drawing. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onDetachedFromWindow ()"}, "getTopEdgeEffectColor()": {"Returns": [["int", "The top edge effect color."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#widget#ScrollView#setEdgeEffectColor_E@", "@B_android#widget#ScrollView#setTopEdgeEffectColor_E@", "@B_android#widget#ScrollView#setBottomEdgeEffectColor_E@", "@B_android#widget#ScrollView#getBottomEdgeEffectColor_E@"], "Permissions": [], "Description": "Returns the top edge effect color.", "history": "Added in API level 29", "FullName": "public int getTopEdgeEffectColor ()"}, "isFillViewport()": {"Returns": [["boolean", "True if the content fills the viewport, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether this ScrollView's content is stretched to fill the viewport.", "history": "Added in API level 1", "FullName": "public boolean isFillViewport ()"}, "arrowScroll(int)": {"Returns": [["boolean", "True if we consumed the event, false otherwise"]], "Parameters": [["int", "int: The direction corresponding to the arrow key that was pressed"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handle scrolling in response to an up or down arrow click.", "history": "Added in API level 1", "FullName": "public boolean arrowScroll (int direction)"}, "requestChildFocus(android.view.View,android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child of this ViewParent that wants focus. This view will contain the focused view. It is not necessarily the view that actually has focus."], ["@B_android#view#View_E@", "View: The view that is a descendant of child that actually has focus"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child of this parent wants focus", "history": "Added in API level 1", "FullName": "public void requestChildFocus (View child, View focused)"}, "scrollTo(int, int)": {"Returns": [], "Parameters": [["int", "int: the x position to scroll to"], ["int", "int: the y position to scroll to"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated. This version also clamps the scrolling to the bounds of our child.", "history": "added in API level 1", "FullName": "public void scrollTo (int x, int y)"}, "onRestoreInstanceState(android.os.Parcelable)": {"Returns": [], "Parameters": [["@B_android#os#Parcelable_E@", "Parcelable: The frozen state that had previously been returned by @B_android#widget#ScrollView#onSaveInstanceState_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to re-apply a representation of its internal state that had previously been generated by @B_android#view#View#onSaveInstanceState_E@. This function will never be called with a null state. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onRestoreInstanceState (Parcelable state)"}, "addView(android.view.View,int,android.view.ViewGroup.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["int", "int: the position at which to add the child or -1 to add last"], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: the layout parameters to set on the child"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view with the specified layout parameters. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void addView (View child, int index, ViewGroup.LayoutParams params)"}, "onNestedScroll(android.view.View,int,int,int,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The descendent view controlling the nested scroll"], ["int", "int: Horizontal scroll distance in pixels already consumed by target"], ["int", "int: Vertical scroll distance in pixels already consumed by target"], ["int", "int: Horizontal scroll distance in pixels not consumed by target"], ["int", "int: Vertical scroll distance in pixels not consumed by target"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll in progress. This method will be called when the ViewParent's current nested scrolling child view dispatches a nested scroll event. To receive calls to this method the ViewParent must have previously returned true for a call to @B_android#view#ViewParent#onStartNestedScroll_E@. Both the consumed and unconsumed portions of the scroll distance are reported to the ViewParent. An implementation may choose to use the consumed portion to match or chase scroll position of multiple child elements, for example. The unconsumed portion may be used to allow continuous dragging of multiple scrolling or draggable elements, such as scrolling a list within a vertical drawer where the drawer begins dragging once the edge of inner scrolling content is reached.", "history": "Added in API level 21", "FullName": "public void onNestedScroll (View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)"}, "getBottomEdgeEffectColor()": {"Returns": [["int", "The bottom edge effect color."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#widget#ScrollView#setEdgeEffectColor_E@", "@B_android#widget#ScrollView#setTopEdgeEffectColor_E@", "@B_android#widget#ScrollView#setBottomEdgeEffectColor_E@", "@B_android#widget#ScrollView#getTopEdgeEffectColor_E@"], "Permissions": [], "Description": "Returns the bottom edge effect color.", "history": "Added in API level 29", "FullName": "public int getBottomEdgeEffectColor ()"}, "addView(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view. If no layout parameters are already set on the child, the default parameters for this ViewGroup are set on the child. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void addView (View child)"}, "getBottomFadingEdgeStrength()": {"Returns": [["float", "the intensity of the bottom fade as a float between 0.0f and 1.0f"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the strength, or intensity, of the bottom faded edge. The strength is a value between 0.0 (no fade) and 1.0 (full fade). The default implementation returns 0.0 or 1.0 but no value in between. Subclasses should override this method to provide a smoother fade transition when scrolling occurs.", "history": "Added in API level 1", "FullName": "protected float getBottomFadingEdgeStrength ()"}, "onInterceptTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true to steal motion events from the children and have them dispatched to this ViewGroup through onTouchEvent(). The current target will receive an ACTION_CANCEL event, and no further messages will be delivered here."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event being dispatched down the hierarchy."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to intercept all touch screen motion events. This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point. Using this function takes some care, as it has a fairly complicated interaction with @B_android#view#View#onTouchEvent_E@, and using it requires implementing that method as well as this one in the correct way. Events will be received in the following order:", "history": "Added in API level 1", "FullName": "public boolean onInterceptTouchEvent (MotionEvent ev)"}, "setTopEdgeEffectColor(int)": {"Returns": [], "Parameters": [["int", "int: The color for the top edge effect."]], "Throws": [], "SeeAlso": ["@B_android#widget#ScrollView#setBottomEdgeEffectColor_E@", "@B_android#widget#ScrollView#setEdgeEffectColor_E@", "@B_android#widget#ScrollView#getTopEdgeEffectColor_E@", "@B_android#widget#ScrollView#getBottomEdgeEffectColor_E@"], "Permissions": [], "Description": "Sets the top edge effect color.", "history": "Added in API level 29", "FullName": "public void setTopEdgeEffectColor (int color)"}, "smoothScrollTo(int, int)": {"Returns": [], "Parameters": [["int", "int: the position where to scroll on the X axis"], ["int", "int: the position where to scroll on the Y axis"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#widget#ScrollView#scrollTo_E@, but scroll smoothly instead of immediately.", "history": "added in API level 1", "FullName": "public final void smoothScrollTo (int x, int y)"}, "measureChild(android.view.View,int,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child to measure"], ["int", "int: The width requirements for this view"], ["int", "int: The height requirements for this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding. The heavy lifting is done in getChildMeasureSpec.", "history": "Added in API level 1", "FullName": "protected void measureChild (View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)"}, "setFillViewport(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True to stretch the content's height to the viewport's boundaries, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates this ScrollView whether it should stretch its content height to fill the viewport or not.", "history": "Added in API level 1", "FullName": "public void setFillViewport (boolean fillViewport)"}, "setEdgeEffectColor(int)": {"Returns": [], "Parameters": [["int", "int: The color for the edge effects."]], "Throws": [], "SeeAlso": ["@B_android#widget#ScrollView#setTopEdgeEffectColor_E@", "@B_android#widget#ScrollView#setBottomEdgeEffectColor_E@", "@B_android#widget#ScrollView#getTopEdgeEffectColor_E@", "@B_android#widget#ScrollView#getBottomEdgeEffectColor_E@"], "Permissions": [], "Description": "Sets the edge effect color for both top and bottom edge effects.", "history": "Added in API level 29", "FullName": "public void setEdgeEffectColor (int color)"}, "getAccessibilityClassName()": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the class name of this object to be used for accessibility purposes. Subclasses should only override this if they are implementing something that should be seen as a completely new class of view when used by accessibility, unrelated to the class it is deriving from. This is used to fill in @B_android#view#accessibility#AccessibilityNodeInfo#setClassName_E@.", "history": "Added in API level 23", "FullName": "public CharSequence getAccessibilityClassName ()"}, "addView(android.view.View,android.view.ViewGroup.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: the layout parameters to set on the child"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view with the specified layout parameters. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "Added in API level 1", "FullName": "public void addView (View child, ViewGroup.LayoutParams params)"}}, "Inheritance": ["@B_android#view#View_E@", "@B_android#view#ViewGroup_E@", "@B_android#widget#FrameLayout_E@"], "ClassName": "android.widget.ScrollView", "ClassDesc": "A view group that allows the view hierarchy placed within it to be scrolled. Scroll view may have only one direct child placed within it. To add multiple views within the scroll view, make the direct child you add a view group, for example @B_android#widget#LinearLayout_E@, and place additional views within that LinearLayout. Scroll view supports vertical scrolling only. For horizontal scrolling, use @B_android#widget#HorizontalScrollView_E@ instead. Never add a https:##developer#android#com@B_android#support#v7#widget#RecyclerView_E@ or @B_android#widget#ListView_E@ to a scroll view. Doing so results in poor user interface performance and a poor user experience. For vertical scrolling, consider https:##developer#android#com@B_android#support#v4#widget#NestedScrollView_E@ instead of scroll view which offers greater user interface flexibility and support for the material design scrolling patterns. Material Design offers guidelines on how the appearance of"}