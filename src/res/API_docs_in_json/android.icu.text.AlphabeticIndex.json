{"Functions": {"getCollator()": {"Returns": [["@B_android#icu#text#RuleBasedCollator_E@", "a clone of the collator used internally"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get a clone of the collator used internally. Note that for performance reasons, the clone is only done once, and then stored. The next time it is accessed, the same instance is returned.", "history": "Added in API level 24", "FullName": "public RuleBasedCollator getCollator ()"}, "getMaxLabelCount()": {"Returns": [["int", "maxLabelCount maximum number of labels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the limit on the number of labels in the index. The number of buckets can be slightly larger: see getBucketCount().", "history": "Added in API level 24", "FullName": "public int getMaxLabelCount ()"}, "addRecord(java.lang.CharSequence,V)": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: Name, such as a name"], ["V", "V: Data, such as an address or link"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add a record (name and data) to the index. The name will be used to sort the items into buckets, and to sort within the bucket. Two records may have the same name. When they do, the sort order is according to the order added: the first added comes first.", "history": "Added in API level 24", "FullName": "public AlphabeticIndex<V> addRecord (CharSequence name, V data)"}, "buildImmutableIndex()": {"Returns": [["@B_android#icu#text#AlphabeticIndex#ImmutableIndex_E@", "an immutable index instance"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Builds an immutable, thread-safe version of this instance, without data records.", "history": "Added in API level 24", "FullName": "public ImmutableIndex<V> buildImmutableIndex ()"}, "AlphabeticIndex(java.util.Locale)": {"Returns": [], "Parameters": [["@B_java#util#Locale_E@", "Locale: The locale for the index."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create the index object.", "history": "Added in API level 24", "FullName": "public AlphabeticIndex (Locale locale)"}, "getRecordCount()": {"Returns": [["int", "total number of records in buckets"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of records in the index: that is, the total number of distinct <name,data> pairs added with addRecord(...), over all the buckets.", "history": "Added in API level 24", "FullName": "public int getRecordCount ()"}, "getUnderflowLabel()": {"Returns": [["@B_java#lang#String_E@", "underflow label"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the default label used in the IndexCharacters' locale for underflow, eg the last item in: X Y Z ...", "history": "Added in API level 24", "FullName": "public String getUnderflowLabel ()"}, "getBucketCount()": {"Returns": [["int", "number of buckets"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of buckets in the index. This will be the same as the number of labels, plus buckets for the underflow, overflow, and inflow(s).", "history": "Added in API level 24", "FullName": "public int getBucketCount ()"}, "AlphabeticIndex(android.icu.text.RuleBasedCollator)": {"Returns": [], "Parameters": [["@B_android#icu#text#RuleBasedCollator_E@", "RuleBasedCollator: The collator to use to order the contents of this index."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create an AlphabeticIndex that uses a specific collator. The index will be created with no labels; the addLabels() function must be called after creation to add the desired labels to the index. The index will work directly with the supplied collator. If the caller will need to continue working with the collator it should be cloned first, so that the collator provided to the AlphabeticIndex remains unchanged after creation of the index.", "history": "Added in API level 24", "FullName": "public AlphabeticIndex (RuleBasedCollator collator)"}, "iterator()": {"Returns": [["@B_java#util#Iterator_E@", "iterator over buckets."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an iterator over the buckets.", "history": "Added in API level 24", "FullName": "public Iterator<Bucket<V>> iterator ()"}, "addLabels(android.icu.text.UnicodeSet)": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [["@B_android#icu#text#UnicodeSet_E@", "UnicodeSet: additional characters to add to the index, such as A-Z."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add more index characters (aside from what are in the locale)", "history": "Added in API level 24", "FullName": "public AlphabeticIndex<V> addLabels (UnicodeSet additions)"}, "getBucketIndex(java.lang.CharSequence)": {"Returns": [["int", "the bucket index for the name"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: Name, such as a name"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the bucket number for the given name. This routine permits callers to implement their own bucket handling mechanisms, including client-server handling. For example, when a new name is created on the client, it can ask the server for the bucket for that name, and the sortkey (using getCollator). Once the client has that information, it can put the name into the right bucket, and sort it within that bucket, without having access to the index or collator. Note that the bucket number (and sort key) are only valid for the settings of the current AlphabeticIndex; if those are changed, then the bucket number and sort key must be regenerated.", "history": "Added in API level 24", "FullName": "public int getBucketIndex (CharSequence name)"}, "getInflowLabel()": {"Returns": [["@B_java#lang#String_E@", "inflow label"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the default label used for abbreviated buckets", "history": "Added in API level 24", "FullName": "public String getInflowLabel ()"}, "addLabels(java.util.Locale...)": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [["@B_java#util#Locale_E@", "Locale: additional characters to add to the index, such as those in Swedish."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add more index characters (aside from what are in the locale)", "history": "Added in API level 24", "FullName": "public AlphabeticIndex<V> addLabels (Locale... additions)"}, "getOverflowLabel()": {"Returns": [["@B_java#lang#String_E@", "overflow label"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the default label used in the IndexCharacters' locale for overflow, eg the first item in: ... A B C", "history": "Added in API level 24", "FullName": "public String getOverflowLabel ()"}, "setMaxLabelCount(int)": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [["int", "int: Set the maximum number of labels. Currently, if the number is exceeded, then every nth item is removed to bring the count down. A more sophisticated mechanism may be available in the future."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a limit on the number of labels in the index. The number of buckets can be slightly larger: see getBucketCount().", "history": "Added in API level 24", "FullName": "public AlphabeticIndex<V> setMaxLabelCount (int maxLabelCount)"}, "setUnderflowLabel(java.lang.String)": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [["@B_java#lang#String_E@", "String: see class description"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the underflowLabel label", "history": "Added in API level 24", "FullName": "public AlphabeticIndex<V> setUnderflowLabel (String underflowLabel)"}, "addRecord(java.lang.CharSequence, V)": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: Name, such as a name"], ["V", "V: Data, such as an address or link"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add a record (name and data) to the index. The name will be used to sort the items into buckets, and to sort within the bucket. Two records may have the same name. When they do, the sort order is according to the order added: the first added comes first.", "history": "added in API level 24", "FullName": "public AlphabeticIndex<V> addRecord (CharSequence name, V data)"}, "setOverflowLabel(java.lang.String)": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [["@B_java#lang#String_E@", "String: see class description"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the overflow label", "history": "Added in API level 24", "FullName": "public AlphabeticIndex<V> setOverflowLabel (String overflowLabel)"}, "getBucketLabels()": {"Returns": [["@B_java#util#List_E@", "The list of bucket labels, after processing."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the labels.", "history": "Added in API level 24", "FullName": "public List<String> getBucketLabels ()"}, "addLabels(android.icu.util.ULocale...)": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: additional characters to add to the index, such as those in Swedish."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add more index characters (aside from what are in the locale)", "history": "Added in API level 24", "FullName": "public AlphabeticIndex<V> addLabels (ULocale... additions)"}, "setInflowLabel(java.lang.String)": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [["@B_java#lang#String_E@", "String: see class description"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the inflowLabel label", "history": "Added in API level 24", "FullName": "public AlphabeticIndex<V> setInflowLabel (String inflowLabel)"}, "clearRecords()": {"Returns": [["@B_android#icu#text#AlphabeticIndex_E@", "this, for chaining"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clear the index.", "history": "Added in API level 24", "FullName": "public AlphabeticIndex<V> clearRecords ()"}, "AlphabeticIndex(android.icu.util.ULocale)": {"Returns": [], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: The locale for the index."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create the index object.", "history": "Added in API level 24", "FullName": "public AlphabeticIndex (ULocale locale)"}}, "Inheritance": [], "ClassName": "android.icu.text.AlphabeticIndex<V>", "ClassDesc": "AlphabeticIndex supports the creation of a UI index appropriate for a given language. It can support either direct use, or use with a client that doesn't support localized collation. The following is an example of what an index might look like in a UI: The class also supports having buckets for strings before the first (underflow), after the last (overflow), and between scripts (inflow). For example, if the index is constructed with labels for Russian and English, Greek characters would fall into an inflow bucket between the other two scripts. Note: If you expect to have a lot of ASCII or Latin characters as well as characters from the user's language, then it is a good idea to call addLabels(ULocale.English). The following shows an example of building an index directly. The \"show...\" methods below are just to illustrate usage. Callers can also use the @B_android#icu#text#AlphabeticIndex#ImmutableIndex_E@, or the AlphabeticIndex itself, to support sorting on a client that doesn't support AlphabeticIndex functionality. The ImmutableIndex is both immutable and thread-safe. The corresponding AlphabeticIndex methods are not thread-safe because they \"lazily\" build the index buckets. ImmutableIndex.getBucket(index) provides random access to all buckets and their labels and label types. AlphabeticIndex.getBucketLabels() or the bucket iterator on either class can be used to get a list of the labels, such as \"...\", \"A\", \"B\",..., and send that list to the client. When the client has a new name, it sends that name to the server. The server needs to call the following methods, and communicate the bucketIndex and collationKey back to the client. The client would put the name (and associated information) into its bucket for bucketIndex. The collationKey is a sequence of bytes that can be compared with a binary compare, and produce the right localized result."}