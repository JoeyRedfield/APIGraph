{"Functions": {"setRawResult(java.lang.Void)": {"Returns": [], "Parameters": [["@B_java#lang#Void_E@", "Void: the value"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Requires null completion value.", "history": "Added in API level 21", "FullName": "protected final void setRawResult (Void mustBeNull)"}, "compute()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The main computation performed by this task.", "history": "Added in API level 21", "FullName": "protected abstract void compute ()"}, "exec()": {"Returns": [["boolean", "true if this task is known to have completed normally"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implements execution conventions for RecursiveActions.", "history": "Added in API level 21", "FullName": "protected final boolean exec ()"}, "RecursiveAction()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 21", "FullName": "public RecursiveAction ()"}, "getRawResult()": {"Returns": [["@B_java#lang#Void_E@", "null always"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Always returns null.", "history": "Added in API level 21", "FullName": "public final Void getRawResult ()"}}, "Inheritance": ["@B_java#util#concurrent#ForkJoinTask_E@"], "ClassName": "java.util.concurrent.RecursiveAction", "ClassDesc": "A recursive resultless @B_java#util#concurrent#ForkJoinTask_E@. This class establishes conventions to parameterize resultless actions as Void ForkJoinTasks. Because null is the only valid value of type Void, methods such as join always return null upon completion. long[] array: anArray by creating new SortTask(anArray) and invoking it in a ForkJoinPool. As a more concrete simple example, the following task increments each element of an array: The following example illustrates some refinements and idioms that may lead to better performance: RecursiveActions need not be fully recursive, so long as they maintain the basic divide-and-conquer approach. Here is a class that sums the squares of each element of a double array, by subdividing out only the right-hand-sides of repeated divisions by two, and keeping track of them with a chain of next references. It uses a dynamic threshold based on method getSurplusQueuedTaskCount, but counterbalances potential excess partitioning by directly performing leaf actions on unstolen tasks rather than further subdividing."}