{"Functions": {"getBounds()": {"Returns": [["@B_java#lang#reflect#Type_E@", "an array of Types representing the upper bound(s) of this type variable"]], "Parameters": [], "Throws": [["@B_java#lang#TypeNotPresentException_E@", "if any of the bounds refers to a non-existent type declaration"], ["@B_java#lang#reflect#MalformedParameterizedTypeException_E@", "if any of the bounds refer to a parameterized type that cannot be instantiated for any reason"]], "SeeAlso": [], "Permissions": [], "Description": "Returns an array of Type objects representing the upper bound(s) of this type variable. Note that if no upper bound is explicitly declared, the upper bound is Object. For each upper bound B: if B is a parameterized type or a type variable, it is created, (see @B_java#lang#reflect#ParameterizedType_E@ for the details of the creation process for parameterized types). Otherwise, B is resolved.", "history": "Added in API level 1", "FullName": "public abstract Type[] getBounds ()"}, "getName()": {"Returns": [["@B_java#lang#String_E@", "the name of this type variable, as it appears in the source code"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the name of this type variable, as it occurs in the source code.", "history": "Added in API level 1", "FullName": "public abstract String getName ()"}, "getGenericDeclaration()": {"Returns": [["D", "the generic declaration declared for this type variable."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the GenericDeclaration object representing the generic declaration declared this type variable.", "history": "Added in API level 1", "FullName": "public abstract D getGenericDeclaration ()"}}, "Inheritance": [], "ClassName": "@B_java#lang#reflect#GenericDeclaration_E@", "ClassDesc": "TypeVariable is the common superinterface for type variables of kinds. A type variable is created the first time it is needed by a reflective method, as specified in this package. If a type variable t is referenced by a type (i.e, class, interface or annotation type) T, and T is declared by the nth enclosing class of T (see JLS 8.1.2), then the creation of t requires the resolution (see JVMS 5) of the ith enclosing class of T, for i = 0 to n, inclusive. Creating a type variable must not cause the creation of its bounds. Repeated creation of a type variable has no effect. Multiple objects may be instantiated at run-time to represent a given type variable. Even though a type variable is created only once, this does not imply any requirement to cache instances representing the type variable. However, all instances representing a type variable must be equal() to each other. As a consequence, users of type variables must not rely on the identity of instances of classes implementing this interface."}