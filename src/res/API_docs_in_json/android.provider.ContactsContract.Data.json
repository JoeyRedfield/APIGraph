{"Functions": {"getContactLookupUri(android.content.ContentResolver,android.net.Uri)": {"Returns": [["@B_android#net#Uri_E@", "no returns description in source"]], "Parameters": [["@B_android#content#ContentResolver_E@", "ContentResolver no parameter comment"], ["@B_android#net#Uri_E@", "Uri no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Build a @B_android#provider#ContactsContract#Contacts#CONTENT_LOOKUP_URI_E@ style @B_android#net#Uri_E@ for the parent @B_android#provider#ContactsContract#Contacts_E@ entry of the given @B_android#provider#ContactsContract#Data_E@ entry. Returns the Uri for the contact in the first entry returned by @B_android#content#ContentResolver#query_E@ for the provided dataUri. If the query returns null or empty results, silently returns null.", "history": "Added in API level 5", "FullName": "public static Uri getContactLookupUri (ContentResolver resolver, Uri dataUri)"}}, "Inheritance": [], "ClassName": "android.provider.ContactsContract.Data", "ClassDesc": "Constants for the data table, which contains data points tied to a raw contact. Each row of the data table is typically used to store a single piece of contact information (such as a phone number) and its associated metadata (such as whether it is a work or home number). Data is a generic table that can hold any kind of contact data. The kind of data stored in a given row is specified by the row's @B_android#provider#ContactsContract#DataColumns#MIMETYPE_E@ value, which determines the meaning of the generic columns @B_android#provider#ContactsContract#DataColumns#DATA1_E@ through @B_android#provider#ContactsContract#DataColumns#DATA15_E@. For example, if the data kind is @B_android#provider#ContactsContract#CommonDataKinds#Phone_E@, then the column @B_android#provider#ContactsContract#DataColumns#DATA1_E@ stores the phone number, but if the data kind is @B_android#provider#ContactsContract#CommonDataKinds#Email_E@, then @B_android#provider#ContactsContract#DataColumns#DATA1_E@ stores the email address. Sync adapters and applications can introduce their own data kinds. ContactsContract defines a small number of pre-defined data kinds, e.g. @B_android#provider#ContactsContract#CommonDataKinds#Phone_E@, @B_android#provider#ContactsContract#CommonDataKinds#Email_E@ etc. As a convenience, these classes define data kind specific aliases for DATA1 etc. For example, @B_android#provider#ContactsContract#CommonDataKinds#Phone_E@ is the same as @B_android#provider#ContactsContract#Data_E@. @B_android#provider#ContactsContract#DataColumns#DATA1_E@ is an indexed column and should be used for the data element that is expected to be most frequently used in query selections. For example, in the case of a row representing email addresses @B_android#provider#ContactsContract#DataColumns#DATA1_E@ should probably be used for the email address itself, while @B_android#provider#ContactsContract#DataColumns#DATA2_E@ etc can be used for auxiliary information like type of email address. By convention, @B_android#provider#ContactsContract#DataColumns#DATA15_E@ is used for storing BLOBs (binary data). The sync adapter for a given account type must correctly handle every data type used in the corresponding raw contacts. Otherwise it could result in lost or corrupted data. Similarly, you should refrain from introducing new kinds of data for an other party's account types. For example, if you add a data row for \"favorite song\" to a raw contact owned by a Google account, it will not get synced to the server, because the Google sync adapter does not know how to handle this data kind. Thus new data kinds are typically introduced along with new account types, i.e. new sync adapters. Data rows can be inserted/updated/deleted using the traditional @B_android#content#ContentResolver#insert_E@, @B_android#content#ContentResolver#update_E@ and @B_android#content#ContentResolver#delete_E@ methods, however the newer mechanism based on a batch of @B_android#content#ContentProviderOperation_E@ will prove to be a better choice in almost all cases. All operations in a batch are executed in a single transaction, which ensures that the phone-side and server-side state of a raw contact are always consistent. Also, the batch-based approach is far more efficient: not only are the database operations faster when executed in a single transaction, but also sending a batch of commands to the content provider saves a lot of time on context switching between your process and the process in which the content provider runs. The flip side of using batched operations is that a large batch may lock up the database for a long time preventing other applications from accessing data and potentially causing ANRs (\"Application Not Responding\" dialogs.) To avoid such lockups of the database, make sure to insert \"yield points\" in the batch. A yield point indicates to the content provider that before executing the next operation it can commit the changes that have already been made, yield to other requests, open another transaction and continue processing operations. A yield point will not automatically commit the transaction, but only if there is another request waiting on the database. Normally a sync adapter should insert a yield point at the beginning of each raw contact operation sequence in the batch. See @B_android#content#ContentProviderOperation#Builder#withYieldAllowed_E@. Many columns are available via a @B_android#provider#ContactsContract#Data#CONTENT_URI_E@ query. For best performance you should explicitly specify a projection to only those columns that you need. Some columns from the most recent associated status update are also available through an implicit join. Some columns from the associated raw contact are also available through an implicit join. The other columns are excluded as uninteresting in this context. The ID column for the associated aggregated contact table @B_android#provider#ContactsContract#Contacts_E@ is available via the implicit join to the @B_android#provider#ContactsContract#RawContacts_E@ table, see above. The remaining columns from this table are also available, through an implicit join. This facilitates lookup by the value of a single data element, such as the email address."}