{"Functions": {"requestDisallowInterceptTouchEvent(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the child does not want the parent to intercept touch events."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child does not want this parent and its ancestors to intercept touch events with @B_android#view#ViewGroup#onInterceptTouchEvent_E@. This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel.", "history": "Added in API level 1", "FullName": "public abstract void requestDisallowInterceptTouchEvent (boolean disallowIntercept)"}, "onNestedPrePerformAccessibilityAction(android.view.View,int,android.os.Bundle)": {"Returns": [["boolean", "true if the action was consumed by this ViewParent"]], "Parameters": [["@B_android#view#View_E@", "View: The target view dispatching this action"], ["int", "int: Action being performed; see @B_android#view#accessibility#AccessibilityNodeInfo_E@"], ["@B_android#os#Bundle_E@", "Bundle: Optional action arguments"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to an accessibility action delegated by a target descendant view before the target processes it. This method may be called by a target descendant view if the target wishes to give a view in its parent chain a chance to react to the event before normal processing occurs. Most commonly this will be a scroll event such as @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_SCROLL_FORWARD_E@. A ViewParent that supports acting as a nested scrolling parent should override this method and act accordingly to implement scrolling via accesibility systems.", "history": "Added in API level 22", "FullName": "public abstract boolean onNestedPrePerformAccessibilityAction (View target, int action, Bundle arguments)"}, "canResolveTextDirection()": {"Returns": [["boolean", "True if this view parent can resolve the text direction."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells if this view parent can resolve the text direction. See @B_android#view#View#setTextDirection_E@", "history": "Added in API level 19", "FullName": "public abstract boolean canResolveTextDirection ()"}, "focusSearch(android.view.View, int)": {"Returns": [["@B_android#view#View_E@", "no returns description in source"]], "Parameters": [["@B_android#view#View_E@", "View: The view that currently has focus"], ["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the nearest view in the specified direction that wants to take focus", "history": "added in API level 1", "FullName": "public abstract View focusSearch (View v, int direction)"}, "isLayoutRequested()": {"Returns": [["boolean", "true if layout was requested, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether layout was requested on this view parent.", "history": "Added in API level 1", "FullName": "public abstract boolean isLayoutRequested ()"}, "focusableViewAvailable(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view that has become newly focusable"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells the parent that a new focusable view has become available. This is to handle transitions from the case where there are no focusable views to the case where the first focusable view appears.", "history": "Added in API level 1", "FullName": "public abstract void focusableViewAvailable (View v)"}, "focusSearch(android.view.View,int)": {"Returns": [["@B_android#view#View_E@", "no returns description in source"]], "Parameters": [["@B_android#view#View_E@", "View: The view that currently has focus"], ["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the nearest view in the specified direction that wants to take focus", "history": "Added in API level 1", "FullName": "public abstract View focusSearch (View v, int direction)"}, "requestTransparentRegion(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the view requesting the transparent region computation"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child wants the view hierarchy to gather and report transparent regions to the window compositor. Views that \"punch\" holes in the view hierarchy, such as SurfaceView can use this API to improve performance of the system. When no such a view is present in the hierarchy, this optimization in unnecessary and might slightly reduce the view hierarchy performance.", "history": "Added in API level 1", "FullName": "public abstract void requestTransparentRegion (View child)"}, "recomputeViewAttributes(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View whose attributes have changed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tell view hierarchy that the global view attributes need to be re-evaluated.", "history": "Added in API level 1", "FullName": "public abstract void recomputeViewAttributes (View child)"}, "onNestedScrollAccepted(android.view.View,android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: Direct child of this ViewParent containing target"], ["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["int", "int: Flags consisting of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@, @B_android#view#View#SCROLL_AXIS_VERTICAL_E@ or both"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewParent#onStartNestedScroll_E@", "@B_android#view#ViewParent#onStopNestedScroll_E@"], "Permissions": [], "Description": "React to the successful claiming of a nested scroll operation. This method will be called after @B_android#view#ViewParent#onStartNestedScroll_E@ returns true. It offers an opportunity for the view and its superclasses to perform initial configuration for the nested scroll. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "Added in API level 21", "FullName": "public abstract void onNestedScrollAccepted (View child, View target, int nestedScrollAxes)"}, "startActionModeForChild(android.view.View,android.view.ActionMode.Callback)": {"Returns": [["@B_android#view#ActionMode_E@", "The new action mode if it was started, null otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: The source view where the action mode was first invoked"], ["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: The callback that will handle lifecycle events for the action mode"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewParent#startActionModeForChild_E@"], "Permissions": [], "Description": "Start an action mode for the specified view with the default type @B_android#view#ActionMode#TYPE_PRIMARY_E@. In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, @B_android#view#ViewManager#addView_E@) then it should override this and start the action mode.", "history": "Added in API level 11", "FullName": "public abstract ActionMode startActionModeForChild (View originalView, ActionMode.Callback callback)"}, "showContextMenuForChild(android.view.View)": {"Returns": [["boolean", "true if the context menu was shown, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: the source view where the context menu was first invoked"]], "Throws": [], "SeeAlso": ["@B_android#view#ViewParent#showContextMenuForChild_E@"], "Permissions": [], "Description": "Shows the context menu for the specified view or its ancestors. In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, @B_android#view#ViewManager#addView_E@) then it should override this and show the context menu.", "history": "Added in API level 1", "FullName": "public abstract boolean showContextMenuForChild (View originalView)"}, "onNestedFling(android.view.View,float,float,boolean)": {"Returns": [["boolean", "true if this parent consumed or otherwise reacted to the fling"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"], ["boolean", "boolean: true if the child consumed the fling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request a fling from a nested scroll. This method signifies that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling.", "history": "Added in API level 21", "FullName": "public abstract boolean onNestedFling (View target, float velocityX, float velocityY, boolean consumed)"}, "createContextMenu(android.view.ContextMenu)": {"Returns": [], "Parameters": [["@B_android#view#ContextMenu_E@", "ContextMenu: The menu to populate"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Have the parent populate the specified context menu if it has anything to add (and then recurse on its parent).", "history": "Added in API level 1", "FullName": "public abstract void createContextMenu (ContextMenu menu)"}, "childHasTransientStateChanged(android.view.View,boolean)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: Child view whose state has changed"], ["boolean", "boolean: true if this child has transient state"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child view now has or no longer is tracking transient state. \"Transient state\" is any state that a View might hold that is not expected to be reflected in the data model that the View currently presents. This state only affects the presentation to the user within the View itself, such as the current state of animations in progress or the state of a text selection operation. Transient state is useful for hinting to other components of the View system that a particular view is tracking something complex but encapsulated. A ListView for example may acknowledge that list item Views with transient state should be preserved within their position or stable item ID instead of treating that view as trivially replaceable by the backing adapter. This allows adapter implementations to be simpler instead of needing to track the state of item view animations in progress such that they could be restored in the event of an unexpected recycling and rebinding of attached item views. This method is called on a parent view when a child view or a view within its subtree begins or ends tracking of internal transient state.", "history": "Added in API level 19", "FullName": "public abstract void childHasTransientStateChanged (View child, boolean hasTransientState)"}, "showContextMenuForChild(android.view.View,float,float)": {"Returns": [["boolean", "true if the context menu was shown, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: the source view where the context menu was first invoked"], ["float", "float: the X coordinate in pixels relative to the original view to which the menu should be anchored, or @B_java#lang#Float#NaN_E@ to disable anchoring"], ["float", "float: the Y coordinate in pixels relative to the original view to which the menu should be anchored, or @B_java#lang#Float#NaN_E@ to disable anchoring"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Shows the context menu for the specified view or its ancestors anchored to the specified view-relative coordinate. In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, @B_android#view#ViewManager#addView_E@) then it should override this and show the context menu. If a subclass overrides this method it should also override @B_android#view#ViewParent#showContextMenuForChild_E@.", "history": "Added in API level 24", "FullName": "public abstract boolean showContextMenuForChild (View originalView, float x, float y)"}, "notifySubtreeAccessibilityStateChanged(android.view.View,android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The direct child whose subtree has changed."], ["@B_android#view#View_E@", "View: The descendant view that changed. May not be null. This value must never be null."], ["int", "int: A bit mask of the types of changes that occurred. One or more of: AccessibilityEvent#CONTENT_CHANGE_TYPE_CONTENT_DESCRIPTION AccessibilityEvent#CONTENT_CHANGE_TYPE_SUBTREE AccessibilityEvent#CONTENT_CHANGE_TYPE_TEXT AccessibilityEvent#CONTENT_CHANGE_TYPE_UNDEFINED"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Notifies a view parent that the accessibility state of one of its descendants has changed and that the structure of the subtree is different.", "history": "Added in API level 19", "FullName": "public abstract void notifySubtreeAccessibilityStateChanged (View child, View source, int changeType)"}, "canResolveLayoutDirection()": {"Returns": [["boolean", "True if this view parent can resolve the layout direction."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells if this view parent can resolve the layout direction. See @B_android#view#View#setLayoutDirection_E@", "history": "Added in API level 19", "FullName": "public abstract boolean canResolveLayoutDirection ()"}, "invalidateChild(android.view.View,android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child which is dirty"], ["@B_android#graphics#Rect_E@", "Rect: The area within the child that is invalid"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#view#ViewParent#onDescendantInvalidated_E@ instead. All or part of a child is dirty and needs to be redrawn.", "history": "Added in API level 1 Deprecated in API level 26", "FullName": "public abstract void invalidateChild (View child, Rect r)"}, "keyboardNavigationClusterSearch(android.view.View,int)": {"Returns": [["@B_android#view#View_E@", "The nearest keyboard navigation cluster in the specified direction, or null if none can be found"]], "Parameters": [["@B_android#view#View_E@", "View: The starting point of the search. Null means the current cluster is not found yet"], ["int", "int: Direction to look"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the nearest keyboard navigation cluster in the specified direction. This does not actually give focus to that cluster.", "history": "Added in API level 26", "FullName": "public abstract View keyboardNavigationClusterSearch (View currentCluster, int direction)"}, "getParentForAccessibility()": {"Returns": [["@B_android#view#ViewParent_E@", "The parent or null if no such is found."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the parent of a given View for accessibility. Since some Views are not exposed to the accessibility layer the parent for accessibility is not necessarily the direct parent of the View, rather it is a predecessor.", "history": "Added in API level 16", "FullName": "public abstract ViewParent getParentForAccessibility ()"}, "onNestedPreScroll(android.view.View,int,int,int[])": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["int", "int: Horizontal scroll distance in pixels"], ["int", "int: Vertical scroll distance in pixels"], ["int[]", "int: Output. The horizontal and vertical scroll distance consumed by this parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll in progress before the target view consumes a portion of the scroll. When working with nested scrolling often the parent view may want an opportunity to consume the scroll before the nested scrolling child does. An example of this is a drawer that contains a scrollable list. The user will want to be able to scroll the list fully into view before the list itself begins scrolling. onNestedPreScroll is called when a nested scrolling child invokes @B_android#view#View#dispatchNestedPreScroll_E@. The implementation should report how any pixels of the scroll reported by dx, dy were consumed in the consumed array. Index 0 corresponds to dx and index 1 corresponds to dy. This parameter will never be null. Initial values for consumed[0] and consumed[1] will always be 0.", "history": "Added in API level 21", "FullName": "public abstract void onNestedPreScroll (View target, int dx, int dy, int[] consumed)"}, "onNestedPreFling(android.view.View, float, float)": {"Returns": [["boolean", "true if this parent consumed the fling ahead of the target view"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested fling before the target view consumes it. This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling parent is consuming motion as part of a @B_android#view#ViewParent#onNestedPreScroll_E@, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well.", "history": "added in API level 21", "FullName": "public abstract boolean onNestedPreFling (View target, float velocityX, float velocityY)"}, "clearChildFocus(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view that is giving up focus"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child of this parent is giving up focus", "history": "Added in API level 1", "FullName": "public abstract void clearChildFocus (View child)"}, "isTextDirectionResolved()": {"Returns": [["boolean", "True if this view parent text direction is resolved."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells if this view parent text direction is resolved. See @B_android#view#View#setTextDirection_E@", "history": "Added in API level 19", "FullName": "public abstract boolean isTextDirectionResolved ()"}, "isLayoutDirectionResolved()": {"Returns": [["boolean", "True if this view parent layout direction is resolved."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells if this view parent layout direction is resolved. See @B_android#view#View#setLayoutDirection_E@", "history": "Added in API level 19", "FullName": "public abstract boolean isLayoutDirectionResolved ()"}, "invalidateChildInParent(int[],android.graphics.Rect)": {"Returns": [["@B_android#view#ViewParent_E@", "the parent of this ViewParent or null"]], "Parameters": [["int[]", "int: An array of 2 ints containing the left and top coordinates of the child to invalidate"], ["@B_android#graphics#Rect_E@", "Rect: The area within the child that is invalid"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#view#ViewParent#onDescendantInvalidated_E@ instead. All or part of a child is dirty and needs to be redrawn. The location array is an array of two int values which respectively define the left and the top position of the dirty child. This method must return the parent of this ViewParent if the specified rectangle must be invalidated in the parent. If the specified rectangle does not require invalidation in the parent or if the parent does not exist, this method must return null. When this method returns a non-null value, the location array must have been updated with the left and top coordinates of this ViewParent.", "history": "Added in API level 1 Deprecated in API level 26", "FullName": "public abstract ViewParent invalidateChildInParent (int[] location, Rect r)"}, "canResolveTextAlignment()": {"Returns": [["boolean", "True if this view parent can resolve the text alignment."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells if this view parent can resolve the text alignment. See @B_android#view#View#setTextAlignment_E@", "history": "Added in API level 19", "FullName": "public abstract boolean canResolveTextAlignment ()"}, "requestLayout()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when something has changed which has invalidated the layout of a child of this view parent. This will schedule a layout pass of the view tree.", "history": "Added in API level 1", "FullName": "public abstract void requestLayout ()"}, "bringChildToFront(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child to bring to the top of the z order"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change the z order of the child so it's on top of all other children. This ordering change may affect layout, if this container uses an order-dependent layout scheme (e.g., LinearLayout). Prior to @B_android#os#Build#VERSION_CODES#KITKAT_E@ this method should be followed by calls to @B_android#view#ViewParent#requestLayout_E@ and @B_android#view#View#invalidate_E@ on this parent to force the parent to redraw with the new child ordering.", "history": "Added in API level 1", "FullName": "public abstract void bringChildToFront (View child)"}, "getParent()": {"Returns": [["@B_android#view#ViewParent_E@", "a ViewParent or null if this ViewParent does not have a parent"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the parent if it exists, or null.", "history": "Added in API level 1", "FullName": "public abstract ViewParent getParent ()"}, "requestChildRectangleOnScreen(android.view.View,android.graphics.Rect,boolean)": {"Returns": [["boolean", "Whether the group scrolled to handle the operation"]], "Parameters": [["@B_android#view#View_E@", "View: The direct child making the request."], ["@B_android#graphics#Rect_E@", "Rect: The rectangle in the child's coordinates the child wishes to be on the screen."], ["boolean", "boolean: True to forbid animated or delayed scrolling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child of this group wants a particular rectangle to be positioned onto the screen. @B_android#view#ViewGroup_E@s overriding this can trust that: child will be a direct child of this group rectangle will be in the child's content coordinates @B_android#view#ViewGroup_E@s overriding this should uphold the contract: nothing will change if the rectangle is already visible the view port will be scrolled only just enough to make the rectangle visible", "history": "Added in API level 3", "FullName": "public abstract boolean requestChildRectangleOnScreen (View child, Rect rectangle, boolean immediate)"}, "onStopNestedScroll(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll operation ending. Perform cleanup after a nested scrolling operation. This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a @B_android#view#MotionEvent#ACTION_UP_E@ or @B_android#view#MotionEvent#ACTION_CANCEL_E@ event. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "Added in API level 21", "FullName": "public abstract void onStopNestedScroll (View target)"}, "onStartNestedScroll(android.view.View,android.view.View,int)": {"Returns": [["boolean", "true if this ViewParent accepts the nested scroll operation"]], "Parameters": [["@B_android#view#View_E@", "View: Direct child of this ViewParent containing target"], ["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["int", "int: Flags consisting of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@, @B_android#view#View#SCROLL_AXIS_VERTICAL_E@ or both"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a descendant view initiating a nestable scroll operation, claiming the nested scroll operation if appropriate. This method will be called in response to a descendant view invoking @B_android#view#View#startNestedScroll_E@. Each parent up the view hierarchy will be given an opportunity to respond and claim the nested scrolling operation by returning true. This method may be overridden by ViewParent implementations to indicate when the view is willing to support a nested scrolling operation that is about to begin. If it returns true, this ViewParent will become the target view's nested scrolling parent for the duration of the scroll operation in progress. When the nested scroll is finished this ViewParent will receive a call to @B_android#view#ViewParent#onStopNestedScroll_E@.", "history": "Added in API level 21", "FullName": "public abstract boolean onStartNestedScroll (View child, View target, int nestedScrollAxes)"}, "getTextAlignment()": {"Returns": [["int", "the resolved text alignment. Returns one of: @B_android#view#View#TEXT_ALIGNMENT_GRAVITY_E@, @B_android#view#View#TEXT_ALIGNMENT_CENTER_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_START_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_END_E@, @B_android#view#View#TEXT_ALIGNMENT_VIEW_START_E@, @B_android#view#View#TEXT_ALIGNMENT_VIEW_END_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return this view parent text alignment. See @B_android#view#View#getTextAlignment_E@", "history": "Added in API level 19", "FullName": "public abstract int getTextAlignment ()"}, "onNestedPreFling(android.view.View,float,float)": {"Returns": [["boolean", "true if this parent consumed the fling ahead of the target view"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested fling before the target view consumes it. This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling parent is consuming motion as part of a @B_android#view#ViewParent#onNestedPreScroll_E@, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well.", "history": "Added in API level 21", "FullName": "public abstract boolean onNestedPreFling (View target, float velocityX, float velocityY)"}, "requestSendAccessibilityEvent(android.view.View,android.view.accessibility.AccessibilityEvent)": {"Returns": [["boolean", "True if the event was sent."]], "Parameters": [["@B_android#view#View_E@", "View: The child which requests sending the event."], ["@B_android#view#accessibility#AccessibilityEvent_E@", "AccessibilityEvent: The event to be sent."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by a child to request from its parent to send an @B_android#view#accessibility#AccessibilityEvent_E@. The child has already populated a record for itself in the event and is delegating to its parent to send the event. The parent can optionally add a record for itself. Note: An accessibility event is fired by an individual view which populates the event with a record for its state and requests from its parent to perform the sending. The parent can optionally add a record for itself before dispatching the request to its parent. A parent can also choose not to respect the request for sending the event. The accessibility event is sent by the topmost view in the view tree.", "history": "Added in API level 14", "FullName": "public abstract boolean requestSendAccessibilityEvent (View child, AccessibilityEvent event)"}, "getTextDirection()": {"Returns": [["int", "the resolved text direction. Returns one of: @B_android#view#View#TEXT_DIRECTION_FIRST_STRONG_E@ @B_android#view#View#TEXT_DIRECTION_ANY_RTL_E@, @B_android#view#View#TEXT_DIRECTION_LTR_E@, @B_android#view#View#TEXT_DIRECTION_RTL_E@, @B_android#view#View#TEXT_DIRECTION_LOCALE_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return this view parent text direction. See @B_android#view#View#getTextDirection_E@", "history": "Added in API level 19", "FullName": "public abstract int getTextDirection ()"}, "startActionModeForChild(android.view.View,android.view.ActionMode.Callback,int)": {"Returns": [["@B_android#view#ActionMode_E@", "The new action mode if it was started, null otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: The source view where the action mode was first invoked"], ["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: The callback that will handle lifecycle events for the action mode"], ["int", "int: One of @B_android#view#ActionMode#TYPE_PRIMARY_E@ or @B_android#view#ActionMode#TYPE_FLOATING_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Start an action mode of a specific type for the specified view. In most cases, a subclass does not need to override this. However, if the subclass is added directly to the window manager (for example, @B_android#view#ViewManager#addView_E@) then it should override this and start the action mode.", "history": "Added in API level 23", "FullName": "public abstract ActionMode startActionModeForChild (View originalView, ActionMode.Callback callback, int type)"}, "getLayoutDirection()": {"Returns": [["int", "@B_android#view#View#LAYOUT_DIRECTION_RTL_E@ if the layout direction is RTL or returns @B_android#view#View#LAYOUT_DIRECTION_LTR_E@ if the layout direction is not RTL."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return this view parent layout direction. See @B_android#view#View#getLayoutDirection_E@", "history": "Added in API level 19", "FullName": "public abstract int getLayoutDirection ()"}, "requestChildFocus(android.view.View,android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child of this ViewParent that wants focus. This view will contain the focused view. It is not necessarily the view that actually has focus."], ["@B_android#view#View_E@", "View: The view that is a descendant of child that actually has focus"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child of this parent wants focus", "history": "Added in API level 1", "FullName": "public abstract void requestChildFocus (View child, View focused)"}, "childDrawableStateChanged(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child whose drawable state has changed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is called on the parent when a child's drawable state has changed.", "history": "Added in API level 1", "FullName": "public abstract void childDrawableStateChanged (View child)"}, "onNestedScroll(android.view.View,int,int,int,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The descendent view controlling the nested scroll"], ["int", "int: Horizontal scroll distance in pixels already consumed by target"], ["int", "int: Vertical scroll distance in pixels already consumed by target"], ["int", "int: Horizontal scroll distance in pixels not consumed by target"], ["int", "int: Vertical scroll distance in pixels not consumed by target"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll in progress. This method will be called when the ViewParent's current nested scrolling child view dispatches a nested scroll event. To receive calls to this method the ViewParent must have previously returned true for a call to @B_android#view#ViewParent#onStartNestedScroll_E@. Both the consumed and unconsumed portions of the scroll distance are reported to the ViewParent. An implementation may choose to use the consumed portion to match or chase scroll position of multiple child elements, for example. The unconsumed portion may be used to allow continuous dragging of multiple scrolling or draggable elements, such as scrolling a list within a vertical drawer where the drawer begins dragging once the edge of inner scrolling content is reached.", "history": "Added in API level 21", "FullName": "public abstract void onNestedScroll (View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed)"}, "isTextAlignmentResolved()": {"Returns": [["boolean", "True if this view parent text alignment is resolved."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells if this view parent text alignment is resolved. See @B_android#view#View#setTextAlignment_E@", "history": "Added in API level 19", "FullName": "public abstract boolean isTextAlignmentResolved ()"}, "requestFitSystemWindows()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask that a new dispatch of @B_android#view#View#fitSystemWindows_E@ be performed.", "history": "Added in API level 16", "FullName": "public abstract void requestFitSystemWindows ()"}, "onDescendantInvalidated(android.view.View,android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: Direct child of this ViewParent containing target This value must never be null."], ["@B_android#view#View_E@", "View: The view that needs to redraw This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The target View has been invalidated, or has had a drawing property changed that requires the hierarchy to re-render. This method is called by the View hierarchy to signal ancestors that a View either needs to re-record its drawing commands, or drawing properties have changed. This is how Views schedule a drawing traversal. This signal is generally only dispatched for attached Views, since only they need to draw.", "history": "Added in API level 26", "FullName": "public void onDescendantInvalidated (View child, View target)"}, "getChildVisibleRect(android.view.View,android.graphics.Rect,android.graphics.Point)": {"Returns": [["boolean", "true if the resulting rectangle is not empty, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: A child View, whose rectangular visible region we want to compute"], ["@B_android#graphics#Rect_E@", "Rect: The input rectangle, defined in the child coordinate system. Will be overwritten to contain the resulting visible rectangle, expressed in global (root) coordinates"], ["@B_android#graphics#Point_E@", "Point: The input coordinates of a point, defined in the child coordinate system. As with the r parameter, this will be overwritten to contain the global (root) coordinates of that point. A null value is valid (in case you are not interested in this result)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compute the visible part of a rectangular region defined in terms of a child view's coordinates. Returns the clipped visible part of the rectangle r, defined in the child's local coordinate system. r is modified by this method to contain the result, expressed in the global (root) coordinate system. The resulting rectangle is always axis aligned. If a rotation is applied to a node in the View hierarchy, the result is the axis-aligned bounding box of the visible rectangle.", "history": "Added in API level 1", "FullName": "public abstract boolean getChildVisibleRect (View child, Rect r, Point offset)"}}, "Inheritance": [], "ClassName": "android.view.ViewParent", "ClassDesc": "Defines the responsibilities for a class that will be a parent of a View. This is the API that a view sees when it wants to interact with its parent."}