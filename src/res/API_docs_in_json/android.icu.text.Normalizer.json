{"Functions": {"compare(char[], int, int, char[], int, int, int)": {"Returns": [["int", "<0 or 0 or >0 as usual for string comparisons"]], "Parameters": [["char[]", "char: First source character array."], ["int", "int: start index of source"], ["int", "int: limit of the source"], ["char[]", "char: Second source character array."], ["int", "int: start index of the source"], ["int", "int: limit of the source"], ["int", "int: A bit set of options: - FOLD_CASE_DEFAULT or 0 is used for default options: Case-sensitive comparison in code unit order, and the input strings are quick-checked for FCD. - INPUT_IS_FCD Set if the caller knows that both s1 and s2 fulfill the FCD conditions.If not set, the function will quickCheck for FCD and normalize if necessary. - COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order - COMPARE_IGNORE_CASE Set to compare strings case-insensitively using case folding, instead of case-sensitively. If set, then the following case folding options are used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compare two strings for canonical equivalence. Further options include case-insensitive comparison and code point order (as opposed to code unit order). Canonical equivalence between two strings is defined as their normalized forms (NFD or NFC) being identical. This function compares strings incrementally instead of normalizing (and optionally case-folding) both strings entirely, improving performance significantly. Bulk normalization is only necessary if the strings do not fulfill the FCD conditions. Only in this case, and only if the strings are relatively long, is memory allocated temporarily. For FCD strings and short non-FCD strings there is no memory allocation. Semantically, this is equivalent to strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2))) where code point order and foldCase are all optional.", "history": "added in API level 24", "FullName": "public static int compare (char[] s1, int s1Start, int s1Limit, char[] s2, int s2Start, int s2Limit, int options)"}, "compare(int,java.lang.String,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["int", "int: the first code point to be checked against"], ["@B_java#lang#String_E@", "String: the second string"], ["int", "int: A bit set of options"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method that can have faster implementation by not allocating buffers.", "history": "Added in API level 24", "FullName": "public static int compare (int char32a, String str2, int options)"}, "compare(java.lang.String,java.lang.String,int)": {"Returns": [["int", "<0 or 0 or >0 as usual for string comparisons"]], "Parameters": [["@B_java#lang#String_E@", "String: First source string."], ["@B_java#lang#String_E@", "String: Second source string."], ["int", "int: A bit set of options: - FOLD_CASE_DEFAULT or 0 is used for default options: Case-sensitive comparison in code unit order, and the input strings are quick-checked for FCD. - INPUT_IS_FCD Set if the caller knows that both s1 and s2 fulfill the FCD conditions. If not set, the function will quickCheck for FCD and normalize if necessary. - COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order - COMPARE_IGNORE_CASE Set to compare strings case-insensitively using case folding, instead of case-sensitively. If set, then the following case folding options are used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compare two strings for canonical equivalence. Further options include case-insensitive comparison and code point order (as opposed to code unit order). Canonical equivalence between two strings is defined as their normalized forms (NFD or NFC) being identical. This function compares strings incrementally instead of normalizing (and optionally case-folding) both strings entirely, improving performance significantly. Bulk normalization is only necessary if the strings do not fulfill the FCD conditions. Only in this case, and only if the strings are relatively long, is memory allocated temporarily. For FCD strings and short non-FCD strings there is no memory allocation. Semantically, this is equivalent to strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2))) where code point order and foldCase are all optional.", "history": "Added in API level 24", "FullName": "public static int compare (String s1, String s2, int options)"}, "compare(java.lang.String, java.lang.String, int)": {"Returns": [["int", "<0 or 0 or >0 as usual for string comparisons"]], "Parameters": [["@B_java#lang#String_E@", "String: First source string."], ["@B_java#lang#String_E@", "String: Second source string."], ["int", "int: A bit set of options: - FOLD_CASE_DEFAULT or 0 is used for default options: Case-sensitive comparison in code unit order, and the input strings are quick-checked for FCD. - INPUT_IS_FCD Set if the caller knows that both s1 and s2 fulfill the FCD conditions. If not set, the function will quickCheck for FCD and normalize if necessary. - COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order - COMPARE_IGNORE_CASE Set to compare strings case-insensitively using case folding, instead of case-sensitively. If set, then the following case folding options are used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compare two strings for canonical equivalence. Further options include case-insensitive comparison and code point order (as opposed to code unit order). Canonical equivalence between two strings is defined as their normalized forms (NFD or NFC) being identical. This function compares strings incrementally instead of normalizing (and optionally case-folding) both strings entirely, improving performance significantly. Bulk normalization is only necessary if the strings do not fulfill the FCD conditions. Only in this case, and only if the strings are relatively long, is memory allocated temporarily. For FCD strings and short non-FCD strings there is no memory allocation. Semantically, this is equivalent to strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2))) where code point order and foldCase are all optional.", "history": "added in API level 24", "FullName": "public static int compare (String s1, String s2, int options)"}, "compare(int, int, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["int", "int: the first code point to be checked against the"], ["int", "int: the second code point"], ["int", "int: A bit set of options"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method that can have faster implementation by not allocating buffers.", "history": "added in API level 24", "FullName": "public static int compare (int char32a, int char32b, int options)"}, "compare(int, java.lang.String, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["int", "int: the first code point to be checked against"], ["@B_java#lang#String_E@", "String: the second string"], ["int", "int: A bit set of options"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method that can have faster implementation by not allocating buffers.", "history": "added in API level 24", "FullName": "public static int compare (int char32a, String str2, int options)"}, "compare(char[],char[],int)": {"Returns": [["int", "<0 or 0 or >0 as usual for string comparisons"]], "Parameters": [["char[]", "char: First source string."], ["char[]", "char: Second source string."], ["int", "int: A bit set of options: - FOLD_CASE_DEFAULT or 0 is used for default options: Case-sensitive comparison in code unit order, and the input strings are quick-checked for FCD. - INPUT_IS_FCD Set if the caller knows that both s1 and s2 fulfill the FCD conditions. If not set, the function will quickCheck for FCD and normalize if necessary. - COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order - COMPARE_IGNORE_CASE Set to compare strings case-insensitively using case folding, instead of case-sensitively. If set, then the following case folding options are used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compare two strings for canonical equivalence. Further options include case-insensitive comparison and code point order (as opposed to code unit order). Convenience method.", "history": "Added in API level 24", "FullName": "public static int compare (char[] s1, char[] s2, int options)"}, "compare(int,int,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["int", "int: the first code point to be checked against the"], ["int", "int: the second code point"], ["int", "int: A bit set of options"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method that can have faster implementation by not allocating buffers.", "history": "Added in API level 24", "FullName": "public static int compare (int char32a, int char32b, int options)"}, "compare(char[], char[], int)": {"Returns": [["int", "<0 or 0 or >0 as usual for string comparisons"]], "Parameters": [["char[]", "char: First source string."], ["char[]", "char: Second source string."], ["int", "int: A bit set of options: - FOLD_CASE_DEFAULT or 0 is used for default options: Case-sensitive comparison in code unit order, and the input strings are quick-checked for FCD. - INPUT_IS_FCD Set if the caller knows that both s1 and s2 fulfill the FCD conditions. If not set, the function will quickCheck for FCD and normalize if necessary. - COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order - COMPARE_IGNORE_CASE Set to compare strings case-insensitively using case folding, instead of case-sensitively. If set, then the following case folding options are used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compare two strings for canonical equivalence. Further options include case-insensitive comparison and code point order (as opposed to code unit order). Convenience method.", "history": "added in API level 24", "FullName": "public static int compare (char[] s1, char[] s2, int options)"}, "compare(char[],int,int,char[],int,int,int)": {"Returns": [["int", "<0 or 0 or >0 as usual for string comparisons"]], "Parameters": [["char[]", "char: First source character array."], ["int", "int: start index of source"], ["int", "int: limit of the source"], ["char[]", "char: Second source character array."], ["int", "int: start index of the source"], ["int", "int: limit of the source"], ["int", "int: A bit set of options: - FOLD_CASE_DEFAULT or 0 is used for default options: Case-sensitive comparison in code unit order, and the input strings are quick-checked for FCD. - INPUT_IS_FCD Set if the caller knows that both s1 and s2 fulfill the FCD conditions.If not set, the function will quickCheck for FCD and normalize if necessary. - COMPARE_CODE_POINT_ORDER Set to choose code point order instead of code unit order - COMPARE_IGNORE_CASE Set to compare strings case-insensitively using case folding, instead of case-sensitively. If set, then the following case folding options are used."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compare two strings for canonical equivalence. Further options include case-insensitive comparison and code point order (as opposed to code unit order). Canonical equivalence between two strings is defined as their normalized forms (NFD or NFC) being identical. This function compares strings incrementally instead of normalizing (and optionally case-folding) both strings entirely, improving performance significantly. Bulk normalization is only necessary if the strings do not fulfill the FCD conditions. Only in this case, and only if the strings are relatively long, is memory allocated temporarily. For FCD strings and short non-FCD strings there is no memory allocation. Semantically, this is equivalent to strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2))) where code point order and foldCase are all optional.", "history": "Added in API level 24", "FullName": "public static int compare (char[] s1, int s1Start, int s1Limit, char[] s2, int s2Start, int s2Limit, int options)"}}, "Inheritance": [], "ClassName": "android.icu.text.Normalizer", "ClassDesc": "Old Unicode normalization API. This API has been replaced by the @B_android#icu#text#Normalizer2_E@ class and is only available for backward compatibility. This class simply delegates to the Normalizer2 class. There are two exceptions: The new API does not provide a replacement for QuickCheckResult and compare(). normalize transforms Unicode text into an equivalent composed or decomposed form, allowing for easier sorting and searching of text. normalize supports the standard normalization forms described in Characters with accents or other adornments can be encoded in several different ways in Unicode. For example, take the character A-acute. In Unicode, this can be encoded as a single character (the \"composed\" form): To a user of your program, however, both of these sequences should be treated as the same \"user-level\" character \"A with acute accent\". When you are searching or comparing text, you must ensure that these two sequences are treated equivalently. In addition, you must handle characters with more than one accent. Sometimes the order of a character's combining accents is significant, while in other cases accent sequences in different orders are really equivalent. Similarly, the string \"ffi\" can be encoded as three separate letters: The ffi ligature is not a distinct semantic character, and strictly speaking it shouldn't be in Unicode at all, but it was included for compatibility with existing character sets that already provided it. The Unicode standard identifies such characters by giving them \"compatibility\" decompositions into the corresponding semantic characters. When sorting and searching, you will often want to use these mappings. normalize helps solve these problems by transforming text into the canonical composed and decomposed forms as shown in the first example above. In addition, you can have it perform compatibility decompositions so that you can treat compatibility characters the same as their equivalents. Finally, normalize rearranges accents into the proper canonical order, so that you do not have to worry about accent rearrangement on your own. Form FCD, \"Fast C or D\", is also designed for collation. It allows to work on strings that are not necessarily normalized with an algorithm (like in collation) that works under \"canonical closure\", i.e., it treats precomposed characters and their decomposed equivalents the same. It is not a normalization form because it does not provide for uniqueness of representation. Multiple strings may be canonically equivalent (their NFDs are identical) and may all conform to FCD without being identical themselves. The form is defined such that the \"raw decomposition\", the recursive canonical decomposition of each character, results in a string that is canonically ordered. This means that precomposed characters are allowed for as long as their decompositions do not need canonical reordering. Its advantage for a process like collation is that all NFD and most NFC texts - and many unnormalized texts - already conform to FCD and do not need to be normalized (NFD) for such a process. The FCD quick check will return YES for most strings in practice. normalize(FCD) may be implemented with NFD. For more details on FCD see Unicode Technical Note #5 (Canonical Equivalence in Applications): http://www.unicode.org/notes/tn5/#FCD ICU collation performs either NFD or FCD normalization automatically if normalization is turned on for the collator object. Beyond collation and string search, normalized strings may be useful for string equivalence comparisons, transliteration/transcription, unique representations, etc. The W3C generally recommends to exchange texts in NFC. Note also that most legacy character encodings use only precomposed forms and often do not encode any combining marks by themselves. For conversion to such character encodings the Unicode text needs to be normalized to NFC. For more usage examples, see the Unicode Standard Annex. Note: The Normalizer class also provides API for iterative normalization. While the setIndex() and getIndex() refer to indices in the underlying Unicode input text, the next() and previous() methods iterate through characters in the normalized output. This means that there is not necessarily a one-to-one correspondence between characters returned by next() and previous() and the indices passed to and returned from setIndex() and getIndex(). It is for this reason that Normalizer does not implement the CharacterIterator interface."}