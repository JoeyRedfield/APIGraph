{"Functions": {"getChildItemId(android.view.View)": {"Returns": [["long", "Item id corresponding to the given view or @B_android#support#v7#widget#RecyclerView#NO_ID_E@"]], "Parameters": [["@B_android#view#View_E@", "View: Child View to query"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the stable item id that the given child view corresponds to.", "history": "added in version 22.0.0", "FullName": "long getChildItemId (View child)"}, "scrollBy(int, int)": {"Returns": [], "Parameters": [["int", "int: the amount of pixels to scroll by horizontally"], ["int", "int: the amount of pixels to scroll by vertically"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Move the scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated.", "history": "", "FullName": "void scrollBy (int x, int y)"}, "requestDisallowInterceptTouchEvent(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the child does not want the parent to intercept touch events."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child does not want this parent and its ancestors to intercept touch events with @B_android#view#ViewGroup#onInterceptTouchEvent_E@. This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel.", "history": "", "FullName": "void requestDisallowInterceptTouchEvent (boolean disallowIntercept)"}, "setNestedScrollingEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to enable nested scrolling, false to disable"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable nested scrolling for this view. If this property is set to true the view will be permitted to initiate nested scrolling operations with a compatible parent view in the current hierarchy. If this view does not implement nested scrolling this will have no effect. Disabling nested scrolling while a nested scroll is in progress has the effect of @B_android#view#View#stopNestedScroll_E@ the nested scroll.", "history": "", "FullName": "void setNestedScrollingEnabled (boolean enabled)"}, "findViewHolderForPosition(int)": {"Returns": [["@B_android#support#v7#widget#RecyclerView#ViewHolder_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#support#v7#widget#RecyclerView#findViewHolderForLayoutPosition_E@ or @B_android#support#v7#widget#RecyclerView#findViewHolderForAdapterPosition_E@", "history": "added in version 22.0.0", "FullName": "RecyclerView.ViewHolder findViewHolderForPosition (int position)"}, "hasNestedScrollingParent(int)": {"Returns": [["boolean", "whether this view has a nested scrolling parent"]], "Parameters": [["int", "int: the type of input which cause this scroll event"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has a nested scrolling parent for the given input type. The presence of a nested scrolling parent indicates that this view has initiated a nested scroll and it was accepted by an ancestor view further up the view hierarchy.", "history": "added in version 26.0.0-beta2", "FullName": "boolean hasNestedScrollingParent (int type)"}, "findViewHolderForAdapterPosition(int)": {"Returns": [["@B_android#support#v7#widget#RecyclerView#ViewHolder_E@", "The ViewHolder at position or null if there is no such item"]], "Parameters": [["int", "int: The position of the item in the data set of the adapter"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the ViewHolder for the item in the given position of the data set. Unlike @B_android#support#v7#widget#RecyclerView#findViewHolderForLayoutPosition_E@ this method takes into account any pending adapter changes that may not be reflected to the layout yet. On the other hand, if @B_android#support#v7#widget#RecyclerView#Adapter#notifyDataSetChanged_E@ has been called but the new layout has not been calculated yet, this method will return null since the new positions of views are unknown until the layout is calculated. This method checks only the children of RecyclerView. If the item at the given position is not laid out, it will not create a new one. When the ItemAnimator is running a change animation, there might be 2 ViewHolders representing the same Item. In this case, the updated ViewHolder will be returned.", "history": "added in version 22.0.0", "FullName": "RecyclerView.ViewHolder findViewHolderForAdapterPosition (int position)"}, "stopNestedScroll(int)": {"Returns": [], "Parameters": [["int", "int: the type of input which cause this scroll event"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Stop a nested scroll in progress for the given input type. Calling this method when a nested scroll is not currently in progress is harmless.", "history": "added in version 26.0.0-beta2", "FullName": "void stopNestedScroll (int type)"}, "getCompatAccessibilityDelegate()": {"Returns": [["@B_android#support#v7#widget#RecyclerViewAccessibilityDelegate_E@", "An instance of AccessibilityDelegateCompat used by RecyclerView"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the accessibility delegate compatibility implementation used by the RecyclerView.", "history": "added in version 22.0.0", "FullName": "RecyclerViewAccessibilityDelegate getCompatAccessibilityDelegate ()"}, "computeHorizontalScrollRange()": {"Returns": [["int", "The total horizontal range represented by the vertical scrollbar"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#computeHorizontalScrollRange_E@"], "Permissions": [], "Description": "Compute the horizontal range that the horizontal scrollbar represents. The range is expressed in arbitrary units that must be the same as the units used by @B_android#support#v7#widget#RecyclerView#computeHorizontalScrollExtent_E@ and @B_android#support#v7#widget#RecyclerView#computeHorizontalScrollOffset_E@. Default implementation returns 0. If you want to support scroll bars, override @B_android#support#v7#widget#RecyclerView#LayoutManager#computeHorizontalScrollRange_E@ in your LayoutManager.", "history": "added in version 22.1.0", "FullName": "int computeHorizontalScrollRange ()"}, "computeHorizontalScrollExtent()": {"Returns": [["int", "The horizontal extent of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#computeHorizontalScrollExtent_E@"], "Permissions": [], "Description": "Compute the horizontal extent of the horizontal scrollbar's thumb within the horizontal range. This value is used to compute the length of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#support#v7#widget#RecyclerView#computeHorizontalScrollRange_E@ and @B_android#support#v7#widget#RecyclerView#computeHorizontalScrollOffset_E@. Default implementation returns 0. If you want to support scroll bars, override @B_android#support#v7#widget#RecyclerView#LayoutManager#computeHorizontalScrollExtent_E@ in your LayoutManager.", "history": "added in version 22.1.0", "FullName": "int computeHorizontalScrollExtent ()"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of the object. In general, the toString method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:", "history": "", "FullName": "String toString ()"}, "onGenericMotionEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The generic motion event being processed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle generic motion events. Generic motion events describe joystick movements, mouse hovers, track pad touches, scroll wheel movements and other input events. The @B_android#view#MotionEvent#getSource_E@ of the motion event specifies the class of input that was received. Implementations of this method must examine the bits in the source before processing the event. The following code example shows how this is done. Generic motion events with source class @B_android#view#InputDevice#SOURCE_CLASS_POINTER_E@ are delivered to the view under the pointer. All other generic motion events are delivered to the focused view.", "history": "", "FullName": "boolean onGenericMotionEvent (MotionEvent event)"}, "dispatchNestedPreFling(float, float)": {"Returns": [["boolean", "true if a nested scrolling parent consumed the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent before it is processed by this view. Nested pre-fling events are to nested fling events what touch intercept is to touch and what nested pre-scroll is to nested scroll. dispatchNestedPreFling offsets an opportunity for the parent view in a nested fling to fully consume the fling before the child view consumes it. If this method returns true, a nested parent view consumed the fling and this view should not scroll as a result. For a better user experience, only one view in a nested scrolling chain should consume the fling at a time. If a parent view consumed the fling this method will return false. Custom view implementations should account for this in two ways: If a custom view is paged and needs to settle to a fixed page-point, do not call dispatchNestedPreFling; consume the fling and settle to a valid position regardless. If a nested parent does consume the fling, this view should not scroll at all, even to settle back to a valid idle position. Views should also not offer fling velocities to nested parent views along an axis where scrolling is not currently supported; a @B_android#widget#ScrollView_E@ should not offer a horizontal fling velocity to its parents since scrolling along that axis is not permitted and carrying velocity along that motion does not make sense.", "history": "", "FullName": "boolean dispatchNestedPreFling (float velocityX, float velocityY)"}, "getChildViewHolder(android.view.View)": {"Returns": [["@B_android#support#v7#widget#RecyclerView#ViewHolder_E@", "The child view's ViewHolder"]], "Parameters": [["@B_android#view#View_E@", "View: Child of this RecyclerView to query for its ViewHolder"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the @B_android#support#v7#widget#RecyclerView#ViewHolder_E@ for the given child view.", "history": "added in version 22.0.0", "FullName": "RecyclerView.ViewHolder getChildViewHolder (View child)"}, "getLayoutManager()": {"Returns": [["@B_android#support#v7#widget#RecyclerView#LayoutManager_E@", "The currently bound LayoutManager"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the @B_android#support#v7#widget#RecyclerView#LayoutManager_E@ currently responsible for layout policy for this RecyclerView.", "history": "added in version 22.0.0", "FullName": "RecyclerView.LayoutManager getLayoutManager ()"}, "isNestedScrollingEnabled()": {"Returns": [["boolean", "true if nested scrolling is enabled"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if nested scrolling is enabled for this view. If nested scrolling is enabled and this View class implementation supports it, this view will act as a nested scrolling child view when applicable, forwarding data about the scroll operation in progress to a compatible and cooperating nested scrolling parent.", "history": "", "FullName": "boolean isNestedScrollingEnabled ()"}, "onTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle touch screen motion events. If this method is used to detect click actions, it is recommended that the actions be performed by implementing and calling @B_android#view#View#performClick_E@. This will ensure consistent system behavior, including: obeying click sound preferences dispatching OnClickListener calls handling @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_CLICK_E@ when accessibility features are enabled", "history": "", "FullName": "boolean onTouchEvent (MotionEvent e)"}, "onSizeChanged(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: Current width of this view."], ["int", "int: Current height of this view."], ["int", "int: Old width of this view."], ["int", "int: Old height of this view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0.", "history": "", "FullName": "void onSizeChanged (int w, int h, int oldw, int oldh)"}, "setLayoutFrozen(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to freeze layout and scroll, false to re-enable."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable layout and scroll. After setLayoutFrozen(true) is called, Layout requests will be postponed until setLayoutFrozen(false) is called; child views are not updated when RecyclerView is frozen, @B_android#support#v7#widget#RecyclerView#smoothScrollBy_E@, @B_android#support#v7#widget#RecyclerView#scrollBy_E@, @B_android#support#v7#widget#RecyclerView#scrollToPosition_E@ and @B_android#support#v7#widget#RecyclerView#smoothScrollToPosition_E@ are dropped; TouchEvents and GenericMotionEvents are dropped; @B_android#support#v7#widget#RecyclerView#LayoutManager#onFocusSearchFailed_E@ will not be called. setLayoutFrozen(true) does not prevent app from directly calling @B_android#support#v7#widget#RecyclerView#LayoutManager#scrollToPosition_E@, @B_android#support#v7#widget#RecyclerView#LayoutManager#smoothScrollToPosition_E@. @B_android#support#v7#widget#RecyclerView#setAdapter_E@ and @B_android#support#v7#widget#RecyclerView#swapAdapter_E@ will automatically stop frozen. Note: Running ItemAnimator is not stopped automatically, it's caller's responsibility to call ItemAnimator.end().", "history": "added in version 23.0.0", "FullName": "void setLayoutFrozen (boolean frozen)"}, "dispatchNestedScroll(int, int, int, int, int[])": {"Returns": [["boolean", "true if the event was dispatched, false if it could not be dispatched."]], "Parameters": [["int", "int: Horizontal distance in pixels consumed by this view during this scroll step"], ["int", "int: Vertical distance in pixels consumed by this view during this scroll step"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress. Implementations of views that support nested scrolling should call this to report info about a scroll in progress to the current nested scrolling parent. If a nested scroll is not currently in progress or nested scrolling is not @B_android#view#View#isNestedScrollingEnabled_E@ for this view this method does nothing. Compatible View implementations should also call @B_android#view#View#dispatchNestedPreScroll_E@ before consuming a component of the scroll event themselves.", "history": "", "FullName": "boolean dispatchNestedScroll (int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)"}, "clearOnChildAttachStateChangeListeners()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes all listeners that were added via @B_android#support#v7#widget#RecyclerView#addOnChildAttachStateChangeListener_E@.", "history": "added in version 22.2.0", "FullName": "void clearOnChildAttachStateChangeListeners ()"}, "getChildAdapterPosition(android.view.View)": {"Returns": [["int", "Adapter position corresponding to the given view or @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@"]], "Parameters": [["@B_android#view#View_E@", "View: Child View to query"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the adapter position that the given child view corresponds to.", "history": "added in version 22.0.0", "FullName": "int getChildAdapterPosition (View child)"}, "onMeasure(int, int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "", "FullName": "void onMeasure (int widthSpec, int heightSpec)"}, "getItemDecorationAt(int)": {"Returns": [["@B_android#support#v7#widget#RecyclerView#ItemDecoration_E@", "the ItemDecoration at index position, or null if invalid index."]], "Parameters": [["int", "int: The index position of the desired ItemDecoration."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns an @B_android#support#v7#widget#RecyclerView#ItemDecoration_E@ previously added to this RecyclerView.", "history": "added in version 26.0.0-beta1", "FullName": "RecyclerView.ItemDecoration getItemDecorationAt (int index)"}, "onDetachedFromWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is detached from a window. At this point it no longer has a surface for drawing.", "history": "", "FullName": "void onDetachedFromWindow ()"}, "setItemViewCacheSize(int)": {"Returns": [], "Parameters": [["int", "int: Number of views to cache offscreen before returning them to the general recycled view pool"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the number of offscreen views to retain before adding them to the potentially shared @B_android#support#v7#widget#RecyclerView#getRecycledViewPool_E@. The offscreen view cache stays aware of changes in the attached adapter, allowing a LayoutManager to reuse those views unmodified without needing to return to the adapter to rebind them.", "history": "added in version 22.0.0", "FullName": "void setItemViewCacheSize (int size)"}, "setPreserveFocusAfterLayout(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether RecyclerView should preserve focused Item during a layout calculations. Defaults to true."]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#getPreserveFocusAfterLayout_E@"], "Permissions": [], "Description": "Set whether the RecyclerView should try to keep the same Item focused after a layout calculation or not. Usually, LayoutManagers keep focused views visible before and after layout but sometimes, views may lose focus during a layout calculation as their state changes or they are replaced with another view due to type change or animation. In these cases, RecyclerView can request focus on the new view automatically.", "history": "added in version 24.0.0", "FullName": "void setPreserveFocusAfterLayout (boolean preserveFocusAfterLayout)"}, "scrollTo(int, int)": {"Returns": [], "Parameters": [["int", "int: the x position to scroll to"], ["int", "int: the y position to scroll to"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated.", "history": "", "FullName": "void scrollTo (int x, int y)"}, "getAdapter()": {"Returns": [["@B_android#support#v7#widget#RecyclerView#Adapter_E@", "The previously set adapter"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#setAdapter_E@"], "Permissions": [], "Description": "Retrieves the previously set adapter or null if no adapter is set.", "history": "added in version 22.0.0", "FullName": "Adapter getAdapter ()"}, "isLayoutFrozen()": {"Returns": [["boolean", "true if layout and scroll are frozen"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#setLayoutFrozen_E@"], "Permissions": [], "Description": "Returns true if layout and scroll are frozen.", "history": "added in version 23.0.0", "FullName": "boolean isLayoutFrozen ()"}, "onChildAttachedToWindow(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: Child view that is now attached to this RecyclerView and its associated window"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when an item view is attached to this RecyclerView. Subclasses of RecyclerView may want to perform extra bookkeeping or modifications of child views as they become attached. This will be called before a @B_android#support#v7#widget#RecyclerView#LayoutManager_E@ measures or lays out the view and is a good time to perform these changes.", "history": "added in version 22.0.0", "FullName": "void onChildAttachedToWindow (View child)"}, "onAttachedToWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before @B_android#view#View#onDraw_E@, however it may be called any time before the first onDraw -- including before or after @B_android#view#View#onMeasure_E@.", "history": "", "FullName": "void onAttachedToWindow ()"}, "onScrollStateChanged(int)": {"Returns": [], "Parameters": [["int", "int: the new scroll state, one of @B_android#support#v7#widget#RecyclerView#SCROLL_STATE_IDLE_E@, @B_android#support#v7#widget#RecyclerView#SCROLL_STATE_DRAGGING_E@ or @B_android#support#v7#widget#RecyclerView#SCROLL_STATE_SETTLING_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the scroll state of this RecyclerView changes. Subclasses should use this method to respond to state changes instead of an explicit listener. This method will always be invoked before listeners, but after the LayoutManager responds to the scroll state change.", "history": "added in version 22.1.0", "FullName": "void onScrollStateChanged (int state)"}, "getScrollState()": {"Returns": [["int", "@B_android#support#v7#widget#RecyclerView#SCROLL_STATE_IDLE_E@, @B_android#support#v7#widget#RecyclerView#SCROLL_STATE_DRAGGING_E@ or @B_android#support#v7#widget#RecyclerView#SCROLL_STATE_SETTLING_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the current scrolling state of the RecyclerView.", "history": "added in version 22.0.0", "FullName": "int getScrollState ()"}, "getClipToPadding()": {"Returns": [["boolean", "true if this RecyclerView clips children to its padding and resizes (but doesn't clip) any EdgeEffect to the padded region, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether this RecyclerView will clip its children to its padding, and resize (but not clip) any EdgeEffect to the padded region, if padding is present. By default, children are clipped to the padding of their parent RecyclerView. This clipping behavior is only enabled if padding is non-zero.", "history": "", "FullName": "boolean getClipToPadding ()"}, "onInterceptTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true to steal motion events from the children and have them dispatched to this ViewGroup through onTouchEvent(). The current target will receive an ACTION_CANCEL event, and no further messages will be delivered here."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event being dispatched down the hierarchy."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to intercept all touch screen motion events. This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point. Using this function takes some care, as it has a fairly complicated interaction with @B_android#view#View#onTouchEvent_E@, and using it requires implementing that method as well as this one in the correct way. Events will be received in the following order:", "history": "", "FullName": "boolean onInterceptTouchEvent (MotionEvent e)"}, "onSaveInstanceState()": {"Returns": [["@B_android#os#Parcelable_E@", "Returns a Parcelable object containing the view's current dynamic state, or null if there is nothing interesting to save."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view.", "history": "", "FullName": "Parcelable onSaveInstanceState ()"}, "getPreserveFocusAfterLayout()": {"Returns": [["boolean", "True if the RecyclerView will try to preserve focused Item after a layout if it loses focus."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#setPreserveFocusAfterLayout_E@"], "Permissions": [], "Description": "Returns true if the RecyclerView should attempt to preserve currently focused Adapter Item's focus even if the View representing the Item is replaced during a layout calculation. By default, this value is true.", "history": "added in version 24.0.0", "FullName": "boolean getPreserveFocusAfterLayout ()"}, "startNestedScroll(int)": {"Returns": [["boolean", "true if a cooperative parent was found and nested scrolling has been enabled for the current gesture."]], "Parameters": [["int", "int: Flags consisting of a combination of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@ and/or @B_android#view#View#SCROLL_AXIS_VERTICAL_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begin a nestable scroll operation along the given axes. A view starting a nested scroll promises to abide by the following contract: The view will call startNestedScroll upon initiating a scroll operation. In the case of a touch scroll this corresponds to the initial @B_android#view#MotionEvent#ACTION_DOWN_E@. In the case of touch scrolling the nested scroll will be terminated automatically in the same manner as @B_android#view#ViewParent#requestDisallowInterceptTouchEvent_E@. In the event of programmatic scrolling the caller must explicitly call @B_android#view#View#stopNestedScroll_E@ to indicate the end of the nested scroll. If startNestedScroll returns true, a cooperative parent was found. If it returns false the caller may ignore the rest of this contract until the next scroll. Calling startNestedScroll while a nested scroll is already in progress will return true. At each incremental step of the scroll the caller should invoke @B_android#view#View#dispatchNestedPreScroll_E@ once it has calculated the requested scrolling delta. If it returns true the nested scrolling parent at least partially consumed the scroll and the caller should adjust the amount it scrolls by. After applying the remainder of the scroll delta the caller should invoke @B_android#view#View#dispatchNestedScroll_E@, passing both the delta consumed and the delta unconsumed. A nested scrolling parent may treat these values differently. See @B_android#view#ViewParent#onNestedScroll_E@.", "history": "", "FullName": "boolean startNestedScroll (int axes)"}, "onDraw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: the canvas on which the background will be drawn"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to do your drawing.", "history": "added in version 22.0.0", "FullName": "void onDraw (Canvas c)"}, "invalidateItemDecorations()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Invalidates all ItemDecorations. If RecyclerView has item decorations, calling this method will trigger a @B_android#support#v7#widget#RecyclerView#requestLayout_E@ call.", "history": "added in version 22.0.0", "FullName": "void invalidateItemDecorations ()"}, "isAnimating()": {"Returns": [["boolean", "True if there are some item animations currently running or waiting to be started."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if RecyclerView is currently running some animations. If you want to be notified when animations are finished, use @B_android#support#v7#widget#RecyclerView#ItemAnimator#isRunning_E@.", "history": "added in version 22.2.0", "FullName": "boolean isAnimating ()"}, "getRecycledViewPool()": {"Returns": [["@B_android#support#v7#widget#RecyclerView#RecycledViewPool_E@", "The pool used to store recycled item views for reuse."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#setRecycledViewPool_E@"], "Permissions": [], "Description": "Retrieve this RecyclerView's @B_android#support#v7#widget#RecyclerView#RecycledViewPool_E@. This method will never return null; if no pool is set for this view a new one will be created. See @B_android#support#v7#widget#RecyclerView#setRecycledViewPool_E@ for more information.", "history": "added in version 22.0.0", "FullName": "RecyclerView.RecycledViewPool getRecycledViewPool ()"}, "getMaxFlingVelocity()": {"Returns": [["int", "The maximum fling velocity used by this RecyclerView."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the maximum fling velocity used by this RecyclerView.", "history": "added in version 22.2.0", "FullName": "int getMaxFlingVelocity ()"}, "focusSearch(android.view.View, int)": {"Returns": [["@B_android#view#View_E@", "A new View that can be the next focus after the focused View"]], "Parameters": [["@B_android#view#View_E@", "View: The view that currently has focus"], ["int", "int: One of @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_DOWN_E@, @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_RIGHT_E@, @B_android#view#View#FOCUS_FORWARD_E@, @B_android#view#View#FOCUS_BACKWARD_E@ or 0 for not applicable."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Since RecyclerView is a collection ViewGroup that includes virtual children (items that are in the Adapter but not visible in the UI), it employs a more involved focus search strategy that differs from other ViewGroups. It first does a focus search within the RecyclerView. If this search finds a View that is in the focus direction with respect to the currently focused View, RecyclerView returns that child as the next focus target. When it cannot find such child, it calls @B_android#support#v7#widget#RecyclerView#LayoutManager#onFocusSearchFailed_E@ to layout more Views in the focus search direction. If LayoutManager adds a View that matches the focus search criteria, it will be returned as the focus search result. Otherwise, RecyclerView will call parent to handle the focus search like a regular ViewGroup. When the direction is @B_android#view#View#FOCUS_FORWARD_E@ or @B_android#view#View#FOCUS_BACKWARD_E@, a View that is not in the focus direction is still valid focus target which may not be the desired behavior if the Adapter has more children in the focus direction. To handle this case, RecyclerView converts the focus direction to an absolute direction and makes a preliminary focus search in that direction. If there are no Views to gain focus, it will call @B_android#support#v7#widget#RecyclerView#LayoutManager#onFocusSearchFailed_E@ before running a focus search with the original (relative) direction. This allows RecyclerView to provide better candidates to the focus search while still allowing the view system to take focus from the RecyclerView and give it to a more suitable child if such child exists.", "history": "", "FullName": "View focusSearch (View focused, int direction)"}, "computeVerticalScrollExtent()": {"Returns": [["int", "The vertical extent of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#computeVerticalScrollExtent_E@"], "Permissions": [], "Description": "Compute the vertical extent of the vertical scrollbar's thumb within the vertical range. This value is used to compute the length of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#support#v7#widget#RecyclerView#computeVerticalScrollRange_E@ and @B_android#support#v7#widget#RecyclerView#computeVerticalScrollOffset_E@. Default implementation returns 0. If you want to support scroll bars, override @B_android#support#v7#widget#RecyclerView#LayoutManager#computeVerticalScrollExtent_E@ in your LayoutManager.", "history": "added in version 22.1.0", "FullName": "int computeVerticalScrollExtent ()"}, "scrollToPosition(int)": {"Returns": [], "Parameters": [["int", "int: Scroll to this adapter position"]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#scrollToPosition_E@"], "Permissions": [], "Description": "Convenience method to scroll to a certain position. RecyclerView does not implement scrolling logic, rather forwards the call to @B_android#support#v7#widget#RecyclerView#LayoutManager#scrollToPosition_E@", "history": "added in version 22.0.0", "FullName": "void scrollToPosition (int position)"}, "startNestedScroll(int, int)": {"Returns": [["boolean", "true if a cooperative parent was found and nested scrolling has been enabled for the current gesture."]], "Parameters": [["int", "int: Flags consisting of a combination of @B_android#support#v4#view#ViewCompat#SCROLL_AXIS_HORIZONTAL_E@ and/or @B_android#support#v4#view#ViewCompat#SCROLL_AXIS_VERTICAL_E@."], ["int", "int: the type of input which cause this scroll event"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begin a nestable scroll operation along the given axes, for the given input type. A view starting a nested scroll promises to abide by the following contract: The view will call startNestedScroll upon initiating a scroll operation. In the case of a touch scroll type this corresponds to the initial @B_android#view#MotionEvent#ACTION_DOWN_E@. In the case of touch scrolling the nested scroll will be terminated automatically in the same manner as @B_android#view#ViewParent#requestDisallowInterceptTouchEvent_E@. In the event of programmatic scrolling the caller must explicitly call @B_android#support#v4#view#NestedScrollingChild2#stopNestedScroll_E@ to indicate the end of the nested scroll. If startNestedScroll returns true, a cooperative parent was found. If it returns false the caller may ignore the rest of this contract until the next scroll. Calling startNestedScroll while a nested scroll is already in progress will return true. At each incremental step of the scroll the caller should invoke @B_android#support#v4#view#NestedScrollingChild2#dispatchNestedPreScroll_E@ once it has calculated the requested scrolling delta. If it returns true the nested scrolling parent at least partially consumed the scroll and the caller should adjust the amount it scrolls by. After applying the remainder of the scroll delta the caller should invoke @B_android#support#v4#view#NestedScrollingChild2#dispatchNestedScroll_E@, passing both the delta consumed and the delta unconsumed. A nested scrolling parent may treat these values differently. See @B_android#support#v4#view#NestedScrollingParent2#onNestedScroll_E@.", "history": "added in version 26.0.0-beta2", "FullName": "boolean startNestedScroll (int axes, int type)"}, "smoothScrollBy(int, int)": {"Returns": [], "Parameters": [["int", "int: Pixels to scroll horizontally"], ["int", "int: Pixels to scroll vertically"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Animate a scroll by the given amount of pixels along either axis.", "history": "added in version 22.0.0", "FullName": "void smoothScrollBy (int dx, int dy)"}, "findViewHolderForItemId(long)": {"Returns": [["@B_android#support#v7#widget#RecyclerView#ViewHolder_E@", "The ViewHolder with the given id or null if there is no such item"]], "Parameters": [["long", "long: The id for the requested item"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the ViewHolder for the item with the given id. The RecyclerView must use an Adapter with @B_android#support#v7#widget#RecyclerView#Adapter#setHasStableIds_E@ to return a non-null value. This method checks only the children of RecyclerView. If the item with the given id is not laid out, it will not create a new one. When the ItemAnimator is running a change animation, there might be 2 ViewHolders with the same id. In this case, the updated ViewHolder will be returned.", "history": "added in version 22.0.0", "FullName": "RecyclerView.ViewHolder findViewHolderForItemId (long id)"}, "dispatchNestedPreScroll(int, int, int[], int[])": {"Returns": [["boolean", "true if the parent consumed some or all of the scroll delta"]], "Parameters": [["int", "int: Horizontal scroll distance in pixels"], ["int", "int: Vertical scroll distance in pixels"], ["int[]", "int: Output. If not null, consumed[0] will contain the consumed component of dx and consumed[1] the consumed dy."], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress before this view consumes any portion of it. Nested pre-scroll events are to nested scroll events what touch intercept is to touch. dispatchNestedPreScroll offers an opportunity for the parent view in a nested scrolling operation to consume some or all of the scroll operation before the child view consumes it.", "history": "", "FullName": "boolean dispatchNestedPreScroll (int dx, int dy, int[] consumed, int[] offsetInWindow)"}, "dispatchNestedFling(float, float, boolean)": {"Returns": [["boolean", "true if the nested scrolling parent consumed or otherwise reacted to the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"], ["boolean", "boolean: true if the child consumed the fling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent. This method should be used to indicate that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling.", "history": "", "FullName": "boolean dispatchNestedFling (float velocityX, float velocityY, boolean consumed)"}, "requestLayout()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this when something has changed which has invalidated the layout of this view. This will schedule a layout pass of the view tree. This should not be called while the view hierarchy is currently in a layout pass (@B_android#view#View#isInLayout_E@. If layout is happening, the request may be honored at the end of the current layout pass (and then layout will run again) or after the current frame is drawn and the next layout occurs. Subclasses which override this method should call the superclass method to handle possible request-during-layout errors correctly.", "history": "", "FullName": "void requestLayout ()"}, "getMinFlingVelocity()": {"Returns": [["int", "The minimum velocity to start a fling"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the minimum velocity to start a fling.", "history": "added in version 22.2.0", "FullName": "int getMinFlingVelocity ()"}, "getBaseline()": {"Returns": [["int", "the offset of the baseline within the RecyclerView's bounds or -1 if baseline alignment is not supported"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the offset of the RecyclerView's text baseline from the its top boundary. If the LayoutManager of this RecyclerView does not support baseline alignment, this method returns -1.", "history": "", "FullName": "int getBaseline ()"}, "removeDetachedView(android.view.View, boolean)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child to be definitely removed from the view hierarchy"], ["boolean", "boolean: if true and the view has an animation, the view is placed in the disappearing views list, otherwise, it is detached from the window"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finishes the removal of a detached view. This method will dispatch the detached from window event and notify the hierarchy change listener. This method is intended to be lightweight and makes no assumptions about whether the parent or child should be redrawn. Proper use of this method will include also making any appropriate @B_android#view#View#requestLayout_E@ or @B_android#view#View#invalidate_E@ calls. For example, callers can @B_android#view#View#post_E@ a @B_java#lang#Runnable_E@ which performs a @B_android#view#View#requestLayout_E@ on the next frame, after all detach/remove calls are finished, causing layout to be run prior to redrawing the view hierarchy.", "history": "", "FullName": "void removeDetachedView (View child, boolean animate)"}, "getChildLayoutPosition(android.view.View)": {"Returns": [["int", "Adapter position of the given View as of last layout pass or @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@ if the View is representing a removed item."]], "Parameters": [["@B_android#view#View_E@", "View: Child View to query"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the adapter position of the given child view as of the latest completed layout pass. This position may not be equal to Item's adapter position if there are pending changes in the adapter which have not been reflected to the layout yet.", "history": "added in version 22.0.0", "FullName": "int getChildLayoutPosition (View child)"}, "computeVerticalScrollRange()": {"Returns": [["int", "The total vertical range represented by the vertical scrollbar"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#computeVerticalScrollRange_E@"], "Permissions": [], "Description": "Compute the vertical range that the vertical scrollbar represents. The range is expressed in arbitrary units that must be the same as the units used by @B_android#support#v7#widget#RecyclerView#computeVerticalScrollExtent_E@ and @B_android#support#v7#widget#RecyclerView#computeVerticalScrollOffset_E@. Default implementation returns 0. If you want to support scroll bars, override @B_android#support#v7#widget#RecyclerView#LayoutManager#computeVerticalScrollRange_E@ in your LayoutManager.", "history": "added in version 22.1.0", "FullName": "int computeVerticalScrollRange ()"}, "findChildViewUnder(float, float)": {"Returns": [["@B_android#view#View_E@", "The child view under (x, y) or null if no matching child is found"]], "Parameters": [["float", "float: Horizontal position in pixels to search"], ["float", "float: Vertical position in pixels to search"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the topmost view under the given point.", "history": "added in version 22.0.0", "FullName": "View findChildViewUnder (float x, float y)"}, "onScrolled(int, int)": {"Returns": [], "Parameters": [["int", "int: horizontal distance scrolled in pixels"], ["int", "int: vertical distance scrolled in pixels"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the scroll position of this RecyclerView changes. Subclasses should use this method to respond to scrolling within the adapter's data set instead of an explicit listener. This method will always be invoked before listeners. If a subclass needs to perform any additional upkeep or bookkeeping after scrolling but before listeners run, this is a good place to do so. This differs from @B_android#view#View#onScrollChanged_E@ in that it receives the distance scrolled in either direction within the adapter's data set instead of absolute scroll coordinates. Since RecyclerView cannot compute the absolute scroll position from any arbitrary point in the data set, onScrollChanged will always receive the current @B_android#view#View#getScrollX_E@ and @B_android#view#View#getScrollY_E@ values which do not correspond to the data set scroll position. However, some subclasses may choose to use these fields as special offsets.", "history": "added in version 22.1.0", "FullName": "void onScrolled (int dx, int dy)"}, "RecyclerView(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "RecyclerView (Context context)"}, "findViewHolderForLayoutPosition(int)": {"Returns": [["@B_android#support#v7#widget#RecyclerView#ViewHolder_E@", "The ViewHolder at position or null if there is no such item"]], "Parameters": [["int", "int: The position of the item in the data set of the adapter"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the ViewHolder for the item in the given position of the data set as of the latest layout pass. This method checks only the children of RecyclerView. If the item at the given position is not laid out, it will not create a new one. Note that when Adapter contents change, ViewHolder positions are not updated until the next layout calculation. If there are pending adapter updates, the return value of this method may not match your adapter contents. You can use #@B_android#support#v7#widget#RecyclerView#ViewHolder#getAdapterPosition_E@ to get the current adapter position of a ViewHolder. When the ItemAnimator is running a change animation, there might be 2 ViewHolders with the same layout position representing the same Item. In this case, the updated ViewHolder will be returned.", "history": "added in version 22.0.0", "FullName": "RecyclerView.ViewHolder findViewHolderForLayoutPosition (int position)"}, "getChildDrawingOrder(int, int)": {"Returns": [["int", "The index of the child to draw this iteration."]], "Parameters": [["int", "int no parameter comment"], ["int", "int: The current iteration."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the index of the child to draw for this iteration. Override this if you want to change the drawing order of children. By default, it returns i. NOTE: In order for this method to be called, you must enable child ordering first by calling @B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@.", "history": "", "FullName": "int getChildDrawingOrder (int childCount, int i)"}, "smoothScrollToPosition(int)": {"Returns": [], "Parameters": [["int", "int: The adapter position to scroll to"]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#smoothScrollToPosition_E@"], "Permissions": [], "Description": "Starts a smooth scroll to an adapter position. To support smooth scrolling, you must override @B_android#support#v7#widget#RecyclerView#LayoutManager#smoothScrollToPosition_E@ and create a @B_android#support#v7#widget#RecyclerView#SmoothScroller_E@. @B_android#support#v7#widget#RecyclerView#LayoutManager_E@ is responsible for creating the actual scroll action. If you want to provide a custom smooth scroll logic, override @B_android#support#v7#widget#RecyclerView#LayoutManager#smoothScrollToPosition_E@ in your LayoutManager.", "history": "added in version 22.0.0", "FullName": "void smoothScrollToPosition (int position)"}, "findContainingItemView(android.view.View)": {"Returns": [["@B_android#view#View_E@", "The direct child of the RecyclerView which contains the given view or null if the provided view is not a descendant of this RecyclerView."]], "Parameters": [["@B_android#view#View_E@", "View: The view that is a descendant of the RecyclerView."]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#getChildViewHolder_E@", "@B_android#support#v7#widget#RecyclerView#findContainingViewHolder_E@"], "Permissions": [], "Description": "Traverses the ancestors of the given view and returns the item view that contains it and also a direct child of the RecyclerView. This returned view can be used to get the ViewHolder by calling @B_android#support#v7#widget#RecyclerView#getChildViewHolder_E@.", "history": "added in version 23.2.0", "FullName": "View findContainingItemView (View view)"}, "hasFixedSize()": {"Returns": [["boolean", "true if the app has specified that changes in adapter content cannot change the size of the RecyclerView itself."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "boolean hasFixedSize ()"}, "findContainingViewHolder(android.view.View)": {"Returns": [["@B_android#support#v7#widget#RecyclerView#ViewHolder_E@", "The ViewHolder that contains the given view or null if the provided view is not a descendant of this RecyclerView."]], "Parameters": [["@B_android#view#View_E@", "View: The view that is a descendant of the RecyclerView."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the ViewHolder that contains the given view.", "history": "added in version 23.2.0", "FullName": "RecyclerView.ViewHolder findContainingViewHolder (View view)"}, "hasPendingAdapterUpdates()": {"Returns": [["boolean", "True if there are some adapter updates which are not yet reflected to layout or false if layout is up to date."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether there are pending adapter updates which are not yet applied to the layout. If this method returns true, it means that what user is currently seeing may not reflect them adapter contents (depending on what has changed). You may use this information to defer or cancel some operations. This method returns true if RecyclerView has not yet calculated the first layout after it is attached to the Window or the Adapter has been replaced.", "history": "added in version 22.1.0", "FullName": "boolean hasPendingAdapterUpdates ()"}, "draw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: The Canvas to which the View is rendered."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Manually render this view (and all of its children) to the given Canvas. The view must have already done a full layout before this function is called. When implementing a view, implement @B_android#view#View#onDraw_E@ instead of overriding this method. If you do need to override this method, call the superclass version.", "history": "", "FullName": "void draw (Canvas c)"}, "setScrollingTouchSlop(int)": {"Returns": [], "Parameters": [["int", "int: One of the TOUCH_SLOP_ constants representing the intended usage of this RecyclerView"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Configure the scrolling touch slop for a specific use case. Set up the RecyclerView's scrolling motion threshold based on common usages. Valid arguments are @B_android#support#v7#widget#RecyclerView#TOUCH_SLOP_DEFAULT_E@ and @B_android#support#v7#widget#RecyclerView#TOUCH_SLOP_PAGING_E@.", "history": "added in version 22.0.0", "FullName": "void setScrollingTouchSlop (int slopConstant)"}, "isComputingLayout()": {"Returns": [["boolean", "true if RecyclerView is currently computing a layout, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether RecyclerView is currently computing a layout. If this method returns true, it means that RecyclerView is in a lockdown state and any attempt to update adapter contents will result in an exception because adapter contents cannot be changed while RecyclerView is trying to compute the layout. It is very unlikely that your code will be running during this state as it is called by the framework when a layout traversal happens or RecyclerView starts to scroll in response to system events (touch, accessibility etc). This case may happen if you have some custom logic to change adapter contents in response to a View callback (e.g. focus change callback) which might be triggered during a layout calculation. In these cases, you should just postpone the change using a Handler or a similar mechanism.", "history": "added in version 22.2.1", "FullName": "boolean isComputingLayout ()"}, "offsetChildrenVertical(int)": {"Returns": [], "Parameters": [["int", "int: Vertical pixel offset to apply to the bounds of all child views"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Offset the bounds of all child views by dy pixels. Useful for implementing simple scrolling in @B_android#support#v7#widget#RecyclerView#LayoutManager_E@.", "history": "added in version 22.0.0", "FullName": "void offsetChildrenVertical (int dy)"}, "generateLayoutParams(android.util.AttributeSet)": {"Returns": [["@B_android#view#ViewGroup#LayoutParams_E@", "an instance of @B_android#view#ViewGroup#LayoutParams_E@ or one of its descendants"]], "Parameters": [["@B_android#util#AttributeSet_E@", "AttributeSet: the attributes to build the layout parameters from"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a new set of layout parameters based on the supplied attributes set.", "history": "", "FullName": "ViewGroup.LayoutParams generateLayoutParams (AttributeSet attrs)"}, "setClipToPadding(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to clip children to the padding of the group, and resize (but not clip) any EdgeEffect to the padded region. False otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets whether this ViewGroup will clip its children to its padding and resize (but not clip) any EdgeEffect to the padded region, if padding is present. By default, children are clipped to the padding of their parent ViewGroup. This clipping behavior is only enabled if padding is non-zero.", "history": "", "FullName": "void setClipToPadding (boolean clipToPadding)"}, "isAttachedToWindow()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if RecyclerView is attached to window.", "history": "", "FullName": "boolean isAttachedToWindow ()"}, "onLayout(boolean, int, int, int, int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "added in version 22.0.0", "FullName": "void onLayout (boolean changed, int l, int t, int r, int b)"}, "stopScroll()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Stop any current scroll in progress, such as one started by @B_android#support#v7#widget#RecyclerView#smoothScrollBy_E@, @B_android#support#v7#widget#RecyclerView#fling_E@ or a touch-initiated fling.", "history": "added in version 22.0.0", "FullName": "void stopScroll ()"}, "onChildDetachedFromWindow(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: Child view that is now detached from this RecyclerView and its associated window"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when an item view is detached from this RecyclerView. Subclasses of RecyclerView may want to perform extra bookkeeping or modifications of child views as they become detached. This will be called as a @B_android#support#v7#widget#RecyclerView#LayoutManager_E@ fully detaches the child view from the parent and its window.", "history": "added in version 22.0.0", "FullName": "void onChildDetachedFromWindow (View child)"}, "getChildPosition(android.view.View)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_android#view#View_E@", "View no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#support#v7#widget#RecyclerView#getChildAdapterPosition_E@ or @B_android#support#v7#widget#RecyclerView#getChildLayoutPosition_E@.", "history": "added in version 22.0.0", "FullName": "int getChildPosition (View child)"}, "offsetChildrenHorizontal(int)": {"Returns": [], "Parameters": [["int", "int: Horizontal pixel offset to apply to the bounds of all child views"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Offset the bounds of all child views by dx pixels. Useful for implementing simple scrolling in @B_android#support#v7#widget#RecyclerView#LayoutManager_E@.", "history": "added in version 22.0.0", "FullName": "void offsetChildrenHorizontal (int dx)"}, "onRestoreInstanceState(android.os.Parcelable)": {"Returns": [], "Parameters": [["@B_android#os#Parcelable_E@", "Parcelable: The frozen state that had previously been returned by @B_android#support#v7#widget#RecyclerView#onSaveInstanceState_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to re-apply a representation of its internal state that had previously been generated by @B_android#view#View#onSaveInstanceState_E@. This function will never be called with a null state.", "history": "", "FullName": "void onRestoreInstanceState (Parcelable state)"}, "computeVerticalScrollOffset()": {"Returns": [["int", "The vertical offset of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#computeVerticalScrollOffset_E@"], "Permissions": [], "Description": "Compute the vertical offset of the vertical scrollbar's thumb within the vertical range. This value is used to compute the length of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#support#v7#widget#RecyclerView#computeVerticalScrollRange_E@ and @B_android#support#v7#widget#RecyclerView#computeVerticalScrollExtent_E@. Default implementation returns 0. If you want to support scroll bars, override @B_android#support#v7#widget#RecyclerView#LayoutManager#computeVerticalScrollOffset_E@ in your LayoutManager.", "history": "added in version 22.1.0", "FullName": "int computeVerticalScrollOffset ()"}, "setHasFixedSize(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if adapter changes cannot affect the size of the RecyclerView."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "RecyclerView can perform several optimizations if it can know in advance that RecyclerView's size is not affected by the adapter contents. RecyclerView can still change its size based on other factors (e.g. its parent's size) but this size calculation cannot depend on the size of its children or contents of its adapter (except the number of items in the adapter). If your use of RecyclerView falls into this category, set this to true. It will allow RecyclerView to avoid invalidating the whole layout when its adapter contents change.", "history": "added in version 22.0.0", "FullName": "void setHasFixedSize (boolean hasFixedSize)"}, "computeHorizontalScrollOffset()": {"Returns": [["int", "The horizontal offset of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#computeHorizontalScrollOffset_E@"], "Permissions": [], "Description": "Compute the horizontal offset of the horizontal scrollbar's thumb within the horizontal range. This value is used to compute the length of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#support#v7#widget#RecyclerView#computeHorizontalScrollRange_E@ and @B_android#support#v7#widget#RecyclerView#computeHorizontalScrollExtent_E@. Default implementation returns 0. If you want to support scroll bars, override @B_android#support#v7#widget#RecyclerView#LayoutManager#computeHorizontalScrollOffset_E@ in your LayoutManager.", "history": "added in version 22.1.0", "FullName": "int computeHorizontalScrollOffset ()"}, "getOnFlingListener()": {"Returns": [["@B_android#support#v7#widget#RecyclerView#OnFlingListener_E@", "The @B_android#support#v7#widget#RecyclerView#OnFlingListener_E@ instance currently set (can be null)."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the current @B_android#support#v7#widget#RecyclerView#OnFlingListener_E@ from this @B_android#support#v7#widget#RecyclerView_E@.", "history": "added in version 24.2.0", "FullName": "RecyclerView.OnFlingListener getOnFlingListener ()"}, "hasNestedScrollingParent()": {"Returns": [["boolean", "whether this view has a nested scrolling parent"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has a nested scrolling parent. The presence of a nested scrolling parent indicates that this view has initiated a nested scroll and it was accepted by an ancestor view further up the view hierarchy.", "history": "", "FullName": "boolean hasNestedScrollingParent ()"}, "getItemAnimator()": {"Returns": [["@B_android#support#v7#widget#RecyclerView#ItemAnimator_E@", "ItemAnimator The current ItemAnimator. If null, no animations will occur when changes occur to the items in this RecyclerView."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the current ItemAnimator for this RecyclerView. A null return value indicates that there is no animator and that item changes will happen without any animations. By default, RecyclerView instantiates and uses an instance of @B_android#support#v7#widget#DefaultItemAnimator_E@.", "history": "added in version 22.0.0", "FullName": "RecyclerView.ItemAnimator getItemAnimator ()"}, "generateDefaultLayoutParams()": {"Returns": [["@B_android#view#ViewGroup#LayoutParams_E@", "a set of default layout parameters or null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a set of default layout parameters. These parameters are requested when the View passed to @B_android#view#ViewGroup#addView_E@ has no layout parameters already set. If null is returned, an exception is thrown from addView.", "history": "", "FullName": "ViewGroup.LayoutParams generateDefaultLayoutParams ()"}, "clearOnScrollListeners()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove all secondary listener that were notified of any changes in scroll state or position.", "history": "added in version 22.1.0", "FullName": "void clearOnScrollListeners ()"}, "stopNestedScroll()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Stop a nested scroll in progress. Calling this method when a nested scroll is not currently in progress is harmless.", "history": "", "FullName": "void stopNestedScroll ()"}, "fling(int, int)": {"Returns": [["boolean", "true if the fling was started, false if the velocity was too low to fling or LayoutManager does not support scrolling in the axis fling is issued."]], "Parameters": [["int", "int: Initial horizontal velocity in pixels per second"], ["int", "int: Initial vertical velocity in pixels per second"]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#canScrollVertically_E@", "@B_android#support#v7#widget#RecyclerView#LayoutManager#canScrollHorizontally_E@"], "Permissions": [], "Description": "Begin a standard fling with an initial velocity along each axis in pixels per second. If the velocity given is below the system-defined minimum this method will return false and no fling will occur.", "history": "added in version 22.0.0", "FullName": "boolean fling (int velocityX, int velocityY)"}}, "Inheritance": ["java.lang.Object", "https:##developer#android#com@B_android#view#View_E@", "https:##developer#android#com@B_android#view#ViewGroup_E@"], "ClassName": "android.support.v7.widget.RecyclerView", "ClassDesc": "A flexible view for providing a limited window into a large data set. Adapter: A subclass of @B_android#support#v7#widget#RecyclerView#Adapter_E@ responsible for providing views that represent items in a data set. Position: The position of a data item within an Adapter. Index: The index of an attached child view as used in a call to https:##developer#android#com@B_android#view#ViewGroup#getChildAt_E@. Contrast with Position. Binding: The process of preparing a child view to display data corresponding to a position within the adapter. Recycle (view): A view previously used to display data for a specific adapter position may be placed in a cache for later reuse to display the same type of data again later. This can drastically improve performance by skipping initial layout inflation or construction. Scrap (view): A child view that has entered into a temporarily detached state during layout. Scrap views may be reused without becoming fully detached from the parent RecyclerView, either unmodified if no rebinding is required or modified by the adapter if the view was considered dirty. Dirty (view): A child view that must be rebound by the adapter before being displayed. RecyclerView introduces an additional level of abstraction between the @B_android#support#v7#widget#RecyclerView#Adapter_E@ and @B_android#support#v7#widget#RecyclerView#LayoutManager_E@ to be able to detect data set changes in batches during a layout calculation. This saves LayoutManager from tracking adapter changes to calculate animations. It also helps with performance because all view bindings happen at the same time and unnecessary bindings are avoided. For this reason, there are two types of position related methods in RecyclerView: layout position: Position of an item in the latest layout calculation. This is the position from the LayoutManager's perspective. adapter position: Position of an item in the adapter. This is the position from the Adapter's perspective. These two positions are the same except the time between dispatching adapter.notify* events and calculating the updated layout. Methods that return or receive *LayoutPosition* use position as of the latest layout calculation (e.g. @B_android#support#v7#widget#RecyclerView#ViewHolder#getLayoutPosition_E@, @B_android#support#v7#widget#RecyclerView#findViewHolderForLayoutPosition_E@). These positions include all changes until the last layout calculation. You can rely on these positions to be consistent with what user is currently seeing on the screen. For example, if you have a list of items on the screen and user asks for the 5 The other set of position related methods are in the form of *AdapterPosition*. (e.g. @B_android#support#v7#widget#RecyclerView#ViewHolder#getAdapterPosition_E@, @B_android#support#v7#widget#RecyclerView#findViewHolderForAdapterPosition_E@) You should use these methods when you need to work with up-to-date adapter positions even if they may not have been reflected to layout yet. For example, if you want to access the item in the adapter on a ViewHolder click, you should use @B_android#support#v7#widget#RecyclerView#ViewHolder#getAdapterPosition_E@. Beware that these methods may not be able to calculate adapter positions if @B_android#support#v7#widget#RecyclerView#Adapter#notifyDataSetChanged_E@ has been called and new layout has not yet been calculated. For this reasons, you should carefully handle @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@ or null results from these methods. When writing a @B_android#support#v7#widget#RecyclerView#LayoutManager_E@ you almost always want to use layout positions whereas when writing an @B_android#support#v7#widget#RecyclerView#Adapter_E@, you probably want to use adapter positions."}