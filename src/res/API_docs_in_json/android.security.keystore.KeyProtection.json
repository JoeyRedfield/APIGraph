{"Functions": {"getKeyValidityStart()": {"Returns": [["@B_java#util#Date_E@", "instant or null if not restricted."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the time instant before which the key is not yet valid.", "history": "Added in API level 23", "FullName": "public Date getKeyValidityStart ()"}, "getDigests()": {"Returns": [["@B_java#lang#String_E@", "This value will never be null. Value is @B_android#security#keystore#KeyProperties#DIGEST_NONE_E@, @B_android#security#keystore#KeyProperties#DIGEST_MD5_E@, @B_android#security#keystore#KeyProperties#DIGEST_SHA1_E@, @B_android#security#keystore#KeyProperties#DIGEST_SHA224_E@, @B_android#security#keystore#KeyProperties#DIGEST_SHA256_E@, @B_android#security#keystore#KeyProperties#DIGEST_SHA384_E@, or @B_android#security#keystore#KeyProperties#DIGEST_SHA512_E@"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this set has not been specified."]], "SeeAlso": ["@B_android#security#keystore#KeyProtection#isDigestsSpecified_E@"], "Permissions": [], "Description": "Gets the set of digest algorithms (e.g., SHA-256, SHA-384) with which the key can be used. See @B_android#security#keystore#KeyProperties_E@.DIGEST constants.", "history": "Added in API level 23", "FullName": "public String[] getDigests ()"}, "getEncryptionPaddings()": {"Returns": [["@B_java#lang#String_E@", "This value will never be null. Value is @B_android#security#keystore#KeyProperties#ENCRYPTION_PADDING_NONE_E@, @B_android#security#keystore#KeyProperties#ENCRYPTION_PADDING_PKCS7_E@, @B_android#security#keystore#KeyProperties#ENCRYPTION_PADDING_RSA_PKCS1_E@, or @B_android#security#keystore#KeyProperties#ENCRYPTION_PADDING_RSA_OAEP_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the set of padding schemes (e.g., PKCS7Padding, PKCS1Padding, NoPadding) with which the key can be used when encrypting/decrypting. Attempts to use the key with any other padding scheme will be rejected. See @B_android#security#keystore#KeyProperties_E@.ENCRYPTION_PADDING constants.", "history": "Added in API level 23", "FullName": "public String[] getEncryptionPaddings ()"}, "getKeyValidityForOriginationEnd()": {"Returns": [["@B_java#util#Date_E@", "instant or null if not restricted."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the time instant after which the key is no long valid for encryption and signing.", "history": "Added in API level 23", "FullName": "public Date getKeyValidityForOriginationEnd ()"}, "getBlockModes()": {"Returns": [["@B_java#lang#String_E@", "This value will never be null. Value is @B_android#security#keystore#KeyProperties#BLOCK_MODE_ECB_E@, @B_android#security#keystore#KeyProperties#BLOCK_MODE_CBC_E@, @B_android#security#keystore#KeyProperties#BLOCK_MODE_CTR_E@, or @B_android#security#keystore#KeyProperties#BLOCK_MODE_GCM_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the set of block modes (e.g., GCM, CBC) with which the key can be used when encrypting/decrypting. Attempts to use the key with any other block modes will be rejected. See @B_android#security#keystore#KeyProperties_E@.BLOCK_MODE constants.", "history": "Added in API level 23", "FullName": "public String[] getBlockModes ()"}, "isUserPresenceRequired()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the key is authorized to be used only if a test of user presence has been performed between the Signature.initSign() and Signature.sign() calls. It requires that the KeyStore implementation have a direct way to validate the user presence for example a KeyStore hardware backed strongbox can use a button press that is observable in hardware. A test for user presence is tangential to authentication. The test can be part of an authentication step as long as this step can be validated by the hardware protecting the key and cannot be spoofed. For example, a physical button press can be used as a test of user presence if the other pins connected to the button are not able to simulate a button press. There must be no way for the primary processor to fake a button press, or that button must not be used as a test of user presence.", "history": "Added in API level 28", "FullName": "public boolean isUserPresenceRequired ()"}, "getUserAuthenticationValidityDurationSeconds()": {"Returns": [["int", "duration in seconds or -1 if authentication is required for every use of the key."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#security#keystore#KeyProtection#isUserAuthenticationRequired_E@", "@B_android#security#keystore#KeyProtection#Builder#setUserAuthenticationValidityDurationSeconds_E@"], "Permissions": [], "Description": "Gets the duration of time (seconds) for which this key is authorized to be used after the user is successfully authenticated. This has effect only if user authentication is required (see @B_android#security#keystore#KeyProtection#isUserAuthenticationRequired_E@). This authorization applies only to secret key and private key operations. Public key operations are not restricted.", "history": "Added in API level 23", "FullName": "public int getUserAuthenticationValidityDurationSeconds ()"}, "isUserAuthenticationRequired()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#security#keystore#KeyProtection#getUserAuthenticationValidityDurationSeconds_E@", "@B_android#security#keystore#KeyProtection#Builder#setUserAuthenticationRequired_E@"], "Permissions": [], "Description": "Returns true if the key is authorized to be used only if the user has been authenticated. This authorization applies only to secret key and private key operations. Public key operations are not restricted.", "history": "Added in API level 23", "FullName": "public boolean isUserAuthenticationRequired ()"}, "isUserAuthenticationValidWhileOnBody()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#security#keystore#KeyProtection#isUserAuthenticationRequired_E@", "@B_android#security#keystore#KeyProtection#getUserAuthenticationValidityDurationSeconds_E@", "@B_android#security#keystore#KeyProtection#Builder#setUserAuthenticationValidWhileOnBody_E@"], "Permissions": [], "Description": "Returns true if the key will be de-authorized when the device is removed from the user's body. This option has no effect on keys that don't have an authentication validity duration, and has no effect if the device lacks an on-body sensor. Authorization applies only to secret key and private key operations. Public key operations are not restricted.", "history": "Added in API level 24", "FullName": "public boolean isUserAuthenticationValidWhileOnBody ()"}, "isInvalidatedByBiometricEnrollment()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#security#keystore#KeyProtection#isUserAuthenticationRequired_E@", "@B_android#security#keystore#KeyProtection#getUserAuthenticationValidityDurationSeconds_E@", "@B_android#security#keystore#KeyProtection#Builder#setInvalidatedByBiometricEnrollment_E@"], "Permissions": [], "Description": "Returns true if the key is irreversibly invalidated when a new biometric is enrolled or all enrolled biometrics are removed. This has effect only for keys that require biometric user authentication for every use.", "history": "Added in API level 24", "FullName": "public boolean isInvalidatedByBiometricEnrollment ()"}, "isRandomizedEncryptionRequired()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if encryption using this key must be sufficiently randomized to produce different ciphertexts for the same plaintext every time. The formal cryptographic property being required is indistinguishability under chosen-plaintext attack (IND-CPA). This property is important because it mitigates several classes of weaknesses due to which ciphertext may leak information about plaintext. For example, if a given plaintext always produces the same ciphertext, an attacker may see the repeated ciphertexts and be able to deduce something about the plaintext.", "history": "Added in API level 23", "FullName": "public boolean isRandomizedEncryptionRequired ()"}, "getPurposes()": {"Returns": [["int", "Value is either 0 or a combination of @B_android#security#keystore#KeyProperties#PURPOSE_ENCRYPT_E@, @B_android#security#keystore#KeyProperties#PURPOSE_DECRYPT_E@, @B_android#security#keystore#KeyProperties#PURPOSE_SIGN_E@, @B_android#security#keystore#KeyProperties#PURPOSE_VERIFY_E@, and @B_android#security#keystore#KeyProperties#PURPOSE_WRAP_KEY_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the set of purposes (e.g., encrypt, decrypt, sign) for which the key can be used. Attempts to use the key for any other purpose will be rejected. See @B_android#security#keystore#KeyProperties_E@.PURPOSE flags.", "history": "Added in API level 23", "FullName": "public int getPurposes ()"}, "getKeyValidityForConsumptionEnd()": {"Returns": [["@B_java#util#Date_E@", "instant or null if not restricted."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the time instant after which the key is no long valid for decryption and verification.", "history": "Added in API level 23", "FullName": "public Date getKeyValidityForConsumptionEnd ()"}, "isUnlockedDeviceRequired()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#security#keystore#KeyProtection#Builder#setUnlockedDeviceRequired_E@"], "Permissions": [], "Description": "Returns true if the screen must be unlocked for this key to be used for decryption or signing. Encryption and signature verification will still be available when the screen is locked.", "history": "Added in API level 28", "FullName": "public boolean isUnlockedDeviceRequired ()"}, "isUserConfirmationRequired()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#security#keystore#KeyProtection#Builder#setUserConfirmationRequired_E@"], "Permissions": [], "Description": "Returns true if the key is authorized to be used only for messages confirmed by the user. Confirmation is separate from user authentication (see @B_android#security#keystore#KeyProtection#isUserAuthenticationRequired_E@). Keys can be created that require confirmation but not user authentication, or user authentication but not confirmation, or both. Confirmation verifies that some user with physical possession of the device has approved a displayed message. User authentication verifies that the correct user is present and has authenticated. This authorization applies only to secret key and private key operations. Public key operations are not restricted.", "history": "Added in API level 28", "FullName": "public boolean isUserConfirmationRequired ()"}, "isDigestsSpecified()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#security#keystore#KeyProtection#getDigests_E@"], "Permissions": [], "Description": "Returns true if the set of digest algorithms with which the key can be used has been specified.", "history": "Added in API level 23", "FullName": "public boolean isDigestsSpecified ()"}, "getSignaturePaddings()": {"Returns": [["@B_java#lang#String_E@", "This value will never be null. Value is @B_android#security#keystore#KeyProperties#SIGNATURE_PADDING_RSA_PKCS1_E@, or @B_android#security#keystore#KeyProperties#SIGNATURE_PADDING_RSA_PSS_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the set of padding schemes (e.g., PSS, PKCS#1) with which the key can be used when signing/verifying. Attempts to use the key with any other padding scheme will be rejected. See @B_android#security#keystore#KeyProperties_E@.SIGNATURE_PADDING constants.", "history": "Added in API level 23", "FullName": "public String[] getSignaturePaddings ()"}}, "Inheritance": [], "ClassName": "android.security.keystore.KeyProtection", "ClassDesc": "Specification of how a key or key pair is secured when imported into the To import a key or key pair into the Android Keystore, create an instance of this class using the @B_android#security#keystore#KeyProtection#Builder_E@ and pass the instance into @B_java#security#KeyStore#setEntry_E@ with the key or key pair being imported. To obtain the secret/symmetric or private key from the Android Keystore use @B_java#security#KeyStore#getKey_E@ or @B_java#security#KeyStore#getEntry_E@. To obtain the public key from the Android Keystore use @B_java#security#KeyStore#getCertificate_E@ and then @B_java#security#cert#Certificate#getPublicKey_E@. To help obtain algorithm-specific public parameters of key pairs stored in the Android Keystore, its private keys implement @B_java#security#interfaces#ECKey_E@ or @B_java#security#interfaces#RSAKey_E@ interfaces whereas its public keys implement @B_java#security#interfaces#ECPublicKey_E@ or @B_java#security#interfaces#RSAPublicKey_E@ interfaces. NOTE: The key material of keys stored in the Android Keystore is not accessible. Instances of this class are immutable. key1 authorized to be used only for encryption/decryption in GCM mode with no padding. The key must export its key material via @B_java#security#Key#getEncoded_E@ in RAW format. key1 authorized to be used only for generating MACs using SHA-512 digest. The key must export its key material via @B_java#security#Key#getEncoded_E@ in RAW format. key2 with the private key authorized to be used only for signing with SHA-256 or SHA-512 digests. The use of the public key is unrestricted. Both the private and the public key must export their key material via @B_java#security#Key#getEncoded_E@ in PKCS#8 and X.509 format respectively. key2 with the private key authorized to be used only for signing using the PKCS#1 signature padding scheme with SHA-256 digest and only if the user has been authenticated within the last ten minutes. The use of the public key is unrestricted (see Known Issues). Both the private and the public key must export their key material via @B_java#security#Key#getEncoded_E@ in PKCS#8 and X.509 format respectively. key2 with the private key authorized to be used only for decryption using the PKCS#1 encryption padding scheme. The use of public key is unrestricted, thus permitting encryption using any padding schemes and digests. Both the private and the public key must export their key material via @B_java#security#Key#getEncoded_E@ in PKCS#8 and X.509 format respectively."}