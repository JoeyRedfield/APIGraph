{"Functions": {"Web()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "Web ()"}, "onWebView(org.hamcrest.Matcher<android.view.View>)": {"Returns": [["@B_android#support#test#espresso#web#sugar#Web#WebInteraction_E@", "no returns description in source"]], "Parameters": [["Matcher", "Matcher no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "WebInteraction<Void> onWebView (Matcher<View> viewMatcher)"}, "onWebView()": {"Returns": [["@B_android#support#test#espresso#web#sugar#Web#WebInteraction_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "WebInteraction<Void> onWebView ()"}}, "Inheritance": ["https:##developer#android#com@B_java#lang#Object_E@"], "ClassName": "android.support.test.espresso.web.sugar.Web", "ClassDesc": "An Entry Point to work with WebViews on Android. Similar to onData, WebView interactions are actually composed of several ViewActions. However they need to be properly orchestrated and are quite verbose. Web and WebInteraction wrap this boilerplate and give an Espresso like feel to interacting with WebViews. WebView interactions constantly cross the Java/Javascript boundary to do their work, since there is no chance of introducing race conditions by exposing data from the Javascript environment (everything we see on the Java side is an isolated copy), returning data from WebInteractions is fully supported."}