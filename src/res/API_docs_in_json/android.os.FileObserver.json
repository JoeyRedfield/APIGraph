{"Functions": {"FileObserver(java.io.File,int)": {"Returns": [], "Parameters": [["@B_java#io#File_E@", "File: The file or directory to monitor This value must never be null."], ["int", "int: The event or events (added together) to watch for Value is either 0 or a combination of @B_android#os#FileObserver#ACCESS_E@, @B_android#os#FileObserver#MODIFY_E@, @B_android#os#FileObserver#ATTRIB_E@, @B_android#os#FileObserver#CLOSE_WRITE_E@, @B_android#os#FileObserver#CLOSE_NOWRITE_E@, @B_android#os#FileObserver#OPEN_E@, @B_android#os#FileObserver#MOVED_FROM_E@, @B_android#os#FileObserver#MOVED_TO_E@, @B_android#os#FileObserver#CREATE_E@, @B_android#os#FileObserver#DELETE_E@, @B_android#os#FileObserver#DELETE_SELF_E@, and @B_android#os#FileObserver#MOVE_SELF_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new file observer for a certain file or directory. Monitoring does not start on creation! You must call @B_android#os#FileObserver#startWatching_E@ before you will receive events.", "history": "Added in API level 29", "FullName": "public FileObserver (File file, int mask)"}, "FileObserver(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#os#FileObserver#FileObserver_E@ instead. Equivalent to FileObserver(path, FileObserver.ALL_EVENTS).", "history": "Added in API level 1", "FullName": "public FileObserver (String path)"}, "FileObserver(java.io.File)": {"Returns": [], "Parameters": [["@B_java#io#File_E@", "File: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to FileObserver(file, FileObserver.ALL_EVENTS).", "history": "Added in API level 29", "FullName": "public FileObserver (File file)"}, "onEvent(int,java.lang.String)": {"Returns": [], "Parameters": [["int", "int: The type of event which happened"], ["@B_java#lang#String_E@", "String: The path, relative to the main monitored file or directory, of the file or directory which triggered the event. This value can be null for certain events, such as @B_android#os#FileObserver#MOVE_SELF_E@. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The event handler, which must be implemented by subclasses. This method is invoked on a special FileObserver thread. It runs independently of any threads, so take care to use appropriate synchronization! Consider using @B_android#os#Handler#post_E@ to shift event handling work to the main thread to avoid concurrency problems. Event handlers must not throw exceptions.", "history": "Added in API level 1", "FullName": "public abstract void onEvent (int event, String path)"}, "onEvent(int, java.lang.String)": {"Returns": [], "Parameters": [["int", "int: The type of event which happened"], ["@B_java#lang#String_E@", "String: The path, relative to the main monitored file or directory, of the file or directory which triggered the event. This value can be null for certain events, such as @B_android#os#FileObserver#MOVE_SELF_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The event handler, which must be implemented by subclasses. This method is invoked on a special FileObserver thread. It runs independently of any threads, so take care to use appropriate synchronization! Consider using @B_android#os#Handler#post_E@ to shift event handling work to the main thread to avoid concurrency problems. Event handlers must not throw exceptions.", "history": "added in API level 1", "FullName": "public abstract void onEvent (int event, String path)"}, "startWatching()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Start watching for events. The monitored file or directory must exist at this time, or else no events will be reported (even if it appears later). If monitoring is already started, this call has no effect.", "history": "Added in API level 1", "FullName": "public void startWatching ()"}, "FileObserver(java.lang.String,int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The file or directory to monitor"], ["int", "int: The event or events (added together) to watch for Value is either 0 or a combination of @B_android#os#FileObserver#ACCESS_E@, @B_android#os#FileObserver#MODIFY_E@, @B_android#os#FileObserver#ATTRIB_E@, @B_android#os#FileObserver#CLOSE_WRITE_E@, @B_android#os#FileObserver#CLOSE_NOWRITE_E@, @B_android#os#FileObserver#OPEN_E@, @B_android#os#FileObserver#MOVED_FROM_E@, @B_android#os#FileObserver#MOVED_TO_E@, @B_android#os#FileObserver#CREATE_E@, @B_android#os#FileObserver#DELETE_E@, @B_android#os#FileObserver#DELETE_SELF_E@, and @B_android#os#FileObserver#MOVE_SELF_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#os#FileObserver#FileObserver_E@ instead. Create a new file observer for a certain file or directory. Monitoring does not start on creation! You must call @B_android#os#FileObserver#startWatching_E@ before you will receive events.", "history": "Added in API level 1", "FullName": "public FileObserver (String path, int mask)"}, "FileObserver(java.util.List<java.io.File>,int)": {"Returns": [], "Parameters": [["@B_java#util#List_E@", "List: The files or directories to monitor This value must never be null."], ["int", "int: The event or events (added together) to watch for Value is either 0 or a combination of @B_android#os#FileObserver#ACCESS_E@, @B_android#os#FileObserver#MODIFY_E@, @B_android#os#FileObserver#ATTRIB_E@, @B_android#os#FileObserver#CLOSE_WRITE_E@, @B_android#os#FileObserver#CLOSE_NOWRITE_E@, @B_android#os#FileObserver#OPEN_E@, @B_android#os#FileObserver#MOVED_FROM_E@, @B_android#os#FileObserver#MOVED_TO_E@, @B_android#os#FileObserver#CREATE_E@, @B_android#os#FileObserver#DELETE_E@, @B_android#os#FileObserver#DELETE_SELF_E@, and @B_android#os#FileObserver#MOVE_SELF_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Version of @B_android#os#FileObserver#FileObserver_E@ that allows callers to monitor multiple files or directories.", "history": "Added in API level 29", "FullName": "public FileObserver (List<File> files, int mask)"}, "FileObserver(java.util.List<java.io.File>)": {"Returns": [], "Parameters": [["@B_java#util#List_E@", "List: The files or directories to monitor This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to FileObserver(paths, FileObserver.ALL_EVENTS).", "history": "Added in API level 29", "FullName": "public FileObserver (List<File> files)"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 1", "FullName": "protected void finalize ()"}, "FileObserver(java.lang.String, int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The file or directory to monitor"], ["int", "int: The event or events (added together) to watch for"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new file observer for a certain file or directory. Monitoring does not start on creation! You must call @B_android#os#FileObserver#startWatching_E@ before you will receive events.", "history": "added in API level 1", "FullName": "public FileObserver (String path, int mask)"}, "stopWatching()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Stop watching for events. Some events may be in process, so events may continue to be reported even after this method completes. If monitoring is already stopped, this call has no effect.", "history": "Added in API level 1", "FullName": "public void stopWatching ()"}}, "Inheritance": [], "ClassName": "android.os.FileObserver", "ClassDesc": "Monitors files (using @B_android#os#FileObserver#onEvent_E@. Each FileObserver instance can monitor multiple files or directories. If a directory is monitored, events will be triggered for all files and subdirectories inside the monitored directory. An event mask is used to specify which changes or actions to report. Event type constants are used to describe the possible changes in the event mask as well as what actually happened in event callbacks."}