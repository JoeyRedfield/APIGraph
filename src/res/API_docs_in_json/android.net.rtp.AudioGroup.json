{"Functions": {"getStreams()": {"Returns": [["@B_android#net#rtp#AudioStream_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the @B_android#net#rtp#AudioStream_E@s in this group.", "history": "Added in API level 12", "FullName": "public AudioStream[] getStreams ()"}, "clear()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes every @B_android#net#rtp#AudioStream_E@ in this group.", "history": "Added in API level 12", "FullName": "public void clear ()"}, "AudioGroup()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates an empty AudioGroup.", "history": "Added in API level 12", "FullName": "public AudioGroup ()"}, "getMode()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current mode.", "history": "Added in API level 12", "FullName": "public int getMode ()"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#Throwable_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 12", "FullName": "protected void finalize ()"}, "sendDtmf(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the event is invalid."]], "SeeAlso": [], "Permissions": [], "Description": "Sends a DTMF digit to every @B_android#net#rtp#AudioStream_E@ in this group. Currently only event 0 to 15 are supported.", "history": "Added in API level 12", "FullName": "public void sendDtmf (int event)"}, "setMode(int)": {"Returns": [], "Parameters": [["int", "int: The mode to change to."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the mode is invalid."]], "SeeAlso": [], "Permissions": [], "Description": "Changes the current mode. It must be one of @B_android#net#rtp#AudioGroup#MODE_ON_HOLD_E@, @B_android#net#rtp#AudioGroup#MODE_MUTED_E@, @B_android#net#rtp#AudioGroup#MODE_NORMAL_E@, and @B_android#net#rtp#AudioGroup#MODE_ECHO_SUPPRESSION_E@.", "history": "Added in API level 12", "FullName": "public void setMode (int mode)"}}, "Inheritance": [], "ClassName": "android.net.rtp.AudioGroup", "ClassDesc": "An AudioGroup is an audio hub for the speaker, the microphone, and @B_android#net#rtp#AudioStream_E@s. Each of these components can be logically turned on or off by calling @B_android#net#rtp#AudioGroup#setMode_E@ or @B_android#net#rtp#RtpStream#setMode_E@. The AudioGroup will go through these components and process them one by one within its execution loop. The loop consists of four steps. First, for each AudioStream not in @B_android#net#rtp#RtpStream#MODE_SEND_ONLY_E@, decodes its incoming packets and stores in its buffer. Then, if the microphone is enabled, processes the recorded audio and stores in its buffer. Third, if the speaker is enabled, mixes all AudioStream buffers and plays back. Finally, for each AudioStream not in @B_android#net#rtp#RtpStream#MODE_RECEIVE_ONLY_E@, mixes all other buffers and sends back the encoded packets. An AudioGroup does nothing if there is no AudioStream in it. Few things must be noticed before using these classes. The performance is highly related to the system load and the network bandwidth. Usually a simpler @B_android#net#rtp#AudioCodec_E@ costs fewer CPU cycles but requires more network bandwidth, and vise versa. Using two AudioStreams at the same time doubles not only the load but also the bandwidth. The condition varies from one device to another, and developers should choose the right combination in order to get the best result. It is sometimes useful to keep multiple AudioGroups at the same time. For example, a Voice over IP (VoIP) application might want to put a conference call on hold in order to make a new call but still allow people in the conference call talking to each other. This can be done easily using two AudioGroups, but there are some limitations. Since the speaker and the microphone are globally shared resources, only one AudioGroup at a time is allowed to run in a mode other than @B_android#net#rtp#AudioGroup#MODE_ON_HOLD_E@. The others will be unable to acquire these resources and fail silently. Using this class requires @B_android#Manifest#permission#RECORD_AUDIO_E@ permission. Developers should set the audio mode to @B_android#media#AudioManager#MODE_IN_COMMUNICATION_E@ using @B_android#media#AudioManager#setMode_E@ and change it back when none of the AudioGroups is in use."}