{"Functions": {"requestDisallowInterceptTouchEvent(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the child does not want the parent to intercept touch events."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child does not want this parent and its ancestors to intercept touch events with @B_android#view#ViewGroup#onInterceptTouchEvent_E@. This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel.", "history": "", "FullName": "void requestDisallowInterceptTouchEvent (boolean disallowIntercept)"}, "getSuggestedMinimumWidth()": {"Returns": [["int", "The suggested minimum width of the view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the suggested minimum width that the view should use. This returns the maximum of the view's minimum width and the background's minimum width (@B_android#graphics#drawable#Drawable#getMinimumWidth_E@). When being used in @B_android#view#View#onMeasure_E@, the caller should still ensure the returned width is within the requirements of the parent.", "history": "", "FullName": "int getSuggestedMinimumWidth ()"}, "onStopNestedScroll(android.view.View, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["int", "int: the type of input which cause this scroll event"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll operation ending. Perform cleanup after a nested scrolling operation. This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a @B_android#view#MotionEvent#ACTION_UP_E@ or @B_android#view#MotionEvent#ACTION_CANCEL_E@ event. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "added in version 26.0.0-beta2", "FullName": "void onStopNestedScroll (View target, int type)"}, "generateLayoutParams(android.util.AttributeSet)": {"Returns": [["@B_android#support#design#widget#CoordinatorLayout#LayoutParams_E@", "an instance of @B_android#view#ViewGroup#LayoutParams_E@ or one of its descendants"]], "Parameters": [["@B_android#util#AttributeSet_E@", "AttributeSet: the attributes to build the layout parameters from"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a new set of layout parameters based on the supplied attributes set.", "history": "", "FullName": "CoordinatorLayout.LayoutParams generateLayoutParams (AttributeSet attrs)"}, "setFitsSystemWindows(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: If true, then the default implementation of @B_android#view#View#fitSystemWindows_E@ will be executed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets whether or not this view should account for system screen decorations such as the status bar and inset its content; that is, controlling whether the default implementation of @B_android#view#View#fitSystemWindows_E@ will be executed. See that method for more details. Note that if you are providing your own implementation of @B_android#view#View#fitSystemWindows_E@, then there is no need to set this flag to true -- your implementation will be overriding the default implementation that checks this flag.", "history": "", "FullName": "void setFitsSystemWindows (boolean fitSystemWindows)"}, "getNestedScrollAxes()": {"Returns": [["int", "Flags indicating the current axes of nested scrolling"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the current axes of nested scrolling for this ViewGroup. A ViewGroup returning something other than @B_android#view#View#SCROLL_AXIS_NONE_E@ is currently acting as a nested scrolling parent for one or more descendant views in the hierarchy.", "history": "", "FullName": "int getNestedScrollAxes ()"}, "onStopNestedScroll(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll operation ending. Perform cleanup after a nested scrolling operation. This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a @B_android#view#MotionEvent#ACTION_UP_E@ or @B_android#view#MotionEvent#ACTION_CANCEL_E@ event. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "", "FullName": "void onStopNestedScroll (View target)"}, "getDependencies(android.view.View)": {"Returns": [["@B_java#util#List_E@", "the list of views which child depends on."]], "Parameters": [["@B_android#view#View_E@", "View: the view to find dependencies for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the list of views which the provided view depends on. Do not store this list as its contents may not be valid beyond the caller.", "history": "added in version 22.2.0", "FullName": "List<View> getDependencies (View child)"}, "getStatusBarBackground()": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "The status bar background drawable, or null if none set"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the drawable used to draw in the insets area for the status bar.", "history": "added in version 22.2.0", "FullName": "Drawable getStatusBarBackground ()"}, "onLayout(boolean, int, int, int, int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "added in version 22.2.0", "FullName": "void onLayout (boolean changed, int l, int t, int r, int b)"}, "setStatusBarBackgroundColor(int)": {"Returns": [], "Parameters": [["int", "int: Color to use as a background drawable to draw behind the status bar in 0xAARRGGBB format."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a drawable to draw in the insets area for the status bar. Note that this will only be activated if this DrawerLayout fitsSystemWindows.", "history": "added in version 22.2.0", "FullName": "void setStatusBarBackgroundColor (int color)"}, "onInterceptTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true to steal motion events from the children and have them dispatched to this ViewGroup through onTouchEvent(). The current target will receive an ACTION_CANCEL event, and no further messages will be delivered here."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event being dispatched down the hierarchy."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to intercept all touch screen motion events. This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point. Using this function takes some care, as it has a fairly complicated interaction with @B_android#view#View#onTouchEvent_E@, and using it requires implementing that method as well as this one in the correct way. Events will be received in the following order:", "history": "", "FullName": "boolean onInterceptTouchEvent (MotionEvent ev)"}, "onMeasure(int, int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "", "FullName": "void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "setStatusBarBackgroundResource(int)": {"Returns": [], "Parameters": [["int", "int: Resource id of a background drawable to draw behind the status bar"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a drawable to draw in the insets area for the status bar. Note that this will only be activated if this DrawerLayout fitsSystemWindows.", "history": "added in version 22.2.0", "FullName": "void setStatusBarBackgroundResource (int resId)"}, "getDependents(android.view.View)": {"Returns": [["@B_java#util#List_E@", "the list of views which depend on child."]], "Parameters": [["@B_android#view#View_E@", "View: the view to find dependents of."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the list of views which depend on the provided view. Do not store this list as its contents may not be valid beyond the caller.", "history": "added in version 24.2.0", "FullName": "List<View> getDependents (View child)"}, "onDetachedFromWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is detached from a window. At this point it no longer has a surface for drawing.", "history": "added in version 22.2.0", "FullName": "void onDetachedFromWindow ()"}, "getSuggestedMinimumHeight()": {"Returns": [["int", "The suggested minimum height of the view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the suggested minimum height that the view should use. This returns the maximum of the view's minimum height and the background's minimum height (@B_android#graphics#drawable#Drawable#getMinimumHeight_E@). When being used in @B_android#view#View#onMeasure_E@, the caller should still ensure the returned height is within the requirements of the parent.", "history": "", "FullName": "int getSuggestedMinimumHeight ()"}, "verifyDrawable(android.graphics.drawable.Drawable)": {"Returns": [["boolean", "boolean If true than the Drawable is being displayed in the view; else false and it is not allowed to animate."]], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: The Drawable to verify. Return true if it is one you are displaying, else return the result of calling through to the super class."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying. This allows animations for those drawables to be scheduled. Be sure to call through to the super class when overriding this function.", "history": "", "FullName": "boolean verifyDrawable (Drawable who)"}, "onRestoreInstanceState(android.os.Parcelable)": {"Returns": [], "Parameters": [["@B_android#os#Parcelable_E@", "Parcelable: The frozen state that had previously been returned by @B_android#support#design#widget#CoordinatorLayout#onSaveInstanceState_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to re-apply a representation of its internal state that had previously been generated by @B_android#view#View#onSaveInstanceState_E@. This function will never be called with a null state.", "history": "", "FullName": "void onRestoreInstanceState (Parcelable state)"}, "drawableStateChanged()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown. If the View has a StateListAnimator, it will also be called to run necessary state change animations. Be sure to call through to the superclass when overriding this function.", "history": "", "FullName": "void drawableStateChanged ()"}, "isPointInChildBounds(android.view.View, int, int)": {"Returns": [["boolean", "true if the point is within the child view's bounds, false otherwise"]], "Parameters": [["@B_android#view#View_E@", "View: child view to test"], ["int", "int: X coordinate to test, in the CoordinatorLayout's coordinate system"], ["int", "int: Y coordinate to test, in the CoordinatorLayout's coordinate system"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if a given point in the CoordinatorLayout's coordinates are within the view bounds of the given direct child view.", "history": "added in version 22.2.0", "FullName": "boolean isPointInChildBounds (View child, int x, int y)"}, "onDraw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: the canvas on which the background will be drawn"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to do your drawing.", "history": "added in version 22.2.0", "FullName": "void onDraw (Canvas c)"}, "onLayoutChild(android.view.View, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: child view to lay out"], ["int", "int: the resolved layout direction for the CoordinatorLayout, such as @B_android#support#v4#view#ViewCompat#LAYOUT_DIRECTION_LTR_E@ or @B_android#support#v4#view#ViewCompat#LAYOUT_DIRECTION_RTL_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called to lay out each individual child view unless a @B_android#support#design#widget#CoordinatorLayout#Behavior_E@ is present. The Behavior may choose to delegate child measurement to this method.", "history": "added in version 22.2.0", "FullName": "void onLayoutChild (View child, int layoutDirection)"}, "setVisibility(int)": {"Returns": [], "Parameters": [["int", "int: One of @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the visibility state of this view.", "history": "", "FullName": "void setVisibility (int visibility)"}, "onTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle touch screen motion events. If this method is used to detect click actions, it is recommended that the actions be performed by implementing and calling @B_android#view#View#performClick_E@. This will ensure consistent system behavior, including: obeying click sound preferences dispatching OnClickListener calls handling @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_CLICK_E@ when accessibility features are enabled", "history": "", "FullName": "boolean onTouchEvent (MotionEvent ev)"}, "onSaveInstanceState()": {"Returns": [["@B_android#os#Parcelable_E@", "Returns a Parcelable object containing the view's current dynamic state, or null if there is nothing interesting to save."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view.", "history": "", "FullName": "Parcelable onSaveInstanceState ()"}, "onNestedPreFling(android.view.View, float, float)": {"Returns": [["boolean", "true if this parent consumed the fling ahead of the target view"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested fling before the target view consumes it. This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling parent is consuming motion as part of a @B_android#view#ViewParent#onNestedPreScroll_E@, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well.", "history": "", "FullName": "boolean onNestedPreFling (View target, float velocityX, float velocityY)"}, "dispatchDependentViewsChanged(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the View to find dependents of to dispatch the call."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Allows the caller to manually dispatch @B_android#support#design#widget#CoordinatorLayout#Behavior#onDependentViewChanged_E@ to the associated @B_android#support#design#widget#CoordinatorLayout#Behavior_E@ instances of views which depend on the provided @B_android#view#View_E@. You should not normally need to call this method as the it will be automatically done when the view has changed.", "history": "added in version 22.2.0", "FullName": "void dispatchDependentViewsChanged (View view)"}, "generateDefaultLayoutParams()": {"Returns": [["@B_android#support#design#widget#CoordinatorLayout#LayoutParams_E@", "a set of default layout parameters or null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a set of default layout parameters. These parameters are requested when the View passed to @B_android#view#ViewGroup#addView_E@ has no layout parameters already set. If null is returned, an exception is thrown from addView.", "history": "", "FullName": "CoordinatorLayout.LayoutParams generateDefaultLayoutParams ()"}, "onAttachedToWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before @B_android#view#View#onDraw_E@, however it may be called any time before the first onDraw -- including before or after @B_android#view#View#onMeasure_E@.", "history": "added in version 22.2.0", "FullName": "void onAttachedToWindow ()"}, "CoordinatorLayout(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.2.0", "FullName": "CoordinatorLayout (Context context)"}}, "Inheritance": ["java.lang.Object", "https:##developer#android#com@B_android#view#View_E@", "https:##developer#android#com@B_android#view#ViewGroup_E@"], "ClassName": "android.support.design.widget.CoordinatorLayout", "ClassDesc": "CoordinatorLayout is a super-powered https:##developer#android#com@B_android#widget#FrameLayout_E@. CoordinatorLayout is intended for two primary use cases: By specifying @B_android#support#design#widget#CoordinatorLayout#Behavior_E@ for child views of a CoordinatorLayout you can provide many different interactions within a single parent and those views can also interact with one another. View classes can specify a default behavior when used as a child of a CoordinatorLayout using the @B_android#support#design#widget#CoordinatorLayout#DefaultBehavior_E@ annotation. Behaviors may be used to implement a variety of interactions and additional layout modifications ranging from sliding drawers and panels to swipe-dismissable elements and buttons that stick to other elements as they move and animate. Children of a CoordinatorLayout may have an @B_android#support#design#widget#CoordinatorLayout#LayoutParams#setAnchorId_E@. This view id must correspond to an arbitrary descendant of the CoordinatorLayout, but it may not be the anchored child itself or a descendant of the anchored child. This can be used to place floating views relative to other arbitrary content panes. Children can specify @B_android#support#design#widget#CoordinatorLayout#LayoutParams#insetEdge_E@ to describe how the view insets the CoordinatorLayout. Any child views which are set to dodge the same inset edges by @B_android#support#design#widget#CoordinatorLayout#LayoutParams#dodgeInsetEdges_E@ will be moved appropriately so that the views do not overlap."}