{"Functions": {"openUdpEncapsulationSocket()": {"Returns": [["@B_android#net#IpSecManager#UdpEncapsulationSocket_E@", "a socket that is bound to a local port This value will never be null."]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", "indicating that the socket could not be opened or bound"], ["@B_android#net#IpSecManager#ResourceUnavailableException_E@", "indicating that too many encapsulation sockets are open"]], "SeeAlso": [], "Permissions": [], "Description": "Open a socket for UDP encapsulation. See @B_android#net#IpSecManager#UdpEncapsulationSocket_E@ for the proper way to close the returned socket. The local port of the returned socket can be obtained by calling @B_android#net#IpSecManager#UdpEncapsulationSocket#getPort_E@.", "history": "Added in API level 28", "FullName": "public IpSecManager.UdpEncapsulationSocket openUdpEncapsulationSocket ()"}, "allocateSecurityParameterIndex(java.net.InetAddress)": {"Returns": [["@B_android#net#IpSecManager#SecurityParameterIndex_E@", "the reserved SecurityParameterIndex This value will never be null."]], "Parameters": [["@B_java#net#InetAddress_E@", "InetAddress: the destination address for traffic bearing the requested SPI. For inbound traffic, the destination should be an address currently assigned on-device. This value must never be null."]], "Throws": [["", "#ResourceUnavailableException} indicating that too many SPIs are currently allocated for this user"], ["@B_android#net#IpSecManager#ResourceUnavailableException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Reserve a random SPI for traffic bound to or from the specified destination address. If successful, this SPI is guaranteed available until released by a call to @B_android#net#IpSecManager#SecurityParameterIndex#close_E@.", "history": "Added in API level 28", "FullName": "public IpSecManager.SecurityParameterIndex allocateSecurityParameterIndex (InetAddress destinationAddress)"}, "removeTransportModeTransforms(java.io.FileDescriptor)": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: a socket that previously had a transform applied to it This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "indicating that the transform could not be removed from the socket"]], "SeeAlso": [], "Permissions": [], "Description": "Remove an IPsec transform from a socket. Once removed, traffic on the socket will not be encrypted. Removing transforms from a socket allows the socket to be reused for communication in the clear. If an IpSecTransform object applied to this socket was deallocated by calling @B_android#net#IpSecTransform#close_E@, then communication on the socket will fail until this method is called.", "history": "Added in API level 28", "FullName": "public void removeTransportModeTransforms (FileDescriptor socket)"}, "applyTransportModeTransform(java.net.DatagramSocket,int,android.net.IpSecTransform)": {"Returns": [], "Parameters": [["@B_java#net#DatagramSocket_E@", "DatagramSocket: a datagram socket This value must never be null."], ["int", "int: the direction in which the transform should be applied Value is @B_android#net#IpSecManager#DIRECTION_IN_E@, or @B_android#net#IpSecManager#DIRECTION_OUT_E@"], ["@B_android#net#IpSecTransform_E@", "IpSecTransform: a transport mode IpSecTransform This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "indicating that the transform could not be applied"]], "SeeAlso": [], "Permissions": [], "Description": "Apply an IPsec transform to a datagram socket. This applies transport mode encapsulation to the given socket. Once applied, I/O on the socket will be encapsulated according to the parameters of the IpSecTransform. When the transform is removed from the socket by calling @B_android#net#IpSecManager#removeTransportModeTransforms_E@, unprotected traffic can resume on that socket. For security reasons, the destination address of any traffic on the socket must match the remote InetAddress of the IpSecTransform. Attempts to send traffic to any other IP address will result in an IOException. In addition, reads and writes on the socket will throw IOException if the user deactivates the transform (by calling @B_android#net#IpSecTransform#close_E@) without calling @B_android#net#IpSecManager#removeTransportModeTransforms_E@. When applying a new tranform to a socket in the outbound direction, the previous transform will be removed and the new transform will take effect immediately, sending all traffic on the new transform; however, when applying a transform in the inbound direction, traffic on the old transform will continue to be decrypted and delivered until that transform is deallocated by calling @B_android#net#IpSecTransform#close_E@. This overlap allows lossless rekey procedures where both transforms are valid until both endpoints are using the new transform and all in-flight packets have been received.", "history": "Added in API level 28", "FullName": "public void applyTransportModeTransform (DatagramSocket socket, int direction, IpSecTransform transform)"}, "applyTransportModeTransform(java.net.Socket,int,android.net.IpSecTransform)": {"Returns": [], "Parameters": [["@B_java#net#Socket_E@", "Socket: a stream socket This value must never be null."], ["int", "int: the direction in which the transform should be applied Value is @B_android#net#IpSecManager#DIRECTION_IN_E@, or @B_android#net#IpSecManager#DIRECTION_OUT_E@"], ["@B_android#net#IpSecTransform_E@", "IpSecTransform: a transport mode IpSecTransform This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "indicating that the transform could not be applied"]], "SeeAlso": [], "Permissions": [], "Description": "Apply an IPsec transform to a stream socket. This applies transport mode encapsulation to the given socket. Once applied, I/O on the socket will be encapsulated according to the parameters of the IpSecTransform. When the transform is removed from the socket by calling @B_android#net#IpSecManager#removeTransportModeTransforms_E@, unprotected traffic can resume on that socket. For security reasons, the destination address of any traffic on the socket must match the remote InetAddress of the IpSecTransform. Attempts to send traffic to any other IP address will result in an IOException. In addition, reads and writes on the socket will throw IOException if the user deactivates the transform (by calling @B_android#net#IpSecTransform#close_E@) without calling @B_android#net#IpSecManager#removeTransportModeTransforms_E@. Note that when applied to TCP sockets, calling @B_android#net#IpSecTransform#close_E@ on an applied transform before completion of graceful shutdown may result in the shutdown sequence failing to complete. As such, applications requiring graceful shutdown MUST close the socket prior to deactivating the applied transform. Socket closure may be performed asynchronously (in batches), so the returning of a close function does not guarantee shutdown of a socket. Setting an SO_LINGER timeout results in socket closure being performed synchronously, and is sufficient to ensure shutdown. Specifically, if the transform is deactivated (by calling @B_android#net#IpSecTransform#close_E@), prior to the socket being closed, the standard [FIN - FIN/ACK - ACK], or the reset [RST] packets are dropped due to the lack of a valid Transform. Similarly, if a socket without the SO_LINGER option set is closed, the delayed/batched FIN packets may be dropped. When applying a new tranform to a socket in the outbound direction, the previous transform will be removed and the new transform will take effect immediately, sending all traffic on the new transform; however, when applying a transform in the inbound direction, traffic on the old transform will continue to be decrypted and delivered until that transform is deallocated by calling @B_android#net#IpSecTransform#close_E@. This overlap allows lossless rekey procedures where both transforms are valid until both endpoints are using the new transform and all in-flight packets have been received.", "history": "Added in API level 28", "FullName": "public void applyTransportModeTransform (Socket socket, int direction, IpSecTransform transform)"}, "allocateSecurityParameterIndex(java.net.InetAddress,int)": {"Returns": [["@B_android#net#IpSecManager#SecurityParameterIndex_E@", "the reserved SecurityParameterIndex This value will never be null."]], "Parameters": [["@B_java#net#InetAddress_E@", "InetAddress: the destination address for traffic bearing the requested SPI. For inbound traffic, the destination should be an address currently assigned on-device. This value must never be null."], ["int", "int: the requested SPI. The range 1-255 is reserved and may not be used. See RFC 4303 Section 2.1."]], "Throws": [["", "#ResourceUnavailableException} indicating that too many SPIs are currently allocated for this user"], ["", "#SpiUnavailableException} indicating that the requested SPI could not be reserved"], ["@B_android#net#IpSecManager#ResourceUnavailableException_E@", ""], ["@B_android#net#IpSecManager#SpiUnavailableException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Reserve the requested SPI for traffic bound to or from the specified destination address. If successful, this SPI is guaranteed available until released by a call to @B_android#net#IpSecManager#SecurityParameterIndex#close_E@.", "history": "Added in API level 28", "FullName": "public IpSecManager.SecurityParameterIndex allocateSecurityParameterIndex (InetAddress destinationAddress, int requestedSpi)"}, "removeTransportModeTransforms(java.net.Socket)": {"Returns": [], "Parameters": [["@B_java#net#Socket_E@", "Socket: a socket that previously had a transform applied to it This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "indicating that the transform could not be removed from the socket"]], "SeeAlso": [], "Permissions": [], "Description": "Remove an IPsec transform from a stream socket. Once removed, traffic on the socket will not be encrypted. Removing transforms from a socket allows the socket to be reused for communication in the clear. If an IpSecTransform object applied to this socket was deallocated by calling @B_android#net#IpSecTransform#close_E@, then communication on the socket will fail until this method is called.", "history": "Added in API level 28", "FullName": "public void removeTransportModeTransforms (Socket socket)"}, "openUdpEncapsulationSocket(int)": {"Returns": [["@B_android#net#IpSecManager#UdpEncapsulationSocket_E@", "a socket that is bound to the given port This value will never be null."]], "Parameters": [["int", "int: a local UDP port"]], "Throws": [["@B_java#io#IOException_E@", "indicating that the socket could not be opened or bound"], ["@B_android#net#IpSecManager#ResourceUnavailableException_E@", "indicating that too many encapsulation sockets are open"]], "SeeAlso": [], "Permissions": [], "Description": "Open a socket for UDP encapsulation and bind to the given port. See @B_android#net#IpSecManager#UdpEncapsulationSocket_E@ for the proper way to close the returned socket.", "history": "Added in API level 28", "FullName": "public IpSecManager.UdpEncapsulationSocket openUdpEncapsulationSocket (int port)"}, "applyTransportModeTransform(java.io.FileDescriptor,int,android.net.IpSecTransform)": {"Returns": [], "Parameters": [["@B_java#io#FileDescriptor_E@", "FileDescriptor: a socket file descriptor This value must never be null."], ["int", "int: the direction in which the transform should be applied Value is @B_android#net#IpSecManager#DIRECTION_IN_E@, or @B_android#net#IpSecManager#DIRECTION_OUT_E@"], ["@B_android#net#IpSecTransform_E@", "IpSecTransform: a transport mode IpSecTransform This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "indicating that the transform could not be applied"]], "SeeAlso": [], "Permissions": [], "Description": "Apply an IPsec transform to a socket. This applies transport mode encapsulation to the given socket. Once applied, I/O on the socket will be encapsulated according to the parameters of the IpSecTransform. When the transform is removed from the socket by calling @B_android#net#IpSecManager#removeTransportModeTransforms_E@, unprotected traffic can resume on that socket. For security reasons, the destination address of any traffic on the socket must match the remote InetAddress of the IpSecTransform. Attempts to send traffic to any other IP address will result in an IOException. In addition, reads and writes on the socket will throw IOException if the user deactivates the transform (by calling @B_android#net#IpSecTransform#close_E@) without calling @B_android#net#IpSecManager#removeTransportModeTransforms_E@. Note that when applied to TCP sockets, calling @B_android#net#IpSecTransform#close_E@ on an applied transform before completion of graceful shutdown may result in the shutdown sequence failing to complete. As such, applications requiring graceful shutdown MUST close the socket prior to deactivating the applied transform. Socket closure may be performed asynchronously (in batches), so the returning of a close function does not guarantee shutdown of a socket. Setting an SO_LINGER timeout results in socket closure being performed synchronously, and is sufficient to ensure shutdown. Specifically, if the transform is deactivated (by calling @B_android#net#IpSecTransform#close_E@), prior to the socket being closed, the standard [FIN - FIN/ACK - ACK], or the reset [RST] packets are dropped due to the lack of a valid Transform. Similarly, if a socket without the SO_LINGER option set is closed, the delayed/batched FIN packets may be dropped. When applying a new tranform to a socket in the outbound direction, the previous transform will be removed and the new transform will take effect immediately, sending all traffic on the new transform; however, when applying a transform in the inbound direction, traffic on the old transform will continue to be decrypted and delivered until that transform is deallocated by calling @B_android#net#IpSecTransform#close_E@. This overlap allows lossless rekey procedures where both transforms are valid until both endpoints are using the new transform and all in-flight packets have been received.", "history": "Added in API level 28", "FullName": "public void applyTransportModeTransform (FileDescriptor socket, int direction, IpSecTransform transform)"}, "removeTransportModeTransforms(java.net.DatagramSocket)": {"Returns": [], "Parameters": [["@B_java#net#DatagramSocket_E@", "DatagramSocket: a socket that previously had a transform applied to it This value must never be null."]], "Throws": [["@B_java#io#IOException_E@", "indicating that the transform could not be removed from the socket"]], "SeeAlso": [], "Permissions": [], "Description": "Remove an IPsec transform from a datagram socket. Once removed, traffic on the socket will not be encrypted. Removing transforms from a socket allows the socket to be reused for communication in the clear. If an IpSecTransform object applied to this socket was deallocated by calling @B_android#net#IpSecTransform#close_E@, then communication on the socket will fail until this method is called.", "history": "Added in API level 28", "FullName": "public void removeTransportModeTransforms (DatagramSocket socket)"}}, "Inheritance": [], "ClassName": "android.net.IpSecManager", "ClassDesc": "This class contains methods for managing IPsec sessions. Once configured, the kernel will apply confidentiality (encryption) and integrity (authentication) to IP traffic. Note that not all aspects of IPsec are permitted by this API. Applications may create transport mode security associations and apply them to individual sockets. Applications looking to create a VPN should use @B_android#net#VpnService_E@."}