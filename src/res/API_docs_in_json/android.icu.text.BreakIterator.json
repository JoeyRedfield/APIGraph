{"Functions": {"getSentenceInstance(android.icu.util.ULocale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates sentence boundaries."]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: A Locale specifying the language of the text being analyzed."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static BreakIterator getSentenceInstance (ULocale where)"}, "setText(java.text.CharacterIterator)": {"Returns": [], "Parameters": [["@B_java#text#CharacterIterator_E@", "CharacterIterator: A CharacterIterator referring to the text to analyze with this BreakIterator (the iterator's current position is ignored, but its other state is significant)."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the iterator to analyze a new piece of text. This function resets the current iteration position to the beginning of the text. (The old iterator is dropped.)", "history": "Added in API level 24", "FullName": "public abstract void setText (CharacterIterator newText)"}, "preceding(int)": {"Returns": [["int", "The position of the last boundary position preceding \"offset\" (whether of not \"offset\" itself is a boundary position), or DONE if \"offset\" is the starting offset of the iterator."]], "Parameters": [["int", "int: The character position to start searching from."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the iterator's current iteration position to be the last boundary position preceding the specified position. (Whether the specified position is itself a boundary position or not doesn't matter-- this function always moves the iteration position to the last boundary before the specified position.) If the specified position is the starting position, returns DONE.", "history": "Added in API level 24", "FullName": "public int preceding (int offset)"}, "getRuleStatusVec(int[])": {"Returns": [["int", "The number of rule status values from rules that determined the the boundary at the current iteration position. In the event that the array is too small, the return value is the total number of status values that were available, not the reduced number that were actually returned."]], "Parameters": [["int[]", "int: an array to be filled in with the status values."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "For RuleBasedBreakIterators, get the status (tag) values from the break rule(s) that determined the the boundary at the current iteration position. For break iterator types that do not support rule status, no values are returned. If the size of the output array is insufficient to hold the data, the output will be truncated to the available length. No exception will be thrown.", "history": "Added in API level 24", "FullName": "public int getRuleStatusVec (int[] fillInArray)"}, "getCharacterInstance(android.icu.util.ULocale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates logical-character boundaries."]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: A Locale specifying the language of the text being analyzed."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static BreakIterator getCharacterInstance (ULocale where)"}, "getCharacterInstance(java.util.Locale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates logical-character boundaries."]], "Parameters": [["@B_java#util#Locale_E@", "Locale: A Locale specifying the language of the text being analyzed."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a new instance of BreakIterator that locates logical-character boundaries.", "history": "Added in API level 24", "FullName": "public static BreakIterator getCharacterInstance (Locale where)"}, "next(int)": {"Returns": [["int", "The position of the boundary n boundaries from the current iteration position, or DONE if moving n boundaries causes the iterator to advance off either end of the text."]], "Parameters": [["int", "int: The number of boundaries to advance over (if positive, moves forward; if negative, moves backwards)."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Move the iterator by the specified number of steps in the text. A positive number moves the iterator forward; a negative number moves the iterator backwards. If this causes the iterator to move off either end of the text, this function returns DONE; otherwise, this function returns the position of the appropriate boundary. Calling this function is equivalent to calling next() or previous() n times.", "history": "Added in API level 24", "FullName": "public abstract int next (int n)"}, "next()": {"Returns": [["int", "The position of the first boundary position following the iteration position."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Advances the iterator forward one boundary. The current iteration position is updated to point to the next boundary position after the current position, and this is also the value that is returned. If the current position is equal to the value returned by last(), or to DONE, this function returns DONE and sets the current position to DONE.", "history": "Added in API level 24", "FullName": "public abstract int next ()"}, "getTitleInstance(android.icu.util.ULocale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates title boundaries."]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: A Locale specifying the language of the text being analyzed."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "@B_android#icu#text#BreakIterator#getWordInstance_E@", "history": "added in API level 24", "FullName": "public static BreakIterator getTitleInstance (ULocale where)"}, "getWordInstance()": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "An instance of BreakIterator that locates word boundaries."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a new instance of BreakIterator that locates word boundaries. This function assumes that the text being analyzed is in the default locale's language.", "history": "Added in API level 24", "FullName": "public static BreakIterator getWordInstance ()"}, "getSentenceInstance()": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates sentence boundaries."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a new instance of BreakIterator that locates sentence boundaries. This function assumes the text being analyzed is in the default locale's language.", "history": "Added in API level 24", "FullName": "public static BreakIterator getSentenceInstance ()"}, "getLineInstance(java.util.Locale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates legal line-wrapping positions."]], "Parameters": [["@B_java#util#Locale_E@", "Locale: A Locale specifying the language of the text being broken."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a new instance of BreakIterator that locates legal line- wrapping positions.", "history": "Added in API level 24", "FullName": "public static BreakIterator getLineInstance (Locale where)"}, "isBoundary(int)": {"Returns": [["boolean", "True if \"offset\" is a boundary position."]], "Parameters": [["int", "int: the offset to check."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if the specified position is a boundary position. If the function returns true, the current iteration position is set to the specified position; if the function returns false, the current iteration position is set as though following() had been called.", "history": "Added in API level 24", "FullName": "public boolean isBoundary (int offset)"}, "setText(java.lang.CharSequence)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: A CharSequence containing the text to analyze with this BreakIterator."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the iterator to analyze a new piece of text. The new piece of text is passed in as a CharSequence, and the current iteration position is reset to the beginning of the text. (The old text is dropped.) The text underlying the CharSequence must not be be modified while the BreakIterator holds a references to it. (As could possibly occur with a StringBuilder, for example).", "history": "Added in API level 29", "FullName": "public void setText (CharSequence newText)"}, "getTitleInstance()": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates title boundaries."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "on Android but not deprecated in ICU @B_android#icu#text#BreakIterator#getWordInstance_E@", "history": "Added in API level 24 Deprecated in API level 29", "FullName": "public static BreakIterator getTitleInstance ()"}, "setText(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: A String containing the text to analyze with this BreakIterator."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the iterator to analyze a new piece of text. The new piece of text is passed in as a String, and the current iteration position is reset to the beginning of the string. (The old text is dropped.)", "history": "Added in API level 24", "FullName": "public void setText (String newText)"}, "following(int)": {"Returns": [["int", "The position of the first boundary position following \"offset\" (whether or not \"offset\" itself is a boundary position), or DONE if \"offset\" is the past-the-end offset."]], "Parameters": [["int", "int: The character position to start searching from."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the iterator's current iteration position to be the first boundary position following the specified position. (Whether the specified position is itself a boundary position or not doesn't matter-- this function always moves the iteration position to the first boundary after the specified position.) If the specified position is the past-the-end position, returns DONE.", "history": "Added in API level 24", "FullName": "public abstract int following (int offset)"}, "getSentenceInstance(java.util.Locale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates sentence boundaries."]], "Parameters": [["@B_java#util#Locale_E@", "Locale: A Locale specifying the language of the text being analyzed."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a new instance of BreakIterator that locates sentence boundaries.", "history": "Added in API level 24", "FullName": "public static BreakIterator getSentenceInstance (Locale where)"}, "getRuleStatus()": {"Returns": [["int", "The status from the break rule that determined the boundary at the current iteration position."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "For RuleBasedBreakIterators, return the status tag from the break rule that determined the boundary at the current iteration position. For break iterator types that do not support a rule status, a default value of 0 is returned.", "history": "Added in API level 24", "FullName": "public int getRuleStatus ()"}, "getWordInstance(android.icu.util.ULocale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "An instance of BreakIterator that locates word boundaries."]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: A locale specifying the language of the text to be analyzed."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static BreakIterator getWordInstance (ULocale where)"}, "getCharacterInstance()": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates logical-character boundaries."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a new instance of BreakIterator that locates logical-character boundaries. This function assumes that the text being analyzed is in the default locale's language.", "history": "Added in API level 24", "FullName": "public static BreakIterator getCharacterInstance ()"}, "getText()": {"Returns": [["@B_java#text#CharacterIterator_E@", "A CharacterIterator over the text being analyzed."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a CharacterIterator over the text being analyzed. The returned CharacterIterator is a reference to the", "history": "Added in API level 24", "FullName": "public abstract CharacterIterator getText ()"}, "clone()": {"Returns": [["@B_java#lang#Object_E@", "The clone."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clone method. Creates another BreakIterator with the same behavior and current state as this one.", "history": "Added in API level 24", "FullName": "public Object clone ()"}, "current()": {"Returns": [["int", "The iterator's current position."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the iterator's current position.", "history": "Added in API level 24", "FullName": "public abstract int current ()"}, "BreakIterator()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default constructor. There is no state that is carried by this abstract base class.", "history": "Added in API level 24", "FullName": "protected BreakIterator ()"}, "getTitleInstance(java.util.Locale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates title boundaries."]], "Parameters": [["@B_java#util#Locale_E@", "Locale: A Locale specifying the language of the text being analyzed."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "on Android but not deprecated in ICU @B_android#icu#text#BreakIterator#getWordInstance_E@", "history": "Added in API level 24 Deprecated in API level 29", "FullName": "public static BreakIterator getTitleInstance (Locale where)"}, "previous()": {"Returns": [["int", "The position of the last boundary position preceding the iteration position."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Move the iterator backward one boundary. The current iteration position is updated to point to the last boundary position before the current position, and this is also the value that is returned. If the current position is equal to the value returned by first(), or to DONE, this function returns DONE and sets the current position to DONE.", "history": "Added in API level 24", "FullName": "public abstract int previous ()"}, "last()": {"Returns": [["int", "The character offset of the end of the stretch of text being broken."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the iterator to the last boundary position. This is always the \"past-the-end\" index of the text this iterator iterates over. For example, if the iterator iterates over a whole string (call it \"text\"), this function will always return text.length().", "history": "Added in API level 24", "FullName": "public abstract int last ()"}, "getLineInstance()": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates legal line-wrapping positions."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a new instance of BreakIterator that locates legal line- wrapping positions. This function assumes the text being broken is in the default locale's language.", "history": "Added in API level 24", "FullName": "public static BreakIterator getLineInstance ()"}, "first()": {"Returns": [["int", "The character offset of the beginning of the stretch of text being broken."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the iterator to the first boundary position. This is always the beginning index of the text this iterator iterates over. For example, if the iterator iterates over a whole string, this function will always return 0.", "history": "Added in API level 24", "FullName": "public abstract int first ()"}, "getWordInstance(java.util.Locale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "An instance of BreakIterator that locates word boundaries."]], "Parameters": [["@B_java#util#Locale_E@", "Locale: A locale specifying the language of the text to be analyzed."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a new instance of BreakIterator that locates word boundaries.", "history": "Added in API level 24", "FullName": "public static BreakIterator getWordInstance (Locale where)"}, "getLineInstance(android.icu.util.ULocale)": {"Returns": [["@B_android#icu#text#BreakIterator_E@", "A new instance of BreakIterator that locates legal line-wrapping positions."]], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: A Locale specifying the language of the text being broken."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if where is null."]], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public static BreakIterator getLineInstance (ULocale where)"}, "getAvailableLocales()": {"Returns": [["@B_java#util#Locale_E@", "An array of Locales. All of the locales in the array can be used when creating a BreakIterator."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a list of locales for which BreakIterators can be used.", "history": "Added in API level 24", "FullName": "public static Locale[] getAvailableLocales ()"}}, "Inheritance": [], "ClassName": "android.icu.text.BreakIterator", "ClassDesc": "@B_java#text#BreakIterator_E@. Methods, fields, and other functionality specific to ICU are labeled 'A class that locates boundaries in text. This class defines a protocol for objects that break up a piece of natural-language text according to a set of criteria. Instances or subclasses of BreakIterator can be provided, for example, to break a piece of text into words, sentences, or logical characters according to the conventions of some language or group of languages. We provide five built-in types of BreakIterator: getTitleInstance() returns a BreakIterator that locates boundaries between title breaks. getSentenceInstance() returns a BreakIterator that locates boundaries between sentences. This is useful for triple-click selection, for example. getWordInstance() returns a BreakIterator that locates boundaries between words. This is useful for double-click selection or \"find whole words\" searches. This type of BreakIterator makes sure there is a boundary position at the beginning and end of each legal word. (Numbers count as words, too.) Whitespace and punctuation are kept separate from real words. getLineInstance() returns a BreakIterator that locates positions where it is legal for a text editor to wrap lines. This is similar to word breaking, but not the same: punctuation and whitespace are generally kept with words (you don't want a line to start with whitespace, for example), and some special characters can force a position to be considered a line-break position or prevent a position from being a line-break position. getCharacterInstance() returns a BreakIterator that locates boundaries between logical characters. Because of the structure of the Unicode encoding, a logical character may be stored internally as more than one Unicode code point. (A with an umlaut may be stored as an a followed by a separate combining umlaut character, for example, but the user still thinks of it as one character.) This iterator allows various processes (especially text editors) to treat as characters the units of text that a user would think of as characters, rather than the units of text that the computer sees as \"characters\". The text boundary positions are found according to the rules described in Unicode Standard Annex #29, Text Boundaries, and Unicode Standard Annex #14, Line Breaking Properties. These are available at http://www.unicode.org/reports/tr14/ and http://www.unicode.org/reports/tr29/. BreakIterator's interface follows an \"iterator\" model (hence the name), meaning it has a concept of a \"current position\" and methods like first(), last(), next(), and previous() that update the current position. All BreakIterators uphold the following invariants: The beginning and end of the text are always treated as boundary positions. The current position of the iterator is always a boundary position (random- access methods move the iterator to the nearest boundary position before or after the specified position, not _to_ the specified position). DONE is used as a flag to indicate when iteration has stopped. DONE is only returned when the current position is the end of the text and the user calls next(), or when the current position is the beginning of the text and the user calls previous(). Break positions are numbered by the positions of the characters that follow them. Thus, under normal circumstances, the position before the first character is 0, the position after the first character is 1, and the position after the last character is 1 plus the length of the string. The client can change the position of an iterator, or the text it analyzes, at will, but cannot change the behavior. If the user wants different behavior, he must instantiate a new iterator. BreakIterator accesses the text it analyzes through a CharacterIterator, which makes it possible to use BreakIterator to analyze text in any text-storage vehicle that provides a CharacterIterator interface. Creating and using text boundaries"}