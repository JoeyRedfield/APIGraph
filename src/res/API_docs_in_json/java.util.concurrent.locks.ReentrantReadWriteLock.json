{"Functions": {"isWriteLocked()": {"Returns": [["boolean", "true if any thread holds the write lock and false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Queries if the write lock is held by any thread. This method is designed for use in monitoring system state, not for synchronization control.", "history": "Added in API level 1", "FullName": "public boolean isWriteLocked ()"}, "writeLock()": {"Returns": [["@B_java#util#concurrent#locks#ReentrantReadWriteLock#WriteLock_E@", "the lock used for writing"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the lock used for writing.", "history": "Added in API level 1", "FullName": "public ReentrantReadWriteLock.WriteLock writeLock ()"}, "hasWaiters(java.util.concurrent.locks.Condition)": {"Returns": [["boolean", "true if there are any waiting threads"]], "Parameters": [["@B_java#util#concurrent#locks#Condition_E@", "Condition: the condition"]], "Throws": [["@B_java#lang#IllegalMonitorStateException_E@", "if this lock is not held"], ["@B_java#lang#IllegalArgumentException_E@", "if the given condition is not associated with this lock"], ["@B_java#lang#NullPointerException_E@", "if the condition is null"]], "SeeAlso": [], "Permissions": [], "Description": "Queries whether any threads are waiting on the given condition associated with the write lock. Note that because timeouts and interrupts may occur at any time, a true return does not guarantee that a future signal will awaken any threads. This method is designed primarily for use in monitoring of the system state.", "history": "Added in API level 1", "FullName": "public boolean hasWaiters (Condition condition)"}, "getWriteHoldCount()": {"Returns": [["int", "the number of holds on the write lock by the current thread, or zero if the write lock is not held by the current thread"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Queries the number of reentrant write holds on this lock by the current thread. A writer thread has a hold on a lock for each lock action that is not matched by an unlock action.", "history": "Added in API level 1", "FullName": "public int getWriteHoldCount ()"}, "getReadHoldCount()": {"Returns": [["int", "the number of holds on the read lock by the current thread, or zero if the read lock is not held by the current thread"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Queries the number of reentrant read holds on this lock by the current thread. A reader thread has a hold on a lock for each lock action that is not matched by an unlock action.", "history": "Added in API level 9", "FullName": "public int getReadHoldCount ()"}, "hasQueuedThreads()": {"Returns": [["boolean", "true if there may be other threads waiting to acquire the lock"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Queries whether any threads are waiting to acquire the read or write lock. Note that because cancellations may occur at any time, a true return does not guarantee that any other thread will ever acquire a lock. This method is designed primarily for use in monitoring of the system state.", "history": "Added in API level 1", "FullName": "public final boolean hasQueuedThreads ()"}, "getWaitQueueLength(java.util.concurrent.locks.Condition)": {"Returns": [["int", "the estimated number of waiting threads"]], "Parameters": [["@B_java#util#concurrent#locks#Condition_E@", "Condition: the condition"]], "Throws": [["@B_java#lang#IllegalMonitorStateException_E@", "if this lock is not held"], ["@B_java#lang#IllegalArgumentException_E@", "if the given condition is not associated with this lock"], ["@B_java#lang#NullPointerException_E@", "if the condition is null"]], "SeeAlso": [], "Permissions": [], "Description": "Returns an estimate of the number of threads waiting on the given condition associated with the write lock. Note that because timeouts and interrupts may occur at any time, the estimate serves only as an upper bound on the actual number of waiters. This method is designed for use in monitoring of the system state, not for synchronization control.", "history": "Added in API level 1", "FullName": "public int getWaitQueueLength (Condition condition)"}, "ReentrantReadWriteLock()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a new ReentrantReadWriteLock with default (nonfair) ordering properties.", "history": "Added in API level 1", "FullName": "public ReentrantReadWriteLock ()"}, "getWaitingThreads(java.util.concurrent.locks.Condition)": {"Returns": [["@B_java#util#Collection_E@", "the collection of threads"]], "Parameters": [["@B_java#util#concurrent#locks#Condition_E@", "Condition: the condition"]], "Throws": [["@B_java#lang#IllegalMonitorStateException_E@", "if this lock is not held"], ["@B_java#lang#IllegalArgumentException_E@", "if the given condition is not associated with this lock"], ["@B_java#lang#NullPointerException_E@", "if the condition is null"]], "SeeAlso": [], "Permissions": [], "Description": "Returns a collection containing those threads that may be waiting on the given condition associated with the write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive condition monitoring facilities.", "history": "Added in API level 1", "FullName": "protected Collection<Thread> getWaitingThreads (Condition condition)"}, "hasQueuedThread(java.lang.Thread)": {"Returns": [["boolean", "true if the given thread is queued waiting for this lock"]], "Parameters": [["@B_java#lang#Thread_E@", "Thread: the thread"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if the thread is null"]], "SeeAlso": [], "Permissions": [], "Description": "Queries whether the given thread is waiting to acquire either the read or write lock. Note that because cancellations may occur at any time, a true return does not guarantee that this thread will ever acquire a lock. This method is designed primarily for use in monitoring of the system state.", "history": "Added in API level 1", "FullName": "public final boolean hasQueuedThread (Thread thread)"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string identifying this lock, as well as its lock state"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string identifying this lock, as well as its lock state. The state, in brackets, includes the String \"Write locks =\" followed by the number of reentrantly held write locks, and the String \"Read locks =\" followed by the number of held read locks.", "history": "Added in API level 1", "FullName": "public String toString ()"}, "isWriteLockedByCurrentThread()": {"Returns": [["boolean", "true if the current thread holds the write lock and false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Queries if the write lock is held by the current thread.", "history": "Added in API level 1", "FullName": "public boolean isWriteLockedByCurrentThread ()"}, "getReadLockCount()": {"Returns": [["int", "the number of read locks held"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Queries the number of read locks held for this lock. This method is designed for use in monitoring system state, not for synchronization control.", "history": "Added in API level 1", "FullName": "public int getReadLockCount ()"}, "getQueueLength()": {"Returns": [["int", "the estimated number of threads waiting for this lock"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns an estimate of the number of threads waiting to acquire either the read or write lock. The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures. This method is designed for use in monitoring system state, not for synchronization control.", "history": "Added in API level 1", "FullName": "public final int getQueueLength ()"}, "getQueuedThreads()": {"Returns": [["@B_java#util#Collection_E@", "the collection of threads"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a collection containing threads that may be waiting to acquire either the read or write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities.", "history": "Added in API level 1", "FullName": "protected Collection<Thread> getQueuedThreads ()"}, "getOwner()": {"Returns": [["@B_java#lang#Thread_E@", "the owner, or null if not owned"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the thread that currently owns the write lock, or null if not owned. When this method is called by a thread that is not the owner, the return value reflects a best-effort approximation of current lock status. For example, the owner may be momentarily null even if there are threads trying to acquire the lock but have not yet done so. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.", "history": "Added in API level 1", "FullName": "protected Thread getOwner ()"}, "getQueuedReaderThreads()": {"Returns": [["@B_java#util#Collection_E@", "the collection of threads"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a collection containing threads that may be waiting to acquire the read lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.", "history": "Added in API level 1", "FullName": "protected Collection<Thread> getQueuedReaderThreads ()"}, "readLock()": {"Returns": [["@B_java#util#concurrent#locks#ReentrantReadWriteLock#ReadLock_E@", "the lock used for reading"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the lock used for reading.", "history": "Added in API level 1", "FullName": "public ReentrantReadWriteLock.ReadLock readLock ()"}, "getQueuedWriterThreads()": {"Returns": [["@B_java#util#Collection_E@", "the collection of threads"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a collection containing threads that may be waiting to acquire the write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.", "history": "Added in API level 1", "FullName": "protected Collection<Thread> getQueuedWriterThreads ()"}, "ReentrantReadWriteLock(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if this lock should use a fair ordering policy"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a new ReentrantReadWriteLock with the given fairness policy.", "history": "Added in API level 1", "FullName": "public ReentrantReadWriteLock (boolean fair)"}, "isFair()": {"Returns": [["boolean", "true if this lock has fairness set true"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this lock has fairness set true.", "history": "Added in API level 1", "FullName": "public final boolean isFair ()"}}, "Inheritance": [], "ClassName": "java.util.concurrent.locks.ReentrantReadWriteLock", "ClassDesc": "An implementation of @B_java#util#concurrent#locks#ReadWriteLock_E@ supporting similar semantics to @B_java#util#concurrent#locks#ReentrantLock_E@. This class has the following properties: This class does not impose a reader or writer preference ordering for lock access. However, it does support an optional fairness policy. This lock allows both readers and writers to reacquire read or write locks in the style of a @B_java#util#concurrent#locks#ReentrantLock_E@. Non-reentrant readers are not allowed until all write locks held by the writing thread have been released. Additionally, a writer can acquire the read lock, but not vice-versa. Among other applications, reentrancy can be useful when write locks are held during calls or callbacks to methods that perform reads under read locks. If a reader tries to acquire the write lock it will never succeed. Reentrancy also allows downgrading from the write lock to a read lock, by acquiring the write lock, then the read lock and then releasing the write lock. However, upgrading from a read lock to the write lock is The read lock and write lock both support interruption during lock acquisition. The write lock provides a @B_java#util#concurrent#locks#Condition_E@ implementation that behaves in the same way, with respect to the write lock, as the @B_java#util#concurrent#locks#Condition_E@ implementation provided by @B_java#util#concurrent#locks#ReentrantLock#newCondition_E@ does for @B_java#util#concurrent#locks#ReentrantLock_E@. This @B_java#util#concurrent#locks#Condition_E@ can, of course, only be used with the write lock. The read lock does not support a @B_java#util#concurrent#locks#Condition_E@ and readLock().newCondition() throws UnsupportedOperationException. This class supports methods to determine whether locks are held or contended. These methods are designed for monitoring system state, not for synchronization control. Serialization of this class behaves in the same way as built-in locks: a deserialized lock is in the unlocked state, regardless of its state when serialized. This lock supports a maximum of 65535 recursive write locks and 65535 read locks. Attempts to exceed these limits result in @B_java#lang#Error_E@ throws from locking methods."}