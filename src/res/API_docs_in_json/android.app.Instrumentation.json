{"Functions": {"callActivityOnSaveInstanceState(android.app.Activity,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being saved. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: The bundle to pass to the call. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onSaveInstanceState_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnSaveInstanceState (Activity activity, Bundle outState)"}, "callActivityOnPostCreate(android.app.Activity,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being created. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: The previously saved state (or null) to pass through to onPostCreate(). This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onPostCreate_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnPostCreate (Activity activity, Bundle savedInstanceState)"}, "sendPointerSync(android.view.MotionEvent)": {"Returns": [], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: A motion event describing the pointer action. (As noted in @B_android#view#MotionEvent#obtain_E@, be sure to use @B_android#os#SystemClock#uptimeMillis_E@ as the timebase."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a pointer event. Finished at some point after the recipient has returned from its event processing, though it may not have completely finished reacting from the event -- for example, if it needs to update its display as a result, it may still be in the process of doing that.", "history": "Added in API level 1", "FullName": "public void sendPointerSync (MotionEvent event)"}, "getProcessName()": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the name of the process this instrumentation is running in. Note this should only be used for testing and debugging. If you are thinking about using this to, for example, conditionalize what is initialized in an Application class, it is strongly recommended to instead use lazy initialization (such as a getter for the state that only creates it when requested). This can greatly reduce the work your process does when created for secondary things, such as to receive a broadcast.", "history": "Added in API level 26", "FullName": "public String getProcessName ()"}, "getAllocCounts()": {"Returns": [["@B_android#os#Bundle_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a bundle with the current results from the allocation counting.", "history": "Added in API level 1", "FullName": "public Bundle getAllocCounts ()"}, "sendKeySync(android.view.KeyEvent)": {"Returns": [], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The event to send to the current focus."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Send a key event to the currently focused window/view and wait for it to be processed. Finished at some point after the recipient has returned from its event processing, though it may not have completely finished reacting from the event -- for example, if it needs to update its display as a result, it may still be in the process of doing that.", "history": "Added in API level 1", "FullName": "public void sendKeySync (KeyEvent event)"}, "stopProfiling()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Stops profiling if isProfiling() returns true.", "history": "Added in API level 1", "FullName": "public void stopProfiling ()"}, "getBinderCounts()": {"Returns": [["@B_android#os#Bundle_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a bundle with the counts for various binder counts for this process. Currently the only two that are reported are the number of send and the number of received transactions.", "history": "Added in API level 1", "FullName": "public Bundle getBinderCounts ()"}, "newActivity(java.lang.ClassLoader,java.lang.String,android.content.Intent)": {"Returns": [["@B_android#app#Activity_E@", "The newly instantiated Activity object."]], "Parameters": [["@B_java#lang#ClassLoader_E@", "ClassLoader: The ClassLoader with which to instantiate the object."], ["@B_java#lang#String_E@", "String: The name of the class implementing the Activity object."], ["@B_android#content#Intent_E@", "Intent: The Intent object that specified the activity class being instantiated."]], "Throws": [["@B_java#lang#ClassNotFoundException_E@", ""], ["@B_java#lang#IllegalAccessException_E@", ""], ["@B_java#lang#InstantiationException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Perform instantiation of the process's @B_android#app#Activity_E@ object. The default implementation provides the normal system behavior.", "history": "Added in API level 1", "FullName": "public Activity newActivity (ClassLoader cl, String className, Intent intent)"}, "addMonitor(android.content.IntentFilter,android.app.Instrumentation.ActivityResult,boolean)": {"Returns": [["@B_android#app#Instrumentation#ActivityMonitor_E@", "The newly created and added activity monitor."]], "Parameters": [["@B_android#content#IntentFilter_E@", "IntentFilter: The set of intents this monitor is responsible for."], ["@B_android#app#Instrumentation#ActivityResult_E@", "Instrumentation.ActivityResult: A canned result to return if the monitor is hit; can be null."], ["boolean", "boolean: Controls whether the monitor should block the activity start (returning its canned result) or let the call proceed."]], "Throws": [], "SeeAlso": ["@B_android#app#Instrumentation#addMonitor_E@", "@B_android#app#Instrumentation#checkMonitorHit_E@"], "Permissions": [], "Description": "A convenience wrapper for @B_android#app#Instrumentation#addMonitor_E@ that creates an intent filter matching @B_android#app#Instrumentation#ActivityMonitor_E@ for you and returns it.", "history": "Added in API level 1", "FullName": "public Instrumentation.ActivityMonitor addMonitor (IntentFilter filter, Instrumentation.ActivityResult result, boolean block)"}, "Instrumentation()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public Instrumentation ()"}, "callActivityOnStop(android.app.Activity)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being stopped."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onStop_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnStop (Activity activity)"}, "callActivityOnUserLeaving(android.app.Activity)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being notified that the user has navigated away"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onUserLeaveHint_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 3", "FullName": "public void callActivityOnUserLeaving (Activity activity)"}, "onCreate(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle: Any additional arguments that were supplied when the instrumentation was started."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the instrumentation is starting, before any application code has been loaded. Usually this will be implemented to simply call @B_android#app#Instrumentation#start_E@ to begin the instrumentation thread, which will then continue execution in @B_android#app#Instrumentation#onStart_E@. If you do not need your own thread -- that is you are writing your instrumentation to be completely asynchronous (returning to the event loop so that the application can run), you can simply begin your instrumentation here, for example call @B_android#content#Context#startActivity_E@ to begin the appropriate first activity of the application.", "history": "Added in API level 1", "FullName": "public void onCreate (Bundle arguments)"}, "getContext()": {"Returns": [["@B_android#content#Context_E@", "The instrumentation's package context."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Instrumentation#getTargetContext_E@"], "Permissions": [], "Description": "Return the Context of this instrumentation's package. Note that this is often different than the Context of the application being instrumentated, since the instrumentation code often lives is a different package than that of the application it is running against. See @B_android#app#Instrumentation#getTargetContext_E@ to retrieve a Context for the target application.", "history": "Added in API level 1", "FullName": "public Context getContext ()"}, "newActivity(java.lang.Class<?>,android.content.Context,android.os.IBinder,android.app.Application,android.content.Intent,android.content.pm.ActivityInfo,java.lang.CharSequence,android.app.Activity,java.lang.String,java.lang.Object)": {"Returns": [["@B_android#app#Activity_E@", "Returns the instantiated activity"]], "Parameters": [["@B_java#lang#Class_E@", "Class: The Class of the desired Activity"], ["@B_android#content#Context_E@", "Context: The base context for the activity to use"], ["@B_android#os#IBinder_E@", "IBinder: The token for this activity to communicate with"], ["@B_android#app#Application_E@", "Application: The application object (if any)"], ["@B_android#content#Intent_E@", "Intent: The intent that started this Activity"], ["@B_android#content#pm#ActivityInfo_E@", "ActivityInfo: ActivityInfo from the manifest"], ["@B_java#lang#CharSequence_E@", "CharSequence: The title, typically retrieved from the ActivityInfo record"], ["@B_android#app#Activity_E@", "Activity: The parent Activity (if any)"], ["@B_java#lang#String_E@", "String: The embedded Id (if any)"], ["@B_java#lang#Object_E@", "Object: Arbitrary object that will be available via @B_android#app#Activity#getLastNonConfigurationInstance_E@."]], "Throws": [["", "java.lang.InstantiationException"], ["", "java.lang.IllegalAccessException"], ["@B_java#lang#IllegalAccessException_E@", ""], ["@B_java#lang#InstantiationException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Perform instantiation of an @B_android#app#Activity_E@ object. This method is intended for use with unit tests, such as android.test.ActivityUnitTestCase. The activity will be useable locally but will be missing some of the linkages necessary for use within the system.", "history": "Added in API level 1", "FullName": "public Activity newActivity (Class<?> clazz, Context context, IBinder token, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, Object lastNonConfigurationInstance)"}, "callActivityOnResume(android.app.Activity)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being resumed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onResume_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnResume (Activity activity)"}, "callActivityOnPause(android.app.Activity)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being paused."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onPause_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnPause (Activity activity)"}, "startProfiling()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method will start profiling if isProfiling() returns true. You should only call this method if you set the handleProfiling attribute in the manifest file for this Instrumentation to true.", "history": "Added in API level 1", "FullName": "public void startProfiling ()"}, "runOnMainSync(java.lang.Runnable)": {"Returns": [], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: The code to run on the main thread."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Execute a call on the application's main thread, blocking until it is complete. Useful for doing things that are not thread-safe, such as looking at or modifying the view hierarchy.", "history": "Added in API level 1", "FullName": "public void runOnMainSync (Runnable runner)"}, "sendTrackballEventSync(android.view.MotionEvent)": {"Returns": [], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: A motion event describing the trackball action. (As noted in @B_android#view#MotionEvent#obtain_E@, be sure to use @B_android#os#SystemClock#uptimeMillis_E@ as the timebase."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a trackball event. Finished at some point after the recipient has returned from its event processing, though it may not have completely finished reacting from the event -- for example, if it needs to update its display as a result, it may still be in the process of doing that.", "history": "Added in API level 1", "FullName": "public void sendTrackballEventSync (MotionEvent event)"}, "callApplicationOnCreate(android.app.Application)": {"Returns": [], "Parameters": [["@B_android#app#Application_E@", "Application: The application being created."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of the application's @B_android#app#Application#onCreate_E@ method. The default implementation simply calls through to that method. Note: This method will be called immediately after @B_android#app#Instrumentation#onCreate_E@. Often instrumentation tests start their test thread in onCreate(); you need to be careful of races between these. (Well between it and everything else, but let's start here.)", "history": "Added in API level 1", "FullName": "public void callApplicationOnCreate (Application app)"}, "newApplication(java.lang.ClassLoader,java.lang.String,android.content.Context)": {"Returns": [["@B_android#app#Application_E@", "The newly instantiated Application object."]], "Parameters": [["@B_java#lang#ClassLoader_E@", "ClassLoader: The ClassLoader with which to instantiate the object."], ["@B_java#lang#String_E@", "String: The name of the class implementing the Application object."], ["@B_android#content#Context_E@", "Context: The context to initialize the application with"]], "Throws": [["@B_java#lang#ClassNotFoundException_E@", ""], ["@B_java#lang#IllegalAccessException_E@", ""], ["@B_java#lang#InstantiationException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Perform instantiation of the process's @B_android#app#Application_E@ object. The default implementation provides the normal system behavior.", "history": "Added in API level 1", "FullName": "public Application newApplication (ClassLoader cl, String className, Context context)"}, "callActivityOnCreate(android.app.Activity,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being created."], ["@B_android#os#Bundle_E@", "Bundle: The previously frozen state (or null) to pass through to onCreate()."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onCreate_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnCreate (Activity activity, Bundle icicle)"}, "sendCharacterSync(int)": {"Returns": [], "Parameters": [["int", "int: The key code of the character to send."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Higher-level method for sending both the down and up key events for a particular character key code. Equivalent to creating both KeyEvent objects by hand and calling @B_android#app#Instrumentation#sendKeySync_E@. The event appears as if it came from keyboard 0, the built in one.", "history": "Added in API level 1", "FullName": "public void sendCharacterSync (int keyCode)"}, "isProfiling()": {"Returns": [["boolean", "Returns true if profiling was enabled when starting, else false."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check whether this instrumentation was started with profiling enabled.", "history": "Added in API level 1", "FullName": "public boolean isProfiling ()"}, "start()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create and start a new thread in which to run instrumentation. This new thread will call to @B_android#app#Instrumentation#onStart_E@ where you can implement the instrumentation.", "history": "Added in API level 1", "FullName": "public void start ()"}, "callActivityOnNewIntent(android.app.Activity,android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity receiving a new Intent."], ["@B_android#content#Intent_E@", "Intent: The new intent being received."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onNewIntent_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnNewIntent (Activity activity, Intent intent)"}, "startActivitySync(android.content.Intent,android.os.Bundle)": {"Returns": [["@B_android#app#Activity_E@", "no returns description in source"]], "Parameters": [["@B_android#content#Intent_E@", "Intent: Description of the activity to start. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. May be null if there are no options. See @B_android#app#ActivityOptions_E@ for how to build the Bundle supplied here; there are no supported definitions for building it manually. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#startActivity_E@"], "Permissions": [], "Description": "Start a new activity and wait for it to begin running before returning. In addition to being synchronous, this method as some semantic differences from the standard @B_android#content#Context#startActivity_E@ call: the activity component is resolved before talking with the activity manager (its class name is specified in the Intent that this method ultimately starts), and it does not allow you to start activities that run in a different process. In addition, if the given Intent resolves to multiple activities, instead of displaying a dialog for the user to select an activity, an exception will be thrown. The function returns as soon as the activity goes idle following the call to its @B_android#app#Activity#onCreate_E@. Generally this means it has gone through the full initialization including @B_android#app#Activity#onResume_E@ and drawn and displayed its initial window.", "history": "Added in API level 28", "FullName": "public Activity startActivitySync (Intent intent, Bundle options)"}, "startActivitySync(android.content.Intent)": {"Returns": [["@B_android#app#Activity_E@", "no returns description in source"]], "Parameters": [["@B_android#content#Intent_E@", "Intent: Description of the activity to start."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#startActivity_E@", "@B_android#app#Instrumentation#startActivitySync_E@"], "Permissions": [], "Description": "Start a new activity and wait for it to begin running before returning. In addition to being synchronous, this method as some semantic differences from the standard @B_android#content#Context#startActivity_E@ call: the activity component is resolved before talking with the activity manager (its class name is specified in the Intent that this method ultimately starts), and it does not allow you to start activities that run in a different process. In addition, if the given Intent resolves to multiple activities, instead of displaying a dialog for the user to select an activity, an exception will be thrown. The function returns as soon as the activity goes idle following the call to its @B_android#app#Activity#onCreate_E@. Generally this means it has gone through the full initialization including @B_android#app#Activity#onResume_E@ and drawn and displayed its initial window.", "history": "Added in API level 1", "FullName": "public Activity startActivitySync (Intent intent)"}, "waitForMonitor(android.app.Instrumentation.ActivityMonitor)": {"Returns": [["@B_android#app#Activity_E@", "The Activity object that matched the monitor."]], "Parameters": [["@B_android#app#Instrumentation#ActivityMonitor_E@", "Instrumentation.ActivityMonitor: The ActivityMonitor to wait for."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Wait for an existing @B_android#app#Instrumentation#ActivityMonitor_E@ to be hit. Once the monitor has been hit, it is removed from the activity monitor list and the first created Activity object that matched it is returned.", "history": "Added in API level 1", "FullName": "public Activity waitForMonitor (Instrumentation.ActivityMonitor monitor)"}, "newApplication(java.lang.Class<?>,android.content.Context)": {"Returns": [["@B_android#app#Application_E@", "The newly instantiated Application object."]], "Parameters": [["@B_java#lang#Class_E@", "Class: The class used to create an Application object from."], ["@B_android#content#Context_E@", "Context: The context to initialize the application with"]], "Throws": [["@B_java#lang#ClassNotFoundException_E@", ""], ["@B_java#lang#IllegalAccessException_E@", ""], ["@B_java#lang#InstantiationException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Perform instantiation of the process's @B_android#app#Application_E@ object. The default implementation provides the normal system behavior.", "history": "Added in API level 1", "FullName": "public static Application newApplication (Class<?> clazz, Context context)"}, "callActivityOnPostCreate(android.app.Activity,android.os.Bundle,android.os.PersistableBundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being created. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: The previously frozen state (or null) to pass through to onPostCreate(). This value may be null."], ["@B_android#os#PersistableBundle_E@", "PersistableBundle: The previously persisted state (or null) This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onPostCreate_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 21", "FullName": "public void callActivityOnPostCreate (Activity activity, Bundle savedInstanceState, PersistableBundle persistentState)"}, "waitForMonitorWithTimeout(android.app.Instrumentation.ActivityMonitor,long)": {"Returns": [["@B_android#app#Activity_E@", "The Activity object that matched the monitor."]], "Parameters": [["@B_android#app#Instrumentation#ActivityMonitor_E@", "Instrumentation.ActivityMonitor: The ActivityMonitor to wait for."], ["long", "long: The timeout value in milliseconds."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Wait for an existing @B_android#app#Instrumentation#ActivityMonitor_E@ to be hit till the timeout expires. Once the monitor has been hit, it is removed from the activity monitor list and the first created Activity object that matched it is returned. If the timeout expires, a null object is returned.", "history": "Added in API level 1", "FullName": "public Activity waitForMonitorWithTimeout (Instrumentation.ActivityMonitor monitor, long timeOut)"}, "checkMonitorHit(android.app.Instrumentation.ActivityMonitor,int)": {"Returns": [["boolean", "True if the hit count has been reached, else false."]], "Parameters": [["@B_android#app#Instrumentation#ActivityMonitor_E@", "Instrumentation.ActivityMonitor: The ActivityMonitor to check."], ["int", "int: The minimum number of hits required."]], "Throws": [], "SeeAlso": ["@B_android#app#Instrumentation#addMonitor_E@"], "Permissions": [], "Description": "Test whether an existing @B_android#app#Instrumentation#ActivityMonitor_E@ has been hit. If the monitor has been hit at least", "history": "Added in API level 1", "FullName": "public boolean checkMonitorHit (Instrumentation.ActivityMonitor monitor, int minHits)"}, "startPerformanceSnapshot()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public void startPerformanceSnapshot ()"}, "callActivityOnCreate(android.app.Activity,android.os.Bundle,android.os.PersistableBundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being created."], ["@B_android#os#Bundle_E@", "Bundle: The previously frozen state (or null) to pass through to"], ["@B_android#os#PersistableBundle_E@", "PersistableBundle: The previously persisted state (or null)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onCreate_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 21", "FullName": "public void callActivityOnCreate (Activity activity, Bundle icicle, PersistableBundle persistentState)"}, "sendStatus(int, android.os.Bundle)": {"Returns": [], "Parameters": [["int", "int: Current success/failure of instrumentation."], ["@B_android#os#Bundle_E@", "Bundle: Any results to send back to the code that started the instrumentation."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Provide a status report about the application.", "history": "added in API level 1", "FullName": "public void sendStatus (int resultCode, Bundle results)"}, "acquireLooperManager(android.os.Looper)": {"Returns": [["@B_android#os#TestLooperManager_E@", "no returns description in source"]], "Parameters": [["@B_android#os#Looper_E@", "Looper no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Takes control of the execution of messages on the specified looper until @B_android#os#TestLooperManager#release_E@ is called.", "history": "Added in API level 26", "FullName": "public TestLooperManager acquireLooperManager (Looper looper)"}, "sendStringSync(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The text to be sent."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sends the key events corresponding to the text to the app being instrumented.", "history": "Added in API level 1", "FullName": "public void sendStringSync (String text)"}, "callActivityOnDestroy(android.app.Activity)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public void callActivityOnDestroy (Activity activity)"}, "removeMonitor(android.app.Instrumentation.ActivityMonitor)": {"Returns": [], "Parameters": [["@B_android#app#Instrumentation#ActivityMonitor_E@", "Instrumentation.ActivityMonitor: The monitor to remove."]], "Throws": [], "SeeAlso": ["@B_android#app#Instrumentation#addMonitor_E@"], "Permissions": [], "Description": "Remove an @B_android#app#Instrumentation#ActivityMonitor_E@ that was previously added with @B_android#app#Instrumentation#addMonitor_E@.", "history": "Added in API level 1", "FullName": "public void removeMonitor (Instrumentation.ActivityMonitor monitor)"}, "waitForIdle(java.lang.Runnable)": {"Returns": [], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: Called the next time the thread's message queue is idle."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Schedule a callback for when the application's main thread goes idle (has no more events to process).", "history": "Added in API level 1", "FullName": "public void waitForIdle (Runnable recipient)"}, "callActivityOnSaveInstanceState(android.app.Activity,android.os.Bundle,android.os.PersistableBundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being saved. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: The bundle to pass to the call. This value must never be null."], ["@B_android#os#PersistableBundle_E@", "PersistableBundle: The persistent bundle to pass to the call. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onSaveInstanceState_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 21", "FullName": "public void callActivityOnSaveInstanceState (Activity activity, Bundle outState, PersistableBundle outPersistentState)"}, "endPerformanceSnapshot()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public void endPerformanceSnapshot ()"}, "setInTouchMode(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Set to true to be in touch mode, false to be in focus mode."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Force the global system in or out of touch mode. This can be used if your instrumentation relies on the UI being in one more or the other when it starts.", "history": "Added in API level 1", "FullName": "public void setInTouchMode (boolean inTouch)"}, "getTargetContext()": {"Returns": [["@B_android#content#Context_E@", "A Context in the target application."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#Instrumentation#getContext_E@"], "Permissions": [], "Description": "Return a Context for the target application being instrumented. Note that this is often different than the Context of the instrumentation code, since the instrumentation code often lives is a different package than that of the application it is running against. See @B_android#app#Instrumentation#getContext_E@ to retrieve a Context for the instrumentation code.", "history": "Added in API level 1", "FullName": "public Context getTargetContext ()"}, "finish(int,android.os.Bundle)": {"Returns": [], "Parameters": [["int", "int: Overall success/failure of instrumentation."], ["@B_android#os#Bundle_E@", "Bundle: Any results to send back to the code that started the instrumentation."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Terminate instrumentation of the application. This will cause the application process to exit, removing this instrumentation from the next time the application is started. If multiple processes are currently running for this instrumentation, all of those processes will be killed.", "history": "Added in API level 1", "FullName": "public void finish (int resultCode, Bundle results)"}, "onStart()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Method where the instrumentation thread enters execution. This allows you to run your instrumentation code in a separate thread than the application, so that it can perform blocking operation such as @B_android#app#Instrumentation#sendKeySync_E@ or @B_android#app#Instrumentation#startActivitySync_E@. You will typically want to call finish() when this function is done, to end your instrumentation.", "history": "Added in API level 1", "FullName": "public void onStart ()"}, "sendKeyDownUpSync(int)": {"Returns": [], "Parameters": [["int", "int: The integer keycode for the event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sends an up and down key event sync to the currently focused window.", "history": "Added in API level 1", "FullName": "public void sendKeyDownUpSync (int key)"}, "getUiAutomation(int)": {"Returns": [["@B_android#app#UiAutomation_E@", "The UI automation instance."]], "Parameters": [["int", "int: The flags to be passed to the UiAutomation, for example @B_android#app#UiAutomation#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES_E@. Value is 0, or @B_android#app#UiAutomation#FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES_E@"]], "Throws": [], "SeeAlso": ["@B_android#app#UiAutomation_E@"], "Permissions": [], "Description": "Gets the @B_android#app#UiAutomation_E@ instance with flags set. @B_android#app#UiAutomation_E@ work across application boundaries while the APIs exposed by the instrumentation do not. For example, @B_android#app#Instrumentation#sendPointerSync_E@ will not allow you to inject the event in an app different from the instrumentation target, while @B_android#app#UiAutomation#injectInputEvent_E@ will work regardless of the current application. A typical test case should be using either the @B_android#app#UiAutomation_E@ or @B_android#app#Instrumentation_E@ APIs. Using both APIs at the same time is not a mistake by itself but a client has to be aware of the APIs limitations. If a @B_android#app#UiAutomation_E@ exists with different flags, the flags on that instance will be changed, and then it will be returned.", "history": "Added in API level 24", "FullName": "public UiAutomation getUiAutomation (int flags)"}, "finish(int, android.os.Bundle)": {"Returns": [], "Parameters": [["int", "int: Overall success/failure of instrumentation."], ["@B_android#os#Bundle_E@", "Bundle: Any results to send back to the code that started the instrumentation."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Terminate instrumentation of the application. This will cause the application process to exit, removing this instrumentation from the next time the application is started. If multiple processes are currently running for this instrumentation, all of those processes will be killed.", "history": "added in API level 1", "FullName": "public void finish (int resultCode, Bundle results)"}, "addResults(android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#os#Bundle_E@", "Bundle no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Report some results in the middle of instrumentation execution. Later results (including those provided by @B_android#app#Instrumentation#finish_E@) will be combined with @B_android#os#Bundle#putAll_E@.", "history": "Added in API level 26", "FullName": "public void addResults (Bundle results)"}, "waitForIdleSync()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Synchronously wait for the application to be idle. Can not be called from the main application thread -- use @B_android#app#Instrumentation#start_E@ to execute instrumentation in its own thread.", "history": "Added in API level 1", "FullName": "public void waitForIdleSync ()"}, "callActivityOnStart(android.app.Activity)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being started."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onStart_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnStart (Activity activity)"}, "getComponentName()": {"Returns": [["@B_android#content#ComponentName_E@", "Returns the complete component name for this instrumentation."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns complete component name of this instrumentation.", "history": "Added in API level 1", "FullName": "public ComponentName getComponentName ()"}, "stopAllocCounting()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1 Deprecated in API level 23", "FullName": "public void stopAllocCounting ()"}, "setAutomaticPerformanceSnapshots()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public void setAutomaticPerformanceSnapshots ()"}, "onException(java.lang.Object,java.lang.Throwable)": {"Returns": [["boolean", "To allow normal system exception process to occur, return false. If true is returned, the system will proceed as if the exception didn't happen."]], "Parameters": [["@B_java#lang#Object_E@", "Object: The client object that generated the exception. May be an Application, Activity, BroadcastReceiver, Service, or null."], ["@B_java#lang#Throwable_E@", "Throwable: The exception that was thrown."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called whenever the system captures an unhandled exception that was thrown by the application. The default implementation simply returns false, allowing normal system handling of the exception to take place.", "history": "Added in API level 1", "FullName": "public boolean onException (Object obj, Throwable e)"}, "startAllocCounting()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1 Deprecated in API level 23", "FullName": "public void startAllocCounting ()"}, "addMonitor(java.lang.String,android.app.Instrumentation.ActivityResult,boolean)": {"Returns": [["@B_android#app#Instrumentation#ActivityMonitor_E@", "The newly created and added activity monitor."]], "Parameters": [["@B_java#lang#String_E@", "String: The activity class this monitor is responsible for."], ["@B_android#app#Instrumentation#ActivityResult_E@", "Instrumentation.ActivityResult: A canned result to return if the monitor is hit; can be null."], ["boolean", "boolean: Controls whether the monitor should block the activity start (returning its canned result) or let the call proceed."]], "Throws": [], "SeeAlso": ["@B_android#app#Instrumentation#addMonitor_E@", "@B_android#app#Instrumentation#checkMonitorHit_E@"], "Permissions": [], "Description": "A convenience wrapper for @B_android#app#Instrumentation#addMonitor_E@ that creates a class matching @B_android#app#Instrumentation#ActivityMonitor_E@ for you and returns it.", "history": "Added in API level 1", "FullName": "public Instrumentation.ActivityMonitor addMonitor (String cls, Instrumentation.ActivityResult result, boolean block)"}, "callActivityOnRestoreInstanceState(android.app.Activity,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being restored. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: The previously saved state being restored. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onRestoreInstanceState_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnRestoreInstanceState (Activity activity, Bundle savedInstanceState)"}, "onDestroy()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the instrumented application is stopping, after all of the normal application cleanup has occurred.", "history": "Added in API level 1", "FullName": "public void onDestroy ()"}, "addMonitor(android.app.Instrumentation.ActivityMonitor)": {"Returns": [], "Parameters": [["@B_android#app#Instrumentation#ActivityMonitor_E@", "Instrumentation.ActivityMonitor: The new ActivityMonitor to see."]], "Throws": [], "SeeAlso": ["@B_android#app#Instrumentation#addMonitor_E@", "@B_android#app#Instrumentation#checkMonitorHit_E@"], "Permissions": [], "Description": "Add a new @B_android#app#Instrumentation#ActivityMonitor_E@ that will be checked whenever an activity is started. The monitor is added after any existing ones; the monitor will be hit only if none of the existing monitors can themselves handle the Intent.", "history": "Added in API level 1", "FullName": "public void addMonitor (Instrumentation.ActivityMonitor monitor)"}, "onException(java.lang.Object, java.lang.Throwable)": {"Returns": [["boolean", "To allow normal system exception process to occur, return false. If true is returned, the system will proceed as if the exception didn't happen."]], "Parameters": [["@B_java#lang#Object_E@", "Object: The client object that generated the exception. May be an Application, Activity, BroadcastReceiver, Service, or null."], ["@B_java#lang#Throwable_E@", "Throwable: The exception that was thrown."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called whenever the system captures an unhandled exception that was thrown by the application. The default implementation simply returns false, allowing normal system handling of the exception to take place.", "history": "added in API level 1", "FullName": "public boolean onException (Object obj, Throwable e)"}, "invokeContextMenuAction(android.app.Activity,int,int)": {"Returns": [["boolean", "Whether the invocation was successful (for example, it could be false if item is disabled)."]], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity in question."], ["int", "int: The identifier associated with the context menu item."], ["int", "int: Additional flags, if any."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Show the context menu for the currently focused view and executes a particular context menu item.", "history": "Added in API level 1", "FullName": "public boolean invokeContextMenuAction (Activity targetActivity, int id, int flag)"}, "getUiAutomation()": {"Returns": [["@B_android#app#UiAutomation_E@", "The UI automation instance."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#app#UiAutomation_E@"], "Permissions": [], "Description": "Gets the @B_android#app#UiAutomation_E@ instance with no flags set. @B_android#app#UiAutomation_E@ work across application boundaries while the APIs exposed by the instrumentation do not. For example, @B_android#app#Instrumentation#sendPointerSync_E@ will not allow you to inject the event in an app different from the instrumentation target, while @B_android#app#UiAutomation#injectInputEvent_E@ will work regardless of the current application. A typical test case should be using either the @B_android#app#UiAutomation_E@ or @B_android#app#Instrumentation_E@ APIs. Using both APIs at the same time is not a mistake by itself but a client has to be aware of the APIs limitations. Equivalent to getUiAutomation(0). If a @B_android#app#UiAutomation_E@ exists with different flags, the flags on that instance will be changed, and then it will be returned.", "history": "Added in API level 18", "FullName": "public UiAutomation getUiAutomation ()"}, "invokeMenuActionSync(android.app.Activity,int,int)": {"Returns": [["boolean", "Whether the invocation was successful (for example, it could be false if item is disabled)."]], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity in question."], ["int", "int: The identifier associated with the menu item."], ["int", "int: Additional flags, if any."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Execute a particular menu item.", "history": "Added in API level 1", "FullName": "public boolean invokeMenuActionSync (Activity targetActivity, int id, int flag)"}, "callActivityOnRestart(android.app.Activity)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being restarted."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onRestart_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 1", "FullName": "public void callActivityOnRestart (Activity activity)"}, "callActivityOnRestoreInstanceState(android.app.Activity,android.os.Bundle,android.os.PersistableBundle)": {"Returns": [], "Parameters": [["@B_android#app#Activity_E@", "Activity: The activity being restored. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: The previously saved state being restored (or null). This value may be null."], ["@B_android#os#PersistableBundle_E@", "PersistableBundle: The previously persisted state (or null) This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Perform calling of an activity's @B_android#app#Activity#onRestoreInstanceState_E@ method. The default implementation simply calls through to that method.", "history": "Added in API level 21", "FullName": "public void callActivityOnRestoreInstanceState (Activity activity, Bundle savedInstanceState, PersistableBundle persistentState)"}, "sendStatus(int,android.os.Bundle)": {"Returns": [], "Parameters": [["int", "int: Current success/failure of instrumentation."], ["@B_android#os#Bundle_E@", "Bundle: Any results to send back to the code that started the instrumentation."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Provide a status report about the application.", "history": "Added in API level 1", "FullName": "public void sendStatus (int resultCode, Bundle results)"}}, "Inheritance": [], "ClassName": "android.app.Instrumentation", "ClassDesc": "Base class for implementing application instrumentation code. When running with instrumentation turned on, this class will be instantiated for you before any of the application code, allowing you to monitor all of the interaction the system has with the application. An Instrumentation implementation is described to the system through an AndroidManifest.xml's <instrumentation> tag."}