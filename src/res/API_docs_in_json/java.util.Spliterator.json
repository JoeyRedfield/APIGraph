{"Functions": {"trySplit()": {"Returns": [["@B_java#util#Spliterator_E@", "a Spliterator covering some portion of the elements, or null if this spliterator cannot be split"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator. If this Spliterator is @B_java#util#Spliterator#ORDERED_E@, the returned Spliterator must cover a strict prefix of the elements. Unless this Spliterator covers an infinite number of elements, repeated calls to trySplit() must eventually return null. Upon non-null return: the value reported for estimateSize() before splitting, must, after splitting, be greater than or equal to estimateSize() for this and the returned Spliterator; and if this Spliterator is SUBSIZED, then estimateSize() for this spliterator before splitting must be equal to the sum of estimateSize() for this and the returned Spliterator after splitting. This method may return null for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations.", "history": "Added in API level 24", "FullName": "public abstract Spliterator<T> trySplit ()"}, "getComparator()": {"Returns": [["@B_java#util#Comparator_E@", "a Comparator, or null if the elements are sorted in the natural order."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the spliterator does not report a characteristic of SORTED."]], "SeeAlso": [], "Permissions": [], "Description": "If this Spliterator's source is @B_java#util#Spliterator#SORTED_E@ by a @B_java#util#Comparator_E@, returns that Comparator. If the source is SORTED in null. Otherwise, if the source is not SORTED, throws @B_java#lang#IllegalStateException_E@.", "history": "Added in API level 24", "FullName": "public Comparator<? super T> getComparator ()"}, "getExactSizeIfKnown()": {"Returns": [["long", "the exact size, if known, else -1."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method that returns @B_java#util#Spliterator#estimateSize_E@ if this Spliterator is @B_java#util#Spliterator#SIZED_E@, else -1.", "history": "Added in API level 24", "FullName": "public long getExactSizeIfKnown ()"}, "tryAdvance(java.util.function.Consumer<? super T>)": {"Returns": [["boolean", "false if no remaining elements existed upon entry to this method, else true."]], "Parameters": [["@B_java#util#function#Consumer_E@", "Consumer: The action"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if the specified action is null"]], "SeeAlso": [], "Permissions": [], "Description": "If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is @B_java#util#Spliterator#ORDERED_E@ the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.", "history": "added in API level 24", "FullName": "public abstract boolean tryAdvance (Consumer<? super T> action)"}, "tryAdvance(java.util.function.Consumer<?superT>)": {"Returns": [["boolean", "false if no remaining elements existed upon entry to this method, else true."]], "Parameters": [["@B_java#util#function#Consumer_E@", "Consumer: The action"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if the specified action is null"]], "SeeAlso": [], "Permissions": [], "Description": "If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is @B_java#util#Spliterator#ORDERED_E@ the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.", "history": "Added in API level 24", "FullName": "public abstract boolean tryAdvance (Consumer<? super T> action)"}, "hasCharacteristics(int)": {"Returns": [["boolean", "true if all the specified characteristics are present, else false"]], "Parameters": [["int", "int: the characteristics to check for"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this Spliterator's @B_java#util#Spliterator#characteristics_E@ contain all of the given characteristics.", "history": "Added in API level 24", "FullName": "public boolean hasCharacteristics (int characteristics)"}, "forEachRemaining(java.util.function.Consumer<?superT>)": {"Returns": [], "Parameters": [["@B_java#util#function#Consumer_E@", "Consumer: The action"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if the specified action is null"]], "SeeAlso": [], "Permissions": [], "Description": "Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is @B_java#util#Spliterator#ORDERED_E@, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.", "history": "Added in API level 24", "FullName": "public void forEachRemaining (Consumer<? super T> action)"}, "estimateSize()": {"Returns": [["long", "the estimated size, or Long.MAX_VALUE if infinite, unknown, or too expensive to compute."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns an estimate of the number of elements that would be encountered by a @B_java#util#Spliterator#forEachRemaining_E@ traversal, or returns @B_java#lang#Long#MAX_VALUE_E@ if infinite, unknown, or too expensive to compute. If this Spliterator is @B_java#util#Spliterator#SIZED_E@ and has not yet been partially traversed or split, or this Spliterator is @B_java#util#Spliterator#SUBSIZED_E@ and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of @B_java#util#Spliterator#trySplit_E@.", "history": "Added in API level 24", "FullName": "public abstract long estimateSize ()"}, "characteristics()": {"Returns": [["int", "a representation of characteristics"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from @B_java#util#Spliterator#ORDERED_E@, @B_java#util#Spliterator#DISTINCT_E@, @B_java#util#Spliterator#SORTED_E@, @B_java#util#Spliterator#SIZED_E@, @B_java#util#Spliterator#NONNULL_E@, @B_java#util#Spliterator#IMMUTABLE_E@, @B_java#util#Spliterator#CONCURRENT_E@, @B_java#util#Spliterator#SUBSIZED_E@. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result. If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.", "history": "Added in API level 24", "FullName": "public abstract int characteristics ()"}}, "Inheritance": [], "ClassName": "java.util.Spliterator<T>", "ClassDesc": "An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a @B_java#util#Collection_E@, an IO channel, or a generator function. A Spliterator may traverse elements individually (@B_java#util#Spliterator#tryAdvance_E@) or sequentially in bulk (@B_java#util#Spliterator#forEachRemaining_E@). A Spliterator may also partition off some of its elements (using @B_java#util#Spliterator#trySplit_E@) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation. A Spliterator also reports a set of @B_java#util#Spliterator#characteristics_E@ of its structure, source, and elements from among @B_java#util#Spliterator#ORDERED_E@, @B_java#util#Spliterator#DISTINCT_E@, @B_java#util#Spliterator#SORTED_E@, @B_java#util#Spliterator#SIZED_E@, @B_java#util#Spliterator#NONNULL_E@, @B_java#util#Spliterator#IMMUTABLE_E@, @B_java#util#Spliterator#CONCURRENT_E@, and @B_java#util#Spliterator#SUBSIZED_E@. These may be employed by Spliterator clients to control, specialize or simplify computation. For example, a Spliterator for a @B_java#util#Collection_E@ would report SIZED, a Spliterator for a @B_java#util#Set_E@ would report DISTINCT, and a Spliterator for a @B_java#util#SortedSet_E@ would also report SORTED. Characteristics are reported as a simple unioned bit set. Some characteristics additionally constrain method behavior; for example if ORDERED, traversal methods must conform to their documented ordering. New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values. late-binding Spliterator binds to the source of elements at the point of first traversal, first split, or first query for estimated size, rather than at the time the Spliterator is created. A Spliterator that is not late-binding binds to the source of elements at the point of construction or first invocation of any method. Modifications made to the source prior to binding are reflected when the Spliterator is traversed. After binding a Spliterator should, on a best-effort basis, throw @B_java#util#ConcurrentModificationException_E@ if structural interference is detected. Spliterators that do this are called fail-fast. The bulk traversal method (@B_java#util#Spliterator#forEachRemaining_E@) of a Spliterator may optimize traversal and check for structural interference after all elements have been traversed, rather than checking per-element and failing immediately. Spliterators can provide an estimate of the number of remaining elements via the @B_java#util#Spliterator#estimateSize_E@ method. Ideally, as reflected in characteristic @B_java#util#Spliterator#SIZED_E@, this value corresponds exactly to the number of elements that would be encountered in a successful traversal. However, even when not exactly known, an estimated value value may still be useful to operations being performed on the source, such as helping to determine whether it is preferable to split further or traverse the remaining elements sequentially. Despite their obvious utility in parallel algorithms, spliterators are not expected to be thread-safe; instead, implementations of parallel algorithms using spliterators should ensure that the spliterator is only used by one thread at a time. This is generally easy to attain via serial thread-confinement, which often is a natural consequence of typical parallel algorithms that work by recursive decomposition. A thread calling @B_java#util#Spliterator#trySplit_E@ may hand over the returned Spliterator to another thread, which in turn may traverse or further split that Spliterator. The behaviour of splitting and traversal is undefined if two or more threads operate concurrently on the same spliterator. If the original thread hands a spliterator off to another thread for processing, it is best if that handoff occurs before any elements are consumed with @B_java#util#Spliterator#tryAdvance_E@, as certain guarantees (such as the accuracy of @B_java#util#Spliterator#estimateSize_E@ for SIZED spliterators) are only valid before traversal has begun. Primitive subtype specializations of Spliterator are provided for @B_java#util#Spliterator#OfInt_E@, @B_java#util#Spliterator#OfLong_E@, and @B_java#util#Spliterator#OfDouble_E@ values. The subtype default implementations of @B_java#util#Spliterator#tryAdvance_E@ and @B_java#util#Spliterator#forEachRemaining_E@ box primitive values to instances of their corresponding wrapper class. Such boxing may undermine any performance advantages gained by using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, @B_java#util#Spliterator#OfInt#tryAdvance_E@ and @B_java#util#Spliterator#OfInt#forEachRemaining_E@ should be used in preference to @B_java#util#Spliterator#tryAdvance_E@ and @B_java#util#Spliterator#forEachRemaining_E@. Traversal of primitive values using boxing-based methods @B_java#util#Spliterator#tryAdvance_E@ and @B_java#util#Spliterator#forEachRemaining_E@ does not affect the order in which the values, transformed to boxed values, are encountered."}