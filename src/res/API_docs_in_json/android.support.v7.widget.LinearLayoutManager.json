{"Functions": {"canScrollVertically()": {"Returns": [["boolean", "true if @B_android#support#v7#widget#LinearLayoutManager#getOrientation_E@ is @B_android#support#v7#widget#LinearLayoutManager#VERTICAL_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Query if vertical scrolling is currently supported. The default implementation returns false.", "history": "added in version 22.0.0", "FullName": "boolean canScrollVertically ()"}, "getReverseLayout()": {"Returns": [["boolean", "If layout is reversed or not."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#setReverseLayout_E@"], "Permissions": [], "Description": "Returns if views are laid out from the opposite direction of the layout.", "history": "added in version 22.0.0", "FullName": "boolean getReverseLayout ()"}, "getRecycleChildrenOnDetach()": {"Returns": [["boolean", "true if LayoutManager will recycle its children when it is detached from RecyclerView."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether LayoutManager will recycle its children when it is detached from RecyclerView.", "history": "added in version 22.0.0", "FullName": "boolean getRecycleChildrenOnDetach ()"}, "getInitialPrefetchItemCount()": {"Returns": [["int", "number of items to prefetch."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#isItemPrefetchEnabled_E@", "@B_android#support#v7#widget#LinearLayoutManager#setInitialPrefetchItemCount_E@", "@B_android#support#v7#widget#LinearLayoutManager#collectInitialPrefetchPositions_E@"], "Permissions": [], "Description": "Gets the number of items to prefetch in @B_android#support#v7#widget#LinearLayoutManager#collectInitialPrefetchPositions_E@, which defines how many inner items should be prefetched when this LayoutManager's RecyclerView is nested inside another RecyclerView.", "history": "added in version 25.3.0", "FullName": "int getInitialPrefetchItemCount ()"}, "isSmoothScrollbarEnabled()": {"Returns": [["boolean", "True if smooth scrollbar is enabled, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#setSmoothScrollbarEnabled_E@"], "Permissions": [], "Description": "Returns the current state of the smooth scrollbar feature. It is enabled by default.", "history": "added in version 22.0.0", "FullName": "boolean isSmoothScrollbarEnabled ()"}, "LinearLayoutManager(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: Current context, will be used to access resources."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a vertical LinearLayoutManager", "history": "added in version 22.0.0", "FullName": "LinearLayoutManager (Context context)"}, "supportsPredictiveItemAnimations()": {"Returns": [["boolean", "true if predictive item animations should be enabled, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether this LayoutManager supports automatic item animations. A LayoutManager wishing to support item animations should obey certain rules as outlined in @B_android#support#v7#widget#RecyclerView#LayoutManager#onLayoutChildren_E@. The default return value is false, so subclasses of LayoutManager will not get predictive item animations by default. Whether item animations are enabled in a RecyclerView is determined both by the return value from this method and the @B_android#support#v7#widget#RecyclerView#setItemAnimator_E@ set on the RecyclerView itself. If the RecyclerView has a non-null ItemAnimator but this method returns false, then simple item animations will be enabled, in which views that are moving onto or off of the screen are simply faded in/out. If the RecyclerView has a non-null ItemAnimator and this method returns true, then there will be two calls to @B_android#support#v7#widget#RecyclerView#LayoutManager#onLayoutChildren_E@ to setup up the information needed to more intelligently predict where appearing and disappearing views should be animated from/to.", "history": "added in version 22.0.0", "FullName": "boolean supportsPredictiveItemAnimations ()"}, "findLastVisibleItemPosition()": {"Returns": [["int", "The adapter position of the last visible view or @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@ if there aren't any visible items."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#findLastCompletelyVisibleItemPosition_E@", "@B_android#support#v7#widget#LinearLayoutManager#findFirstVisibleItemPosition_E@"], "Permissions": [], "Description": "Returns the adapter position of the last visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that, this value is not affected by layout orientation or item order traversal. (@B_android#support#v7#widget#LinearLayoutManager#setReverseLayout_E@). Views are sorted by their positions in the adapter, not in the layout. If RecyclerView has item decorators, they will be considered in calculations as well. LayoutManager may pre-cache some views that are not necessarily visible. Those views are ignored in this method.", "history": "added in version 22.0.0", "FullName": "int findLastVisibleItemPosition ()"}, "findFirstCompletelyVisibleItemPosition()": {"Returns": [["int", "The adapter position of the first fully visible item or @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@ if there aren't any visible items."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#findFirstVisibleItemPosition_E@", "@B_android#support#v7#widget#LinearLayoutManager#findLastCompletelyVisibleItemPosition_E@"], "Permissions": [], "Description": "Returns the adapter position of the first fully visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that bounds check is only performed in the current orientation. That means, if LayoutManager is horizontal, it will only check the view's left and right edges.", "history": "added in version 22.0.0", "FullName": "int findFirstCompletelyVisibleItemPosition ()"}, "scrollToPosition(int)": {"Returns": [], "Parameters": [["int", "int: Scroll to this adapter position"]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#scrollToPositionWithOffset_E@"], "Permissions": [], "Description": "Scroll the RecyclerView to make the position visible. RecyclerView will scroll the minimum amount that is necessary to make the target position visible. If you are looking for a similar behavior to @B_android#widget#ListView#setSelection_E@ or @B_android#widget#AbsListView#setSelectionFromTop_E@, use @B_android#support#v7#widget#LinearLayoutManager#scrollToPositionWithOffset_E@. Note that scroll position change will not be reflected until the next layout call.", "history": "added in version 22.0.0", "FullName": "void scrollToPosition (int position)"}, "setSmoothScrollbarEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether or not to enable smooth scrollbar."]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#setSmoothScrollbarEnabled_E@"], "Permissions": [], "Description": "When smooth scrollbar is enabled, the position and size of the scrollbar thumb is computed based on the number of visible pixels in the visible items. This however assumes that all list items have similar or equal widths or heights (depending on list orientation). If you use a list in which items have different dimensions, the scrollbar will change appearance as the user scrolls through the list. To avoid this issue, you need to disable this property. When smooth scrollbar is disabled, the position and size of the scrollbar thumb is based solely on the number of items in the adapter and the position of the visible items inside the adapter. This provides a stable scrollbar as the user navigates through a list of items with varying widths / heights.", "history": "added in version 22.0.0", "FullName": "void setSmoothScrollbarEnabled (boolean enabled)"}, "setStackFromEnd(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compatibility support for @B_android#widget#AbsListView#setStackFromBottom_E@", "history": "added in version 22.0.0", "FullName": "void setStackFromEnd (boolean stackFromEnd)"}, "computeScrollVectorForPosition(int)": {"Returns": [["@B_android#graphics#PointF_E@", "the scroll vector for a given position."]], "Parameters": [["int", "int: the target position to which the returned vector should point"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Should calculate the vector that points to the direction where the target position can be found. This method is used by the @B_android#support#v7#widget#LinearSmoothScroller_E@ to initiate a scroll towards the target position. The magnitude of the vector is not important. It is always normalized before being used by the @B_android#support#v7#widget#LinearSmoothScroller_E@. LayoutManager should not check whether the position exists in the adapter or not.", "history": "added in version 22.0.0", "FullName": "PointF computeScrollVectorForPosition (int targetPosition)"}, "setRecycleChildrenOnDetach(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether children should be recycled in detach or not."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set whether LayoutManager will recycle its children when it is detached from RecyclerView. If you are using a @B_android#support#v7#widget#RecyclerView#RecycledViewPool_E@, it might be a good idea to set this flag to true so that views will be available to other RecyclerViews immediately. Note that, setting this flag will result in a performance drop if RecyclerView is restored.", "history": "added in version 22.0.0", "FullName": "void setRecycleChildrenOnDetach (boolean recycleChildrenOnDetach)"}, "isLayoutRTL()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "boolean isLayoutRTL ()"}, "setReverseLayout(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Used to reverse item traversal and layout order. This behaves similar to the layout change for RTL views. When set to true, first item is laid out at the end of the UI, second item is laid out before it etc. For horizontal layouts, it depends on the layout direction. When set to true, If @B_android#support#v7#widget#RecyclerView_E@ is LTR, than it will layout from RTL, if @B_android#support#v7#widget#RecyclerView_E@} is RTL, it will layout from LTR. If you are looking for the exact same behavior of @B_android#widget#AbsListView#setStackFromBottom_E@, use @B_android#support#v7#widget#LinearLayoutManager#setStackFromEnd_E@", "history": "added in version 22.0.0", "FullName": "void setReverseLayout (boolean reverseLayout)"}, "onRestoreInstanceState(android.os.Parcelable)": {"Returns": [], "Parameters": [["@B_android#os#Parcelable_E@", "Parcelable no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "void onRestoreInstanceState (Parcelable state)"}, "findViewByPosition(int)": {"Returns": [["@B_android#view#View_E@", "The child view that represents the given position or null if the position is not laid out"]], "Parameters": [["int", "int: Position of the item in adapter"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finds the view which represents the given adapter position. This method traverses each child since it has no information about child order. Override this method to improve performance if your LayoutManager keeps data about child views. If a view is ignored via @B_android#support#v7#widget#RecyclerView#LayoutManager#ignoreView_E@, it is also ignored by this method.", "history": "added in version 22.0.0", "FullName": "View findViewByPosition (int position)"}, "findLastCompletelyVisibleItemPosition()": {"Returns": [["int", "The adapter position of the last fully visible view or @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@ if there aren't any visible items."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#findLastVisibleItemPosition_E@", "@B_android#support#v7#widget#LinearLayoutManager#findFirstCompletelyVisibleItemPosition_E@"], "Permissions": [], "Description": "Returns the adapter position of the last fully visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that bounds check is only performed in the current orientation. That means, if LayoutManager is horizontal, it will only check the view's left and right edges.", "history": "added in version 22.0.0", "FullName": "int findLastCompletelyVisibleItemPosition ()"}, "getOrientation()": {"Returns": [["int", "Current orientation, either @B_android#support#v7#widget#LinearLayoutManager#HORIZONTAL_E@ or @B_android#support#v7#widget#LinearLayoutManager#VERTICAL_E@"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#setOrientation_E@"], "Permissions": [], "Description": "Returns the current orientation of the layout.", "history": "added in version 22.0.0", "FullName": "int getOrientation ()"}, "scrollToPositionWithOffset(int, int)": {"Returns": [], "Parameters": [["int", "int: Index (starting at 0) of the reference item."], ["int", "int: The distance (in pixels) between the start edge of the item view and start edge of the RecyclerView."]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#setReverseLayout_E@", "@B_android#support#v7#widget#LinearLayoutManager#scrollToPosition_E@"], "Permissions": [], "Description": "Scroll to the specified adapter position with the given offset from resolved layout start. Resolved layout start depends on @B_android#support#v7#widget#LinearLayoutManager#getReverseLayout_E@, @B_android#support#v4#view#ViewCompat#getLayoutDirection_E@ and @B_android#support#v7#widget#LinearLayoutManager#getStackFromEnd_E@. For example, if layout is @B_android#support#v7#widget#LinearLayoutManager#VERTICAL_E@ and @B_android#support#v7#widget#LinearLayoutManager#getStackFromEnd_E@ is true, calling scrollToPositionWithOffset(10, 20) will layout such that item[10]'s bottom is 20 pixels above the RecyclerView's bottom. Note that scroll position change will not be reflected until the next layout call. If you are just trying to make a position visible, use @B_android#support#v7#widget#LinearLayoutManager#scrollToPosition_E@.", "history": "added in version 22.0.0", "FullName": "void scrollToPositionWithOffset (int position, int offset)"}, "canScrollHorizontally()": {"Returns": [["boolean", "true if @B_android#support#v7#widget#LinearLayoutManager#getOrientation_E@ is @B_android#support#v7#widget#LinearLayoutManager#HORIZONTAL_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Query if horizontal scrolling is currently supported. The default implementation returns false.", "history": "added in version 22.0.0", "FullName": "boolean canScrollHorizontally ()"}, "onSaveInstanceState()": {"Returns": [["@B_android#os#Parcelable_E@", "Necessary information for LayoutManager to be able to restore its state"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the LayoutManager should save its state. This is a good time to save your scroll position, configuration and anything else that may be required to restore the same layout state if the LayoutManager is recreated. RecyclerView does NOT verify if the LayoutManager has changed between state save and restore. This will let you share information between your LayoutManagers but it is also your responsibility to make sure they use the same parcelable class.", "history": "added in version 22.0.0", "FullName": "Parcelable onSaveInstanceState ()"}, "generateDefaultLayoutParams()": {"Returns": [["@B_android#support#v7#widget#RecyclerView#LayoutParams_E@", "A new LayoutParams for a child view"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a default LayoutParams object for a child of the RecyclerView. LayoutManagers will often want to use a custom LayoutParams type to store extra information specific to the layout. Client code should subclass @B_android#support#v7#widget#RecyclerView#LayoutParams_E@ for this purpose. Important: if you use your own custom LayoutParams type you must also override @B_android#support#v7#widget#RecyclerView#LayoutManager#checkLayoutParams_E@, @B_android#support#v7#widget#RecyclerView#LayoutManager#generateLayoutParams_E@ and @B_android#support#v7#widget#RecyclerView#LayoutManager#generateLayoutParams_E@.", "history": "added in version 22.0.0", "FullName": "RecyclerView.LayoutParams generateDefaultLayoutParams ()"}, "findFirstVisibleItemPosition()": {"Returns": [["int", "The adapter position of the first visible item or @B_android#support#v7#widget#RecyclerView#NO_POSITION_E@ if there aren't any visible items."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#LinearLayoutManager#findFirstCompletelyVisibleItemPosition_E@", "@B_android#support#v7#widget#LinearLayoutManager#findLastVisibleItemPosition_E@"], "Permissions": [], "Description": "Returns the adapter position of the first visible view. This position does not include adapter changes that were dispatched after the last layout pass. Note that, this value is not affected by layout orientation or item order traversal. (@B_android#support#v7#widget#LinearLayoutManager#setReverseLayout_E@). Views are sorted by their positions in the adapter, not in the layout. If RecyclerView has item decorators, they will be considered in calculations as well. LayoutManager may pre-cache some views that are not necessarily visible. Those views are ignored in this method.", "history": "added in version 22.0.0", "FullName": "int findFirstVisibleItemPosition ()"}, "assertNotInLayoutOrScroll(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The message for the exception. Can be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Checks if RecyclerView is in the middle of a layout or scroll and throws an @B_java#lang#IllegalStateException_E@ if it", "history": "added in version 22.0.0", "FullName": "void assertNotInLayoutOrScroll (String message)"}, "getStackFromEnd()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "boolean getStackFromEnd ()"}, "setInitialPrefetchItemCount(int)": {"Returns": [], "Parameters": [["int", "int: Number of items to prefetch"]], "Throws": [], "SeeAlso": ["@B_android#support#v7#widget#RecyclerView#LayoutManager#isItemPrefetchEnabled_E@", "@B_android#support#v7#widget#LinearLayoutManager#getInitialPrefetchItemCount_E@", "@B_android#support#v7#widget#LinearLayoutManager#collectInitialPrefetchPositions_E@"], "Permissions": [], "Description": "Sets the number of items to prefetch in @B_android#support#v7#widget#LinearLayoutManager#collectInitialPrefetchPositions_E@, which defines how many inner items should be prefetched when this LayoutManager's RecyclerView is nested inside another RecyclerView. Set this value to the number of items this inner LayoutManager will display when it is first scrolled into the viewport. RecyclerView will attempt to prefetch that number of items so they are ready, avoiding jank as the inner RecyclerView is scrolled into the viewport. For example, take a vertically scrolling RecyclerView with horizontally scrolling inner RecyclerViews. The rows always have 4 items visible in them (or 5 if not aligned). Passing 4 to this method for each inner RecyclerView's LinearLayoutManager will enable RecyclerView's prefetching feature to do create/bind work for 4 views within a row early, before it is scrolled on screen, instead of just the default 2. Calling this method does nothing unless the LayoutManager is in a RecyclerView nested in another RecyclerView.", "history": "added in version 25.1.0", "FullName": "void setInitialPrefetchItemCount (int itemCount)"}, "setOrientation(int)": {"Returns": [], "Parameters": [["int", "int: @B_android#support#v7#widget#LinearLayoutManager#HORIZONTAL_E@ or @B_android#support#v7#widget#LinearLayoutManager#VERTICAL_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the orientation of the layout. @B_android#support#v7#widget#LinearLayoutManager_E@ will do its best to keep scroll position.", "history": "added in version 22.0.0", "FullName": "void setOrientation (int orientation)"}}, "Inheritance": ["java.lang.Object", "@B_android#support#v7#widget#RecyclerView#LayoutManager_E@"], "ClassName": "android.support.v7.widget.LinearLayoutManager", "ClassDesc": "A @B_android#support#v7#widget#RecyclerView#LayoutManager_E@ implementation which provides similar functionality to https:##developer#android#com@B_android#widget#ListView_E@."}