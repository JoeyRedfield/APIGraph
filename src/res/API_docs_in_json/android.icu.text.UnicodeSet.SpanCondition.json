{"Functions": {"valueOf(java.lang.String)": {"Returns": [["@B_android#icu#text#UnicodeSet#SpanCondition_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 24", "FullName": "public static UnicodeSet.SpanCondition valueOf (String name)"}, "values()": {"Returns": [["@B_android#icu#text#UnicodeSet#SpanCondition_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 24", "FullName": "public static final SpanCondition[] values ()"}}, "Inheritance": ["@B_java#lang#Enum_E@"], "ClassName": "android.icu.text.UnicodeSet.SpanCondition", "ClassDesc": "Argument values for whether span() and similar functions continue while the current character is contained vs. not contained in the set. The functionality is straightforward for sets with only single code points, without strings (which is the common case): CONTAINED and SIMPLE work the same. CONTAINED and SIMPLE are inverses of NOT_CONTAINED. span() and spanBack() partition any string the same way when alternating between span(NOT_CONTAINED) and span(either \"contained\" condition). Using a complemented (inverted) set and the opposite span conditions yields the same results. When a set contains multi-code point strings, then these statements may not be true, depending on the strings in the set (for example, whether they overlap with each other) and the string that is processed. For a set with strings: The complement of the set contains the opposite set of code points, but the same set of strings. Therefore, complementing both the set and the span conditions may yield different results. When starting spans at different positions in a string (span(s, ...) vs. span(s+1, ...)) the ends of the spans may be different because a set string may start before the later position. span(SIMPLE) may be shorter than span(CONTAINED) because it will not recursively try all possible paths. For example, with a set which contains the three strings \"xy\", \"xya\" and \"ax\", span(\"xyax\", CONTAINED) will return 4 but span(\"xyax\", SIMPLE) will return 3. span(SIMPLE) will never be longer than span(CONTAINED). With either \"contained\" condition, span() and spanBack() may partition a string in different ways. For example, with a set which contains the two strings \"ab\" and \"ba\", and when processing the string \"aba\", span() will yield contained/not-contained boundaries of { 0, 2, 3 } while spanBack() will yield boundaries of { 0, 1, 3 }. Note: If it is important to get the same boundaries whether iterating forward or backward through a string, then either only span() should be used and the boundaries cached for backward operation, or an ICU BreakIterator could be used. Note: Unpaired surrogates are treated like surrogate code points. Similarly, set strings match only on code point boundaries, never in the middle of a surrogate pair."}