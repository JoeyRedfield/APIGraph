{"Functions": {"sendOrderedBroadcast(android.content.Intent,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast."], ["@B_java#lang#String_E@", "String: (optional) String naming a permissions that a receiver must hold in order to receive your broadcast. If null, no permission is required. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Broadcast the given intent to all interested BroadcastReceivers, delivering them one at a time to allow more preferred receivers to consume the broadcast before it is delivered to less preferred receivers. This call is asynchronous; it returns immediately, and you will continue executing while the receivers are run. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public void sendOrderedBroadcast (Intent intent, String receiverPermission)"}, "sendBroadcast(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Broadcast the given intent to all interested BroadcastReceivers. This call is asynchronous; it returns immediately, and you will continue executing while the receivers are run. No results are propagated from receivers and receivers can not abort the broadcast. If you want to allow receivers to propagate results or abort the broadcast, you must send an ordered broadcast using @B_android#content#Context#sendOrderedBroadcast_E@. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public void sendBroadcast (Intent intent)"}, "bindIsolatedService(android.content.Intent,int,java.lang.String,java.util.concurrent.Executor,android.content.ServiceConnection)": {"Returns": [["boolean", "Returns success of binding as per @B_android#content#Context#bindService_E@."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: Identifies the service to connect to. The Intent must specify an explicit component name. This value must never be null."], ["int", "int: Operation options for the binding as per @B_android#test#IsolatedContext#bindService_E@. Value is either 0 or a combination of @B_android#content#Context#BIND_AUTO_CREATE_E@, @B_android#content#Context#BIND_DEBUG_UNBIND_E@, @B_android#content#Context#BIND_NOT_FOREGROUND_E@, @B_android#content#Context#BIND_ABOVE_CLIENT_E@, @B_android#content#Context#BIND_ALLOW_OOM_MANAGEMENT_E@, @B_android#content#Context#BIND_WAIVE_PRIORITY_E@, @B_android#content#Context#BIND_IMPORTANT_E@, @B_android#content#Context#BIND_ADJUST_WITH_ACTIVITY_E@, @B_android#content#Context#BIND_NOT_PERCEPTIBLE_E@, and @B_android#content#Context#BIND_INCLUDE_CAPABILITIES_E@"], ["@B_java#lang#String_E@", "String: Unique identifier for the service instance. Each unique name here will result in a different service instance being created. Identifiers must only contain ASCII letters, digits, underscores, and periods. This value must never be null."], ["@B_java#util#concurrent#Executor_E@", "Executor: Callbacks on ServiceConnection will be called on executor. Must use same instance for the same instance of ServiceConnection. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#content#ServiceConnection_E@", "ServiceConnection: Receives information as the service is started and stopped. This must be a valid ServiceConnection object; it must not be null. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Variation of @B_android#content#Context#bindService_E@ that, in the specific case of isolated services, allows the caller to generate multiple instances of a service from a single component declaration. In other words, you can use this to bind to a service that has specified @B_android#R#attr#isolatedProcess_E@ and, in addition to the existing behavior of running in an isolated process, you can also through the arguments here have the system bring up multiple concurrent processes hosting their own instances of that service. The @B_android#content#Context#updateServiceGroup_E@ to tell the system how it should manage each of these instances.", "history": "Added in API level 29 Deprecated in API level 24", "FullName": "public boolean bindIsolatedService (Intent service, int flags, String instanceName, Executor executor, ServiceConnection conn)"}, "checkUriPermission(android.net.Uri,int,int,int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the given pid/uid is allowed to access that uri, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."], ["int", "int: The access modes to check. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determine whether a particular process and user ID has been granted permission to access a specific URI. This only checks for permissions that have been explicitly granted -- if the given process/uid has more general access to the URI's content provider then this check will always fail.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public int checkUriPermission (Uri uri, int pid, int uid, int modeFlags)"}, "bindService(android.content.Intent,int,java.util.concurrent.Executor,android.content.ServiceConnection)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#content#Intent_E@", "Intent: This value must never be null."], ["int", "int: Value is either 0 or a combination of @B_android#content#Context#BIND_AUTO_CREATE_E@, @B_android#content#Context#BIND_DEBUG_UNBIND_E@, @B_android#content#Context#BIND_NOT_FOREGROUND_E@, @B_android#content#Context#BIND_ABOVE_CLIENT_E@, @B_android#content#Context#BIND_ALLOW_OOM_MANAGEMENT_E@, @B_android#content#Context#BIND_WAIVE_PRIORITY_E@, @B_android#content#Context#BIND_IMPORTANT_E@, @B_android#content#Context#BIND_ADJUST_WITH_ACTIVITY_E@, @B_android#content#Context#BIND_NOT_PERCEPTIBLE_E@, and @B_android#content#Context#BIND_INCLUDE_CAPABILITIES_E@"], ["@B_java#util#concurrent#Executor_E@", "Executor: Callbacks on ServiceConnection will be called on executor. Must use same instance for the same instance of ServiceConnection. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#content#ServiceConnection_E@", "ServiceConnection: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_android#content#Context#bindService_E@ with executor to control ServiceConnection callbacks.", "history": "Added in API level 29 Deprecated in API level 24", "FullName": "public boolean bindService (Intent service, int flags, Executor executor, ServiceConnection conn)"}, "getContentResolver()": {"Returns": [["@B_android#content#ContentResolver_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a ContentResolver instance for your application's package.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public ContentResolver getContentResolver ()"}, "checkUriPermission(android.net.Uri,java.lang.String,java.lang.String,int,int,int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the caller is allowed to access that uri or holds one of the given permissions, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The Uri whose permission is to be checked, or null to not do this check. This value may be null."], ["@B_java#lang#String_E@", "String: The permission that provides overall read access, or null to not do this check. This value may be null."], ["@B_java#lang#String_E@", "String: The permission that provides overall write access, or null to not do this check. This value may be null."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."], ["int", "int: The access modes to check. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check both a Uri and normal permission. This allows you to perform both @B_android#content#Context#checkPermission_E@ and @B_android#content#Context#checkUriPermission_E@ in one call.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public int checkUriPermission (Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags)"}, "bindService(android.content.Intent,android.content.ServiceConnection,int)": {"Returns": [["boolean", "true if the system is in the process of bringing up a service that your client has permission to bind to; false if the system couldn't find the service or if your client doesn't have permission to bind to it. If this value is true, you should later call @B_android#content#Context#unbindService_E@ to release the connection."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: Identifies the service to connect to. The Intent must specify an explicit component name."], ["@B_android#content#ServiceConnection_E@", "ServiceConnection: Receives information as the service is started and stopped. This must be a valid ServiceConnection object; it must not be null. This value must never be null."], ["int", "int: Operation options for the binding. May be 0, @B_android#content#Context#BIND_AUTO_CREATE_E@, @B_android#content#Context#BIND_DEBUG_UNBIND_E@, @B_android#content#Context#BIND_NOT_FOREGROUND_E@, @B_android#content#Context#BIND_ABOVE_CLIENT_E@, @B_android#content#Context#BIND_ALLOW_OOM_MANAGEMENT_E@, @B_android#content#Context#BIND_WAIVE_PRIORITY_E@. @B_android#content#Context#BIND_IMPORTANT_E@, or @B_android#content#Context#BIND_ADJUST_WITH_ACTIVITY_E@. Value is either 0 or a combination of @B_android#content#Context#BIND_AUTO_CREATE_E@, @B_android#content#Context#BIND_DEBUG_UNBIND_E@, @B_android#content#Context#BIND_NOT_FOREGROUND_E@, @B_android#content#Context#BIND_ABOVE_CLIENT_E@, @B_android#content#Context#BIND_ALLOW_OOM_MANAGEMENT_E@, @B_android#content#Context#BIND_WAIVE_PRIORITY_E@, @B_android#content#Context#BIND_IMPORTANT_E@, @B_android#content#Context#BIND_ADJUST_WITH_ACTIVITY_E@, @B_android#content#Context#BIND_NOT_PERCEPTIBLE_E@, and @B_android#content#Context#BIND_INCLUDE_CAPABILITIES_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Connect to an application service, creating it if needed. This defines a dependency between your application and the service. The given If the service does not support binding, it may return null from its @B_android#app#Service#onBind_E@ method. If it does, then the ServiceConnection's @B_android#content#ServiceConnection#onNullBinding_E@ method will be invoked instead of @B_android#content#ServiceConnection#onServiceConnected_E@. This method will throw @B_java#lang#SecurityException_E@ if the calling app does not have permission to bind to the given service. Note: this method cannot be called from a @B_android#content#BroadcastReceiver_E@ component. A pattern you can use to communicate from a BroadcastReceiver to a Service is to call @B_android#content#Context#startService_E@ with the arguments containing the command to be sent, with the service calling its @B_android#app#Service#stopSelf_E@ method when done executing that command. See the API demo App/Service/Service Start Arguments Controller for an illustration of this. It is okay, however, to use this method from a BroadcastReceiver that has been registered with @B_android#content#Context#registerReceiver_E@, since the lifetime of this BroadcastReceiver is tied to another object (the one that registered it).", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public boolean bindService (Intent service, ServiceConnection conn, int flags)"}, "getSystemService(java.lang.String)": {"Returns": [["@B_java#lang#Object_E@", "The service or null if the name does not exist."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the desired service. Value is @B_android#content#Context#POWER_SERVICE_E@, @B_android#content#Context#WINDOW_SERVICE_E@, @B_android#content#Context#LAYOUT_INFLATER_SERVICE_E@, @B_android#content#Context#ACCOUNT_SERVICE_E@, @B_android#content#Context#ACTIVITY_SERVICE_E@, @B_android#content#Context#ALARM_SERVICE_E@, @B_android#content#Context#NOTIFICATION_SERVICE_E@, @B_android#content#Context#ACCESSIBILITY_SERVICE_E@, @B_android#content#Context#CAPTIONING_SERVICE_E@, @B_android#content#Context#KEYGUARD_SERVICE_E@, @B_android#content#Context#LOCATION_SERVICE_E@, @B_android#content#Context#SEARCH_SERVICE_E@, @B_android#content#Context#SENSOR_SERVICE_E@, android.content.Context.SENSOR_PRIVACY_SERVICE, @B_android#content#Context#STORAGE_SERVICE_E@, @B_android#content#Context#STORAGE_STATS_SERVICE_E@, @B_android#content#Context#WALLPAPER_SERVICE_E@, android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE, @B_android#content#Context#VIBRATOR_SERVICE_E@, @B_android#content#Context#CONNECTIVITY_SERVICE_E@, @B_android#content#Context#IPSEC_SERVICE_E@, android.content.Context.TEST_NETWORK_SERVICE, @B_android#content#Context#NETWORK_STATS_SERVICE_E@, @B_android#content#Context#WIFI_SERVICE_E@, @B_android#content#Context#WIFI_AWARE_SERVICE_E@, @B_android#content#Context#WIFI_P2P_SERVICE_E@, android.content.Context.WIFI_SCANNING_SERVICE, @B_android#content#Context#WIFI_RTT_RANGING_SERVICE_E@, @B_android#content#Context#NSD_SERVICE_E@, @B_android#content#Context#AUDIO_SERVICE_E@, @B_android#content#Context#FINGERPRINT_SERVICE_E@, @B_android#content#Context#BIOMETRIC_SERVICE_E@, @B_android#content#Context#MEDIA_ROUTER_SERVICE_E@, @B_android#content#Context#TELEPHONY_SERVICE_E@, @B_android#content#Context#TELEPHONY_SUBSCRIPTION_SERVICE_E@, @B_android#content#Context#CARRIER_CONFIG_SERVICE_E@, @B_android#content#Context#TELECOM_SERVICE_E@, @B_android#content#Context#CLIPBOARD_SERVICE_E@, @B_android#content#Context#INPUT_METHOD_SERVICE_E@, @B_android#content#Context#TEXT_SERVICES_MANAGER_SERVICE_E@, @B_android#content#Context#TEXT_CLASSIFICATION_SERVICE_E@, @B_android#content#Context#APPWIDGET_SERVICE_E@, android.content.Context.ROLLBACK_SERVICE, @B_android#content#Context#DROPBOX_SERVICE_E@, @B_android#content#Context#DEVICE_POLICY_SERVICE_E@, @B_android#content#Context#UI_MODE_SERVICE_E@, @B_android#content#Context#DOWNLOAD_SERVICE_E@, @B_android#content#Context#NFC_SERVICE_E@, @B_android#content#Context#BLUETOOTH_SERVICE_E@, @B_android#content#Context#USB_SERVICE_E@, @B_android#content#Context#LAUNCHER_APPS_SERVICE_E@, @B_android#content#Context#INPUT_SERVICE_E@, @B_android#content#Context#DISPLAY_SERVICE_E@, @B_android#content#Context#USER_SERVICE_E@, @B_android#content#Context#RESTRICTIONS_SERVICE_E@, @B_android#content#Context#APP_OPS_SERVICE_E@, @B_android#content#Context#ROLE_SERVICE_E@, @B_android#content#Context#CAMERA_SERVICE_E@, @B_android#content#Context#PRINT_SERVICE_E@, @B_android#content#Context#CONSUMER_IR_SERVICE_E@, @B_android#content#Context#TV_INPUT_SERVICE_E@, @B_android#content#Context#USAGE_STATS_SERVICE_E@, @B_android#content#Context#MEDIA_SESSION_SERVICE_E@, @B_android#content#Context#BATTERY_SERVICE_E@, @B_android#content#Context#JOB_SCHEDULER_SERVICE_E@, @B_android#content#Context#MEDIA_PROJECTION_SERVICE_E@, @B_android#content#Context#MIDI_SERVICE_E@, android.content.Context.RADIO_SERVICE, @B_android#content#Context#HARDWARE_PROPERTIES_SERVICE_E@, @B_android#content#Context#SHORTCUT_SERVICE_E@, @B_android#content#Context#SYSTEM_HEALTH_SERVICE_E@, @B_android#content#Context#COMPANION_DEVICE_SERVICE_E@, @B_android#content#Context#CROSS_PROFILE_APPS_SERVICE_E@, or android.content.Context.PERMISSION_SERVICE This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the handle to a system-level service by name. The class of the returned object varies by the requested name. Currently available names are: Note: System services obtained via this API may be closely associated with the Context in which they are obtained from. In general, do not share the service objects between various different contexts (Activities, Applications, Services, Providers, etc.) Note: Instant apps, for which @B_android#content#pm#PackageManager#isInstantApp_E@ returns true, don't have access to the following system services: @B_android#content#Context#DEVICE_POLICY_SERVICE_E@, @B_android#content#Context#FINGERPRINT_SERVICE_E@, @B_android#content#Context#KEYGUARD_SERVICE_E@, @B_android#content#Context#SHORTCUT_SERVICE_E@, @B_android#content#Context#USB_SERVICE_E@, @B_android#content#Context#WALLPAPER_SERVICE_E@, @B_android#content#Context#WIFI_P2P_SERVICE_E@, @B_android#content#Context#WIFI_SERVICE_E@, @B_android#content#Context#WIFI_AWARE_SERVICE_E@. For these services this method will return null. Generally, if you are running as an instant app you should always check whether the result of this method is null. Note: When implementing this method, keep in mind that new services can be added on newer Android releases, so if you're looking for just the explicit names mentioned above, make sure to return null when you don't recognize the name \u2014 if you throw a @B_java#lang#RuntimeException_E@ exception instead, you're app might break on new Android releases.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public Object getSystemService (String name)"}, "getAndClearBroadcastIntents()": {"Returns": [["@B_java#util#List_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the list of intents that were broadcast since the last call to this method.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public List<Intent> getAndClearBroadcastIntents ()"}, "getFilesDir()": {"Returns": [["@B_java#io#File_E@", "The path of the directory holding application files."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the absolute path to the directory on the filesystem where files created with @B_android#content#Context#openFileOutput_E@ are stored. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted. No additional permissions are required for the calling app to read or write files under the returned path.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public File getFilesDir ()"}, "registerReceiver(android.content.BroadcastReceiver,android.content.IntentFilter)": {"Returns": [["@B_android#content#Intent_E@", "The first sticky intent found that matches filter, or null if there are none."]], "Parameters": [["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: The BroadcastReceiver to handle the broadcast. This value may be null."], ["@B_android#content#IntentFilter_E@", "IntentFilter: Selects the Intent broadcasts to be received."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a BroadcastReceiver to be run in the main activity thread. The The system may broadcast Intents that are \"sticky\" -- these stay around after the broadcast has finished, to be sent to any later registrations. If your IntentFilter matches one of these sticky Intents, that Intent will be returned by this function There may be multiple sticky Intents that match If you know the Intent your are registering for is sticky, you can supply null for your See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts. As of @B_android#os#Build#VERSION_CODES#ICE_CREAM_SANDWICH_E@, receivers registered with this method will correctly respect the @B_android#content#Intent#setPackage_E@ specified for an Intent being broadcast. Prior to that, it would be ignored and delivered to all matching registered receivers. Be careful if using this for security. Note: this method cannot be called from a @B_android#content#BroadcastReceiver_E@ component; that is, from a BroadcastReceiver that is declared in an application's manifest. It is okay, however, to call this method from another BroadcastReceiver that has itself been registered at run time with @B_android#content#Context#registerReceiver_E@, since the lifetime of such a registered BroadcastReceiver is tied to the object that registered it.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public Intent registerReceiver (BroadcastReceiver receiver, IntentFilter filter)"}, "checkUriPermission(android.net.Uri, int, int, int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the given pid/uid is allowed to access that uri, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."], ["int", "int: The access modes to check."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determine whether a particular process and user ID has been granted permission to access a specific URI. This only checks for permissions that have been explicitly granted -- if the given process/uid has more general access to the URI's content provider then this check will always fail.", "history": "added in API level 1", "FullName": "public int checkUriPermission (Uri uri, int pid, int uid, int modeFlags)"}, "IsolatedContext(android.content.ContentResolver,android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#ContentResolver_E@", "ContentResolver no parameter comment"], ["@B_android#content#Context_E@", "Context no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public IsolatedContext (ContentResolver resolver, Context targetContext)"}, "unregisterReceiver(android.content.BroadcastReceiver)": {"Returns": [], "Parameters": [["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: The BroadcastReceiver to unregister."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Unregister a previously registered BroadcastReceiver. All filters that have been registered for this BroadcastReceiver will be removed.", "history": "Added in API level 1 Deprecated in API level 24", "FullName": "public void unregisterReceiver (BroadcastReceiver receiver)"}}, "Inheritance": ["@B_android#content#Context_E@", "@B_android#content#ContextWrapper_E@"], "ClassName": "android.test.IsolatedContext", "ClassDesc": "New tests should be written using the A mock context which prevents its users from talking to the rest of the device while stubbing enough methods to satify code that tries to talk to other packages."}