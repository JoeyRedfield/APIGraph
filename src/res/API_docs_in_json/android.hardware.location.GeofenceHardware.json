{"Functions": {"getMonitoringTypes()": {"Returns": [["", "An array of all the monitoring types. An array of length 0 is returned in case of errors."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#LOCATION_HARDWARE_E@"], "Description": "Returns all the hardware geofence monitoring systems which are supported Call @B_android#hardware#location#GeofenceHardware#getStatusOfMonitoringType_E@ to know the current state of a monitoring system. Requires @B_android#Manifest#permission#LOCATION_HARDWARE_E@ permission to access geofencing in hardware.", "history": "Added in API level 18", "FullName": "public int[] getMonitoringTypes ()"}, "registerForMonitorStateChangeCallback(int, android.hardware.location.GeofenceHardwareMonitorCallback)": {"Returns": [["", "true on success"]], "Parameters": [["int", "Type of the monitor"], ["@B_android#hardware#location#GeofenceHardwareMonitorCallback_E@", "Callback that will be called."]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@", "@B_android#Manifest#permission#LOCATION_HARDWARE_E@"], "Description": "Register the callback to be notified when the state of a hardware geofence monitoring system changes. For instance, it can change from @B_android#hardware#location#GeofenceHardware#MONITOR_CURRENTLY_AVAILABLE_E@ to @B_android#hardware#location#GeofenceHardware#MONITOR_CURRENTLY_UNAVAILABLE_E@ Requires @B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@ permission when @B_android#hardware#location#GeofenceHardware#MONITORING_TYPE_GPS_HARDWARE_E@ is used. Requires @B_android#Manifest#permission#LOCATION_HARDWARE_E@ permission to access geofencing in hardware. This API should not be called directly by the app developers. A higher level api which abstracts the hardware should be used instead. All the checks are done by the higher level public API. Any needed locking should be handled by the higher level API. The same callback object can be used to be informed of geofence transitions and state changes of the underlying hardware subsystem.", "history": "Added in API level 18", "FullName": "public boolean registerForMonitorStateChangeCallback (int monitoringType, GeofenceHardwareMonitorCallback callback)"}, "getStatusOfMonitoringType(int)": {"Returns": [["", "Current status of the monitoring type."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns current status of a hardware geofence monitoring system. Status can be one of @B_android#hardware#location#GeofenceHardware#MONITOR_CURRENTLY_AVAILABLE_E@, @B_android#hardware#location#GeofenceHardware#MONITOR_CURRENTLY_UNAVAILABLE_E@ or @B_android#hardware#location#GeofenceHardware#MONITOR_UNSUPPORTED_E@ Some supported hardware monitoring systems might not be available for monitoring geofences in certain scenarios. For example, when a user enters a building, the GPS hardware subsystem might not be able monitor geofences and will change from @B_android#hardware#location#GeofenceHardware#MONITOR_CURRENTLY_AVAILABLE_E@ to @B_android#hardware#location#GeofenceHardware#MONITOR_CURRENTLY_UNAVAILABLE_E@.", "history": "Added in API level 18", "FullName": "public int getStatusOfMonitoringType (int monitoringType)"}, "pauseGeofence(int, int)": {"Returns": [["", "true when the geofence is successfully sent to the hardware for pausing."]], "Parameters": [["int", "The id of the geofence."], ["int", "The type of the hardware subsystem that should be used to monitor the geofence."]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@", "@B_android#Manifest#permission#LOCATION_HARDWARE_E@"], "Description": "Pauses the monitoring of a geofence added by @B_android#hardware#location#GeofenceHardware#addGeofence_E@ call. If this call returns true, it means that the geofence has been sent to the hardware. @B_android#hardware#location#GeofenceHardwareCallback#onGeofencePause_E@ will be called with the result of the pause call from the hardware. Requires @B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@ permission when @B_android#hardware#location#GeofenceHardware#MONITORING_TYPE_GPS_HARDWARE_E@ is used. Requires @B_android#Manifest#permission#LOCATION_HARDWARE_E@ permission to access geofencing in hardware. This API should not be called directly by the app developers. A higher level api which abstracts the hardware should be used instead. All the checks are done by the higher level public API. Any needed locking should be handled by the higher level API.", "history": "Added in API level 18", "FullName": "public boolean pauseGeofence (int geofenceId, int monitoringType)"}, "unregisterForMonitorStateChangeCallback(int, android.hardware.location.GeofenceHardwareMonitorCallback)": {"Returns": [["", "true on success"]], "Parameters": [["int", "Type of the monitor"], ["@B_android#hardware#location#GeofenceHardwareMonitorCallback_E@", "Callback that will be called."]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@", "@B_android#Manifest#permission#LOCATION_HARDWARE_E@"], "Description": "Unregister the callback that was used with @B_android#hardware#location#GeofenceHardware#registerForMonitorStateChangeCallback_E@ to notify when the state of the hardware geofence monitoring system changes. Requires @B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@ permission when @B_android#hardware#location#GeofenceHardware#MONITORING_TYPE_GPS_HARDWARE_E@ is used. Requires @B_android#Manifest#permission#LOCATION_HARDWARE_E@ permission to access geofencing in hardware. This API should not be called directly by the app developers. A higher level api which abstracts the hardware should be used instead. All the checks are done by the higher level public API. Any needed locking should be handled by the higher level API.", "history": "Added in API level 18", "FullName": "public boolean unregisterForMonitorStateChangeCallback (int monitoringType, GeofenceHardwareMonitorCallback callback)"}, "addGeofence(int, int, android.hardware.location.GeofenceHardwareRequest, android.hardware.location.GeofenceHardwareCallback)": {"Returns": [["", "true when the geofence is successfully sent to the hardware for addition."]], "Parameters": [["int", "The id associated with the geofence."], ["int", "The type of the hardware subsystem that should be used to monitor the geofence."], ["@B_android#hardware#location#GeofenceHardwareRequest_E@", "The @B_android#hardware#location#GeofenceHardwareRequest_E@ object associated with the geofence."], ["@B_android#hardware#location#GeofenceHardwareCallback_E@", "@B_android#hardware#location#GeofenceHardwareCallback_E@ that will be use to notify the transition."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when the geofence request type is not supported."]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@", "@B_android#Manifest#permission#LOCATION_HARDWARE_E@"], "Description": "Creates a circular geofence which is monitored by subsystems in the hardware. When the device detects that is has entered, exited or is uncertain about the area specified by the geofence, the given callback will be called. If this call returns true, it means that the geofence has been sent to the hardware. @B_android#hardware#location#GeofenceHardwareCallback#onGeofenceAdd_E@ will be called with the result of the add call from the hardware. The @B_android#hardware#location#GeofenceHardwareCallback#onGeofenceAdd_E@ will be called with the following parameters when a transition event occurs. The geofence Id The location object indicating the last known location. The transition associated with the geofence. One of @B_android#hardware#location#GeofenceHardware#GEOFENCE_ENTERED_E@, @B_android#hardware#location#GeofenceHardware#GEOFENCE_EXITED_E@, @B_android#hardware#location#GeofenceHardware#GEOFENCE_UNCERTAIN_E@ The timestamp when the geofence transition occured. The monitoring type (@B_android#hardware#location#GeofenceHardware#MONITORING_TYPE_GPS_HARDWARE_E@ is one such example) that was used. The geofence will be monitored by the subsystem specified by monitoring_type parameter. The application does not need to hold a wakelock when the monitoring is being done by the underlying hardware subsystem. If the same geofence Id is being monitored by two different monitoring systems, the same id can be used for both calls, as long as the same callback object is used. Requires @B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@ permission when @B_android#hardware#location#GeofenceHardware#MONITORING_TYPE_GPS_HARDWARE_E@ is used. Requires @B_android#Manifest#permission#LOCATION_HARDWARE_E@ permission to access geofencing in hardware. This API should not be called directly by the app developers. A higher level api which abstracts the hardware should be used instead. All the checks are done by the higher level public API. Any needed locking should be handled by the higher level API. Create a geofence request object using the methods in @B_android#hardware#location#GeofenceHardwareRequest_E@ to set all the characteristics of the geofence. Use the created GeofenceHardwareRequest object in this call.", "history": "Added in API level 18", "FullName": "public boolean addGeofence (int geofenceId, int monitoringType, GeofenceHardwareRequest geofenceRequest, GeofenceHardwareCallback callback)"}, "resumeGeofence(int, int, int)": {"Returns": [["", "true when the geofence is successfully sent to the hardware for resumption."]], "Parameters": [["int", "The id of the geofence."], ["int", "The type of the hardware subsystem that should be used to monitor the geofence."], ["int", "Bitwise OR of @B_android#hardware#location#GeofenceHardware#GEOFENCE_ENTERED_E@, @B_android#hardware#location#GeofenceHardware#GEOFENCE_EXITED_E@, @B_android#hardware#location#GeofenceHardware#GEOFENCE_UNCERTAIN_E@"]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@", "@B_android#Manifest#permission#LOCATION_HARDWARE_E@"], "Description": "Resumes the monitoring of a geofence added by @B_android#hardware#location#GeofenceHardware#pauseGeofence_E@ call. If this call returns true, it means that the geofence has been sent to the hardware. @B_android#hardware#location#GeofenceHardwareCallback#onGeofenceResume_E@ will be called with the result of the resume call from the hardware. Requires @B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@ permission when @B_android#hardware#location#GeofenceHardware#MONITORING_TYPE_GPS_HARDWARE_E@ is used. Requires @B_android#Manifest#permission#LOCATION_HARDWARE_E@ permission to access geofencing in hardware. This API should not be called directly by the app developers. A higher level api which abstracts the hardware should be used instead. All the checks are done by the higher level public API. Any needed locking should be handled by the higher level API.", "history": "Added in API level 18", "FullName": "public boolean resumeGeofence (int geofenceId, int monitoringType, int monitorTransition)"}, "removeGeofence(int, int)": {"Returns": [["", "true when the geofence is successfully sent to the hardware for removal. ."]], "Parameters": [["int", "The id of the geofence."], ["int", "The type of the hardware subsystem that should be used to monitor the geofence."]], "Throws": [], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@", "@B_android#Manifest#permission#LOCATION_HARDWARE_E@"], "Description": "Removes a geofence added by @B_android#hardware#location#GeofenceHardware#addGeofence_E@ call. If this call returns true, it means that the geofence has been sent to the hardware. @B_android#hardware#location#GeofenceHardwareCallback#onGeofenceRemove_E@ will be called with the result of the remove call from the hardware. Requires @B_android#Manifest#permission#ACCESS_FINE_LOCATION_E@ permission when @B_android#hardware#location#GeofenceHardware#MONITORING_TYPE_GPS_HARDWARE_E@ is used. Requires @B_android#Manifest#permission#LOCATION_HARDWARE_E@ permission to access geofencing in hardware. This API should not be called directly by the app developers. A higher level api which abstracts the hardware should be used instead. All the checks are done by the higher level public API. Any needed locking should be handled by the higher level API.", "history": "Added in API level 18", "FullName": "public boolean removeGeofence (int geofenceId, int monitoringType)"}}, "Inheritance": [], "ClassName": "android.hardware.location.GeofenceHardware", "ClassDesc": "This class handles geofences managed by various hardware subsystems. It contains the public APIs that is needed to accomplish the task. The APIs should not be called directly by the app developers. A higher level api which abstracts the hardware should be used instead. All the checks are done by the higher level public API. Any needed locking should be handled by the higher level API. There are 3 states associated with a Geofence: Inside, Outside, Unknown. There are 3 transitions: @B_android#hardware#location#GeofenceHardware#GEOFENCE_ENTERED_E@, @B_android#hardware#location#GeofenceHardware#GEOFENCE_EXITED_E@, @B_android#hardware#location#GeofenceHardware#GEOFENCE_UNCERTAIN_E@. The APIs only expose the transitions. Inside state: The hardware subsystem is reasonably confident that the user is inside the geofence. Outside state: The hardware subsystem is reasonably confident that the user is outside the geofence Unknown state: Unknown state can be interpreted as a state in which the monitoring subsystem isn't confident enough that the user is either inside or outside the Geofence. If the accuracy does not improve for a sufficient period of time, the @B_android#hardware#location#GeofenceHardware#GEOFENCE_UNCERTAIN_E@ transition would be triggered. If the accuracy improves later, an appropriate transition would be triggered. The \"reasonably confident\" parameter depends on the hardware system and the positioning algorithms used. For instance, @B_android#hardware#location#GeofenceHardware#MONITORING_TYPE_GPS_HARDWARE_E@ uses 95% as a confidence level."}