{"Functions": {"findEditTable(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "the first table listed"]], "Parameters": [["@B_java#lang#String_E@", "String: a list of tables"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finds the name of the first table, which is editable.", "history": "Added in API level 1", "FullName": "public static String findEditTable (String tables)"}, "openDatabase(java.io.File,android.database.sqlite.SQLiteDatabase.OpenParams)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "the newly opened database"]], "Parameters": [["@B_java#io#File_E@", "File: path to database file to open and/or create. Important: The file should be constructed either from an absolute path or by using Context.getDatabasePath(String). This value must never be null."], ["@B_android#database#sqlite#SQLiteDatabase#OpenParams_E@", "SQLiteDatabase.OpenParams: configuration parameters that are used for opening @B_android#database#sqlite#SQLiteDatabase_E@ This value must never be null."]], "Throws": [["@B_android#database#sqlite#SQLiteException_E@", "if the database cannot be opened"]], "SeeAlso": [], "Permissions": [], "Description": "Open the database according to the specified @B_android#database#sqlite#SQLiteDatabase#OpenParams_E@", "history": "Added in API level 27", "FullName": "public static SQLiteDatabase openDatabase (File path, SQLiteDatabase.OpenParams openParams)"}, "isDbLockedByOtherThreads()": {"Returns": [["boolean", "False."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Always returns false. Do not use this method. Always returns false. There is no longer the concept of a database lock, so this method always returns false.", "history": "Added in API level 1 Deprecated in API level 16", "FullName": "public boolean isDbLockedByOtherThreads ()"}, "setTransactionSuccessful()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the current thread is not in a transaction or the transaction is already marked as successful."]], "SeeAlso": [], "Permissions": [], "Description": "Marks the current transaction as successful. Do not do any more database work between calling this and calling endTransaction. Do as little non-database work as possible in that situation too. If any errors are encountered between this and endTransaction the transaction will still be committed.", "history": "Added in API level 1", "FullName": "public void setTransactionSuccessful ()"}, "enableWriteAheadLogging()": {"Returns": [["boolean", "True if write-ahead logging is enabled."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if there are transactions in progress at the time this method is called. WAL mode can only be changed when there are no transactions in progress."]], "SeeAlso": ["@B_android#database#sqlite#SQLiteDatabase_E@", "@B_android#database#sqlite#SQLiteDatabase#disableWriteAheadLogging_E@"], "Permissions": [], "Description": "This method enables parallel execution of queries from multiple threads on the same database. It does this by opening multiple connections to the database and using a different database connection for each query. The database journal mode is also changed to enable writes to proceed concurrently with reads. When write-ahead logging is not enabled (the default), it is not possible for reads and writes to occur on the database at the same time. Before modifying the database, the writer implicitly acquires an exclusive lock on the database which prevents readers from accessing the database until the write is completed. In contrast, when write-ahead logging is enabled (by calling this method), write operations occur in a separate log file which allows reads to proceed concurrently. While a write is in progress, readers on other threads will perceive the state of the database as it was before the write began. When the write completes, readers on other threads will then perceive the new state of the database. It is a good idea to enable write-ahead logging whenever a database will be concurrently accessed and modified by multiple threads at the same time. However, write-ahead logging uses significantly more memory than ordinary journaling because there are multiple connections to the same database. So if a database will only be used by a single thread, or if optimizing concurrency is not very important, then write-ahead logging should be disabled. After calling this method, execution of queries in parallel is enabled as long as the database remains open. To disable execution of queries in parallel, either call @B_android#database#sqlite#SQLiteDatabase#disableWriteAheadLogging_E@ or close the database and reopen it. The maximum number of connections used to execute queries in parallel is dependent upon the device memory and possibly other properties. If a query is part of a transaction, then it is executed on the same database handle the transaction was begun. Writers should use @B_android#database#sqlite#SQLiteDatabase#beginTransactionNonExclusive_E@ or @B_android#database#sqlite#SQLiteDatabase#beginTransactionWithListenerNonExclusive_E@ to start a transaction. Non-exclusive mode allows database file to be in readable by other threads executing queries. If the database has any attached databases, then execution of queries in parallel is NOT possible. Likewise, write-ahead logging is not supported for read-only databases or memory databases. In such cases, @B_android#database#sqlite#SQLiteDatabase#enableWriteAheadLogging_E@ returns false. The best way to enable write-ahead logging is to pass the @B_android#database#sqlite#SQLiteDatabase#ENABLE_WRITE_AHEAD_LOGGING_E@ flag to @B_android#database#sqlite#SQLiteDatabase#openDatabase_E@. This is more efficient than calling @B_android#database#sqlite#SQLiteDatabase#enableWriteAheadLogging_E@. SQLiteDatabase db = SQLiteDatabase.openDatabase(\"db_filename\", cursorFactory, SQLiteDatabase.CREATE_IF_NECESSARY | SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING, myDatabaseErrorHandler); Another way to enable write-ahead logging is to call @B_android#database#sqlite#SQLiteDatabase#enableWriteAheadLogging_E@ after opening the database. SQLiteDatabase db = SQLiteDatabase.openDatabase(\"db_filename\", cursorFactory, SQLiteDatabase.CREATE_IF_NECESSARY, myDatabaseErrorHandler); db.enableWriteAheadLogging(); See also", "history": "Added in API level 11", "FullName": "public boolean enableWriteAheadLogging ()"}, "markTableSyncable(java.lang.String,java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: an update on this table will trigger a sync time removal"], ["@B_java#lang#String_E@", "String: this is the column in table whose value is an _id in updateTable"], ["@B_java#lang#String_E@", "String: this is the table that will have its _sync_dirty"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method no longer serves any useful purpose and has been deprecated. Mark this table as syncable, with the _sync_dirty residing in another table. When an update occurs in this table the _sync_dirty field of the row in updateTable with the _id in foreignKey will be set to ensure proper syncing operation.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public void markTableSyncable (String table, String foreignKey, String updateTable)"}, "setPageSize(long)": {"Returns": [], "Parameters": [["long", "long: the database page size, in bytes"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the database page size. The page size must be a power of two. This method does not work if any data has been written to the database file, and must be called right after the database has been created.", "history": "Added in API level 1", "FullName": "public void setPageSize (long numBytes)"}, "openDatabase(java.lang.String,android.database.sqlite.SQLiteDatabase.CursorFactory,int)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "the newly opened database"]], "Parameters": [["@B_java#lang#String_E@", "String: to database file to open and/or create This value must never be null."], ["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: an optional factory class that is called to instantiate a cursor when query is called, or null for default This value may be null."], ["int", "int: to control database access mode Value is either 0 or a combination of @B_android#database#sqlite#SQLiteDatabase#OPEN_READWRITE_E@, @B_android#database#sqlite#SQLiteDatabase#OPEN_READONLY_E@, @B_android#database#sqlite#SQLiteDatabase#CREATE_IF_NECESSARY_E@, @B_android#database#sqlite#SQLiteDatabase#NO_LOCALIZED_COLLATORS_E@, and @B_android#database#sqlite#SQLiteDatabase#ENABLE_WRITE_AHEAD_LOGGING_E@"]], "Throws": [["@B_android#database#sqlite#SQLiteException_E@", "if the database cannot be opened"]], "SeeAlso": [], "Permissions": [], "Description": "Open the database according to the flags @B_android#database#sqlite#SQLiteDatabase#OPEN_READWRITE_E@ @B_android#database#sqlite#SQLiteDatabase#OPEN_READONLY_E@ @B_android#database#sqlite#SQLiteDatabase#CREATE_IF_NECESSARY_E@ and/or @B_android#database#sqlite#SQLiteDatabase#NO_LOCALIZED_COLLATORS_E@. Sets the locale of the database to the the system's current locale. Call @B_android#database#sqlite#SQLiteDatabase#setLocale_E@ if you would like something else.", "history": "Added in API level 1", "FullName": "public static SQLiteDatabase openDatabase (String path, SQLiteDatabase.CursorFactory factory, int flags)"}, "inTransaction()": {"Returns": [["boolean", "True if the current thread is in a transaction."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the current thread has a transaction pending.", "history": "Added in API level 1", "FullName": "public boolean inTransaction ()"}, "query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String)": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_java#lang#String_E@", "String: The table name to compile the query against."], ["@B_java#lang#String_E@", "String: A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used."], ["@B_java#lang#String_E@", "String: A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table."], ["@B_java#lang#String_E@", "String: You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings."], ["@B_java#lang#String_E@", "String: A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped."], ["@B_java#lang#String_E@", "String: A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used."], ["@B_java#lang#String_E@", "String: How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered."]], "Throws": [], "SeeAlso": ["@B_android#database#Cursor_E@"], "Permissions": [], "Description": "Query the given table, returning a @B_android#database#Cursor_E@ over the result set.", "history": "Added in API level 1", "FullName": "public Cursor query (String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy)"}, "disableWriteAheadLogging()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if there are transactions in progress at the time this method is called. WAL mode can only be changed when there are no transactions in progress."]], "SeeAlso": ["@B_android#database#sqlite#SQLiteDatabase#enableWriteAheadLogging_E@"], "Permissions": [], "Description": "This method disables the features enabled by @B_android#database#sqlite#SQLiteDatabase#enableWriteAheadLogging_E@.", "history": "Added in API level 16", "FullName": "public void disableWriteAheadLogging ()"}, "validateSql(java.lang.String,android.os.CancellationSignal)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: SQL to be validated This value must never be null."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. If the operation is canceled, then @B_android#os#OperationCanceledException_E@ will be thrown when the query is executed. This value may be null."]], "Throws": [["@B_android#database#sqlite#SQLiteException_E@", "if sql is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Verifies that a SQL SELECT statement is valid by compiling it. If the SQL statement is not valid, this method will throw a @B_android#database#sqlite#SQLiteException_E@.", "history": "Added in API level 24", "FullName": "public void validateSql (String sql, CancellationSignal cancellationSignal)"}, "setVersion(int)": {"Returns": [], "Parameters": [["int", "int: the new database version"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the database version.", "history": "Added in API level 1", "FullName": "public void setVersion (int version)"}, "yieldIfContendedSafely(long)": {"Returns": [["boolean", "true if the transaction was yielded"]], "Parameters": [["long", "long: if > 0, sleep this long before starting a new transaction if the lock was actually yielded. This will allow other background threads to make some more progress than they would if we started the transaction immediately."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Temporarily end the transaction to let other threads run. The transaction is assumed to be successful so far. Do not call setTransactionSuccessful before calling this. When this returns a new transaction will have been created but not marked as successful. This assumes that there are no nested transactions (beginTransaction has only been called once) and will throw an exception if that is not the case.", "history": "Added in API level 5", "FullName": "public boolean yieldIfContendedSafely (long sleepAfterYieldDelay)"}, "compileStatement(java.lang.String)": {"Returns": [["@B_android#database#sqlite#SQLiteStatement_E@", "A pre-compiled @B_android#database#sqlite#SQLiteStatement_E@ object. Note that @B_android#database#sqlite#SQLiteStatement_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_java#lang#String_E@", "String: The raw SQL statement, may contain ? for unknown values to be bound later."]], "Throws": [["@B_android#database#SQLException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Compiles an SQL statement into a reusable pre-compiled statement object. The parameters are identical to @B_android#database#sqlite#SQLiteDatabase#execSQL_E@. You may put ?s in the statement and fill in those values with @B_android#database#sqlite#SQLiteProgram#bindString_E@ and @B_android#database#sqlite#SQLiteProgram#bindLong_E@ each time you want to run the statement. Statements may not return result sets larger than 1x1. No two threads should be using the same @B_android#database#sqlite#SQLiteStatement_E@ at the same time.", "history": "Added in API level 1", "FullName": "public SQLiteStatement compileStatement (String sql)"}, "yieldIfContended()": {"Returns": [["boolean", "true if the transaction was yielded"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "if the db is locked more than once (because of nested transactions) then the lock will not be yielded. Use yieldIfContendedSafely instead. Temporarily end the transaction to let other threads run. The transaction is assumed to be successful so far. Do not call setTransactionSuccessful before calling this. When this returns a new transaction will have been created but not marked as successful.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public boolean yieldIfContended ()"}, "update(java.lang.String,android.content.ContentValues,java.lang.String,java.lang.String[])": {"Returns": [["int", "the number of rows affected"]], "Parameters": [["@B_java#lang#String_E@", "String: the table to update in"], ["@B_android#content#ContentValues_E@", "ContentValues: a map from column names to new column values. null is a valid value that will be translated to NULL."], ["@B_java#lang#String_E@", "String: the optional WHERE clause to apply when updating. Passing null will update all rows."], ["@B_java#lang#String_E@", "String: You may include ?s in the where clause, which will be replaced by the values from whereArgs. The values will be bound as Strings."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method for updating rows in the database.", "history": "Added in API level 1", "FullName": "public int update (String table, ContentValues values, String whereClause, String[] whereArgs)"}, "onAllReferencesReleased()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the last reference to the object was released by a call to @B_android#database#sqlite#SQLiteClosable#releaseReference_E@ or @B_android#database#sqlite#SQLiteClosable#close_E@.", "history": "Added in API level 1", "FullName": "protected void onAllReferencesReleased ()"}, "openOrCreateDatabase(java.lang.String,android.database.sqlite.SQLiteDatabase.CursorFactory,android.database.DatabaseErrorHandler)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: This value must never be null."], ["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: This value may be null."], ["@B_android#database#DatabaseErrorHandler_E@", "DatabaseErrorHandler: This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY, errorHandler).", "history": "Added in API level 11", "FullName": "public static SQLiteDatabase openOrCreateDatabase (String path, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler)"}, "releaseMemory()": {"Returns": [["int", "the number of bytes actually released"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Attempts to release memory that SQLite holds but does not require to operate properly. Typically this memory will come from the page cache.", "history": "Added in API level 1", "FullName": "public static int releaseMemory ()"}, "rawQuery(java.lang.String,java.lang.String[],android.os.CancellationSignal)": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_java#lang#String_E@", "String: the SQL query. The SQL string must not be ; terminated"], ["@B_java#lang#String_E@", "String: You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. If the operation is canceled, then @B_android#os#OperationCanceledException_E@ will be thrown when the query is executed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Runs the provided SQL and returns a @B_android#database#Cursor_E@ over the result set.", "history": "Added in API level 16", "FullName": "public Cursor rawQuery (String sql, String[] selectionArgs, CancellationSignal cancellationSignal)"}, "openOrCreateDatabase(java.lang.String,android.database.sqlite.SQLiteDatabase.CursorFactory)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String: This value must never be null."], ["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to openDatabase(path, factory, CREATE_IF_NECESSARY).", "history": "Added in API level 1", "FullName": "public static SQLiteDatabase openOrCreateDatabase (String path, SQLiteDatabase.CursorFactory factory)"}, "rawQuery(java.lang.String,java.lang.String[])": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_java#lang#String_E@", "String: the SQL query. The SQL string must not be ; terminated"], ["@B_java#lang#String_E@", "String: You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Runs the provided SQL and returns a @B_android#database#Cursor_E@ over the result set.", "history": "Added in API level 1", "FullName": "public Cursor rawQuery (String sql, String[] selectionArgs)"}, "endTransaction()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "End a transaction. See beginTransaction for notes about how to use this and when transactions are committed and rolled back.", "history": "Added in API level 1", "FullName": "public void endTransaction ()"}, "isDbLockedByCurrentThread()": {"Returns": [["boolean", "True if the current thread is holding an active connection to the database."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the current thread is holding an active connection to the database. The name of this method comes from a time when having an active connection to the database meant that the thread was holding an actual lock on the database. Nowadays, there is no longer a true \"database lock\" although threads may block if they cannot acquire a database connection to perform a particular operation.", "history": "Added in API level 1", "FullName": "public boolean isDbLockedByCurrentThread ()"}, "execSQL(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the SQL statement to be executed. Multiple statements separated by semicolons are not supported."]], "Throws": [["@B_android#database#SQLException_E@", "if the SQL string is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Execute a single SQL statement that is NOT a SELECT or any other SQL statement that returns data. It has no means to return any data (such as the number of affected rows). Instead, you're encouraged to use @B_android#database#sqlite#SQLiteDatabase#insert_E@, @B_android#database#sqlite#SQLiteDatabase#update_E@, et al, when possible. When using @B_android#database#sqlite#SQLiteDatabase#enableWriteAheadLogging_E@, journal_mode is automatically managed by this class. So, do not set journal_mode using \"PRAGMA journal_mode'", "history": "Added in API level 1", "FullName": "public void execSQL (String sql)"}, "isDatabaseIntegrityOk()": {"Returns": [["boolean", "true if the given database (and all its attached databases) pass integrity_check, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Runs 'pragma integrity_check' on the given database (and all the attached databases) and returns true if the given database (and all its attached databases) pass integrity_check, false otherwise. If the result is false, then this method logs the errors reported by the integrity_check command execution. Note that 'pragma integrity_check' on a database can take a long time.", "history": "Added in API level 11", "FullName": "public boolean isDatabaseIntegrityOk ()"}, "openOrCreateDatabase(java.io.File,android.database.sqlite.SQLiteDatabase.CursorFactory)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "no returns description in source"]], "Parameters": [["@B_java#io#File_E@", "File: This value must never be null."], ["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to openDatabase(file.getPath(), factory, CREATE_IF_NECESSARY).", "history": "Added in API level 1", "FullName": "public static SQLiteDatabase openOrCreateDatabase (File file, SQLiteDatabase.CursorFactory factory)"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of the object. In general, the toString method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:", "history": "Added in API level 1", "FullName": "public String toString ()"}, "getPageSize()": {"Returns": [["long", "the database page size, in bytes"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current database page size, in bytes.", "history": "Added in API level 1", "FullName": "public long getPageSize ()"}, "isOpen()": {"Returns": [["boolean", "True if the database is currently open (has not been closed)."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the database is currently open.", "history": "Added in API level 1", "FullName": "public boolean isOpen ()"}, "getAttachedDbs()": {"Returns": [["@B_java#util#List_E@", "ArrayList of pairs of (database name, database file path) or null if the database is not open."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns list of full pathnames of all attached databases including the main database by executing 'pragma database_list' on the database.", "history": "Added in API level 11", "FullName": "public List<Pair<String, String>> getAttachedDbs ()"}, "beginTransactionNonExclusive()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begins a transaction in IMMEDIATE mode. Transactions can be nested. When the outer transaction is ended all of the work done in that transaction and all of the nested transactions will be committed or rolled back. The changes will be rolled back if any transaction is ended without being marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed. Here is the standard idiom for transactions:", "history": "Added in API level 11", "FullName": "public void beginTransactionNonExclusive ()"}, "rawQueryWithFactory(android.database.sqlite.SQLiteDatabase.CursorFactory,java.lang.String,java.lang.String[],java.lang.String)": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: the cursor factory to use, or null for the default factory"], ["@B_java#lang#String_E@", "String: the SQL query. The SQL string must not be ; terminated"], ["@B_java#lang#String_E@", "String: You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings."], ["@B_java#lang#String_E@", "String: the name of the first table, which is editable"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Runs the provided SQL and returns a cursor over the result set.", "history": "Added in API level 1", "FullName": "public Cursor rawQueryWithFactory (SQLiteDatabase.CursorFactory cursorFactory, String sql, String[] selectionArgs, String editTable)"}, "rawQueryWithFactory(android.database.sqlite.SQLiteDatabase.CursorFactory,java.lang.String,java.lang.String[],java.lang.String,android.os.CancellationSignal)": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: the cursor factory to use, or null for the default factory"], ["@B_java#lang#String_E@", "String: the SQL query. The SQL string must not be ; terminated"], ["@B_java#lang#String_E@", "String: You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings."], ["@B_java#lang#String_E@", "String: the name of the first table, which is editable"], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. If the operation is canceled, then @B_android#os#OperationCanceledException_E@ will be thrown when the query is executed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Runs the provided SQL and returns a cursor over the result set.", "history": "Added in API level 16", "FullName": "public Cursor rawQueryWithFactory (SQLiteDatabase.CursorFactory cursorFactory, String sql, String[] selectionArgs, String editTable, CancellationSignal cancellationSignal)"}, "setMaximumSize(long)": {"Returns": [["long", "the new maximum database size"]], "Parameters": [["long", "long: the maximum database size, in bytes"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the maximum size the database will grow to. The maximum size cannot be set below the current size.", "history": "Added in API level 1", "FullName": "public long setMaximumSize (long numBytes)"}, "createInMemory(android.database.sqlite.SQLiteDatabase.OpenParams)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "a SQLiteDatabase instance This value will never be null."]], "Parameters": [["@B_android#database#sqlite#SQLiteDatabase#OpenParams_E@", "SQLiteDatabase.OpenParams: configuration parameters that are used for opening SQLiteDatabase This value must never be null."]], "Throws": [["@B_android#database#SQLException_E@", "if the database cannot be created"]], "SeeAlso": [], "Permissions": [], "Description": "Create a memory backed SQLite database. Its contents will be destroyed when the database is closed. Sets the locale of the database to the the system's current locale. Call @B_android#database#sqlite#SQLiteDatabase#setLocale_E@ if you would like something else.", "history": "Added in API level 27", "FullName": "public static SQLiteDatabase createInMemory (SQLiteDatabase.OpenParams openParams)"}, "getPath()": {"Returns": [["@B_java#lang#String_E@", "The path to the database file."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the path to the database file.", "history": "Added in API level 1", "FullName": "public String getPath ()"}, "create(android.database.sqlite.SQLiteDatabase.CursorFactory)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "a SQLiteDatabase instance This value will never be null."]], "Parameters": [["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: an optional factory class that is called to instantiate a cursor when query is called This value may be null."]], "Throws": [["@B_android#database#sqlite#SQLiteException_E@", "if the database cannot be created"]], "SeeAlso": [], "Permissions": [], "Description": "Create a memory backed SQLite database. Its contents will be destroyed when the database is closed. Sets the locale of the database to the the system's current locale. Call @B_android#database#sqlite#SQLiteDatabase#setLocale_E@ if you would like something else.", "history": "Added in API level 1", "FullName": "public static SQLiteDatabase create (SQLiteDatabase.CursorFactory factory)"}, "queryWithFactory(android.database.sqlite.SQLiteDatabase.CursorFactory,boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.os.CancellationSignal)": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: the cursor factory to use, or null for the default factory"], ["boolean", "boolean: true if you want each row to be unique, false otherwise."], ["@B_java#lang#String_E@", "String: The table name to compile the query against."], ["@B_java#lang#String_E@", "String: A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used."], ["@B_java#lang#String_E@", "String: A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table."], ["@B_java#lang#String_E@", "String: You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings."], ["@B_java#lang#String_E@", "String: A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped."], ["@B_java#lang#String_E@", "String: A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used."], ["@B_java#lang#String_E@", "String: How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered."], ["@B_java#lang#String_E@", "String: Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. If the operation is canceled, then @B_android#os#OperationCanceledException_E@ will be thrown when the query is executed."]], "Throws": [], "SeeAlso": ["@B_android#database#Cursor_E@"], "Permissions": [], "Description": "Query the given URL, returning a @B_android#database#Cursor_E@ over the result set.", "history": "Added in API level 16", "FullName": "public Cursor queryWithFactory (SQLiteDatabase.CursorFactory cursorFactory, boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit, CancellationSignal cancellationSignal)"}, "delete(java.lang.String,java.lang.String,java.lang.String[])": {"Returns": [["int", "the number of rows affected if a whereClause is passed in, 0 otherwise. To remove all rows and get a count pass \"1\" as the whereClause."]], "Parameters": [["@B_java#lang#String_E@", "String: the table to delete from"], ["@B_java#lang#String_E@", "String: the optional WHERE clause to apply when deleting. Passing null will delete all rows."], ["@B_java#lang#String_E@", "String: You may include ?s in the where clause, which will be replaced by the values from whereArgs. The values will be bound as Strings."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method for deleting rows in the database.", "history": "Added in API level 1", "FullName": "public int delete (String table, String whereClause, String[] whereArgs)"}, "query(java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_java#lang#String_E@", "String: The table name to compile the query against."], ["@B_java#lang#String_E@", "String: A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used."], ["@B_java#lang#String_E@", "String: A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table."], ["@B_java#lang#String_E@", "String: You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings."], ["@B_java#lang#String_E@", "String: A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped."], ["@B_java#lang#String_E@", "String: A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used."], ["@B_java#lang#String_E@", "String: How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered."], ["@B_java#lang#String_E@", "String: Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause."]], "Throws": [], "SeeAlso": ["@B_android#database#Cursor_E@"], "Permissions": [], "Description": "Query the given table, returning a @B_android#database#Cursor_E@ over the result set.", "history": "Added in API level 1", "FullName": "public Cursor query (String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#Throwable_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 1", "FullName": "protected void finalize ()"}, "beginTransaction()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begins a transaction in EXCLUSIVE mode. Transactions can be nested. When the outer transaction is ended all of the work done in that transaction and all of the nested transactions will be committed or rolled back. The changes will be rolled back if any transaction is ended without being marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed. Here is the standard idiom for transactions:", "history": "Added in API level 1", "FullName": "public void beginTransaction ()"}, "query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["boolean", "boolean: true if you want each row to be unique, false otherwise."], ["@B_java#lang#String_E@", "String: The table name to compile the query against."], ["@B_java#lang#String_E@", "String: A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used."], ["@B_java#lang#String_E@", "String: A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table."], ["@B_java#lang#String_E@", "String: You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings."], ["@B_java#lang#String_E@", "String: A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped."], ["@B_java#lang#String_E@", "String: A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used."], ["@B_java#lang#String_E@", "String: How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered."], ["@B_java#lang#String_E@", "String: Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause."]], "Throws": [], "SeeAlso": ["@B_android#database#Cursor_E@"], "Permissions": [], "Description": "Query the given URL, returning a @B_android#database#Cursor_E@ over the result set.", "history": "Added in API level 1", "FullName": "public Cursor query (boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)"}, "beginTransactionWithListener(android.database.sqlite.SQLiteTransactionListener)": {"Returns": [], "Parameters": [["@B_android#database#sqlite#SQLiteTransactionListener_E@", "SQLiteTransactionListener: listener that should be notified when the transaction begins, commits, or is rolled back, either explicitly or by a call to @B_android#database#sqlite#SQLiteDatabase#yieldIfContendedSafely_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begins a transaction in EXCLUSIVE mode. Transactions can be nested. When the outer transaction is ended all of the work done in that transaction and all of the nested transactions will be committed or rolled back. The changes will be rolled back if any transaction is ended without being marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed. Here is the standard idiom for transactions:", "history": "Added in API level 5", "FullName": "public void beginTransactionWithListener (SQLiteTransactionListener transactionListener)"}, "rawQuery(java.lang.String, java.lang.String[])": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_java#lang#String_E@", "String: the SQL query. The SQL string must not be ; terminated"], ["@B_java#lang#String_E@", "String: You may include ?s in where clause in the query, which will be replaced by the values from selectionArgs. The values will be bound as Strings."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Runs the provided SQL and returns a @B_android#database#Cursor_E@ over the result set.", "history": "added in API level 1", "FullName": "public Cursor rawQuery (String sql, String[] selectionArgs)"}, "execSQL(java.lang.String, java.lang.Object[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the SQL statement to be executed. Multiple statements separated by semicolons are not supported."], ["@B_java#lang#Object_E@", "Object: only byte[], String, Long and Double are supported in bindArgs."]], "Throws": [["@B_android#database#SQLException_E@", "if the SQL string is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE. For INSERT statements, use any of the following instead. @B_android#database#sqlite#SQLiteDatabase#insert_E@ @B_android#database#sqlite#SQLiteDatabase#insertOrThrow_E@ @B_android#database#sqlite#SQLiteDatabase#insertWithOnConflict_E@ For UPDATE statements, use any of the following instead. @B_android#database#sqlite#SQLiteDatabase#update_E@ @B_android#database#sqlite#SQLiteDatabase#updateWithOnConflict_E@ For DELETE statements, use any of the following instead. @B_android#database#sqlite#SQLiteDatabase#delete_E@ For example, the following are good candidates for using this method: ALTER TABLE CREATE or DROP table / trigger / view / index / virtual table REINDEX RELEASE SAVEPOINT PRAGMA that returns no data When using @B_android#database#sqlite#SQLiteDatabase#enableWriteAheadLogging_E@, journal_mode is automatically managed by this class. So, do not set journal_mode using \"PRAGMA journal_mode'", "history": "added in API level 1", "FullName": "public void execSQL (String sql, Object[] bindArgs)"}, "query(boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.os.CancellationSignal)": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["boolean", "boolean: true if you want each row to be unique, false otherwise."], ["@B_java#lang#String_E@", "String: The table name to compile the query against."], ["@B_java#lang#String_E@", "String: A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used."], ["@B_java#lang#String_E@", "String: A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table."], ["@B_java#lang#String_E@", "String: You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings."], ["@B_java#lang#String_E@", "String: A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped."], ["@B_java#lang#String_E@", "String: A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used."], ["@B_java#lang#String_E@", "String: How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered."], ["@B_java#lang#String_E@", "String: Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause."], ["@B_android#os#CancellationSignal_E@", "CancellationSignal: A signal to cancel the operation in progress, or null if none. If the operation is canceled, then @B_android#os#OperationCanceledException_E@ will be thrown when the query is executed."]], "Throws": [], "SeeAlso": ["@B_android#database#Cursor_E@"], "Permissions": [], "Description": "Query the given URL, returning a @B_android#database#Cursor_E@ over the result set.", "history": "Added in API level 16", "FullName": "public Cursor query (boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit, CancellationSignal cancellationSignal)"}, "updateWithOnConflict(java.lang.String,android.content.ContentValues,java.lang.String,java.lang.String[],int)": {"Returns": [["int", "the number of rows affected"]], "Parameters": [["@B_java#lang#String_E@", "String: the table to update in"], ["@B_android#content#ContentValues_E@", "ContentValues: a map from column names to new column values. null is a valid value that will be translated to NULL."], ["@B_java#lang#String_E@", "String: the optional WHERE clause to apply when updating. Passing null will update all rows."], ["@B_java#lang#String_E@", "String: You may include ?s in the where clause, which will be replaced by the values from whereArgs. The values will be bound as Strings."], ["int", "int: for update conflict resolver"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method for updating rows in the database.", "history": "Added in API level 8", "FullName": "public int updateWithOnConflict (String table, ContentValues values, String whereClause, String[] whereArgs, int conflictAlgorithm)"}, "isWriteAheadLoggingEnabled()": {"Returns": [["boolean", "True if write-ahead logging has been enabled for this database."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#database#sqlite#SQLiteDatabase#enableWriteAheadLogging_E@", "@B_android#database#sqlite#SQLiteDatabase_E@"], "Permissions": [], "Description": "Returns true if write-ahead logging has been enabled for this database.", "history": "Added in API level 16", "FullName": "public boolean isWriteAheadLoggingEnabled ()"}, "setMaxSqlCacheSize(int)": {"Returns": [], "Parameters": [["int", "int: the size of the cache. can be (0 to @B_android#database#sqlite#SQLiteDatabase#MAX_SQL_CACHE_SIZE_E@)"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if input cacheSize > @B_android#database#sqlite#SQLiteDatabase#MAX_SQL_CACHE_SIZE_E@."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the maximum size of the prepared-statement cache for this database. (size of the cache = number of compiled-sql-statements stored in the cache). Maximum cache size can ONLY be increased from its current size (default = 10). If this method is called with smaller size than the current maximum value, then IllegalStateException is thrown. This method is thread-safe.", "history": "Added in API level 11", "FullName": "public void setMaxSqlCacheSize (int cacheSize)"}, "insert(java.lang.String,java.lang.String,android.content.ContentValues)": {"Returns": [["long", "the row ID of the newly inserted row, or -1 if an error occurred"]], "Parameters": [["@B_java#lang#String_E@", "String: the table to insert the row into"], ["@B_java#lang#String_E@", "String: optional; may be null. SQL doesn't allow inserting a completely empty row without naming at least one column name. If your provided values is empty, no column names are known and an empty row can't be inserted. If not set to null, the nullColumnHack parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your values is empty."], ["@B_android#content#ContentValues_E@", "ContentValues: this map contains the initial column values for the row. The keys should be the column names and the values the column values"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method for inserting a row into the database.", "history": "Added in API level 1", "FullName": "public long insert (String table, String nullColumnHack, ContentValues values)"}, "markTableSyncable(java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the table to mark as syncable"], ["@B_java#lang#String_E@", "String: The deleted table that corresponds to the syncable table"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method no longer serves any useful purpose and has been deprecated. Mark this table as syncable. When an update occurs in this table the _sync_dirty field will be set to ensure proper syncing operation.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public void markTableSyncable (String table, String deletedTable)"}, "beginTransactionWithListenerNonExclusive(android.database.sqlite.SQLiteTransactionListener)": {"Returns": [], "Parameters": [["@B_android#database#sqlite#SQLiteTransactionListener_E@", "SQLiteTransactionListener: listener that should be notified when the transaction begins, commits, or is rolled back, either explicitly or by a call to @B_android#database#sqlite#SQLiteDatabase#yieldIfContendedSafely_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begins a transaction in IMMEDIATE mode. Transactions can be nested. When the outer transaction is ended all of the work done in that transaction and all of the nested transactions will be committed or rolled back. The changes will be rolled back if any transaction is ended without being marked as clean (by calling setTransactionSuccessful). Otherwise they will be committed. Here is the standard idiom for transactions:", "history": "Added in API level 11", "FullName": "public void beginTransactionWithListenerNonExclusive (SQLiteTransactionListener transactionListener)"}, "replaceOrThrow(java.lang.String,java.lang.String,android.content.ContentValues)": {"Returns": [["long", "the row ID of the newly inserted row, or -1 if an error occurred"]], "Parameters": [["@B_java#lang#String_E@", "String: the table in which to replace the row"], ["@B_java#lang#String_E@", "String: optional; may be null. SQL doesn't allow inserting a completely empty row without naming at least one column name. If your provided initialValues is empty, no column names are known and an empty row can't be inserted. If not set to null, the nullColumnHack parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your initialValues is empty."], ["@B_android#content#ContentValues_E@", "ContentValues: this map contains the initial column values for the row. The keys should be the column names and the values the column values."]], "Throws": [["", "android.database.SQLException"], ["@B_android#database#SQLException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Convenience method for replacing a row in the database. Inserts a new row if a row does not already exist.", "history": "Added in API level 1", "FullName": "public long replaceOrThrow (String table, String nullColumnHack, ContentValues initialValues)"}, "openDatabase(java.lang.String,android.database.sqlite.SQLiteDatabase.CursorFactory,int,android.database.DatabaseErrorHandler)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "the newly opened database"]], "Parameters": [["@B_java#lang#String_E@", "String: to database file to open and/or create This value must never be null."], ["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: an optional factory class that is called to instantiate a cursor when query is called, or null for default This value may be null."], ["int", "int: to control database access mode Value is either 0 or a combination of @B_android#database#sqlite#SQLiteDatabase#OPEN_READWRITE_E@, @B_android#database#sqlite#SQLiteDatabase#OPEN_READONLY_E@, @B_android#database#sqlite#SQLiteDatabase#CREATE_IF_NECESSARY_E@, @B_android#database#sqlite#SQLiteDatabase#NO_LOCALIZED_COLLATORS_E@, and @B_android#database#sqlite#SQLiteDatabase#ENABLE_WRITE_AHEAD_LOGGING_E@"], ["@B_android#database#DatabaseErrorHandler_E@", "DatabaseErrorHandler: the @B_android#database#DatabaseErrorHandler_E@ obj to be used to handle corruption when sqlite reports database corruption This value may be null."]], "Throws": [["@B_android#database#sqlite#SQLiteException_E@", "if the database cannot be opened"]], "SeeAlso": [], "Permissions": [], "Description": "Open the database according to the flags @B_android#database#sqlite#SQLiteDatabase#OPEN_READWRITE_E@ @B_android#database#sqlite#SQLiteDatabase#OPEN_READONLY_E@ @B_android#database#sqlite#SQLiteDatabase#CREATE_IF_NECESSARY_E@ and/or @B_android#database#sqlite#SQLiteDatabase#NO_LOCALIZED_COLLATORS_E@. Sets the locale of the database to the the system's current locale. Call @B_android#database#sqlite#SQLiteDatabase#setLocale_E@ if you would like something else. Accepts input param: a concrete instance of @B_android#database#DatabaseErrorHandler_E@ to be used to handle corruption when sqlite reports database corruption.", "history": "Added in API level 11", "FullName": "public static SQLiteDatabase openDatabase (String path, SQLiteDatabase.CursorFactory factory, int flags, DatabaseErrorHandler errorHandler)"}, "needUpgrade(int)": {"Returns": [["boolean", "True if the new version code is greater than the current database version."]], "Parameters": [["int", "int: The new version code."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the new version code is greater than the current database version.", "history": "Added in API level 1", "FullName": "public boolean needUpgrade (int newVersion)"}, "queryWithFactory(android.database.sqlite.SQLiteDatabase.CursorFactory,boolean,java.lang.String,java.lang.String[],java.lang.String,java.lang.String[],java.lang.String,java.lang.String,java.lang.String,java.lang.String)": {"Returns": [["@B_android#database#Cursor_E@", "A @B_android#database#Cursor_E@ object, which is positioned before the first entry. Note that @B_android#database#Cursor_E@s are not synchronized, see the documentation for more details."]], "Parameters": [["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: the cursor factory to use, or null for the default factory"], ["boolean", "boolean: true if you want each row to be unique, false otherwise."], ["@B_java#lang#String_E@", "String: The table name to compile the query against."], ["@B_java#lang#String_E@", "String: A list of which columns to return. Passing null will return all columns, which is discouraged to prevent reading data from storage that isn't going to be used."], ["@B_java#lang#String_E@", "String: A filter declaring which rows to return, formatted as an SQL WHERE clause (excluding the WHERE itself). Passing null will return all rows for the given table."], ["@B_java#lang#String_E@", "String: You may include ?s in selection, which will be replaced by the values from selectionArgs, in order that they appear in the selection. The values will be bound as Strings."], ["@B_java#lang#String_E@", "String: A filter declaring how to group rows, formatted as an SQL GROUP BY clause (excluding the GROUP BY itself). Passing null will cause the rows to not be grouped."], ["@B_java#lang#String_E@", "String: A filter declare which row groups to include in the cursor, if row grouping is being used, formatted as an SQL HAVING clause (excluding the HAVING itself). Passing null will cause all row groups to be included, and is required when row grouping is not being used."], ["@B_java#lang#String_E@", "String: How to order the rows, formatted as an SQL ORDER BY clause (excluding the ORDER BY itself). Passing null will use the default sort order, which may be unordered."], ["@B_java#lang#String_E@", "String: Limits the number of rows returned by the query, formatted as LIMIT clause. Passing null denotes no LIMIT clause."]], "Throws": [], "SeeAlso": ["@B_android#database#Cursor_E@"], "Permissions": [], "Description": "Query the given URL, returning a @B_android#database#Cursor_E@ over the result set.", "history": "Added in API level 1", "FullName": "public Cursor queryWithFactory (SQLiteDatabase.CursorFactory cursorFactory, boolean distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit)"}, "execSQL(java.lang.String,java.lang.Object[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the SQL statement to be executed. Multiple statements separated by semicolons are not supported."], ["@B_java#lang#Object_E@", "Object: only byte[], String, Long and Double are supported in bindArgs."]], "Throws": [["@B_android#database#SQLException_E@", "if the SQL string is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Execute a single SQL statement that is NOT a SELECT/INSERT/UPDATE/DELETE. For INSERT statements, use any of the following instead. @B_android#database#sqlite#SQLiteDatabase#insert_E@ @B_android#database#sqlite#SQLiteDatabase#insertOrThrow_E@ @B_android#database#sqlite#SQLiteDatabase#insertWithOnConflict_E@ For UPDATE statements, use any of the following instead. @B_android#database#sqlite#SQLiteDatabase#update_E@ @B_android#database#sqlite#SQLiteDatabase#updateWithOnConflict_E@ For DELETE statements, use any of the following instead. @B_android#database#sqlite#SQLiteDatabase#delete_E@ For example, the following are good candidates for using this method: ALTER TABLE CREATE or DROP table / trigger / view / index / virtual table REINDEX RELEASE SAVEPOINT PRAGMA that returns no data When using @B_android#database#sqlite#SQLiteDatabase#enableWriteAheadLogging_E@, journal_mode is automatically managed by this class. So, do not set journal_mode using \"PRAGMA journal_mode'", "history": "Added in API level 1", "FullName": "public void execSQL (String sql, Object[] bindArgs)"}, "getVersion()": {"Returns": [["int", "the database version"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the database version.", "history": "Added in API level 1", "FullName": "public int getVersion ()"}, "close()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Close the database.", "history": "Since: API Level 1", "FullName": "public void close ()"}, "isReadOnly()": {"Returns": [["boolean", "True if database is opened as read only."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if the database is opened as read only.", "history": "Added in API level 1", "FullName": "public boolean isReadOnly ()"}, "setLockingEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: set to true to enable locks, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method now does nothing. Do not use. Control whether or not the SQLiteDatabase is made thread-safe by using locks around critical sections. This is pretty expensive, so if you know that your DB will only be used by a single thread then you should set this to false. The default is true.", "history": "Added in API level 1 Deprecated in API level 16", "FullName": "public void setLockingEnabled (boolean lockingEnabled)"}, "getSyncedTables()": {"Returns": [["@B_java#util#Map_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method no longer serves any useful purpose and has been deprecated. Deprecated.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public Map<String, String> getSyncedTables ()"}, "yieldIfContendedSafely()": {"Returns": [["boolean", "true if the transaction was yielded"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Temporarily end the transaction to let other threads run. The transaction is assumed to be successful so far. Do not call setTransactionSuccessful before calling this. When this returns a new transaction will have been created but not marked as successful. This assumes that there are no nested transactions (beginTransaction has only been called once) and will throw an exception if that is not the case.", "history": "Added in API level 3", "FullName": "public boolean yieldIfContendedSafely ()"}, "deleteDatabase(java.io.File)": {"Returns": [["boolean", "True if the database was successfully deleted."]], "Parameters": [["@B_java#io#File_E@", "File: The database file path. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Deletes a database including its journal file and other auxiliary files that may have been created by the database engine.", "history": "Added in API level 16", "FullName": "public static boolean deleteDatabase (File file)"}, "setForeignKeyConstraintsEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True to enable foreign key constraints, false to disable them."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the are transactions is in progress when this method is called."]], "SeeAlso": [], "Permissions": [], "Description": "Sets whether foreign key constraints are enabled for the database. By default, foreign key constraints are not enforced by the database. This method allows an application to enable foreign key constraints. It must be called each time the database is opened to ensure that foreign key constraints are enabled for the session. A good time to call this method is right after calling @B_android#database#sqlite#SQLiteDatabase#openOrCreateDatabase_E@ or in the @B_android#database#sqlite#SQLiteOpenHelper#onConfigure_E@ callback. When foreign key constraints are disabled, the database does not check whether changes to the database will violate foreign key constraints. Likewise, when foreign key constraints are disabled, the database will not execute cascade delete or update triggers. As a result, it is possible for the database state to become inconsistent. To perform a database integrity check, call @B_android#database#sqlite#SQLiteDatabase#isDatabaseIntegrityOk_E@. This method must not be called while a transaction is in progress. See also", "history": "Added in API level 16", "FullName": "public void setForeignKeyConstraintsEnabled (boolean enable)"}, "getMaximumSize()": {"Returns": [["long", "the new maximum database size"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the maximum size the database may grow to.", "history": "Added in API level 1", "FullName": "public long getMaximumSize ()"}, "insertOrThrow(java.lang.String,java.lang.String,android.content.ContentValues)": {"Returns": [["long", "the row ID of the newly inserted row, or -1 if an error occurred"]], "Parameters": [["@B_java#lang#String_E@", "String: the table to insert the row into"], ["@B_java#lang#String_E@", "String: optional; may be null. SQL doesn't allow inserting a completely empty row without naming at least one column name. If your provided values is empty, no column names are known and an empty row can't be inserted. If not set to null, the nullColumnHack parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your values is empty."], ["@B_android#content#ContentValues_E@", "ContentValues: this map contains the initial column values for the row. The keys should be the column names and the values the column values"]], "Throws": [["", "android.database.SQLException"], ["@B_android#database#SQLException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Convenience method for inserting a row into the database.", "history": "Added in API level 1", "FullName": "public long insertOrThrow (String table, String nullColumnHack, ContentValues values)"}, "insertWithOnConflict(java.lang.String,java.lang.String,android.content.ContentValues,int)": {"Returns": [["long", "the row ID of the newly inserted row OR -1 if either the input parameter conflictAlgorithm = @B_android#database#sqlite#SQLiteDatabase#CONFLICT_IGNORE_E@ or an error occurred."]], "Parameters": [["@B_java#lang#String_E@", "String: the table to insert the row into"], ["@B_java#lang#String_E@", "String: optional; may be null. SQL doesn't allow inserting a completely empty row without naming at least one column name. If your provided initialValues is empty, no column names are known and an empty row can't be inserted. If not set to null, the nullColumnHack parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your initialValues is empty."], ["@B_android#content#ContentValues_E@", "ContentValues: this map contains the initial column values for the row. The keys should be the column names and the values the column values"], ["int", "int: for insert conflict resolver"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "General method for inserting a row into the database.", "history": "Added in API level 8", "FullName": "public long insertWithOnConflict (String table, String nullColumnHack, ContentValues initialValues, int conflictAlgorithm)"}, "setLocale(java.util.Locale)": {"Returns": [], "Parameters": [["@B_java#util#Locale_E@", "Locale: The new locale."]], "Throws": [["@B_android#database#SQLException_E@", "if the locale could not be set. The most common reason for this is that there is no collator available for the locale you requested. In this case the database remains unchanged."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the locale for this database. Does nothing if this database has the @B_android#database#sqlite#SQLiteDatabase#NO_LOCALIZED_COLLATORS_E@ flag set or was opened read only.", "history": "Added in API level 1", "FullName": "public void setLocale (Locale locale)"}, "replace(java.lang.String,java.lang.String,android.content.ContentValues)": {"Returns": [["long", "the row ID of the newly inserted row, or -1 if an error occurred"]], "Parameters": [["@B_java#lang#String_E@", "String: the table in which to replace the row"], ["@B_java#lang#String_E@", "String: optional; may be null. SQL doesn't allow inserting a completely empty row without naming at least one column name. If your provided initialValues is empty, no column names are known and an empty row can't be inserted. If not set to null, the nullColumnHack parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your initialValues is empty."], ["@B_android#content#ContentValues_E@", "ContentValues: this map contains the initial column values for the row. The keys should be the column names and the values the column values."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method for replacing a row in the database. Inserts a new row if a row does not already exist.", "history": "Added in API level 1", "FullName": "public long replace (String table, String nullColumnHack, ContentValues initialValues)"}}, "Inheritance": ["@B_android#database#sqlite#SQLiteClosable_E@"], "ClassName": "android.database.sqlite.SQLiteDatabase", "ClassDesc": "Exposes methods to manage a SQLite database. SQLiteDatabase has methods to create, delete, execute SQL commands, and perform other common database management tasks. See the Notepad sample application in the SDK for an example of creating and managing a database. Database names must be unique within an application, not across all applications. In addition to SQLite's default BINARY collator, Android supplies two more, LOCALIZED, which changes with the system's current locale, and UNICODE, which is the Unicode Collation Algorithm and not tailored to the current locale."}