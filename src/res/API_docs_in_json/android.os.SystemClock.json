{"Functions": {"sleep(long)": {"Returns": [], "Parameters": [["long", "long: to sleep before returning, in milliseconds of uptime."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Waits a given number of milliseconds (of uptimeMillis) before returning. Similar to @B_java#lang#Thread#sleep_E@, but does not throw @B_java#lang#InterruptedException_E@; @B_java#lang#Thread#interrupt_E@ events are deferred until the next interruptible operation. Does not return until at least the specified number of milliseconds has elapsed.", "history": "Added in API level 1", "FullName": "public static void sleep (long ms)"}, "elapsedRealtime()": {"Returns": [["long", "elapsed milliseconds since boot."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns milliseconds since boot, including time spent in sleep.", "history": "Added in API level 1", "FullName": "public static long elapsedRealtime ()"}, "uptimeMillis()": {"Returns": [["long", "milliseconds of non-sleep uptime since boot."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns milliseconds since boot, not counting time spent in deep sleep.", "history": "Added in API level 1", "FullName": "public static long uptimeMillis ()"}, "setCurrentTimeMillis(long)": {"Returns": [["boolean", "if the clock was successfully set to the specified time."]], "Parameters": [["long", "long no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the current wall time, in milliseconds. Requires the calling process to have appropriate permissions.", "history": "Added in API level 1", "FullName": "public static boolean setCurrentTimeMillis (long millis)"}, "elapsedRealtimeNanos()": {"Returns": [["long", "elapsed nanoseconds since boot."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns nanoseconds since boot, including time spent in sleep.", "history": "Added in API level 17", "FullName": "public static long elapsedRealtimeNanos ()"}, "currentThreadTimeMillis()": {"Returns": [["long", "elapsed milliseconds in the thread"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns milliseconds running in the current thread.", "history": "Added in API level 1", "FullName": "public static long currentThreadTimeMillis ()"}, "currentGnssTimeClock()": {"Returns": [["@B_java#time#Clock_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#time#DateTimeException_E@", "when the location provider has not had a location fix since boot."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a @B_java#time#Clock_E@ that starts at January 1, 1970 00:00:00.0 UTC, synchronized using the device's location provider.", "history": "Added in API level 29", "FullName": "public static Clock currentGnssTimeClock ()"}}, "Inheritance": [], "ClassName": "android.os.SystemClock", "ClassDesc": "Core timekeeping facilities. Three different clocks are available, and they should not be confused: @B_java#lang#System#currentTimeMillis_E@ is the standard \"wall\" clock (time and date) expressing milliseconds since the epoch. The wall clock can be set by the user or the phone network (see @B_android#os#SystemClock#setCurrentTimeMillis_E@), so the time may jump backwards or forwards unpredictably. This clock should only be used when correspondence with real-world dates and times is important, such as in a calendar or alarm clock application. Interval or elapsed time measurements should use a different clock. If you are using System.currentTimeMillis(), consider listening to the @B_android#content#Intent#ACTION_TIME_TICK_E@, @B_android#content#Intent#ACTION_TIME_CHANGED_E@ and @B_android#content#Intent#ACTION_TIMEZONE_CHANGED_E@ @B_android#content#Intent_E@ broadcasts to find out when the time changes. @B_android#os#SystemClock#uptimeMillis_E@ is counted in milliseconds since the system was booted. This clock stops when the system enters deep sleep (CPU off, display dark, device waiting for external input), but is not affected by clock scaling, idle, or other power saving mechanisms. This is the basis for most interval timing such as @B_java#lang#Thread#sleep_E@, @B_java#lang#Object#wait_E@, and @B_java#lang#System#nanoTime_E@. This clock is guaranteed to be monotonic, and is suitable for interval timing when the interval does not span device sleep. Most methods that accept a timestamp value currently expect the @B_android#os#SystemClock#uptimeMillis_E@ clock. @B_android#os#SystemClock#elapsedRealtime_E@ and @B_android#os#SystemClock#elapsedRealtimeNanos_E@ return the time since the system was booted, and include deep sleep. This clock is guaranteed to be monotonic, and continues to tick even when the CPU is in power saving modes, so is the recommend basis for general purpose interval timing. There are several mechanisms for controlling the timing of events: Standard functions like @B_java#lang#Thread#sleep_E@ and @B_java#lang#Object#wait_E@ are always available. These functions use the @B_android#os#SystemClock#uptimeMillis_E@ clock; if the device enters sleep, the remainder of the time will be postponed until the device wakes up. These synchronous functions may be interrupted with @B_java#lang#Thread#interrupt_E@, and you must handle @B_java#lang#InterruptedException_E@. @B_android#os#SystemClock#sleep_E@ is a utility function very similar to @B_java#lang#Thread#sleep_E@, but it ignores @B_java#lang#InterruptedException_E@. Use this function for delays if you do not use @B_java#lang#Thread#interrupt_E@, as it will preserve the interrupted state of the thread. The @B_android#os#Handler_E@ class can schedule asynchronous callbacks at an absolute or relative time. Handler objects also use the @B_android#os#SystemClock#uptimeMillis_E@ clock, and require an @B_android#os#Looper_E@ (normally present in any GUI application). The @B_android#app#AlarmManager_E@ can trigger one-time or recurring events which occur even when the device is in deep sleep or your application is not running. Events may be scheduled with your choice of @B_java#lang#System#currentTimeMillis_E@ (RTC) or @B_android#os#SystemClock#elapsedRealtime_E@ (ELAPSED_REALTIME), and cause an @B_android#content#Intent_E@ broadcast when they occur."}