{"Functions": {"toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Human-readable description of the tag, for debugging.", "history": "Added in API level 10", "FullName": "public String toString ()"}, "writeToParcel(android.os.Parcel, int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "added in API level 10", "FullName": "public void writeToParcel (Parcel dest, int flags)"}, "getTechList()": {"Returns": [["@B_java#lang#String_E@", "an array of fully-qualified @B_android#nfc#tech#TagTechnology_E@ class-names."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the technologies available in this tag, as fully qualified class names. A technology is an implementation of the @B_android#nfc#tech#TagTechnology_E@ interface, and can be instantiated by calling the static get(Tag) method on the implementation with this Tag. The @B_android#nfc#tech#TagTechnology_E@ object can then be used to perform advanced, technology-specific operations on a tag. Android defines a mandatory set of technologies that must be correctly enumerated by all Android NFC devices, and an optional set of proprietary technologies. See @B_android#nfc#tech#TagTechnology_E@ for more details. The ordering of the returned array is undefined and should not be relied upon.", "history": "Added in API level 10", "FullName": "public String[] getTechList ()"}, "getId()": {"Returns": [["byte[]", "ID as byte array, never null"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the Tag Identifier (if it has one). The tag identifier is a low level serial number, used for anti-collision and identification. Most tags have a stable unique identifier (UID), but some tags will generate a random ID every time they are discovered (RID), and there are some tags with no ID at all (the byte array will be zero-sized). The size and format of an ID is specific to the RF technology used by the tag. This function retrieves the ID as determined at discovery time, and does not perform any further RF communication or block.", "history": "Added in API level 10", "FullName": "public byte[] getId ()"}, "writeToParcel(android.os.Parcel,int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@. Value is either 0 or a combination of @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "Added in API level 10", "FullName": "public void writeToParcel (Parcel dest, int flags)"}, "describeContents()": {"Returns": [["int", "a bitmask indicating the set of special object types marshaled by this Parcelable object instance. Value is either 0 or @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Describe the kinds of special objects contained in this Parcelable instance's marshaled representation. For example, if the object will include a file descriptor in the output of @B_android#os#Parcelable#writeToParcel_E@, the return value of this method must include the @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@ bit.", "history": "Added in API level 10", "FullName": "public int describeContents ()"}}, "Inheritance": [], "ClassName": "android.nfc.Tag", "ClassDesc": "Represents an NFC tag that has been discovered. @B_android#nfc#Tag_E@ is an immutable object that represents the state of a NFC tag at the time of discovery. It can be used as a handle to @B_android#nfc#tech#TagTechnology_E@ classes to perform advanced operations, or directly queried for its ID via @B_android#nfc#Tag#getId_E@ and the set of technologies it contains via @B_android#nfc#Tag#getTechList_E@. Arrays passed to and returned by this class are not cloned, so be careful not to modify them. A new tag object is created every time a tag is discovered (comes into range), even if it is the same physical tag. If a tag is removed and then returned into range, then only the most recent tag object can be successfully used to create a @B_android#nfc#tech#TagTechnology_E@. @B_android#nfc#Tag_E@ object is created and passed to a single activity via the @B_android#nfc#NfcAdapter#EXTRA_TAG_E@ extra in an @B_android#content#Intent_E@ via @B_android#content#Context#startActivity_E@. A four stage dispatch is used to select the most appropriate activity to handle the tag. The Android OS executes each stage in order, and completes dispatch as soon as a single matching activity is found. If there are multiple matching activities found at any one stage then the Android activity chooser dialog is shown to allow the user to select the activity to receive the tag. The Tag dispatch mechanism was designed to give a high probability of dispatching a tag to the correct activity without showing the user an activity chooser dialog. This is important for NFC interactions because they are very transient -- if a user has to move the Android device to choose an application then the connection will likely be broken. @B_android#nfc#NfcAdapter#enableForegroundDispatch_E@ is given priority. See the documentation on @B_android#nfc#NfcAdapter#enableForegroundDispatch_E@ for its usage. @B_android#nfc#NdefRecord_E@ in the first @B_android#nfc#NdefMessage_E@. If the record is a URI, SmartPoster, or MIME data @B_android#content#Context#startActivity_E@ is called with @B_android#nfc#NfcAdapter#ACTION_NDEF_DISCOVERED_E@. For URI and SmartPoster records the URI is put into the intent's data field. For MIME records the MIME type is put in the intent's type field. This allows activities to register to be launched only when data they know how to handle is present on a tag. This is the preferred method of handling data on a tag since NDEF data can be stored on many types of tags and doesn't depend on a specific tag technology. See @B_android#nfc#NfcAdapter#ACTION_NDEF_DISCOVERED_E@ for more detail. If the tag does not contain NDEF data, or if no activity is registered for @B_android#nfc#NfcAdapter#ACTION_NDEF_DISCOVERED_E@ with a matching data URI or MIME type then dispatch moves to stage 3. @B_android#content#Context#startActivity_E@ is called with @B_android#nfc#NfcAdapter#ACTION_TECH_DISCOVERED_E@ to dispatch the tag to an activity that can handle the technologies present on the tag. Technologies are defined as sub-classes of @B_android#nfc#tech#TagTechnology_E@, see the package @B_android#nfc#tech#package-summary_E@. The Android OS looks for an activity that can handle one or more technologies in the tag. See @B_android#nfc#NfcAdapter#ACTION_TECH_DISCOVERED_E@ for more detail. @B_android#content#Context#startActivity_E@ is called with @B_android#nfc#NfcAdapter#ACTION_TAG_DISCOVERED_E@. This is intended as a fall-back mechanism. See @B_android#nfc#NfcAdapter#ACTION_TAG_DISCOVERED_E@. Tags can have a wide range of capabilities. Simple tags just offer read/write semantics, and contain some one time programmable areas to make read-only. More complex tags offer math operations and per-sector access control and authentication. The most sophisticated tags contain operating environments allowing complex interactions with the code executing on the tag. Use @B_android#nfc#tech#TagTechnology_E@ classes to access a broad range of capabilities available in NFC tags."}