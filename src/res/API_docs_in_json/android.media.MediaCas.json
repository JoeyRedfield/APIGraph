{"Functions": {"processEmm(byte[],int,int)": {"Returns": [], "Parameters": [["byte[]", "byte: byte array of the EMM data. This value must never be null."], ["int", "int: position within data where the EMM data begins."], ["int", "int: length of the data (starting from offset)."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Send a received EMM packet to the CA system.", "history": "Added in API level 26", "FullName": "public void processEmm (byte[] data, int offset, int length)"}, "enumeratePlugins()": {"Returns": [["@B_android#media#MediaCas#PluginDescriptor_E@", "an array of descriptors for the available CA plugins."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "List all available CA plugins on the device.", "history": "Added in API level 26", "FullName": "public static PluginDescriptor[] enumeratePlugins ()"}, "processEmm(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: byte array of the EMM data. This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Send a received EMM packet to the CA system. This is similar to @B_android#media#MediaCas#processEmm_E@ except that the entire byte array is sent.", "history": "Added in API level 26", "FullName": "public void processEmm (byte[] data)"}, "refreshEntitlements(int,byte[])": {"Returns": [], "Parameters": [["int", "int: the type of the refreshment."], ["byte[]", "byte: private data associated with the refreshment. This value may be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Notify the CA system to refresh entitlement keys.", "history": "Added in API level 26", "FullName": "public void refreshEntitlements (int refreshType, byte[] refreshData)"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 26", "FullName": "protected void finalize ()"}, "sendEvent(int,int,byte[])": {"Returns": [], "Parameters": [["int", "int: an integer denoting a scheme-specific event to be sent."], ["int", "int: a scheme-specific integer argument for the event."], ["byte[]", "byte: a byte array containing scheme-specific data for the event. This value may be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Send an event to a CA system. The format of the event is scheme-specific and is opaque to the framework.", "history": "Added in API level 26", "FullName": "public void sendEvent (int event, int arg, byte[] data)"}, "close()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Closes this resource, relinquishing any underlying resources. This method is invoked automatically on objects managed by the try-with-resources statement. While this interface method is declared to throw Exception, implementers are strongly encouraged to declare concrete implementations of the close method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail. Cases where the close operation may fail require careful attention by implementers. It is strongly advised to relinquish the underlying resources and to internally mark the resource as closed, prior to throwing the exception. The close method is unlikely to be invoked more than once and so this ensures that the resources are released in a timely manner. Furthermore it reduces problems that could arise when the resource wraps, or is wrapped, by another resource. Implementers of this interface are also strongly advised to not have the close method throw @B_java#lang#InterruptedException_E@. This exception interacts with a thread's interrupted status, and runtime misbehavior is likely to occur if an InterruptedException is AutoCloseable.close method should not throw it. Note that unlike the @B_java#io#Closeable#close_E@ method of @B_java#io#Closeable_E@, this close method is not required to be idempotent. In other words, calling this close method more than once may have some visible side effect, unlike Closeable.close which is required to have no effect if called more than once. However, implementers of this interface are strongly encouraged to make their close methods idempotent.", "history": "Added in API level 26", "FullName": "public void close ()"}, "sendEvent(int, int, byte[])": {"Returns": [], "Parameters": [["int", "int: an integer denoting a scheme-specific event to be sent."], ["int", "int: a scheme-specific integer argument for the event."], ["byte[]", "byte: a byte array containing scheme-specific data for the event.This value may be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Send an event to a CA system. The format of the event is scheme-specific and is opaque to the framework.", "history": "added in API level 26", "FullName": "public void sendEvent (int event, int arg, byte[] data)"}, "openSession()": {"Returns": [["@B_android#media#MediaCas#Session_E@", "session the newly opened session."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Open a session to descramble one or more streams scrambled by the conditional access system.", "history": "Added in API level 26", "FullName": "public MediaCas.Session openSession ()"}, "isSystemIdSupported(int)": {"Returns": [["boolean", "Whether the specified CA system is supported on this device."]], "Parameters": [["int", "int: the id of the CA system."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Query if a certain CA system is supported on this device.", "history": "Added in API level 26", "FullName": "public static boolean isSystemIdSupported (int CA_system_id)"}, "processEmm(byte[], int, int)": {"Returns": [], "Parameters": [["byte[]", "byte: byte array of the EMM data.This value must never be null."], ["int", "int: position within data where the EMM data begins."], ["int", "int: length of the data (starting from offset)."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Send a received EMM packet to the CA system.", "history": "added in API level 26", "FullName": "public void processEmm (byte[] data, int offset, int length)"}, "refreshEntitlements(int, byte[])": {"Returns": [], "Parameters": [["int", "int: the type of the refreshment."], ["byte[]", "byte: private data associated with the refreshment.This value may be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Notify the CA system to refresh entitlement keys.", "history": "added in API level 26", "FullName": "public void refreshEntitlements (int refreshType, byte[] refreshData)"}, "setEventListener(android.media.MediaCas.EventListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaCas#EventListener_E@", "MediaCas.EventListener: the event listener to be set. This value may be null."], ["@B_android#os#Handler_E@", "Handler: the handler whose looper the event listener will be called on. If handler is null, we'll try to use current thread's looper, or the main looper. If neither are available, an internal thread will be created instead. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set an event listener to receive notifications from the MediaCas instance.", "history": "Added in API level 26", "FullName": "public void setEventListener (MediaCas.EventListener listener, Handler handler)"}, "MediaCas(int)": {"Returns": [], "Parameters": [["int", "int: The system id of the CA system."]], "Throws": [["@B_android#media#MediaCasException#UnsupportedCasException_E@", "if the device does not support the specified CA system."]], "SeeAlso": [], "Permissions": [], "Description": "Instantiate a CA system of the specified system id.", "history": "Added in API level 26", "FullName": "public MediaCas (int CA_system_id)"}, "setPrivateData(byte[])": {"Returns": [], "Parameters": [["byte[]", "byte: byte array of the private data. This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Send the private data for the CA system.", "history": "Added in API level 26", "FullName": "public void setPrivateData (byte[] data)"}, "provision(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: string containing information needed for the provisioning operation, the format of which is scheme and implementation specific. This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the MediaCas instance is not valid."], ["@B_android#media#MediaCasException_E@", "for CAS-specific errors."], ["@B_android#media#MediaCasStateException_E@", "for CAS-specific state exceptions."]], "SeeAlso": [], "Permissions": [], "Description": "Initiate a provisioning operation for a CA system.", "history": "Added in API level 26", "FullName": "public void provision (String provisionString)"}}, "Inheritance": [], "ClassName": "android.media.MediaCas", "ClassDesc": "MediaCas can be used to obtain keys for descrambling protected media streams, in conjunction with @B_android#media#MediaDescrambler_E@. The MediaCas APIs are designed to support conditional access such as those in the ISO/IEC13818-1. The CA system is identified by a 16-bit integer CA_system_id. The scrambling algorithms are usually proprietary and implemented by vendor-specific CA plugins installed on the device. The app is responsible for constructing a MediaCas object for the CA system it intends to use. The app can query if a certain CA system is supported using static method @B_android#media#MediaCas#isSystemIdSupported_E@. It can also obtain the entire list of supported CA systems using static method @B_android#media#MediaCas#enumeratePlugins_E@. Once the MediaCas object is constructed, the app should properly provision it by using method @B_android#media#MediaCas#provision_E@ and/or @B_android#media#MediaCas#processEmm_E@. The EMMs (Entitlement management messages) can be distributed out-of-band, or in-band with the stream. To descramble elementary streams, the app first calls @B_android#media#MediaCas#openSession_E@ to generate a @B_android#media#MediaCas#Session_E@ object that will uniquely identify a session. A session provides a context for subsequent key updates and descrambling activities. The ECMs (Entitlement control messages) are sent to the session via method @B_android#media#MediaCas#Session#processEcm_E@. The app next constructs a MediaDescrambler object, and initializes it with the session using @B_android#media#MediaDescrambler#setMediaCasSession_E@. This ties the descrambler to the session, and the descrambler can then be used to descramble content secured with the session's key, either during extraction, or during decoding with @B_android#media#MediaCodec_E@. If the app handles sample extraction using its own extractor, it can use MediaDescrambler to descramble samples into clear buffers (if the session's license doesn't require secure decoders), or descramble a small amount of data to retrieve information necessary for the downstream pipeline to process the sample (if the session's license requires secure decoders). If the session requires a secure decoder, a MediaDescrambler needs to be provided to MediaCodec to descramble samples queued by @B_android#media#MediaCodec#queueSecureInputBuffer_E@ into protected buffers. The app should use @B_android#media#MediaCodec#configure_E@ instead of the normal @B_android#media#MediaCodec#configure_E@ method to configure MediaCodec. If the app uses @B_android#media#MediaExtractor_E@, it can delegate the CAS session management to MediaExtractor by calling @B_android#media#MediaExtractor#setMediaCas_E@. MediaExtractor will take over and call @B_android#media#MediaCas#openSession_E@, @B_android#media#MediaCas#processEmm_E@ and/or @B_android#media#MediaCas#Session#processEcm_E@, etc.. if necessary. When using @B_android#media#MediaExtractor_E@, the app would still need a MediaDescrambler to use with @B_android#media#MediaCodec_E@ if the licensing requires a secure decoder. The session associated with the descrambler of a track can be retrieved by calling @B_android#media#MediaExtractor#getCasInfo_E@, and used to initialize a MediaDescrambler object for MediaCodec. The app may register a listener to receive events from the CA system using method @B_android#media#MediaCas#setEventListener_E@. The exact format of the event is scheme-specific and is not specified by this API."}