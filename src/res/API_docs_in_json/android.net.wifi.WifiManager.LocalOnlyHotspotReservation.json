{"Functions": {"finalize()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#Throwable_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 26", "FullName": "protected void finalize ()"}, "close()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Closes this resource, relinquishing any underlying resources. This method is invoked automatically on objects managed by the try-with-resources statement. While this interface method is declared to throw Exception, implementers are strongly encouraged to declare concrete implementations of the close method to throw more specific exceptions, or to throw no exception at all if the close operation cannot fail. Cases where the close operation may fail require careful attention by implementers. It is strongly advised to relinquish the underlying resources and to internally mark the resource as closed, prior to throwing the exception. The close method is unlikely to be invoked more than once and so this ensures that the resources are released in a timely manner. Furthermore it reduces problems that could arise when the resource wraps, or is wrapped, by another resource. Implementers of this interface are also strongly advised to not have the close method throw @B_java#lang#InterruptedException_E@. This exception interacts with a thread's interrupted status, and runtime misbehavior is likely to occur if an InterruptedException is AutoCloseable.close method should not throw it. Note that unlike the @B_java#io#Closeable#close_E@ method of @B_java#io#Closeable_E@, this close method is not required to be idempotent. In other words, calling this close method more than once may have some visible side effect, unlike Closeable.close which is required to have no effect if called more than once. However, implementers of this interface are strongly encouraged to make their close methods idempotent.", "history": "Added in API level 26", "FullName": "public void close ()"}, "getWifiConfiguration()": {"Returns": [["@B_android#net#wifi#WifiConfiguration_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public WifiConfiguration getWifiConfiguration ()"}}, "Inheritance": [], "ClassName": "android.net.wifi.WifiManager.LocalOnlyHotspotReservation", "ClassDesc": "LocalOnlyHotspotReservation that contains the @B_android#net#wifi#WifiConfiguration_E@ for the active LocalOnlyHotspot request. Applications requesting LocalOnlyHotspot for sharing will receive an instance of the LocalOnlyHotspotReservation in the @B_android#net#wifi#WifiManager#LocalOnlyHotspotCallback#onStarted_E@ call. This reservation contains the relevant @B_android#net#wifi#WifiConfiguration_E@. When an application is done with the LocalOnlyHotspot, they should call @B_android#net#wifi#WifiManager#LocalOnlyHotspotReservation#close_E@. Once this happens, the application will not receive any further callbacks. If the LocalOnlyHotspot is stopped due to a user triggered mode change, applications will be notified via the @B_android#net#wifi#WifiManager#LocalOnlyHotspotCallback#onStopped_E@ callback."}