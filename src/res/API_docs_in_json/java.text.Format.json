{"Functions": {"format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)": {"Returns": [["@B_java#lang#StringBuffer_E@", "the string buffer passed in as toAppendTo, with formatted text appended"]], "Parameters": [["@B_java#lang#Object_E@", "Object: The object to format"], ["@B_java#lang#StringBuffer_E@", "StringBuffer: where the text is to be appended"], ["@B_java#text#FieldPosition_E@", "FieldPosition: A FieldPosition identifying a field in the formatted text"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if toAppendTo or pos is null"], ["@B_java#lang#IllegalArgumentException_E@", "if the Format cannot format the given object"]], "SeeAlso": [], "Permissions": [], "Description": "Formats an object and appends the resulting text to a given string buffer. If the pos argument identifies a field used by the format, then its indices are set to the beginning and end of the first such field encountered.", "history": "Added in API level 1", "FullName": "public abstract StringBuffer format (Object obj, StringBuffer toAppendTo, FieldPosition pos)"}, "formatToCharacterIterator(java.lang.Object)": {"Returns": [["@B_java#text#AttributedCharacterIterator_E@", "AttributedCharacterIterator describing the formatted value."]], "Parameters": [["@B_java#lang#Object_E@", "Object: The object to format"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if obj is null."], ["@B_java#lang#IllegalArgumentException_E@", "when the Format cannot format the given object."]], "SeeAlso": [], "Permissions": [], "Description": "Formats an Object producing an AttributedCharacterIterator. You can use the returned AttributedCharacterIterator to build the resulting String, as well as to determine information about the resulting String. Each attribute key of the AttributedCharacterIterator will be of type Field. It is up to each Format implementation to define what the legal values are for each attribute in the AttributedCharacterIterator, but typically the attribute key is also used as the attribute value. The default implementation creates an AttributedCharacterIterator with no attributes. Subclasses that support fields should override this and create an AttributedCharacterIterator with meaningful attributes.", "history": "Added in API level 1", "FullName": "public AttributedCharacterIterator formatToCharacterIterator (Object obj)"}, "Format()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sole constructor. (For invocation by subclass constructors, typically implicit.)", "history": "Added in API level 1", "FullName": "protected Format ()"}, "parseObject(java.lang.String,java.text.ParsePosition)": {"Returns": [["@B_java#lang#Object_E@", "An Object parsed from the string. In case of error, returns null."]], "Parameters": [["@B_java#lang#String_E@", "String: A String, part of which should be parsed."], ["@B_java#text#ParsePosition_E@", "ParsePosition: A ParsePosition object with index and error index information as described above."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if pos is null."]], "SeeAlso": [], "Permissions": [], "Description": "Parses text from a string to produce an object. The method attempts to parse text starting at the index given by pos. If parsing succeeds, then the index of pos is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed object is returned. The updated pos can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of pos is not changed, the error index of pos is set to the index of the character where the error occurred, and null is returned.", "history": "Added in API level 1", "FullName": "public abstract Object parseObject (String source, ParsePosition pos)"}, "format(java.lang.Object)": {"Returns": [["@B_java#lang#String_E@", "Formatted string."]], "Parameters": [["@B_java#lang#Object_E@", "Object: The object to format"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the Format cannot format the given object"]], "SeeAlso": [], "Permissions": [], "Description": "Formats an object to produce a string. This is equivalent to", "history": "Added in API level 1", "FullName": "public final String format (Object obj)"}, "parseObject(java.lang.String)": {"Returns": [["@B_java#lang#Object_E@", "An Object parsed from the string."]], "Parameters": [["@B_java#lang#String_E@", "String: A String whose beginning should be parsed."]], "Throws": [["@B_java#text#ParseException_E@", "if the beginning of the specified string cannot be parsed."]], "SeeAlso": [], "Permissions": [], "Description": "Parses text from the beginning of the given string to produce an object. The method may not use the entire text of the given string.", "history": "Added in API level 1", "FullName": "public Object parseObject (String source)"}, "clone()": {"Returns": [["@B_java#lang#Object_E@", "a clone of this instance."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates and returns a copy of this object.", "history": "Added in API level 1", "FullName": "public Object clone ()"}}, "Inheritance": [], "ClassName": "java.text.Format", "ClassDesc": "Format is an abstract base class for formatting locale-sensitive information such as dates, messages, and numbers. Format defines the programming interface for formatting locale-sensitive objects into Strings (the format method) and for parsing Strings back into objects (the parseObject method). Generally, a format's parseObject method must be able to parse any string formatted by its format method. However, there may be exceptional cases where this is not possible. For example, a format method might create two adjacent integer numbers with no separator in between, and in this case the parseObject could not tell which digits belong to which number. The Java Platform provides three specialized subclasses of Format-- DateFormat, MessageFormat, and NumberFormat--for formatting dates, messages, and numbers, respectively. Concrete subclasses must implement three methods: MessageFormat. Subclasses often also provide additional format methods for specific input types as well as parse methods for specific result types. Any parse method that does not take a ParsePosition argument should throw ParseException when no text in the required format is at the beginning of the input text. Most subclasses will also implement the following factory methods: getXxxxInstance methods for more specialized control. For example, the NumberFormat class provides getPercentInstance and getCurrencyInstance methods for getting specialized number formatters. Subclasses of Format that allow programmers to create objects for locales (with getInstance(Locale) for example) must also implement the following class method: And finally subclasses may define a set of constants to identify the various fields in the formatted output. These constants are used to create a FieldPosition object which identifies what information is contained in the field and its position in the formatted result. These constants should be named item_FIELD where item identifies the field. For examples of these constants, see ERA_FIELD and its friends in @B_java#text#DateFormat_E@. Formats are generally not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally."}