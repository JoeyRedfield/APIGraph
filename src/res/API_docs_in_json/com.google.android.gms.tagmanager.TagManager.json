{"Functions": {"loadContainerPreferFresh(java.lang.String, int)": {"Returns": [], "Parameters": [["String", "the ID of the container to load"], ["int", "the resource ID of the default container (for example, R.raw.GTM_XYZZY if you stored your container in res/raw/GTM_XYZZY). Pass -1 if you have no default container."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The @B_com#google#android#gms#tagmanager#ContainerHolder_E@ will be available from the returned @B_com#google#android#gms#common#api#PendingResult_E@ as soon as one of the following happens: a saved container which has been recently refreshed is loaded, a network container is loaded or a network error occurs, or a timeout occurs (as specified in @B_com#google#android#gms#common#api#PendingResult#await_E@, or @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@. If a timeout occurs, the container available from @B_com#google#android#gms#tagmanager#ContainerHolder#getContainer_E@ will be: a saved container which has not recently been refreshed (stale). a default container (if no stale container is available, or could not be loaded before the timeout). null (if no default container is available, or a saved or default container couldn't be loaded before the timeout). In this case, @B_com#google#android#gms#common#api#Result#getStatus_E@ will return an error. Use @B_com#google#android#gms#tagmanager#Container#isDefault_E@ if you need to know whether the container you have is a default container. Use @B_com#google#android#gms#tagmanager#Container#getLastRefreshTime_E@ to determine when the container was last refreshed. You should not call any of the loadContainer methods a second time with a given containerId, since a different ContainerHolder will be returned which will hold a different container. Those separate containers will each fire any tags within them, which would cause double-tagging. Any callback set by @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@ or @B_com#google#android#gms#tagmanager#ContainerHolder#setContainerAvailableListener_E@, will be invoked on the main looper thread.", "history": "", "FullName": "public PendingResult<ContainerHolder> loadContainerPreferFresh (String containerId, int defaultContainerResourceId)"}, "loadContainerPreferNonDefault(java.lang.String, int)": {"Returns": [], "Parameters": [["String", "the ID of the container to load"], ["int", "the resource ID of the default container (for example, R.raw.GTM_XYZZY if you stored your container in res/raw/GTM_XYZZY). Pass -1 if you have no default container."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The @B_com#google#android#gms#tagmanager#ContainerHolder_E@ will be available from the returned @B_com#google#android#gms#common#api#PendingResult_E@ as soon as one of the following happens: a saved container is loaded, or if there is no saved container, a network container is loaded or a network error occurs, or a timeout occurs (as specified in @B_com#google#android#gms#common#api#PendingResult#await_E@, or @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@. If a timeout occurs, the container available from @B_com#google#android#gms#tagmanager#ContainerHolder#getContainer_E@ will (initially) be a default container, if available (if no default container is available, @B_com#google#android#gms#tagmanager#ContainerHolder#getContainer_E@ will return null and @B_com#google#android#gms#common#api#Result#getStatus_E@ will return an error). Use @B_com#google#android#gms#tagmanager#Container#isDefault_E@ if you need to know whether the container you have is a default container. You should not call any of the loadContainer methods a second time with a given containerId, since a different ContainerHolder will be returned which will hold a different container. Those separate containers will each fire any tags within them, which would cause double-tagging. Any callback set by @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@ or @B_com#google#android#gms#tagmanager#ContainerHolder#setContainerAvailableListener_E@, will be invoked on the main looper thread.", "history": "", "FullName": "public PendingResult<ContainerHolder> loadContainerPreferNonDefault (String containerId, int defaultContainerResourceId)"}, "getInstance(android.content.Context)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the singleton instance of the @B_com#google#android#gms#tagmanager#TagManager_E@ class, creating it if necessary.", "history": "", "FullName": "public static TagManager getInstance (Context context)"}, "loadContainerDefaultOnly(java.lang.String, int, android.os.Handler)": {"Returns": [], "Parameters": [["String", "the ID of the container to load"], ["int", "the resource ID of the default container (for example, R.raw.GTM_XYZZY if you stored your container in res/raw/GTM_XYZZY)."], ["Handler", "the handler on whose thread the callback set with @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@ or @B_com#google#android#gms#tagmanager#ContainerHolder#setContainerAvailableListener_E@ is invoked"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The @B_com#google#android#gms#tagmanager#ContainerHolder_E@ will be available from the returned @B_com#google#android#gms#common#api#PendingResult_E@ as soon as either of the following happens: the default container is loaded, or no default container is found. If no default container is found, @B_com#google#android#gms#tagmanager#ContainerHolder#getContainer_E@ will return null and @B_com#google#android#gms#common#api#Result#getStatus_E@ will return an error). The returned ContainerHolder will not be updated from disk, or from the network. The intended use is during development: this provides a way for developers to add new container key/value pairs without having to use the GTM UI or needing a network connection. A developer can add new key/value pairs to a JSON default container, and then use this call to load that container. You should not call any of the loadContainer methods a second time with a given containerId, since a different ContainerHolder will be returned which will hold a different container. Those separate containers will each fire any tags within them, which would cause double-tagging.", "history": "", "FullName": "public PendingResult<ContainerHolder> loadContainerDefaultOnly (String containerId, int defaultContainerResourceId, Handler handler)"}, "setVerboseLoggingEnabled(boolean)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets whether or not verbose logging is enabled. By default, verbose logging is not enabled.", "history": "", "FullName": "public void setVerboseLoggingEnabled (boolean enableVerboseLogging)"}, "getDataLayer()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the data layer object that is used by the tag manager.", "history": "", "FullName": "public DataLayer getDataLayer ()"}, "loadContainerPreferNonDefault(java.lang.String, int, android.os.Handler)": {"Returns": [], "Parameters": [["String", "the ID of the container to load"], ["int", "the resource ID of the default container (for example, R.raw.GTM_XYZZY if you stored your container in res/raw/GTM_XYZZY). Pass -1 if you have no default container."], ["Handler", "the handler on whose thread the callback set with @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@ or @B_com#google#android#gms#tagmanager#ContainerHolder#setContainerAvailableListener_E@ is invoked"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The @B_com#google#android#gms#tagmanager#ContainerHolder_E@ will be available from the returned @B_com#google#android#gms#common#api#PendingResult_E@ as soon as one of the following happens: a saved container is loaded, if there is no saved container, a network container is loaded or a network error occurs, or a timeout occurs (as specified in @B_com#google#android#gms#common#api#PendingResult#await_E@, or @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@. If a timeout occurs, the container available from @B_com#google#android#gms#tagmanager#ContainerHolder#getContainer_E@ will (initially) be a default container, if available (if no default container is available, @B_com#google#android#gms#tagmanager#ContainerHolder#getContainer_E@ will return null and @B_com#google#android#gms#common#api#Result#getStatus_E@ will return an error). Use @B_com#google#android#gms#tagmanager#Container#isDefault_E@ if you need to know whether the container you have is a default container. You should not call any of the loadContainer methods a second time with a given containerId, since a different ContainerHolder will be returned which will hold a different container. Those separate containers will each fire any tags within them, which would cause double-tagging.", "history": "", "FullName": "public PendingResult<ContainerHolder> loadContainerPreferNonDefault (String containerId, int defaultContainerResourceId, Handler handler)"}, "loadContainerDefaultOnly(java.lang.String, int)": {"Returns": [], "Parameters": [["String", "the ID of the container to load"], ["int", "the resource ID of the default container (for example, R.raw.GTM_XYZZY if you stored your container in res/raw/GTM_XYZZY)."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The @B_com#google#android#gms#tagmanager#ContainerHolder_E@ will be available from the returned @B_com#google#android#gms#common#api#PendingResult_E@ as soon as either of the following happens: the default container is loaded, or no default container is found. If no default container is found, @B_com#google#android#gms#tagmanager#ContainerHolder#getContainer_E@ will return null and @B_com#google#android#gms#common#api#Result#getStatus_E@ will return an error). The returned ContainerHolder will not be updated from disk, or from the network. The intended use is during development: this provides a way for developers to add new container key/value pairs without having to use the GTM UI or needing a network connection. A developer can add new key/value pairs to a JSON default container, and then use this call to load that container. You should not call any of the loadContainer methods a second time with a given containerId, since a different ContainerHolder will be returned which will hold a different container. Those separate containers will each fire any tags within them, which would cause double-tagging. Any callback set by @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@ or @B_com#google#android#gms#tagmanager#ContainerHolder#setContainerAvailableListener_E@, will be invoked on the main looper thread.", "history": "", "FullName": "public PendingResult<ContainerHolder> loadContainerDefaultOnly (String containerId, int defaultContainerResourceId)"}, "loadContainerPreferFresh(java.lang.String, int, android.os.Handler)": {"Returns": [], "Parameters": [["String", "the ID of the container to load"], ["int", "the resource ID of the default container (for example, R.raw.GTM_XYZZY if you stored your container in res/raw/GTM_XYZZY). Pass -1 if you have no default container."], ["Handler", "the handler on whose thread the callback set with @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@ or @B_com#google#android#gms#tagmanager#ContainerHolder#setContainerAvailableListener_E@ is invoked"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The @B_com#google#android#gms#tagmanager#ContainerHolder_E@ will be available from the returned @B_com#google#android#gms#common#api#PendingResult_E@ as soon as one of the following happens: a saved container which has been recently refreshed is loaded, a network container is loaded or a network error occurs, or a timeout occurs (as specified in @B_com#google#android#gms#common#api#PendingResult#await_E@, or @B_com#google#android#gms#common#api#PendingResult#setResultCallback_E@. If a timeout occurs, the container available from @B_com#google#android#gms#tagmanager#ContainerHolder#getContainer_E@ will be: a saved container which has not recently been refreshed (stale). a default container (if no stale container is available, or could not be loaded before the timeout). null (if no default container is available, or a saved or default container couldn't be loaded before the timeout). In this case, @B_com#google#android#gms#common#api#Result#getStatus_E@ will return an error. Use @B_com#google#android#gms#tagmanager#Container#isDefault_E@ if you need to know whether the container you have is a default container. Use @B_com#google#android#gms#tagmanager#Container#getLastRefreshTime_E@ to determine when the container was last refreshed. You should not call any of the loadContainer methods a second time with a given containerId, since a different ContainerHolder will be returned which will hold a different container. Those separate containers will each fire any tags within them, which would cause double-tagging.", "history": "", "FullName": "public PendingResult<ContainerHolder> loadContainerPreferFresh (String containerId, int defaultContainerResourceId, Handler handler)"}, "dispatch()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Manually dispatches queued events (tracking pixels, etc) if a network connection is available. Dispatching after significant application events can help to ensure accurate reporting. Calling dispatch frequently can cause excessive battery drain and should be avoided.", "history": "", "FullName": "public void dispatch ()"}}, "Inheritance": ["java.lang.Object"], "ClassName": "com.google.android.gms.tagmanager.TagManager", "ClassDesc": "This is the mobile implementation of Google Tag Manager (GTM). Sample usage: The @B_com#google#android#gms#tagmanager#Container_E@ class provides methods for retrieving values given a key. The routines @B_com#google#android#gms#tagmanager#Container#getBoolean_E@, @B_com#google#android#gms#tagmanager#Container#getDouble_E@, @B_com#google#android#gms#tagmanager#Container#getLong_E@, @B_com#google#android#gms#tagmanager#Container#getString_E@ return the current value for the key of a value collection macro, depending on the rules associated with the container. As an example, if your container has a value collection macro with a key speed whose value is 32, and the enabling rule is Language is \"en\"; and another value collection macro with a key speed whose value is 45, and the enabling rule is Language is not \"en\", then making the following call: The data layer is a map holding generic information about the application. The @B_com#google#android#gms#tagmanager#DataLayer_E@ class provides methods to push and retrieve data from the data layer. Pushing an event key to the data layer will cause tags that match this event to fire. An initial version of the container is bundled with the application. It should be placed as a raw resource in the res/raw directory. When you call one of the loadContainer... methods, you'll pass in the assigned ID (R.raw.filename); the container will be returned with those bundled rules/macros. You will create the container in the UI and use the Download button to download it. Alternatively, you can provide a JSON file containing key/value pairs. You can modify the container in the UI and publish a new version. In that case, the next time the mobile app refreshes the container from the network (currently every 12 hours), it will get that new version. When you call @B_com#google#android#gms#tagmanager#ContainerHolder#getContainer_E@, it'll make that new container active and return it. Calling one of the get... routines on that container will return a value computed using the most recent rules. The downloaded container is saved locally; when you call one of the loadContainer... methods, it will first load the default container, and will then load any saved container. If none is found, or if it is older than 12 hours, it will try to retrieve a newer version from the network."}