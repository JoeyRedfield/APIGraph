{"Functions": {"send(int,android.app.PendingIntent.OnFinished,android.os.Handler)": {"Returns": [], "Parameters": [["int", "int: Result code to supply back to the PendingIntent's target."], ["@B_android#app#PendingIntent#OnFinished_E@", "PendingIntent.OnFinished: The object to call back on when the send has completed, or null for no callback. This value may be null."], ["@B_android#os#Handler_E@", "Handler: Handler identifying the thread on which the callback should happen. If null, the callback will happen from the thread pool of the process. This value may be null."]], "Throws": [["@B_android#app#PendingIntent#CanceledException_E@", "Throws CanceledException if the PendingIntent is no longer allowing more intents to be sent through it."]], "SeeAlso": ["@B_android#app#PendingIntent#send_E@"], "Permissions": [], "Description": "Perform the operation associated with this PendingIntent, allowing the caller to be notified when the send has completed.", "history": "Added in API level 1", "FullName": "public void send (int code, PendingIntent.OnFinished onFinished, Handler handler)"}, "describeContents()": {"Returns": [["int", "a bitmask indicating the set of special object types marshaled by this Parcelable object instance. Value is either 0 or @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Describe the kinds of special objects contained in this Parcelable instance's marshaled representation. For example, if the object will include a file descriptor in the output of @B_android#os#Parcelable#writeToParcel_E@, the return value of this method must include the @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@ bit.", "history": "Added in API level 1", "FullName": "public int describeContents ()"}, "writePendingIntentOrNullToParcel(android.app.PendingIntent,android.os.Parcel)": {"Returns": [], "Parameters": [["@B_android#app#PendingIntent_E@", "PendingIntent: The PendingIntent to write, or null. This value may be null."], ["@B_android#os#Parcel_E@", "Parcel: Where to write the PendingIntent. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience function for writing either a PendingIntent or null pointer to a Parcel. You must use this with @B_android#app#PendingIntent#readPendingIntentOrNullFromParcel_E@ for later reading it.", "history": "Added in API level 1", "FullName": "public static void writePendingIntentOrNullToParcel (PendingIntent sender, Parcel out)"}, "getActivities(android.content.Context,int,android.content.Intent[],int)": {"Returns": [["@B_android#app#PendingIntent_E@", "Returns an existing or new PendingIntent matching the given parameters. May return null only if @B_android#app#PendingIntent#FLAG_NO_CREATE_E@ has been supplied."]], "Parameters": [["@B_android#content#Context_E@", "Context: The Context in which this PendingIntent should start the activity."], ["int", "int: Private request code for the sender"], ["@B_android#content#Intent_E@", "Intent: Array of Intents of the activities to be launched. This value must never be null."], ["int", "int: May be @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, or any of the flags as supported by @B_android#content#Intent#fillIn_E@ to control which unspecified parts of the intent that can be supplied when the actual send happens. Value is either 0 or a combination of @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@, @B_android#content#Intent#FILL_IN_ACTION_E@, @B_android#content#Intent#FILL_IN_DATA_E@, @B_android#content#Intent#FILL_IN_CATEGORIES_E@, @B_android#content#Intent#FILL_IN_COMPONENT_E@, @B_android#content#Intent#FILL_IN_PACKAGE_E@, @B_android#content#Intent#FILL_IN_SOURCE_BOUNDS_E@, @B_android#content#Intent#FILL_IN_SELECTOR_E@, and @B_android#content#Intent#FILL_IN_CLIP_DATA_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#app#PendingIntent#getActivity_E@, but allows an array of Intents to be supplied. The last Intent in the array is taken as the primary key for the PendingIntent, like the single Intent given to @B_android#app#PendingIntent#getActivity_E@. Upon sending the resulting PendingIntent, all of the Intents are started in the same way as they would be by passing them to @B_android#content#Context#startActivities_E@. The first intent in the array will be started outside of the context of an existing activity, so you must use the @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@ launch flag in the Intent. (Activities after the first in the array are started in the context of the previous activity in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) The last intent in the array represents the key for the PendingIntent. In other words, it is the significant element for matching (as done with the single intent given to @B_android#app#PendingIntent#getActivity_E@, its content will be the subject of replacement by @B_android#app#PendingIntent#send_E@ and @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, etc. This is because it is the most specific of the supplied intents, and the UI the user actually sees when the intents are started. For security reasons, the @B_android#content#Intent_E@ objects you supply here should almost always be explicit intents, that is specify an explicit component to be delivered to through @B_android#content#Intent#setClass_E@", "history": "Added in API level 11", "FullName": "public static PendingIntent getActivities (Context context, int requestCode, Intent[] intents, int flags)"}, "cancel()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Cancel a currently active PendingIntent. Only the original application owning a PendingIntent can cancel it.", "history": "Added in API level 1", "FullName": "public void cancel ()"}, "getCreatorUid()": {"Returns": [["int", "The uid of the PendingIntent, or -1 if there is none associated with it."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the uid of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent. The returned integer is supplied by the system, so that an application can not spoof its uid. Be careful about how you use this. All this tells you is who created the PendingIntent. It does @B_android#app#PendingIntent#send_E@ call, not who gave you the PendingIntent.", "history": "Added in API level 17", "FullName": "public int getCreatorUid ()"}, "getService(android.content.Context,int,android.content.Intent,int)": {"Returns": [["@B_android#app#PendingIntent_E@", "Returns an existing or new PendingIntent matching the given parameters. May return null only if @B_android#app#PendingIntent#FLAG_NO_CREATE_E@ has been supplied."]], "Parameters": [["@B_android#content#Context_E@", "Context: The Context in which this PendingIntent should start the service."], ["int", "int: Private request code for the sender"], ["@B_android#content#Intent_E@", "Intent: An Intent describing the service to be started. This value must never be null."], ["int", "int: May be @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@ or any of the flags as supported by @B_android#content#Intent#fillIn_E@ to control which unspecified parts of the intent that can be supplied when the actual send happens. Value is either 0 or a combination of @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@, @B_android#content#Intent#FILL_IN_ACTION_E@, @B_android#content#Intent#FILL_IN_DATA_E@, @B_android#content#Intent#FILL_IN_CATEGORIES_E@, @B_android#content#Intent#FILL_IN_COMPONENT_E@, @B_android#content#Intent#FILL_IN_PACKAGE_E@, @B_android#content#Intent#FILL_IN_SOURCE_BOUNDS_E@, @B_android#content#Intent#FILL_IN_SELECTOR_E@, and @B_android#content#Intent#FILL_IN_CLIP_DATA_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a PendingIntent that will start a service, like calling @B_android#content#Context#startService_E@. The start arguments given to the service will come from the extras of the Intent. For security reasons, the @B_android#content#Intent_E@ you supply here should almost always be an explicit intent, that is specify an explicit component to be delivered to through @B_android#content#Intent#setClass_E@", "history": "Added in API level 1", "FullName": "public static PendingIntent getService (Context context, int requestCode, Intent intent, int flags)"}, "getIntentSender()": {"Returns": [["@B_android#content#IntentSender_E@", "Returns a IntentSender object that wraps the sender of PendingIntent"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a IntentSender object that wraps the existing sender of the PendingIntent", "history": "Added in API level 4", "FullName": "public IntentSender getIntentSender ()"}, "send()": {"Returns": [], "Parameters": [], "Throws": [["@B_android#app#PendingIntent#CanceledException_E@", "Throws CanceledException if the PendingIntent is no longer allowing more intents to be sent through it."]], "SeeAlso": ["@B_android#app#PendingIntent#send_E@"], "Permissions": [], "Description": "Perform the operation associated with this PendingIntent.", "history": "Added in API level 1", "FullName": "public void send ()"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if this object is the same as the obj argument; false otherwise."]], "Parameters": [["@B_java#lang#Object_E@", "Object: the reference object with which to compare."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Comparison operator on two PendingIntent objects, such that true is returned then they both represent the same operation from the same package. This allows you to use @B_android#app#PendingIntent#getActivity_E@, @B_android#app#PendingIntent#getBroadcast_E@, or @B_android#app#PendingIntent#getService_E@ multiple times (even across a process being killed), resulting in different PendingIntent objects but whose equals() method identifies them as being the same operation.", "history": "Added in API level 1", "FullName": "public boolean equals (Object otherObj)"}, "getActivity(android.content.Context,int,android.content.Intent,int,android.os.Bundle)": {"Returns": [["@B_android#app#PendingIntent_E@", "Returns an existing or new PendingIntent matching the given parameters. May return null only if @B_android#app#PendingIntent#FLAG_NO_CREATE_E@ has been supplied."]], "Parameters": [["@B_android#content#Context_E@", "Context: The Context in which this PendingIntent should start the activity."], ["int", "int: Private request code for the sender"], ["@B_android#content#Intent_E@", "Intent: Intent of the activity to be launched. This value must never be null."], ["int", "int: May be @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, or any of the flags as supported by @B_android#content#Intent#fillIn_E@ to control which unspecified parts of the intent that can be supplied when the actual send happens. Value is either 0 or a combination of @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@, @B_android#content#Intent#FILL_IN_ACTION_E@, @B_android#content#Intent#FILL_IN_DATA_E@, @B_android#content#Intent#FILL_IN_CATEGORIES_E@, @B_android#content#Intent#FILL_IN_COMPONENT_E@, @B_android#content#Intent#FILL_IN_PACKAGE_E@, @B_android#content#Intent#FILL_IN_SOURCE_BOUNDS_E@, @B_android#content#Intent#FILL_IN_SELECTOR_E@, and @B_android#content#Intent#FILL_IN_CLIP_DATA_E@"], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. May be null if there are no options. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a PendingIntent that will start a new activity, like calling @B_android#content#Context#startActivity_E@. Note that the activity will be started outside of the context of an existing activity, so you must use the @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@ launch flag in the Intent. For security reasons, the @B_android#content#Intent_E@ you supply here should almost always be an explicit intent, that is specify an explicit component to be delivered to through @B_android#content#Intent#setClass_E@", "history": "Added in API level 16", "FullName": "public static PendingIntent getActivity (Context context, int requestCode, Intent intent, int flags, Bundle options)"}, "getTargetPackage()": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Renamed to @B_android#app#PendingIntent#getCreatorPackage_E@.", "history": "Added in API level 1 Deprecated in API level 17", "FullName": "public String getTargetPackage ()"}, "getForegroundService(android.content.Context,int,android.content.Intent,int)": {"Returns": [["@B_android#app#PendingIntent_E@", "Returns an existing or new PendingIntent matching the given parameters. May return null only if @B_android#app#PendingIntent#FLAG_NO_CREATE_E@ has been supplied."]], "Parameters": [["@B_android#content#Context_E@", "Context: The Context in which this PendingIntent should start the service."], ["int", "int: Private request code for the sender"], ["@B_android#content#Intent_E@", "Intent: An Intent describing the service to be started. This value must never be null."], ["int", "int: May be @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@ or any of the flags as supported by @B_android#content#Intent#fillIn_E@ to control which unspecified parts of the intent that can be supplied when the actual send happens. Value is either 0 or a combination of @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@, @B_android#content#Intent#FILL_IN_ACTION_E@, @B_android#content#Intent#FILL_IN_DATA_E@, @B_android#content#Intent#FILL_IN_CATEGORIES_E@, @B_android#content#Intent#FILL_IN_COMPONENT_E@, @B_android#content#Intent#FILL_IN_PACKAGE_E@, @B_android#content#Intent#FILL_IN_SOURCE_BOUNDS_E@, @B_android#content#Intent#FILL_IN_SELECTOR_E@, and @B_android#content#Intent#FILL_IN_CLIP_DATA_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a PendingIntent that will start a foreground service, like calling @B_android#content#Context#startForegroundService_E@. The start arguments given to the service will come from the extras of the Intent. For security reasons, the @B_android#content#Intent_E@ you supply here should almost always be an explicit intent, that is specify an explicit component to be delivered to through @B_android#content#Intent#setClass_E@", "history": "Added in API level 26", "FullName": "public static PendingIntent getForegroundService (Context context, int requestCode, Intent intent, int flags)"}, "readPendingIntentOrNullFromParcel(android.os.Parcel)": {"Returns": [["@B_android#app#PendingIntent_E@", "Returns the PendingIntent read from the Parcel, or null if null had been written."]], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel containing the written PendingIntent. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience function for reading either a PendingIntent or null pointer from a Parcel. You must have previously written the PendingIntent with @B_android#app#PendingIntent#writePendingIntentOrNullToParcel_E@.", "history": "Added in API level 1", "FullName": "public static PendingIntent readPendingIntentOrNullFromParcel (Parcel in)"}, "getCreatorUserHandle()": {"Returns": [["@B_android#os#UserHandle_E@", "The user handle of the PendingIntent, or null if there is none associated with it."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the user handle of the application that created this PendingIntent, that is the user under which you will actually be sending the Intent. The returned UserHandle is supplied by the system, so that an application can not spoof its user. See @B_android#os#Process#myUserHandle_E@ for more explanation of user handles. Be careful about how you use this. All this tells you is who created the PendingIntent. It does @B_android#app#PendingIntent#send_E@ call, not who gave you the PendingIntent.", "history": "Added in API level 17", "FullName": "public UserHandle getCreatorUserHandle ()"}, "writeToParcel(android.os.Parcel, int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "added in API level 1", "FullName": "public void writeToParcel (Parcel out, int flags)"}, "getActivity(android.content.Context,int,android.content.Intent,int)": {"Returns": [["@B_android#app#PendingIntent_E@", "Returns an existing or new PendingIntent matching the given parameters. May return null only if @B_android#app#PendingIntent#FLAG_NO_CREATE_E@ has been supplied."]], "Parameters": [["@B_android#content#Context_E@", "Context: The Context in which this PendingIntent should start the activity."], ["int", "int: Private request code for the sender"], ["@B_android#content#Intent_E@", "Intent: Intent of the activity to be launched."], ["int", "int: May be @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, or any of the flags as supported by @B_android#content#Intent#fillIn_E@ to control which unspecified parts of the intent that can be supplied when the actual send happens. Value is either 0 or a combination of @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@, @B_android#content#Intent#FILL_IN_ACTION_E@, @B_android#content#Intent#FILL_IN_DATA_E@, @B_android#content#Intent#FILL_IN_CATEGORIES_E@, @B_android#content#Intent#FILL_IN_COMPONENT_E@, @B_android#content#Intent#FILL_IN_PACKAGE_E@, @B_android#content#Intent#FILL_IN_SOURCE_BOUNDS_E@, @B_android#content#Intent#FILL_IN_SELECTOR_E@, and @B_android#content#Intent#FILL_IN_CLIP_DATA_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a PendingIntent that will start a new activity, like calling @B_android#content#Context#startActivity_E@. Note that the activity will be started outside of the context of an existing activity, so you must use the @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@ launch flag in the Intent. For security reasons, the @B_android#content#Intent_E@ you supply here should almost always be an explicit intent, that is specify an explicit component to be delivered to through @B_android#content#Intent#setClass_E@", "history": "Added in API level 1", "FullName": "public static PendingIntent getActivity (Context context, int requestCode, Intent intent, int flags)"}, "send(int)": {"Returns": [], "Parameters": [["int", "int: Result code to supply back to the PendingIntent's target."]], "Throws": [["@B_android#app#PendingIntent#CanceledException_E@", "Throws CanceledException if the PendingIntent is no longer allowing more intents to be sent through it."]], "SeeAlso": ["@B_android#app#PendingIntent#send_E@"], "Permissions": [], "Description": "Perform the operation associated with this PendingIntent.", "history": "Added in API level 1", "FullName": "public void send (int code)"}, "getBroadcast(android.content.Context,int,android.content.Intent,int)": {"Returns": [["@B_android#app#PendingIntent_E@", "Returns an existing or new PendingIntent matching the given parameters. May return null only if @B_android#app#PendingIntent#FLAG_NO_CREATE_E@ has been supplied."]], "Parameters": [["@B_android#content#Context_E@", "Context: The Context in which this PendingIntent should perform the broadcast."], ["int", "int: Private request code for the sender"], ["@B_android#content#Intent_E@", "Intent: The Intent to be broadcast."], ["int", "int: May be @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@ or any of the flags as supported by @B_android#content#Intent#fillIn_E@ to control which unspecified parts of the intent that can be supplied when the actual send happens. Value is either 0 or a combination of @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@, @B_android#content#Intent#FILL_IN_ACTION_E@, @B_android#content#Intent#FILL_IN_DATA_E@, @B_android#content#Intent#FILL_IN_CATEGORIES_E@, @B_android#content#Intent#FILL_IN_COMPONENT_E@, @B_android#content#Intent#FILL_IN_PACKAGE_E@, @B_android#content#Intent#FILL_IN_SOURCE_BOUNDS_E@, @B_android#content#Intent#FILL_IN_SELECTOR_E@, and @B_android#content#Intent#FILL_IN_CLIP_DATA_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a PendingIntent that will perform a broadcast, like calling @B_android#content#Context#sendBroadcast_E@. For security reasons, the @B_android#content#Intent_E@ you supply here should almost always be an explicit intent, that is specify an explicit component to be delivered to through @B_android#content#Intent#setClass_E@", "history": "Added in API level 1", "FullName": "public static PendingIntent getBroadcast (Context context, int requestCode, Intent intent, int flags)"}, "getCreatorPackage()": {"Returns": [["@B_java#lang#String_E@", "The package name of the PendingIntent, or null if there is none associated with it."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the package name of the application that created this PendingIntent, that is the identity under which you will actually be sending the Intent. The returned string is supplied by the system, so that an application can not spoof its package. Be careful about how you use this. All this tells you is who created the PendingIntent. It does @B_android#app#PendingIntent#send_E@ call, not who gave you the PendingIntent.", "history": "Added in API level 17", "FullName": "public String getCreatorPackage ()"}, "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The Context of the caller. This may be null if intent is also null."], ["int", "int: Result code to supply back to the PendingIntent's target."], ["@B_android#content#Intent_E@", "Intent: Additional Intent data. See @B_android#content#Intent#fillIn_E@ for information on how this is applied to the original Intent. Use null to not modify the original Intent. If flag @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@ was set when this pending intent was created, this argument will be ignored. This value may be null."], ["@B_android#app#PendingIntent#OnFinished_E@", "PendingIntent.OnFinished: The object to call back on when the send has completed, or null for no callback. This value may be null."], ["@B_android#os#Handler_E@", "Handler: Handler identifying the thread on which the callback should happen. If null, the callback will happen from the thread pool of the process. This value may be null."]], "Throws": [["@B_android#app#PendingIntent#CanceledException_E@", "Throws CanceledException if the PendingIntent is no longer allowing more intents to be sent through it."]], "SeeAlso": ["@B_android#app#PendingIntent#send_E@"], "Permissions": [], "Description": "Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed. For the intent parameter, a PendingIntent often has restrictions on which fields can be supplied here, based on how the PendingIntent was retrieved in @B_android#app#PendingIntent#getActivity_E@, @B_android#app#PendingIntent#getBroadcast_E@, or @B_android#app#PendingIntent#getService_E@.", "history": "Added in API level 1", "FullName": "public void send (Context context, int code, Intent intent, PendingIntent.OnFinished onFinished, Handler handler)"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of the object. In general, the toString method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:", "history": "Added in API level 1", "FullName": "public String toString ()"}, "writeToParcel(android.os.Parcel,int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@. Value is either 0 or a combination of @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "Added in API level 1", "FullName": "public void writeToParcel (Parcel out, int flags)"}, "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The Context of the caller. This may be null if intent is also null."], ["int", "int: Result code to supply back to the PendingIntent's target."], ["@B_android#content#Intent_E@", "Intent: Additional Intent data. See @B_android#content#Intent#fillIn_E@ for information on how this is applied to the original Intent. Use null to not modify the original Intent. If flag @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@ was set when this pending intent was created, this argument will be ignored. This value may be null."], ["@B_android#app#PendingIntent#OnFinished_E@", "PendingIntent.OnFinished: The object to call back on when the send has completed, or null for no callback. This value may be null."], ["@B_android#os#Handler_E@", "Handler: Handler identifying the thread on which the callback should happen. If null, the callback will happen from the thread pool of the process. This value may be null."], ["@B_java#lang#String_E@", "String: Name of permission that a recipient of the PendingIntent is required to hold. This is only valid for broadcast intents, and corresponds to the permission argument in @B_android#content#Context#sendBroadcast_E@. If null, no permission is required. This value may be null."]], "Throws": [["@B_android#app#PendingIntent#CanceledException_E@", "Throws CanceledException if the PendingIntent is no longer allowing more intents to be sent through it."]], "SeeAlso": ["@B_android#app#PendingIntent#send_E@"], "Permissions": [], "Description": "Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed. For the intent parameter, a PendingIntent often has restrictions on which fields can be supplied here, based on how the PendingIntent was retrieved in @B_android#app#PendingIntent#getActivity_E@, @B_android#app#PendingIntent#getBroadcast_E@, or @B_android#app#PendingIntent#getService_E@.", "history": "Added in API level 14", "FullName": "public void send (Context context, int code, Intent intent, PendingIntent.OnFinished onFinished, Handler handler, String requiredPermission)"}, "send(android.content.Context,int,android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The Context of the caller."], ["int", "int: Result code to supply back to the PendingIntent's target."], ["@B_android#content#Intent_E@", "Intent: Additional Intent data. See @B_android#content#Intent#fillIn_E@ for information on how this is applied to the original Intent. If flag @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@ was set when this pending intent was created, this argument will be ignored. This value may be null."]], "Throws": [["@B_android#app#PendingIntent#CanceledException_E@", "Throws CanceledException if the PendingIntent is no longer allowing more intents to be sent through it."]], "SeeAlso": ["@B_android#app#PendingIntent#send_E@"], "Permissions": [], "Description": "Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use.", "history": "Added in API level 1", "FullName": "public void send (Context context, int code, Intent intent)"}, "hashCode()": {"Returns": [["int", "a hash code value for this object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by @B_java#util#HashMap_E@. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the @B_java#lang#Object#equals_E@ method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java\u2122 programming language.)", "history": "Added in API level 1", "FullName": "public int hashCode ()"}, "getActivities(android.content.Context,int,android.content.Intent[],int,android.os.Bundle)": {"Returns": [["@B_android#app#PendingIntent_E@", "Returns an existing or new PendingIntent matching the given parameters. May return null only if @B_android#app#PendingIntent#FLAG_NO_CREATE_E@ has been supplied."]], "Parameters": [["@B_android#content#Context_E@", "Context: The Context in which this PendingIntent should start the activity."], ["int", "int: Private request code for the sender"], ["@B_android#content#Intent_E@", "Intent: Array of Intents of the activities to be launched. This value must never be null."], ["int", "int: May be @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@ or any of the flags as supported by @B_android#content#Intent#fillIn_E@ to control which unspecified parts of the intent that can be supplied when the actual send happens. Value is either 0 or a combination of @B_android#app#PendingIntent#FLAG_ONE_SHOT_E@, @B_android#app#PendingIntent#FLAG_NO_CREATE_E@, @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@, @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@, @B_android#content#Intent#FILL_IN_ACTION_E@, @B_android#content#Intent#FILL_IN_DATA_E@, @B_android#content#Intent#FILL_IN_CATEGORIES_E@, @B_android#content#Intent#FILL_IN_COMPONENT_E@, @B_android#content#Intent#FILL_IN_PACKAGE_E@, @B_android#content#Intent#FILL_IN_SOURCE_BOUNDS_E@, @B_android#content#Intent#FILL_IN_SELECTOR_E@, and @B_android#content#Intent#FILL_IN_CLIP_DATA_E@"], ["@B_android#os#Bundle_E@", "Bundle: This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#app#PendingIntent#getActivity_E@, but allows an array of Intents to be supplied. The last Intent in the array is taken as the primary key for the PendingIntent, like the single Intent given to @B_android#app#PendingIntent#getActivity_E@. Upon sending the resulting PendingIntent, all of the Intents are started in the same way as they would be by passing them to @B_android#content#Context#startActivities_E@. The first intent in the array will be started outside of the context of an existing activity, so you must use the @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@ launch flag in the Intent. (Activities after the first in the array are started in the context of the previous activity in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.) The last intent in the array represents the key for the PendingIntent. In other words, it is the significant element for matching (as done with the single intent given to @B_android#app#PendingIntent#getActivity_E@, its content will be the subject of replacement by @B_android#app#PendingIntent#send_E@ and @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@, etc. This is because it is the most specific of the supplied intents, and the UI the user actually sees when the intents are started. For security reasons, the @B_android#content#Intent_E@ objects you supply here should almost always be explicit intents, that is specify an explicit component to be delivered to through @B_android#content#Intent#setClass_E@", "history": "Added in API level 16", "FullName": "public static PendingIntent getActivities (Context context, int requestCode, Intent[] intents, int flags, Bundle options)"}, "send(android.content.Context,int,android.content.Intent,android.app.PendingIntent.OnFinished,android.os.Handler,java.lang.String,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The Context of the caller. This may be null if intent is also null."], ["int", "int: Result code to supply back to the PendingIntent's target."], ["@B_android#content#Intent_E@", "Intent: Additional Intent data. See @B_android#content#Intent#fillIn_E@ for information on how this is applied to the original Intent. Use null to not modify the original Intent. If flag @B_android#app#PendingIntent#FLAG_IMMUTABLE_E@ was set when this pending intent was created, this argument will be ignored. This value may be null."], ["@B_android#app#PendingIntent#OnFinished_E@", "PendingIntent.OnFinished: The object to call back on when the send has completed, or null for no callback. This value may be null."], ["@B_android#os#Handler_E@", "Handler: Handler identifying the thread on which the callback should happen. If null, the callback will happen from the thread pool of the process. This value may be null."], ["@B_java#lang#String_E@", "String: Name of permission that a recipient of the PendingIntent is required to hold. This is only valid for broadcast intents, and corresponds to the permission argument in @B_android#content#Context#sendBroadcast_E@. If null, no permission is required. This value may be null."], ["@B_android#os#Bundle_E@", "Bundle: Additional options the caller would like to provide to modify the sending behavior. May be built from an @B_android#app#ActivityOptions_E@ to apply to an activity start. This value may be null."]], "Throws": [["@B_android#app#PendingIntent#CanceledException_E@", "Throws CanceledException if the PendingIntent is no longer allowing more intents to be sent through it."]], "SeeAlso": ["@B_android#app#PendingIntent#send_E@"], "Permissions": [], "Description": "Perform the operation associated with this PendingIntent, allowing the caller to specify information about the Intent to use and be notified when the send has completed. For the intent parameter, a PendingIntent often has restrictions on which fields can be supplied here, based on how the PendingIntent was retrieved in @B_android#app#PendingIntent#getActivity_E@, @B_android#app#PendingIntent#getBroadcast_E@, or @B_android#app#PendingIntent#getService_E@.", "history": "Added in API level 23", "FullName": "public void send (Context context, int code, Intent intent, PendingIntent.OnFinished onFinished, Handler handler, String requiredPermission, Bundle options)"}}, "Inheritance": [], "ClassName": "android.app.PendingIntent", "ClassDesc": "A description of an Intent and target action to perform with it. Instances of this class are created with @B_android#app#PendingIntent#getActivity_E@, @B_android#app#PendingIntent#getActivities_E@, @B_android#app#PendingIntent#getBroadcast_E@, and @B_android#app#PendingIntent#getService_E@; the returned object can be handed to other applications so that they can perform the action you described on your behalf at a later time. By giving a PendingIntent to another application, you are granting it the right to perform the operation you have specified as if the other application was yourself (with the same permissions and identity). As such, you should be careful about how you build the PendingIntent: almost always, for example, the base Intent you supply should have the component name explicitly set to one of your own components, to ensure it is ultimately sent there and nowhere else. A PendingIntent itself is simply a reference to a token maintained by the system describing the original data used to retrieve it. This means that, even if its owning application's process is killed, the PendingIntent itself will remain usable from other processes that have been given it. If the creating application later re-retrieves the same kind of PendingIntent (same operation, same Intent action, data, categories, and components, and same flags), it will receive a PendingIntent representing the same token if that is still valid, and can thus call @B_android#app#PendingIntent#cancel_E@ to remove it. Because of this behavior, it is important to know when two Intents are considered to be the same for purposes of retrieving a PendingIntent. A common mistake people make is to create multiple PendingIntent objects with Intents that only vary in their \"extra\" contents, expecting to get a different PendingIntent each time. This does not happen. The parts of the Intent that are used for matching are the same ones defined by @B_android#content#Intent#filterEquals_E@. If you use two Intent objects that are equivalent as per @B_android#content#Intent#filterEquals_E@, then you will get the same PendingIntent for both of them. There are two typical ways to deal with this. If you truly need multiple distinct PendingIntent objects active at the same time (such as to use as two notifications that are both shown at the same time), then you will need to ensure there is something that is different about them to associate them with different PendingIntents. This may be any of the Intent attributes considered by @B_android#content#Intent#filterEquals_E@, or different request code integers supplied to @B_android#app#PendingIntent#getActivity_E@, @B_android#app#PendingIntent#getActivities_E@, @B_android#app#PendingIntent#getBroadcast_E@, or @B_android#app#PendingIntent#getService_E@. If you only need one PendingIntent active at a time for any of the Intents you will use, then you can alternatively use the flags @B_android#app#PendingIntent#FLAG_CANCEL_CURRENT_E@ or @B_android#app#PendingIntent#FLAG_UPDATE_CURRENT_E@ to either cancel or modify whatever current PendingIntent is associated with the Intent you are supplying."}