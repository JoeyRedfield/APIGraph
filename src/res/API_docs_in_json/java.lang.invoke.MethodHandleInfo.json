{"Functions": {"toString(int,java.lang.Class<?>,java.lang.String,java.lang.invoke.MethodType)": {"Returns": [["@B_java#lang#String_E@", "a string of the form \"RK C.N:MT\""]], "Parameters": [["int", "int: the reference kind part of the symbolic reference"], ["@B_java#lang#Class_E@", "Class: the declaring class part of the symbolic reference"], ["@B_java#lang#String_E@", "String: the member name part of the symbolic reference"], ["@B_java#lang#invoke#MethodType_E@", "MethodType: the method type part of the symbolic reference"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the first argument is not a valid reference kind number"], ["@B_java#lang#NullPointerException_E@", "if any reference argument is null"]], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation for a MethodHandleInfo, given the four parts of its symbolic reference. This is defined to be of the form \"RK C.N:MT\", where RK is the kind, C is the defc N is the name, and MT is the type. These four values may be obtained from the MethodHandleInfo object.", "history": "Added in API level 26", "FullName": "public static String toString (int kind, Class<?> defc, String name, MethodType type)"}, "refKindName(int)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This internal method was accidentally added to API 26 and must not be used. Use @B_java#lang#invoke#MethodHandleInfo#referenceKindToString_E@ instead.", "history": "Added in API level 26 Deprecated in API level 29", "FullName": "public static String refKindName (int refKind)"}, "getReferenceKind()": {"Returns": [["int", "the integer code for the kind of reference used to access the underlying member"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the reference kind of the cracked method handle, which in turn determines whether the method handle's underlying member was a constructor, method, or field. See the", "history": "Added in API level 26", "FullName": "public abstract int getReferenceKind ()"}, "refKindIsValid(int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This internal method was accidentally added to API 26 and must not be used. No replacement is available but it is possible to replicate using information from the refKind >= 1 && refKind <= 9. There are no guarantees that this logic will work if future versions extend the table.", "history": "Added in API level 26 Deprecated in API level 29", "FullName": "public static boolean refKindIsValid (int refKind)"}, "reflectAs(java.lang.Class<T>,java.lang.invoke.MethodHandles.Lookup)": {"Returns": [["T", "a reference to the method, constructor, or field object"]], "Parameters": [["@B_java#lang#Class_E@", "Class: a class object representing the desired result type T"], ["@B_java#lang#invoke#MethodHandles#Lookup_E@", "MethodHandles.Lookup: the lookup object that created this MethodHandleInfo, or one with equivalent access privileges"]], "Throws": [["@B_java#lang#ClassCastException_E@", "if the member is not of the expected type"], ["@B_java#lang#NullPointerException_E@", "if either argument is null"], ["@B_java#lang#IllegalArgumentException_E@", "if the underlying member is not accessible to the given lookup object"]], "SeeAlso": [], "Permissions": [], "Description": "Reflects the underlying member as a method, constructor, or field object. If the underlying member is public, it is reflected as if by getMethod, getConstructor, or getField. Otherwise, it is reflected as if by getDeclaredMethod, getDeclaredConstructor, or getDeclaredField. The underlying member must be accessible to the given lookup object.", "history": "Added in API level 26", "FullName": "public abstract T reflectAs (Class<T> expected, MethodHandles.Lookup lookup)"}, "refKindIsField(int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This internal method was accidentally added to API 26 and must not be used. No replacement is available but it is possible to replicate using information from the refKind >= 1 && refKind <= 4. There are no guarantees that this logic will work if future versions extend the table.", "history": "Added in API level 26 Deprecated in API level 29", "FullName": "public static boolean refKindIsField (int refKind)"}, "isVarArgs()": {"Returns": [["boolean", "true if and only if the underlying member was declared with variable arity."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Determines if the underlying member was a variable arity method or constructor. Such members are represented by method handles that are varargs collectors.", "history": "Added in API level 26", "FullName": "public boolean isVarArgs ()"}, "referenceKindToString(int)": {"Returns": [["@B_java#lang#String_E@", "a mixed-case string such as \"getField\""]], "Parameters": [["int", "int: an integer code for a kind of reference used to access a class member"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the argument is not a valid reference kind number"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the descriptive name of the given reference kind, as defined in the", "history": "Added in API level 26", "FullName": "public static String referenceKindToString (int referenceKind)"}, "getMethodType()": {"Returns": [["@B_java#lang#invoke#MethodType_E@", "the type of the underlying member, expressed as a method type"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the nominal type of the cracked symbolic reference, expressed as a method type. If the reference is to a constructor, the return type will be void. If it is to a non-static method, the method type will not mention the this parameter. If it is to a field and the requested access is to read the field, the method type will have no parameters and return the field type. If it is to a field and the requested access is to write the field, the method type will have one parameter of the field type and return void. Note that original direct method handle may include a leading this parameter, or (in the case of a constructor) will replace the void return type with the constructed class. The nominal type does not include any this parameter, and (in the case of a constructor) will return void.", "history": "Added in API level 26", "FullName": "public abstract MethodType getMethodType ()"}, "getModifiers()": {"Returns": [["int", "the Java language modifiers for underlying member, or -1 if the member cannot be accessed"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_java#lang#reflect#Modifier_E@", "@B_java#lang#invoke#MethodHandleInfo#reflectAs_E@"], "Permissions": [], "Description": "Returns the access modifiers of the underlying member.", "history": "Added in API level 26", "FullName": "public abstract int getModifiers ()"}, "getDeclaringClass()": {"Returns": [["@B_java#lang#Class_E@", "the declaring class of the underlying member"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the class in which the cracked method handle's underlying member was defined.", "history": "Added in API level 26", "FullName": "public abstract Class<?> getDeclaringClass ()"}, "getName()": {"Returns": [["@B_java#lang#String_E@", "the simple name of the underlying member"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the name of the cracked method handle's underlying member. This is \"<init>\" if the underlying member was a constructor, else it is a simple method name or field name.", "history": "Added in API level 26", "FullName": "public abstract String getName ()"}}, "Inheritance": [], "ClassName": "java.lang.invoke.MethodHandleInfo", "ClassDesc": "A symbolic reference obtained by cracking a direct method handle into its consitutent symbolic parts. To crack a direct method handle, call @B_java#lang#invoke#MethodHandles#Lookup#revealDirect_E@. direct method handle represents a method, constructor, or field without any intervening argument bindings or other transformations. The method, constructor, or field referred to by a direct method handle is called its underlying member. Direct method handles may be obtained in any of these ways: By executing an ldc instruction on a CONSTANT_MethodHandle constant. (See the Java Virtual Machine Specification, sections 4.4.8 and 5.4.3.) By calling one of the @B_java#lang#invoke#MethodHandles#Lookup#findVirtual_E@, to resolve a symbolic reference into a method handle. A symbolic reference consists of a class, name string, and type. By calling the factory method @B_java#lang#invoke#MethodHandles#Lookup#unreflect_E@ or @B_java#lang#invoke#MethodHandles#Lookup#unreflectSpecial_E@ to convert a @B_java#lang#reflect#Method_E@ into a method handle. By calling the factory method @B_java#lang#invoke#MethodHandles#Lookup#unreflectConstructor_E@ to convert a @B_java#lang#reflect#Constructor_E@ into a method handle. By calling the factory method @B_java#lang#invoke#MethodHandles#Lookup#unreflectGetter_E@ or @B_java#lang#invoke#MethodHandles#Lookup#unreflectSetter_E@ to convert a @B_java#lang#reflect#Field_E@ into a method handle. Lookup object, it is possible to crack any direct method handle to recover a symbolic reference for the underlying method, constructor, or field. Cracking must be done via a Lookup object equivalent to that which created the target method handle, or which has enough access permissions to recreate an equivalent method handle. If the underlying method is Class.forName). The requirement of lookup object matching provides a \"fast fail\" behavior for programs which may otherwise trust erroneous revelation of a method handle with symbolic information (or caller binding) from an unexpected scope. Use @B_java#lang#invoke#MethodHandles#reflectAs_E@ to override this limitation."}