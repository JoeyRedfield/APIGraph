{"Functions": {"WakefulBroadcastReceiver()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.0.0", "FullName": "WakefulBroadcastReceiver ()"}, "completeWakefulIntent(android.content.Intent)": {"Returns": [["boolean", "Returns true if the intent is associated with a wake lock that is now released; returns false if there was no wake lock specified for it."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent as originally generated by @B_android#support#v4#content#WakefulBroadcastReceiver#startWakefulService_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finish the execution from a previous @B_android#support#v4#content#WakefulBroadcastReceiver#startWakefulService_E@. Any wake lock that was being held will now be released.", "history": "added in version 22.0.0", "FullName": "boolean completeWakefulIntent (Intent intent)"}}, "Inheritance": ["java.lang.Object", "https:##developer#android#com@B_android#content#BroadcastReceiver_E@"], "ClassName": "android.support.v4.content.WakefulBroadcastReceiver", "ClassDesc": "As of https:##developer#android#com@B_android#os#Build#VERSION_CODES#O_E@, background check restrictions make this class no longer generally useful. (It is generally not safe to start a service from the receipt of a broadcast, because you don't have any guarantees that your app is in the foreground at this point and thus allowed to do so.) Instead, developers should use android.app.job.JobScheduler to schedule a job, and this does not require that the app hold a wake lock while doing so (the system will take care of holding a wake lock for the job). This helper is for an old pattern of implementing a https:##developer#android#com@B_android#content#BroadcastReceiver_E@ that receives a device wakeup event and then passes the work off to a https:##developer#android#com@B_android#app#Service_E@, while ensuring that the device does not go back to sleep during the transition. This class takes care of creating and managing a partial wake lock for you; you must request the @B_android#Manifest#permission#WAKE_LOCK_E@ permission to use it. Wakelocks held by this class are reported to tools as \"androidx.core:wake:<component-name>\". A @B_android#support#v4#content#WakefulBroadcastReceiver_E@ uses the method @B_android#support#v4#content#WakefulBroadcastReceiver#startWakefulService_E@ to start the service that does the work. This method is comparable to https:##developer#android#com@B_android#content#Context#startService_E@, except that the @B_android#support#v4#content#WakefulBroadcastReceiver_E@ is holding a wake lock when the service starts. The intent that is passed with @B_android#support#v4#content#WakefulBroadcastReceiver#startWakefulService_E@ holds an extra identifying the wake lock. The service (in this example, an https:##developer#android#com@B_android#app#IntentService_E@) does some work. When it is finished, it releases the wake lock by calling @B_android#support#v4#content#WakefulBroadcastReceiver#completeWakefulIntent_E@. The intent it passes as a parameter is the same intent that the @B_android#support#v4#content#WakefulBroadcastReceiver_E@ originally passed in."}