{"Functions": {"startActivities(android.content.Intent[],android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: An array of Intents to be started."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details."]], "Throws": [["@B_android#content#ActivityNotFoundException_E@", ""]], "SeeAlso": ["@B_android#content#Context#startActivities_E@", "@B_android#content#pm#PackageManager#resolveActivity_E@"], "Permissions": [], "Description": "Launch multiple new activities. This is generally the same as calling @B_android#content#Context#startActivity_E@ for the first Intent in the array, that activity during its creation calling @B_android#content#Context#startActivity_E@ for the second entry, etc. Note that unlike that approach, generally none of the activities except the last in the array will be created at this point, but rather will be created when the user first visits them (due to pressing back from the activity on top). This method throws @B_android#content#ActivityNotFoundException_E@ if there was no Activity found for any given Intent. In this case the state of the activity stack is undefined (some Intents in the list may be on it, some not), so you probably want to avoid such situations.", "history": "Added in API level 16", "FullName": "public abstract void startActivities (Intent[] intents, Bundle options)"}, "revokeUriPermission(android.net.Uri, int)": {"Returns": [], "Parameters": [["@B_android#net#Uri_E@", "Uri: The Uri you would like to revoke access to."], ["int", "int: The access modes to revoke.Value is either 0 or combination of FLAG_GRANT_READ_URI_PERMISSION or FLAG_GRANT_WRITE_URI_PERMISSION."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#grantUriPermission_E@"], "Permissions": [], "Description": "Remove all permissions to access a particular content provider Uri that were previously added with @B_android#content#Context#grantUriPermission_E@ or any other mechanism. The given Uri will match all previously granted Uris that are the same or a sub-path of the given Uri. That is, revoking \"content://foo/target\" will revoke both \"content://foo/target\" and \"content://foo/target/sub\", but not \"content://foo\". It will not remove any prefix grants that exist at a higher level. Prior to @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@, if you did not have regular permission access to a Uri, but had received access to it through a specific Uri permission grant, you could not revoke that grant with this function and a @B_java#lang#SecurityException_E@ would be thrown. As of @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@, this function will not throw a security exception, but will remove whatever permission grants to the Uri had been given to the app (or none). Unlike @B_android#content#Context#revokeUriPermission_E@, this method impacts all permission grants matching the given Uri, for any package they had been granted to, through any mechanism this had happened (such as indirectly through the clipboard, activity launch, service start, etc). That means this can be potentially dangerous to use, as it can revoke grants that another app could be strongly expecting to stick around.", "history": "added in API level 1", "FullName": "public abstract void revokeUriPermission (Uri uri, int modeFlags)"}, "sendBroadcastAsUser(android.content.Intent,android.os.UserHandle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The intent to broadcast"], ["@B_android#os#UserHandle_E@", "UserHandle: UserHandle to send the intent to."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendBroadcast_E@"], "Permissions": [], "Description": "Version of @B_android#content#Context#sendBroadcast_E@ that allows you to specify the user the broadcast will be sent to. This is not available to applications that are not pre-installed on the system image. Requires android.Manifest.permission.INTERACT_ACROSS_USERS", "history": "Added in API level 17", "FullName": "public abstract void sendBroadcastAsUser (Intent intent, UserHandle user)"}, "enforceCallingOrSelfUriPermission(android.net.Uri,int,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The access modes to enforce. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"], ["@B_java#lang#String_E@", "String: A message to include in the exception if it is thrown."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkCallingOrSelfUriPermission_E@"], "Permissions": [], "Description": "If the calling process of an IPC or you has not been granted permission to access a specific URI, throw @B_java#lang#SecurityException_E@. This is the same as @B_android#content#Context#enforceCallingUriPermission_E@, except it grants your own permissions if you are not currently processing an IPC. Use with care!", "history": "Added in API level 1", "FullName": "public abstract void enforceCallingOrSelfUriPermission (Uri uri, int modeFlags, String message)"}, "checkCallingOrSelfPermission(java.lang.String)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the calling pid/uid is allowed that permission, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the permission being checked. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#pm#PackageManager#checkPermission_E@", "@B_android#content#Context#checkPermission_E@", "@B_android#content#Context#checkCallingPermission_E@"], "Permissions": [], "Description": "Determine whether the calling process of an IPC or you have been granted a particular permission. This is the same as @B_android#content#Context#checkCallingPermission_E@, except it grants your own permissions if you are not currently processing an IPC. Use with care!", "history": "Added in API level 1", "FullName": "public abstract int checkCallingOrSelfPermission (String permission)"}, "checkUriPermission(android.net.Uri,int,int,int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the given pid/uid is allowed to access that uri, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."], ["int", "int: The access modes to check. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkCallingUriPermission_E@"], "Permissions": [], "Description": "Determine whether a particular process and user ID has been granted permission to access a specific URI. This only checks for permissions that have been explicitly granted -- if the given process/uid has more general access to the URI's content provider then this check will always fail.", "history": "Added in API level 1", "FullName": "public abstract int checkUriPermission (Uri uri, int pid, int uid, int modeFlags)"}, "sendStickyOrderedBroadcastAsUser(android.content.Intent,android.os.UserHandle,android.content.BroadcastReceiver,android.os.Handler,int,java.lang.String,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast."], ["@B_android#os#UserHandle_E@", "UserHandle: UserHandle to send the intent to."], ["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: Your own BroadcastReceiver to treat as the final receiver of the broadcast."], ["@B_android#os#Handler_E@", "Handler: A custom Handler with which to schedule the resultReceiver callback; if null it will be scheduled in the Context's main thread. This value may be null."], ["int", "int: An initial value for the result code. Often Activity.RESULT_OK."], ["@B_java#lang#String_E@", "String: An initial value for the result data. Often null. This value may be null."], ["@B_android#os#Bundle_E@", "Bundle: An initial value for the result extras. Often null. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendStickyOrderedBroadcast_E@"], "Permissions": ["@B_android#Manifest#permission#BROADCAST_STICKY_E@"], "Description": "Sticky broadcasts should not be used. They provide no security (anyone can access them), no protection (anyone can modify them), and many other problems. The recommended pattern is to use a non-sticky broadcast to report that something has changed, with another mechanism for apps to retrieve the current value whenever desired. Version of @B_android#content#Context#sendStickyOrderedBroadcast_E@ that allows you to specify the user the broadcast will be sent to. This is not available to applications that are not pre-installed on the system image. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts. Requires android.Manifest.permission.INTERACT_ACROSS_USERS and @B_android#Manifest#permission#BROADCAST_STICKY_E@", "history": "Added in API level 17 Deprecated in API level 21", "FullName": "public abstract void sendStickyOrderedBroadcastAsUser (Intent intent, UserHandle user, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)"}, "getText(int)": {"Returns": [["@B_java#lang#CharSequence_E@", "This value will never be null."]], "Parameters": [["int", "int: Resource id for the CharSequence text"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a localized, styled CharSequence from the application's package's default string table.", "history": "Added in API level 1", "FullName": "public final CharSequence getText (int resId)"}, "removeStickyBroadcast(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent that was previously broadcast."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendStickyBroadcast_E@"], "Permissions": ["@B_android#Manifest#permission#BROADCAST_STICKY_E@"], "Description": "Sticky broadcasts should not be used. They provide no security (anyone can access them), no protection (anyone can modify them), and many other problems. The recommended pattern is to use a non-sticky broadcast to report that something has changed, with another mechanism for apps to retrieve the current value whenever desired. Remove the data previously sent with @B_android#content#Context#sendStickyBroadcast_E@, so that it is as if the sticky broadcast had never happened. Requires @B_android#Manifest#permission#BROADCAST_STICKY_E@", "history": "Added in API level 1 Deprecated in API level 21", "FullName": "public abstract void removeStickyBroadcast (Intent intent)"}, "getObbDirs()": {"Returns": [["@B_java#io#File_E@", "the absolute paths to application-specific directories. Some individual paths may be null if that shared storage is not currently available. The first path returned is the same as @B_android#content#Context#getObbDir_E@"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#getObbDir_E@", "@B_android#os#Environment#getExternalStorageState_E@", "@B_android#os#Environment#isExternalStorageEmulated_E@", "@B_android#os#Environment#isExternalStorageRemovable_E@"], "Permissions": ["@B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@"], "Description": "Returns absolute paths to application-specific directories on all shared/external storage devices where the application's OBB files (if there are any) can be found. Note if the application does not have any OBB files, these directories may not exist. This is like @B_android#content#Context#getFilesDir_E@ in that these files will be deleted when the application is uninstalled, however there are some important differences: Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using @B_android#os#Environment#getExternalStorageState_E@. There is no security enforced with these files. For example, any application holding @B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@ can write to these files. Shared storage devices returned here are considered a stable part of the device, including physical media slots under a protective cover. The returned paths do not include transient devices, such as USB flash drives connected to handheld devices. An application may store data on any or all of the returned devices. For example, an app may choose to store large files on the device with the most available space, as measured by @B_android#os#StatFs_E@. No additional permissions are required for the calling app to read or write files under the returned path. Write access outside of these paths on secondary external storage devices is not available.", "history": "Added in API level 19", "FullName": "public abstract File[] getObbDirs ()"}, "getWallpaperDesiredMinimumHeight()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#app#WallpaperManager#getDesiredMinimumHeight_E@ instead.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public abstract int getWallpaperDesiredMinimumHeight ()"}, "enforceCallingPermission(java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The name of the permission being checked. This value must never be null."], ["@B_java#lang#String_E@", "String: A message to include in the exception if it is thrown. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkCallingPermission_E@"], "Permissions": [], "Description": "If the calling process of an IPC you are handling has not been granted a particular permission, throw a @B_java#lang#SecurityException_E@. This is basically the same as calling @B_android#content#Context#enforcePermission_E@ with the pid and uid returned by @B_android#os#Binder#getCallingPid_E@ and @B_android#os#Binder#getCallingUid_E@. One important difference is that if you are not currently processing an IPC, this function will always throw the SecurityException. This is done to protect against accidentally leaking permissions; you can use @B_android#content#Context#enforceCallingOrSelfPermission_E@ to avoid this protection.", "history": "Added in API level 1", "FullName": "public abstract void enforceCallingPermission (String permission, String message)"}, "getContentResolver()": {"Returns": [["@B_android#content#ContentResolver_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a ContentResolver instance for your application's package.", "history": "Added in API level 1", "FullName": "public abstract ContentResolver getContentResolver ()"}, "getSharedPreferences(java.lang.String,int)": {"Returns": [["@B_android#content#SharedPreferences_E@", "The single @B_android#content#SharedPreferences_E@ instance that can be used to retrieve and modify the preference values."]], "Parameters": [["@B_java#lang#String_E@", "String: Desired preferences file."], ["int", "int: Operating mode. Value is either 0 or a combination of @B_android#content#Context#MODE_PRIVATE_E@, @B_android#content#Context#MODE_WORLD_READABLE_E@, @B_android#content#Context#MODE_WORLD_WRITEABLE_E@, and @B_android#content#Context#MODE_MULTI_PROCESS_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context_E@"], "Permissions": [], "Description": "Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values. Only one instance of the SharedPreferences object is returned to any callers for the same name, meaning they will see each other's edits as soon as they are made. This method is thread-safe. If the preferences directory does not already exist, it will be created when this method is called. If a preferences file by this name does not exist, it will be created when you retrieve an editor (@B_android#content#SharedPreferences#edit_E@) and then commit changes (@B_android#content#SharedPreferences#Editor#commit_E@ or @B_android#content#SharedPreferences#Editor#apply_E@).", "history": "Added in API level 1", "FullName": "public abstract SharedPreferences getSharedPreferences (String name, int mode)"}, "enforceCallingOrSelfPermission(java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The name of the permission being checked. This value must never be null."], ["@B_java#lang#String_E@", "String: A message to include in the exception if it is thrown. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkCallingOrSelfPermission_E@"], "Permissions": [], "Description": "If neither you nor the calling process of an IPC you are handling has been granted a particular permission, throw a @B_java#lang#SecurityException_E@. This is the same as @B_android#content#Context#enforceCallingPermission_E@, except it grants your own permissions if you are not currently processing an IPC. Use with care!", "history": "Added in API level 1", "FullName": "public abstract void enforceCallingOrSelfPermission (String permission, String message)"}, "unregisterComponentCallbacks(android.content.ComponentCallbacks)": {"Returns": [], "Parameters": [["@B_android#content#ComponentCallbacks_E@", "ComponentCallbacks no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove a @B_android#content#ComponentCallbacks_E@ object that was previously registered with @B_android#content#Context#registerComponentCallbacks_E@.", "history": "Added in API level 14", "FullName": "public void unregisterComponentCallbacks (ComponentCallbacks callback)"}, "getSharedPreferences(java.lang.String, int)": {"Returns": [["@B_android#content#SharedPreferences_E@", "The single @B_android#content#SharedPreferences_E@ instance that can be used to retrieve and modify the preference values."]], "Parameters": [["@B_java#lang#String_E@", "String: Desired preferences file. If a preferences file by this name does not exist, it will be created when you retrieve an editor (SharedPreferences.edit()) and then commit changes (Editor.commit())."], ["int", "int: Operating mode.Value is either 0 or combination of MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE or MODE_MULTI_PROCESS."]], "Throws": [], "SeeAlso": ["@B_android#content#Context_E@"], "Permissions": [], "Description": "Retrieve and hold the contents of the preferences file 'name', returning a SharedPreferences through which you can retrieve and modify its values. Only one instance of the SharedPreferences object is returned to any callers for the same name, meaning they will see each other's edits as soon as they are made. This method is thead-safe.", "history": "added in API level 1", "FullName": "public abstract SharedPreferences getSharedPreferences (String name, int mode)"}, "obtainStyledAttributes(android.util.AttributeSet,int[],int,int)": {"Returns": [["@B_android#content#res#TypedArray_E@", "This value will never be null."]], "Parameters": [["@B_android#util#AttributeSet_E@", "AttributeSet: This value may be null."], ["int[]", "int: This value must never be null."], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": ["@B_android#content#res#Resources#Theme#obtainStyledAttributes_E@"], "Permissions": [], "Description": "Retrieve styled attribute information in this Context's theme. See @B_android#content#res#Resources#Theme#obtainStyledAttributes_E@ for more information.", "history": "Added in API level 1", "FullName": "public final TypedArray obtainStyledAttributes (AttributeSet set, int[] attrs, int defStyleAttr, int defStyleRes)"}, "grantUriPermission(java.lang.String,android.net.Uri,int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The package you would like to allow to access the Uri."], ["@B_android#net#Uri_E@", "Uri: The Uri you would like to grant access to."], ["int", "int: The desired access modes. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@, @B_android#content#Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_PREFIX_URI_PERMISSION_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context#revokeUriPermission_E@"], "Permissions": [], "Description": "Grant permission to access a specific Uri to another package, regardless of whether that package has general permission to access the Uri's content provider. This can be used to grant specific, temporary permissions, typically in response to user interaction (such as the user opening an attachment that you would like someone else to display). Normally you should use @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@ or @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@ with the Intent being used to start an activity instead of this function directly. If you use this function directly, you should be sure to call @B_android#content#Context#revokeUriPermission_E@ when the target should no longer be allowed to access it. To succeed, the content provider owning the Uri must have set the @B_android#R#styleable#AndroidManifestProvider_grantUriPermissions_E@ attribute in its manifest or included the @B_android#R#styleable#AndroidManifestGrantUriPermission_E@ tag.", "history": "Added in API level 1", "FullName": "public abstract void grantUriPermission (String toPackage, Uri uri, int modeFlags)"}, "sendStickyBroadcastAsUser(android.content.Intent,android.os.UserHandle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast, and the Intent will be held to be re-broadcast to future receivers."], ["@B_android#os#UserHandle_E@", "UserHandle: UserHandle to send the intent to."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendBroadcast_E@"], "Permissions": ["@B_android#Manifest#permission#BROADCAST_STICKY_E@"], "Description": "Sticky broadcasts should not be used. They provide no security (anyone can access them), no protection (anyone can modify them), and many other problems. The recommended pattern is to use a non-sticky broadcast to report that something has changed, with another mechanism for apps to retrieve the current value whenever desired. Version of @B_android#content#Context#sendStickyBroadcast_E@ that allows you to specify the user the broadcast will be sent to. This is not available to applications that are not pre-installed on the system image. Requires android.Manifest.permission.INTERACT_ACROSS_USERS and @B_android#Manifest#permission#BROADCAST_STICKY_E@", "history": "Added in API level 17 Deprecated in API level 21", "FullName": "public abstract void sendStickyBroadcastAsUser (Intent intent, UserHandle user)"}, "getDataDir()": {"Returns": [["@B_java#io#File_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#pm#ApplicationInfo#dataDir_E@"], "Permissions": [], "Description": "Returns the absolute path to the directory on the filesystem where all private files belonging to this app are stored. Apps should not use this path directly; they should instead use @B_android#content#Context#getFilesDir_E@, @B_android#content#Context#getCacheDir_E@, @B_android#content#Context#getDir_E@, or other storage APIs on this class. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted. No additional permissions are required for the calling app to read or write files under the returned path.", "history": "Added in API level 24", "FullName": "public abstract File getDataDir ()"}, "getAssets()": {"Returns": [["@B_android#content#res#AssetManager_E@", "an AssetManager instance for the application's package"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#getResources_E@"], "Permissions": [], "Description": "Returns an AssetManager instance for the application's package. @B_android#content#Context#getResources_E@. For example, they should share the same @B_android#content#res#Configuration_E@ object.", "history": "Added in API level 1", "FullName": "public abstract AssetManager getAssets ()"}, "getApplicationContext()": {"Returns": [["@B_android#content#Context_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the context of the single, global Application object of the current process. This generally should only be used if you need a Context whose lifecycle is separate from the current context, that is tied to the lifetime of the process rather than the current component. Consider for example how this interacts with @B_android#content#Context#registerReceiver_E@: If used from an Activity context, the receiver is being registered within that activity. This means that you are expected to unregister before the activity is done being destroyed; in fact if you do not do so, the framework will clean up your leaked registration as it removes the activity and log an error. Thus, if you use the Activity context to register a receiver that is static (global to the process, not associated with an Activity instance) then that registration will be removed on you at whatever point the activity you used is destroyed. If used from the Context returned here, the receiver is being registered with the global state associated with your application. Thus it will never be unregistered for you. This is necessary if the receiver is associated with static data, not a particular component. However using the ApplicationContext elsewhere can easily lead to serious leaks if you forget to unregister, unbind, etc.", "history": "Added in API level 1", "FullName": "public abstract Context getApplicationContext ()"}, "getSystemService(java.lang.Class<T>)": {"Returns": [["T", "The service or null if the class is not a supported system service. Note: never throw a @B_java#lang#RuntimeException_E@ if the name is not supported."]], "Parameters": [["@B_java#lang#Class_E@", "Class: The class of the desired service. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the handle to a system-level service by class. Currently available classes are: @B_android#view#WindowManager_E@, @B_android#view#LayoutInflater_E@, @B_android#app#ActivityManager_E@, @B_android#os#PowerManager_E@, @B_android#app#AlarmManager_E@, @B_android#app#NotificationManager_E@, @B_android#app#KeyguardManager_E@, @B_android#location#LocationManager_E@, @B_android#app#SearchManager_E@, @B_android#os#Vibrator_E@, @B_android#net#ConnectivityManager_E@, @B_android#net#wifi#WifiManager_E@, @B_android#media#AudioManager_E@, @B_android#media#MediaRouter_E@, @B_android#telephony#TelephonyManager_E@, @B_android#telephony#SubscriptionManager_E@, @B_android#view#inputmethod#InputMethodManager_E@, @B_android#app#UiModeManager_E@, @B_android#app#DownloadManager_E@, @B_android#os#BatteryManager_E@, @B_android#app#job#JobScheduler_E@, @B_android#app#usage#NetworkStatsManager_E@. Note: System services obtained via this API may be closely associated with the Context in which they are obtained from. In general, do not share the service objects between various different contexts (Activities, Applications, Services, Providers, etc.) Note: Instant apps, for which @B_android#content#pm#PackageManager#isInstantApp_E@ returns true, don't have access to the following system services: @B_android#content#Context#DEVICE_POLICY_SERVICE_E@, @B_android#content#Context#FINGERPRINT_SERVICE_E@, @B_android#content#Context#KEYGUARD_SERVICE_E@, @B_android#content#Context#SHORTCUT_SERVICE_E@, @B_android#content#Context#USB_SERVICE_E@, @B_android#content#Context#WALLPAPER_SERVICE_E@, @B_android#content#Context#WIFI_P2P_SERVICE_E@, @B_android#content#Context#WIFI_SERVICE_E@, @B_android#content#Context#WIFI_AWARE_SERVICE_E@. For these services this method will return null. Generally, if you are running as an instant app you should always check whether the result of this method is null.", "history": "Added in API level 23", "FullName": "public final T getSystemService (Class<T> serviceClass)"}, "checkCallingUriPermission(android.net.Uri, int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the caller is allowed to access that uri, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not.Value is PERMISSION_GRANTED or PERMISSION_DENIED."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The access modes to check.Value is either 0 or combination of FLAG_GRANT_READ_URI_PERMISSION or FLAG_GRANT_WRITE_URI_PERMISSION."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkUriPermission_E@"], "Permissions": [], "Description": "Determine whether the calling process and user ID has been granted permission to access a specific URI. This is basically the same as calling @B_android#content#Context#checkUriPermission_E@ with the pid and uid returned by @B_android#os#Binder#getCallingPid_E@ and @B_android#os#Binder#getCallingUid_E@. One important difference is that if you are not currently processing an IPC, this function will always fail.", "history": "added in API level 1", "FullName": "public abstract int checkCallingUriPermission (Uri uri, int modeFlags)"}, "getNoBackupFilesDir()": {"Returns": [["@B_java#io#File_E@", "The path of the directory holding application files that will not be automatically backed up to remote storage."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#openFileOutput_E@", "@B_android#content#Context#getFileStreamPath_E@", "@B_android#content#Context#getDir_E@", "@B_android#app#backup#BackupAgent_E@"], "Permissions": [], "Description": "Returns the absolute path to the directory on the filesystem similar to @B_android#content#Context#getFilesDir_E@. The difference is that files placed under this directory will be excluded from automatic backup to remote storage. See @B_android#app#backup#BackupAgent_E@ for a full discussion of the automatic backup mechanism in Android. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted. No additional permissions are required for the calling app to read or write files under the returned path.", "history": "Added in API level 21", "FullName": "public abstract File getNoBackupFilesDir ()"}, "getColorStateList(int)": {"Returns": [["@B_android#content#res#ColorStateList_E@", "A color state list. This value will never be null."]], "Parameters": [["int", "int: The desired resource identifier, as generated by the aapt tool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier."]], "Throws": [["@B_android#content#res#Resources#NotFoundException_E@", "if the given ID does not exist."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a color state list associated with a particular resource ID and styled for the current theme.", "history": "Added in API level 23", "FullName": "public final ColorStateList getColorStateList (int id)"}, "startForegroundService(android.content.Intent)": {"Returns": [["@B_android#content#ComponentName_E@", "If the service is being started or is already running, the @B_android#content#ComponentName_E@ of the actual service that was started is returned; else if the service does not exist null is returned."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: Identifies the service to be started. The Intent must be fully explicit (supplying a component name). Additional values may be included in the Intent extras to supply arguments along with this specific start call."]], "Throws": [["@B_java#lang#SecurityException_E@", "If the caller does not have permission to access the service or the service can not be found."]], "SeeAlso": ["@B_android#content#Context#stopService_E@", "@B_android#app#Service#startForeground_E@"], "Permissions": [], "Description": "Similar to @B_android#content#Context#startService_E@, but with an implicit promise that the Service will call @B_android#app#Service#startForeground_E@ once it begins running. The service is given an amount of time comparable to the ANR interval to do this, otherwise the system will automatically stop the service and declare the app ANR. Unlike the ordinary @B_android#content#Context#startService_E@, this method can be used at any time, regardless of whether the app hosting the service is in a foreground state.", "history": "Added in API level 26", "FullName": "public abstract ComponentName startForegroundService (Intent service)"}, "setTheme(int)": {"Returns": [], "Parameters": [["int", "int: The style resource describing the theme."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the base theme for this context. Note that this should be called before any views are instantiated in the Context (for example before calling @B_android#app#Activity#setContentView_E@ or @B_android#view#LayoutInflater#inflate_E@).", "history": "Added in API level 1", "FullName": "public abstract void setTheme (int resid)"}, "moveDatabaseFrom(android.content.Context,java.lang.String)": {"Returns": [["boolean", "true if the move was successful or if the database didn't exist in the source context, otherwise false."]], "Parameters": [["@B_android#content#Context_E@", "Context: The source context which contains the existing database to move."], ["@B_java#lang#String_E@", "String: The name of the database file."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#createDeviceProtectedStorageContext_E@"], "Permissions": [], "Description": "Move an existing database file from the given source storage context to this context. This is typically used to migrate data between storage locations after an upgrade, such as migrating to device protected storage. The database must be closed before being moved.", "history": "Added in API level 24", "FullName": "public abstract boolean moveDatabaseFrom (Context sourceContext, String name)"}, "checkCallingPermission(java.lang.String)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the calling pid/uid is allowed that permission, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the permission being checked. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#pm#PackageManager#checkPermission_E@", "@B_android#content#Context#checkPermission_E@", "@B_android#content#Context#checkCallingOrSelfPermission_E@"], "Permissions": [], "Description": "Determine whether the calling process of an IPC you are handling has been granted a particular permission. This is basically the same as calling @B_android#content#Context#checkPermission_E@ with the pid and uid returned by @B_android#os#Binder#getCallingPid_E@ and @B_android#os#Binder#getCallingUid_E@. One important difference is that if you are not currently processing an IPC, this function will always fail. This is done to protect against accidentally leaking permissions; you can use @B_android#content#Context#checkCallingOrSelfPermission_E@ to avoid this protection.", "history": "Added in API level 1", "FullName": "public abstract int checkCallingPermission (String permission)"}, "checkCallingOrSelfUriPermission(android.net.Uri,int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the caller is allowed to access that uri, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The access modes to check. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkCallingUriPermission_E@"], "Permissions": [], "Description": "Determine whether the calling process of an IPC or you has been granted permission to access a specific URI. This is the same as @B_android#content#Context#checkCallingUriPermission_E@, except it grants your own permissions if you are not currently processing an IPC. Use with care!", "history": "Added in API level 1", "FullName": "public abstract int checkCallingOrSelfUriPermission (Uri uri, int modeFlags)"}, "obtainStyledAttributes(android.util.AttributeSet,int[])": {"Returns": [["@B_android#content#res#TypedArray_E@", "This value will never be null."]], "Parameters": [["@B_android#util#AttributeSet_E@", "AttributeSet: This value may be null."], ["int[]", "int: This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#res#Resources#Theme#obtainStyledAttributes_E@"], "Permissions": [], "Description": "Retrieve styled attribute information in this Context's theme. See @B_android#content#res#Resources#Theme#obtainStyledAttributes_E@ for more information.", "history": "Added in API level 1", "FullName": "public final TypedArray obtainStyledAttributes (AttributeSet set, int[] attrs)"}, "revokeUriPermission(android.net.Uri,int)": {"Returns": [], "Parameters": [["@B_android#net#Uri_E@", "Uri: The Uri you would like to revoke access to."], ["int", "int: The access modes to revoke. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context#grantUriPermission_E@"], "Permissions": [], "Description": "Remove all permissions to access a particular content provider Uri that were previously added with @B_android#content#Context#grantUriPermission_E@ or any other mechanism. The given Uri will match all previously granted Uris that are the same or a sub-path of the given Uri. That is, revoking \"content://foo/target\" will revoke both \"content://foo/target\" and \"content://foo/target/sub\", but not \"content://foo\". It will not remove any prefix grants that exist at a higher level. Prior to @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@, if you did not have regular permission access to a Uri, but had received access to it through a specific Uri permission grant, you could not revoke that grant with this function and a @B_java#lang#SecurityException_E@ would be thrown. As of @B_android#os#Build#VERSION_CODES#LOLLIPOP_E@, this function will not throw a security exception, but will remove whatever permission grants to the Uri had been given to the app (or none). Unlike @B_android#content#Context#revokeUriPermission_E@, this method impacts all permission grants matching the given Uri, for any package they had been granted to, through any mechanism this had happened (such as indirectly through the clipboard, activity launch, service start, etc). That means this can be potentially dangerous to use, as it can revoke grants that another app could be strongly expecting to stick around.", "history": "Added in API level 1", "FullName": "public abstract void revokeUriPermission (Uri uri, int modeFlags)"}, "sendStickyOrderedBroadcast(android.content.Intent,android.content.BroadcastReceiver,android.os.Handler,int,java.lang.String,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast."], ["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: Your own BroadcastReceiver to treat as the final receiver of the broadcast."], ["@B_android#os#Handler_E@", "Handler: A custom Handler with which to schedule the resultReceiver callback; if null it will be scheduled in the Context's main thread. This value may be null."], ["int", "int: An initial value for the result code. Often Activity.RESULT_OK."], ["@B_java#lang#String_E@", "String: An initial value for the result data. Often null. This value may be null."], ["@B_android#os#Bundle_E@", "Bundle: An initial value for the result extras. Often null. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#sendOrderedBroadcast_E@", "@B_android#content#Context#sendStickyBroadcast_E@", "@B_android#content#BroadcastReceiver_E@", "@B_android#content#Context#registerReceiver_E@", "@B_android#app#Activity_E@"], "Permissions": ["@B_android#Manifest#permission#BROADCAST_STICKY_E@"], "Description": "Sticky broadcasts should not be used. They provide no security (anyone can access them), no protection (anyone can modify them), and many other problems. The recommended pattern is to use a non-sticky broadcast to report that something has changed, with another mechanism for apps to retrieve the current value whenever desired. Version of @B_android#content#Context#sendStickyBroadcast_E@ that allows you to receive data back from the broadcast. This is accomplished by supplying your own BroadcastReceiver when calling, which will be treated as a final receiver at the end of the broadcast -- its @B_android#content#BroadcastReceiver#onReceive_E@ method will be called with the result values collected from the other receivers. The broadcast will be serialized in the same way as calling @B_android#content#Context#sendOrderedBroadcast_E@. Like @B_android#content#Context#sendBroadcast_E@, this method is asynchronous; it will return before resultReceiver.onReceive() is called. Note that the sticky data stored is only the data you initially supply to the broadcast, not the result of any changes made by the receivers. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts. Requires @B_android#Manifest#permission#BROADCAST_STICKY_E@", "history": "Added in API level 5 Deprecated in API level 21", "FullName": "public abstract void sendStickyOrderedBroadcast (Intent intent, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)"}, "getPackageCodePath()": {"Returns": [["@B_java#lang#String_E@", "String Path to the code and assets."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the full path to this context's primary Android package. The Android package is a ZIP file which contains application's primary code and assets. Note: this is not generally useful for applications, since they should not be directly accessing the file system.", "history": "Added in API level 8", "FullName": "public abstract String getPackageCodePath ()"}, "createDisplayContext(android.view.Display)": {"Returns": [["@B_android#content#Context_E@", "A @B_android#content#Context_E@ for the display."]], "Parameters": [["@B_android#view#Display_E@", "Display: A @B_android#view#Display_E@ object specifying the display for whose metrics the Context's resources should be tailored and upon which new windows should be shown. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a new Context object for the current Context but whose resources are adjusted to match the metrics of the given Display. Each call to this method returns a new instance of a Context object; Context objects are not shared, however common state (ClassLoader, other Resources for the same configuration) may be so the Context itself can be fairly lightweight. The returned display Context provides a @B_android#view#WindowManager_E@ (see @B_android#content#Context#getSystemService_E@) that is configured to show windows on the given display. The WindowManager's @B_android#view#WindowManager#getDefaultDisplay_E@ method can be used to retrieve the Display from the returned Context.", "history": "Added in API level 17", "FullName": "public abstract Context createDisplayContext (Display display)"}, "Context()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public Context ()"}, "moveSharedPreferencesFrom(android.content.Context,java.lang.String)": {"Returns": [["boolean", "true if the move was successful or if the shared preferences didn't exist in the source context, otherwise false."]], "Parameters": [["@B_android#content#Context_E@", "Context: The source context which contains the existing shared preferences to move."], ["@B_java#lang#String_E@", "String: The name of the shared preferences file."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#createDeviceProtectedStorageContext_E@"], "Permissions": [], "Description": "Move an existing shared preferences file from the given source storage context to this context. This is typically used to migrate data between storage locations after an upgrade, such as moving to device protected storage.", "history": "Added in API level 24", "FullName": "public abstract boolean moveSharedPreferencesFrom (Context sourceContext, String name)"}, "getDir(java.lang.String, int)": {"Returns": [["@B_java#io#File_E@", "A @B_java#io#File_E@ object for the requested directory. The directory will have been created if it does not already exist."]], "Parameters": [["@B_java#lang#String_E@", "String: Name of the directory to retrieve. This is a directory that is created as part of your application data."], ["int", "int: Operating mode.Value is either 0 or combination of MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE or MODE_APPEND."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#openFileOutput_E@"], "Permissions": [], "Description": "Retrieve, creating if needed, a new directory in which the application can place its own custom data files. You can use the returned File object to create and access files in this directory. Note that files created through a File object will only be accessible by your own application; you can only set the mode of the entire directory, not of individual files. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted. Apps require no extra permissions to read or write to the returned path, since this path lives in their private storage.", "history": "added in API level 1", "FullName": "public abstract File getDir (String name, int mode)"}, "startService(android.content.Intent)": {"Returns": [["@B_android#content#ComponentName_E@", "If the service is being started or is already running, the @B_android#content#ComponentName_E@ of the actual service that was started is returned; else if the service does not exist null is returned."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: Identifies the service to be started. The Intent must be fully explicit (supplying a component name). Additional values may be included in the Intent extras to supply arguments along with this specific start call."]], "Throws": [["@B_java#lang#SecurityException_E@", "If the caller does not have permission to access the service or the service can not be found."], ["@B_java#lang#IllegalStateException_E@", "If the application is in a state where the service can not be started (such as not in the foreground in a state when services are allowed)."]], "SeeAlso": ["@B_android#content#Context#stopService_E@", "@B_android#content#Context#bindService_E@"], "Permissions": [], "Description": "Request that a given application service be started. The Intent should either contain the complete class name of a specific service implementation to start, or a specific package name to target. If the Intent is less specified, it logs a warning about this. In this case any of the multiple matching services may be used. If this service is not already running, it will be instantiated and started (creating a process for it if needed); if it is running then it remains running. Every call to this method will result in a corresponding call to the target service's @B_android#app#Service#onStartCommand_E@ method, with the Using startService() overrides the default service lifetime that is managed by @B_android#content#Context#bindService_E@: it requires the service to remain running until @B_android#content#Context#stopService_E@ is called, regardless of whether any clients are connected to it. Note that calls to startService() do not nest: no matter how many times you call startService(), a single call to @B_android#content#Context#stopService_E@ will stop it. The system attempts to keep running services around as much as possible. The only time they should be stopped is if the current foreground application is using so many resources that the service needs to be killed. If any errors happen in the service's process, it will automatically be restarted. This function will throw @B_java#lang#SecurityException_E@ if you do not have permission to start the given service. @B_android#content#Context#bindService_E@ for high frequency calls.", "history": "Added in API level 1", "FullName": "public abstract ComponentName startService (Intent service)"}, "getOpPackageName()": {"Returns": [["@B_java#lang#String_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the package name that should be used for @B_android#app#AppOpsManager_E@ calls from this context, so that app ops manager's uid verification will work with the name. This is not generally intended for third party application developers.", "history": "Added in API level 29", "FullName": "public String getOpPackageName ()"}, "stopService(android.content.Intent)": {"Returns": [["boolean", "If there is a service matching the given Intent that is already running, then it is stopped and true is returned; else false is returned."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: Description of the service to be stopped. The Intent must be either fully explicit (supplying a component name) or specify a specific package name it is targeted to."]], "Throws": [["@B_java#lang#SecurityException_E@", "If the caller does not have permission to access the service or the service can not be found."], ["@B_java#lang#IllegalStateException_E@", "If the application is in a state where the service can not be started (such as not in the foreground in a state when services are allowed)."]], "SeeAlso": ["@B_android#content#Context#startService_E@"], "Permissions": [], "Description": "Request that a given application service be stopped. If the service is not running, nothing happens. Otherwise it is stopped. Note that calls to startService() are not counted -- this stops the service no matter how many times it was started. Note that if a stopped service still has @B_android#content#ServiceConnection_E@ objects bound to it with the @B_android#content#Context#BIND_AUTO_CREATE_E@ set, it will not be destroyed until all of these bindings are removed. See the @B_android#app#Service_E@ documentation for more details on a service's lifecycle. This function will throw @B_java#lang#SecurityException_E@ if you do not have permission to stop the given service.", "history": "Added in API level 1", "FullName": "public abstract boolean stopService (Intent service)"}, "openFileOutput(java.lang.String, int)": {"Returns": [["@B_java#io#FileOutputStream_E@", "The resulting @B_java#io#FileOutputStream_E@."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the file to open; can not contain path separators."], ["int", "int: Operating mode.Value is either 0 or combination of MODE_PRIVATE, MODE_WORLD_READABLE, MODE_WORLD_WRITEABLE or MODE_APPEND."]], "Throws": [["@B_java#io#FileNotFoundException_E@", ""]], "SeeAlso": ["@B_android#content#Context_E@", "@B_android#content#Context#openFileInput_E@", "@B_android#content#Context#fileList_E@", "@B_android#content#Context#deleteFile_E@", "@B_java#io#FileOutputStream#FileOutputStream_E@"], "Permissions": [], "Description": "Open a private file associated with this Context's application package for writing. Creates the file if it doesn't already exist. No additional permissions are required for the calling app to read or write the returned file.", "history": "added in API level 1", "FullName": "public abstract FileOutputStream openFileOutput (String name, int mode)"}, "openOrCreateDatabase(java.lang.String,int,android.database.sqlite.SQLiteDatabase.CursorFactory,android.database.DatabaseErrorHandler)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "The contents of a newly created database with the given name."]], "Parameters": [["@B_java#lang#String_E@", "String: The name (unique in the application package) of the database."], ["int", "int: Operating mode. Value is either 0 or a combination of @B_android#content#Context#MODE_PRIVATE_E@, @B_android#content#Context#MODE_WORLD_READABLE_E@, @B_android#content#Context#MODE_WORLD_WRITEABLE_E@, @B_android#content#Context#MODE_ENABLE_WRITE_AHEAD_LOGGING_E@, and @B_android#content#Context#MODE_NO_LOCALIZED_COLLATORS_E@"], ["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: An optional factory class that is called to instantiate a cursor when query is called."], ["@B_android#database#DatabaseErrorHandler_E@", "DatabaseErrorHandler: the @B_android#database#DatabaseErrorHandler_E@ to be used when sqlite reports database corruption. if null, @B_android#database#DefaultDatabaseErrorHandler_E@ is assumed. This value may be null."]], "Throws": [["@B_android#database#sqlite#SQLiteException_E@", "if the database file could not be opened."]], "SeeAlso": ["@B_android#content#Context_E@", "@B_android#content#Context#deleteDatabase_E@"], "Permissions": [], "Description": "Open a new private SQLiteDatabase associated with this Context's application package. Creates the database file if it doesn't exist. Accepts input param: a concrete instance of @B_android#database#DatabaseErrorHandler_E@ to be used to handle corruption when sqlite reports database corruption.", "history": "Added in API level 11", "FullName": "public abstract SQLiteDatabase openOrCreateDatabase (String name, int mode, SQLiteDatabase.CursorFactory factory, DatabaseErrorHandler errorHandler)"}, "getPackageResourcePath()": {"Returns": [["@B_java#lang#String_E@", "String Path to the resources."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the full path to this context's primary Android package. The Android package is a ZIP file which contains the application's primary resources. Note: this is not generally useful for applications, since they should not be directly accessing the file system.", "history": "Added in API level 8", "FullName": "public abstract String getPackageResourcePath ()"}, "getCodeCacheDir()": {"Returns": [["@B_java#io#File_E@", "The path of the directory holding application code cache files."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the absolute path to the application specific cache directory on the filesystem designed for storing cached code. The system will delete any files stored in this location both when your specific application is upgraded, and when the entire platform is upgraded. This location is optimal for storing compiled or optimized code generated by your application at runtime. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted. Apps require no extra permissions to read or write to the returned path, since this path lives in their private storage.", "history": "Added in API level 21", "FullName": "public abstract File getCodeCacheDir ()"}, "updateServiceGroup(android.content.ServiceConnection,int,int)": {"Returns": [], "Parameters": [["@B_android#content#ServiceConnection_E@", "ServiceConnection: The connection interface previously supplied to bindService(). This parameter must not be null. This value must never be null."], ["int", "int: A group to put this connection's process in. Upon calling here, this will override any previous group that was set for that process. The group tells the system about processes that are logically grouped together, so should be managed as one unit of importance (such as when being considered a recently used app). All processes in the same app with the same group are considered to be related. Supplying 0 reverts to the default behavior of not grouping."], ["int", "int: Additional importance of the processes within a group. Upon calling here, this will override any previous importance that was set for that process. The most important process is 0, and higher values are successively less important. You can view this as describing how to order the processes in an array, with the processes at the end of the array being the least important. This value has no meaning besides indicating how processes should be ordered in that array one after the other. This provides a way to fine-tune the system's process killing, guiding it to kill processes at the end of the array first."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#bindIsolatedService_E@"], "Permissions": [], "Description": "For a service previously bound with @B_android#content#Context#bindService_E@ or a related method, change how the system manages that service's process in relation to other processes. This doesn't modify the original bind flags that were passed in when binding, but adjusts how the process will be managed in some cases based on those flags. Currently only works on isolated processes (will be ignored for non-isolated processes). Note that this call does not take immediate effect, but will be applied the next time the impacted process is adjusted for some other reason. Typically you would call this before then calling a new @B_android#content#Context#bindIsolatedService_E@ on the service of interest, with that binding causing the process to be shuffled accordingly.", "history": "Added in API level 29", "FullName": "public void updateServiceGroup (ServiceConnection conn, int group, int importance)"}, "bindIsolatedService(android.content.Intent,int,java.lang.String,java.util.concurrent.Executor,android.content.ServiceConnection)": {"Returns": [["boolean", "Returns success of binding as per @B_android#content#Context#bindService_E@."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: Identifies the service to connect to. The Intent must specify an explicit component name. This value must never be null."], ["int", "int: Operation options for the binding as per @B_android#content#Context#bindService_E@. Value is either 0 or a combination of @B_android#content#Context#BIND_AUTO_CREATE_E@, @B_android#content#Context#BIND_DEBUG_UNBIND_E@, @B_android#content#Context#BIND_NOT_FOREGROUND_E@, @B_android#content#Context#BIND_ABOVE_CLIENT_E@, @B_android#content#Context#BIND_ALLOW_OOM_MANAGEMENT_E@, @B_android#content#Context#BIND_WAIVE_PRIORITY_E@, @B_android#content#Context#BIND_IMPORTANT_E@, @B_android#content#Context#BIND_ADJUST_WITH_ACTIVITY_E@, @B_android#content#Context#BIND_NOT_PERCEPTIBLE_E@, and @B_android#content#Context#BIND_INCLUDE_CAPABILITIES_E@"], ["@B_java#lang#String_E@", "String: Unique identifier for the service instance. Each unique name here will result in a different service instance being created. Identifiers must only contain ASCII letters, digits, underscores, and periods. This value must never be null."], ["@B_java#util#concurrent#Executor_E@", "Executor: Callbacks on ServiceConnection will be called on executor. Must use same instance for the same instance of ServiceConnection. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#content#ServiceConnection_E@", "ServiceConnection: Receives information as the service is started and stopped. This must be a valid ServiceConnection object; it must not be null. This value must never be null."]], "Throws": [["@B_java#lang#SecurityException_E@", "If the caller does not have permission to access the service"], ["@B_java#lang#IllegalArgumentException_E@", "If the instanceName is invalid."]], "SeeAlso": ["@B_android#content#Context#bindService_E@", "@B_android#content#Context#updateServiceGroup_E@", "@B_android#R#attr#isolatedProcess_E@"], "Permissions": [], "Description": "Variation of @B_android#content#Context#bindService_E@ that, in the specific case of isolated services, allows the caller to generate multiple instances of a service from a single component declaration. In other words, you can use this to bind to a service that has specified @B_android#R#attr#isolatedProcess_E@ and, in addition to the existing behavior of running in an isolated process, you can also through the arguments here have the system bring up multiple concurrent processes hosting their own instances of that service. The @B_android#content#Context#updateServiceGroup_E@ to tell the system how it should manage each of these instances.", "history": "Added in API level 29", "FullName": "public boolean bindIsolatedService (Intent service, int flags, String instanceName, Executor executor, ServiceConnection conn)"}, "startIntentSender(android.content.IntentSender,android.content.Intent,int,int,int,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#IntentSender_E@", "IntentSender: The IntentSender to launch."], ["@B_android#content#Intent_E@", "Intent: If non-null, this will be provided as the intent parameter to @B_android#content#IntentSender#sendIntent_E@. This value may be null."], ["int", "int: Intent flags in the original IntentSender that you would like to change. Value is either 0 or a combination of @B_android#content#Intent#FLAG_FROM_BACKGROUND_E@, @B_android#content#Intent#FLAG_DEBUG_LOG_RESOLUTION_E@, @B_android#content#Intent#FLAG_EXCLUDE_STOPPED_PACKAGES_E@, @B_android#content#Intent#FLAG_INCLUDE_STOPPED_PACKAGES_E@, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, @B_android#content#Intent#FLAG_ACTIVITY_MATCH_EXTERNAL_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_HISTORY_E@, @B_android#content#Intent#FLAG_ACTIVITY_SINGLE_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_MULTIPLE_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_FORWARD_RESULT_E@, @B_android#content#Intent#FLAG_ACTIVITY_PREVIOUS_IS_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS_E@, @B_android#content#Intent#FLAG_ACTIVITY_BROUGHT_TO_FRONT_E@, @B_android#content#Intent#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED_E@, @B_android#content#Intent#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET_E@, @B_android#content#Intent#FLAG_ACTIVITY_NEW_DOCUMENT_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_USER_ACTION_E@, @B_android#content#Intent#FLAG_ACTIVITY_REORDER_TO_FRONT_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_ANIMATION_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_TASK_ON_HOME_E@, @B_android#content#Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS_E@, @B_android#content#Intent#FLAG_ACTIVITY_LAUNCH_ADJACENT_E@, @B_android#content#Intent#FLAG_RECEIVER_REGISTERED_ONLY_E@, @B_android#content#Intent#FLAG_RECEIVER_REPLACE_PENDING_E@, @B_android#content#Intent#FLAG_RECEIVER_FOREGROUND_E@, @B_android#content#Intent#FLAG_RECEIVER_NO_ABORT_E@, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, @B_android#content#Intent#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS_E@, and android.content.Intent.FLAG_RECEIVER_OFFLOAD"], ["int", "int: Desired values for any bits set in flagsMask Value is either 0 or a combination of @B_android#content#Intent#FLAG_FROM_BACKGROUND_E@, @B_android#content#Intent#FLAG_DEBUG_LOG_RESOLUTION_E@, @B_android#content#Intent#FLAG_EXCLUDE_STOPPED_PACKAGES_E@, @B_android#content#Intent#FLAG_INCLUDE_STOPPED_PACKAGES_E@, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, @B_android#content#Intent#FLAG_ACTIVITY_MATCH_EXTERNAL_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_HISTORY_E@, @B_android#content#Intent#FLAG_ACTIVITY_SINGLE_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_MULTIPLE_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_FORWARD_RESULT_E@, @B_android#content#Intent#FLAG_ACTIVITY_PREVIOUS_IS_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS_E@, @B_android#content#Intent#FLAG_ACTIVITY_BROUGHT_TO_FRONT_E@, @B_android#content#Intent#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED_E@, @B_android#content#Intent#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET_E@, @B_android#content#Intent#FLAG_ACTIVITY_NEW_DOCUMENT_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_USER_ACTION_E@, @B_android#content#Intent#FLAG_ACTIVITY_REORDER_TO_FRONT_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_ANIMATION_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_TASK_ON_HOME_E@, @B_android#content#Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS_E@, @B_android#content#Intent#FLAG_ACTIVITY_LAUNCH_ADJACENT_E@, @B_android#content#Intent#FLAG_RECEIVER_REGISTERED_ONLY_E@, @B_android#content#Intent#FLAG_RECEIVER_REPLACE_PENDING_E@, @B_android#content#Intent#FLAG_RECEIVER_FOREGROUND_E@, @B_android#content#Intent#FLAG_RECEIVER_NO_ABORT_E@, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, @B_android#content#Intent#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS_E@, and android.content.Intent.FLAG_RECEIVER_OFFLOAD"], ["int", "int: Always set to 0."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. See @B_android#content#Context#startActivity_E@ Context.startActivity(Intent, Bundle)} for more details. If options have also been supplied by the IntentSender, options given here will override any that conflict with those given by the IntentSender. This value may be null."]], "Throws": [["@B_android#content#IntentSender#SendIntentException_E@", ""]], "SeeAlso": ["@B_android#content#Context#startActivity_E@", "@B_android#content#Context#startIntentSender_E@"], "Permissions": [], "Description": "Like @B_android#content#Context#startActivity_E@, but taking a IntentSender to start. If the IntentSender is for an activity, that activity will be started as if you had called the regular @B_android#content#Context#startActivity_E@ here; otherwise, its associated action will be executed (such as sending a broadcast) as if you had called @B_android#content#IntentSender#sendIntent_E@ on it.", "history": "Added in API level 16", "FullName": "public abstract void startIntentSender (IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags, Bundle options)"}, "checkCallingUriPermission(android.net.Uri,int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the caller is allowed to access that uri, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The access modes to check. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkUriPermission_E@"], "Permissions": [], "Description": "Determine whether the calling process and user ID has been granted permission to access a specific URI. This is basically the same as calling @B_android#content#Context#checkUriPermission_E@ with the pid and uid returned by @B_android#os#Binder#getCallingPid_E@ and @B_android#os#Binder#getCallingUid_E@. One important difference is that if you are not currently processing an IPC, this function will always fail.", "history": "Added in API level 1", "FullName": "public abstract int checkCallingUriPermission (Uri uri, int modeFlags)"}, "getResources()": {"Returns": [["@B_android#content#res#Resources_E@", "a Resources instance for the application's package"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#getAssets_E@"], "Permissions": [], "Description": "Returns a Resources instance for the application's package. @B_android#content#Context#getAssets_E@. For example, they should share the same @B_android#content#res#Configuration_E@ object.", "history": "Added in API level 1", "FullName": "public abstract Resources getResources ()"}, "enforceCallingUriPermission(android.net.Uri,int,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The access modes to enforce. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"], ["@B_java#lang#String_E@", "String: A message to include in the exception if it is thrown."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkCallingUriPermission_E@"], "Permissions": [], "Description": "If the calling process and user ID has not been granted permission to access a specific URI, throw @B_java#lang#SecurityException_E@. This is basically the same as calling @B_android#content#Context#enforceUriPermission_E@ with the pid and uid returned by @B_android#os#Binder#getCallingPid_E@ and @B_android#os#Binder#getCallingUid_E@. One important difference is that if you are not currently processing an IPC, this function will always throw a SecurityException.", "history": "Added in API level 1", "FullName": "public abstract void enforceCallingUriPermission (Uri uri, int modeFlags, String message)"}, "createConfigurationContext(android.content.res.Configuration)": {"Returns": [["@B_android#content#Context_E@", "A @B_android#content#Context_E@ with the given configuration override."]], "Parameters": [["@B_android#content#res#Configuration_E@", "Configuration: A @B_android#content#res#Configuration_E@ specifying what values to modify in the base Configuration of the original Context's resources. If the base configuration changes (such as due to an orientation change), the resources of this context will also change except for those that have been explicitly overridden with a value here. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a new Context object for the current Context but whose resources are adjusted to match the given Configuration. Each call to this method returns a new instance of a Context object; Context objects are not shared, however common state (ClassLoader, other Resources for the same configuration) may be so the Context itself can be fairly lightweight.", "history": "Added in API level 17", "FullName": "public abstract Context createConfigurationContext (Configuration overrideConfiguration)"}, "createDeviceProtectedStorageContext()": {"Returns": [["@B_android#content#Context_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#isDeviceProtectedStorage_E@"], "Permissions": [], "Description": "Return a new Context object for the current Context but whose storage APIs are backed by device-protected storage. On devices with direct boot, data stored in this location is encrypted with a key tied to the physical device, and it can be accessed immediately after the device has booted successfully, both before and after the user has authenticated with their credentials (such as a lock pattern or PIN). Because device-protected data is available without user authentication, you should carefully limit the data you store using this Context. For example, storing sensitive authentication tokens or passwords in the device-protected area is strongly discouraged. If the underlying device does not have the ability to store device-protected and credential-protected data using different keys, then both storage areas will become available at the same time. They remain as two distinct storage locations on disk, and only the window of availability changes. Each call to this method returns a new instance of a Context object; Context objects are not shared, however common state (ClassLoader, other Resources for the same configuration) may be so the Context itself can be fairly lightweight.", "history": "Added in API level 24", "FullName": "public abstract Context createDeviceProtectedStorageContext ()"}, "openFileOutput(java.lang.String,int)": {"Returns": [["@B_java#io#FileOutputStream_E@", "The resulting @B_java#io#FileOutputStream_E@."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the file to open; can not contain path separators."], ["int", "int: Operating mode. Value is either 0 or a combination of @B_android#content#Context#MODE_PRIVATE_E@, @B_android#content#Context#MODE_WORLD_READABLE_E@, @B_android#content#Context#MODE_WORLD_WRITEABLE_E@, and @B_android#content#Context#MODE_APPEND_E@"]], "Throws": [["@B_java#io#FileNotFoundException_E@", ""]], "SeeAlso": ["@B_android#content#Context_E@", "@B_android#content#Context#openFileInput_E@", "@B_android#content#Context#fileList_E@", "@B_android#content#Context#deleteFile_E@", "@B_java#io#FileOutputStream#FileOutputStream_E@"], "Permissions": [], "Description": "Open a private file associated with this Context's application package for writing. Creates the file if it doesn't already exist. No additional permissions are required for the calling app to read or write the returned file.", "history": "Added in API level 1", "FullName": "public abstract FileOutputStream openFileOutput (String name, int mode)"}, "getPackageManager()": {"Returns": [["@B_android#content#pm#PackageManager_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return PackageManager instance to find global package information.", "history": "Added in API level 1", "FullName": "public abstract PackageManager getPackageManager ()"}, "checkPermission(java.lang.String,int,int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the given pid/uid is allowed that permission, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the permission being checked. This value must never be null."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."]], "Throws": [], "SeeAlso": ["@B_android#content#pm#PackageManager#checkPermission_E@", "@B_android#content#Context#checkCallingPermission_E@"], "Permissions": [], "Description": "Determine whether the given permission is allowed for a particular process and user ID running in the system.", "history": "Added in API level 1", "FullName": "public abstract int checkPermission (String permission, int pid, int uid)"}, "unbindService(android.content.ServiceConnection)": {"Returns": [], "Parameters": [["@B_android#content#ServiceConnection_E@", "ServiceConnection: The connection interface previously supplied to bindService(). This parameter must not be null. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#bindService_E@"], "Permissions": [], "Description": "Disconnect from an application service. You will no longer receive calls as the service is restarted, and the service is now allowed to stop at any time.", "history": "Added in API level 1", "FullName": "public abstract void unbindService (ServiceConnection conn)"}, "startActivity(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The description of the activity to start."]], "Throws": [["@B_android#content#ActivityNotFoundException_E@", "`"]], "SeeAlso": ["@B_android#content#Context#startActivity_E@", "@B_android#content#pm#PackageManager#resolveActivity_E@"], "Permissions": [], "Description": "Same as @B_android#content#Context#startActivity_E@ with no options specified.", "history": "Added in API level 1", "FullName": "public abstract void startActivity (Intent intent)"}, "checkUriPermission(android.net.Uri,java.lang.String,java.lang.String,int,int,int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the caller is allowed to access that uri or holds one of the given permissions, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The Uri whose permission is to be checked, or null to not do this check. This value may be null."], ["@B_java#lang#String_E@", "String: The permission that provides overall read access, or null to not do this check. This value may be null."], ["@B_java#lang#String_E@", "String: The permission that provides overall write access, or null to not do this check. This value may be null."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."], ["int", "int: The access modes to check. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check both a Uri and normal permission. This allows you to perform both @B_android#content#Context#checkPermission_E@ and @B_android#content#Context#checkUriPermission_E@ in one call.", "history": "Added in API level 1", "FullName": "public abstract int checkUriPermission (Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags)"}, "bindService(android.content.Intent,android.content.ServiceConnection,int)": {"Returns": [["boolean", "true if the system is in the process of bringing up a service that your client has permission to bind to; false if the system couldn't find the service or if your client doesn't have permission to bind to it. If this value is true, you should later call @B_android#content#Context#unbindService_E@ to release the connection."]], "Parameters": [["@B_android#content#Intent_E@", "Intent: Identifies the service to connect to. The Intent must specify an explicit component name."], ["@B_android#content#ServiceConnection_E@", "ServiceConnection: Receives information as the service is started and stopped. This must be a valid ServiceConnection object; it must not be null. This value must never be null."], ["int", "int: Operation options for the binding. May be 0, @B_android#content#Context#BIND_AUTO_CREATE_E@, @B_android#content#Context#BIND_DEBUG_UNBIND_E@, @B_android#content#Context#BIND_NOT_FOREGROUND_E@, @B_android#content#Context#BIND_ABOVE_CLIENT_E@, @B_android#content#Context#BIND_ALLOW_OOM_MANAGEMENT_E@, @B_android#content#Context#BIND_WAIVE_PRIORITY_E@. @B_android#content#Context#BIND_IMPORTANT_E@, or @B_android#content#Context#BIND_ADJUST_WITH_ACTIVITY_E@. Value is either 0 or a combination of @B_android#content#Context#BIND_AUTO_CREATE_E@, @B_android#content#Context#BIND_DEBUG_UNBIND_E@, @B_android#content#Context#BIND_NOT_FOREGROUND_E@, @B_android#content#Context#BIND_ABOVE_CLIENT_E@, @B_android#content#Context#BIND_ALLOW_OOM_MANAGEMENT_E@, @B_android#content#Context#BIND_WAIVE_PRIORITY_E@, @B_android#content#Context#BIND_IMPORTANT_E@, @B_android#content#Context#BIND_ADJUST_WITH_ACTIVITY_E@, @B_android#content#Context#BIND_NOT_PERCEPTIBLE_E@, and @B_android#content#Context#BIND_INCLUDE_CAPABILITIES_E@"]], "Throws": [["@B_java#lang#SecurityException_E@", "If the caller does not have permission to access the service or the service can not be found."]], "SeeAlso": ["@B_android#content#Context#unbindService_E@", "@B_android#content#Context#startService_E@", "@B_android#content#Context_E@"], "Permissions": [], "Description": "Connect to an application service, creating it if needed. This defines a dependency between your application and the service. The given If the service does not support binding, it may return null from its @B_android#app#Service#onBind_E@ method. If it does, then the ServiceConnection's @B_android#content#ServiceConnection#onNullBinding_E@ method will be invoked instead of @B_android#content#ServiceConnection#onServiceConnected_E@. This method will throw @B_java#lang#SecurityException_E@ if the calling app does not have permission to bind to the given service. Note: this method cannot be called from a @B_android#content#BroadcastReceiver_E@ component. A pattern you can use to communicate from a BroadcastReceiver to a Service is to call @B_android#content#Context#startService_E@ with the arguments containing the command to be sent, with the service calling its @B_android#app#Service#stopSelf_E@ method when done executing that command. See the API demo App/Service/Service Start Arguments Controller for an illustration of this. It is okay, however, to use this method from a BroadcastReceiver that has been registered with @B_android#content#Context#registerReceiver_E@, since the lifetime of this BroadcastReceiver is tied to another object (the one that registered it).", "history": "Added in API level 1", "FullName": "public abstract boolean bindService (Intent service, ServiceConnection conn, int flags)"}, "getDatabasePath(java.lang.String)": {"Returns": [["@B_java#io#File_E@", "An absolute path to the given database."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the database for which you would like to get its path."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#openOrCreateDatabase_E@"], "Permissions": [], "Description": "Returns the absolute path on the filesystem where a database created with @B_android#content#Context#openOrCreateDatabase_E@ is stored. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted.", "history": "Added in API level 1", "FullName": "public abstract File getDatabasePath (String name)"}, "createContextForSplit(java.lang.String)": {"Returns": [["@B_android#content#Context_E@", "A @B_android#content#Context_E@ with the given split's code and/or resources loaded."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the split to include, as declared in the split's AndroidManifest.xml."]], "Throws": [["@B_android#content#pm#PackageManager#NameNotFoundException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Return a new Context object for the given split name. The new Context has a ClassLoader and Resources object that can access the split's and all of its dependencies' code/resources. Each call to this method returns a new instance of a Context object; Context objects are not shared, however common state (ClassLoader, other Resources for the same split) may be so the Context itself can be fairly lightweight.", "history": "Added in API level 26", "FullName": "public abstract Context createContextForSplit (String splitName)"}, "getClassLoader()": {"Returns": [["@B_java#lang#ClassLoader_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a class loader you can use to retrieve classes in this package.", "history": "Added in API level 1", "FullName": "public abstract ClassLoader getClassLoader ()"}, "getSystemService(java.lang.String)": {"Returns": [["@B_java#lang#Object_E@", "The service or null if the name does not exist."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the desired service. Value is @B_android#content#Context#POWER_SERVICE_E@, @B_android#content#Context#WINDOW_SERVICE_E@, @B_android#content#Context#LAYOUT_INFLATER_SERVICE_E@, @B_android#content#Context#ACCOUNT_SERVICE_E@, @B_android#content#Context#ACTIVITY_SERVICE_E@, @B_android#content#Context#ALARM_SERVICE_E@, @B_android#content#Context#NOTIFICATION_SERVICE_E@, @B_android#content#Context#ACCESSIBILITY_SERVICE_E@, @B_android#content#Context#CAPTIONING_SERVICE_E@, @B_android#content#Context#KEYGUARD_SERVICE_E@, @B_android#content#Context#LOCATION_SERVICE_E@, @B_android#content#Context#SEARCH_SERVICE_E@, @B_android#content#Context#SENSOR_SERVICE_E@, android.content.Context.SENSOR_PRIVACY_SERVICE, @B_android#content#Context#STORAGE_SERVICE_E@, @B_android#content#Context#STORAGE_STATS_SERVICE_E@, @B_android#content#Context#WALLPAPER_SERVICE_E@, android.content.Context.TIME_ZONE_RULES_MANAGER_SERVICE, @B_android#content#Context#VIBRATOR_SERVICE_E@, @B_android#content#Context#CONNECTIVITY_SERVICE_E@, @B_android#content#Context#IPSEC_SERVICE_E@, android.content.Context.TEST_NETWORK_SERVICE, @B_android#content#Context#NETWORK_STATS_SERVICE_E@, @B_android#content#Context#WIFI_SERVICE_E@, @B_android#content#Context#WIFI_AWARE_SERVICE_E@, @B_android#content#Context#WIFI_P2P_SERVICE_E@, android.content.Context.WIFI_SCANNING_SERVICE, @B_android#content#Context#WIFI_RTT_RANGING_SERVICE_E@, @B_android#content#Context#NSD_SERVICE_E@, @B_android#content#Context#AUDIO_SERVICE_E@, @B_android#content#Context#FINGERPRINT_SERVICE_E@, @B_android#content#Context#BIOMETRIC_SERVICE_E@, @B_android#content#Context#MEDIA_ROUTER_SERVICE_E@, @B_android#content#Context#TELEPHONY_SERVICE_E@, @B_android#content#Context#TELEPHONY_SUBSCRIPTION_SERVICE_E@, @B_android#content#Context#CARRIER_CONFIG_SERVICE_E@, @B_android#content#Context#TELECOM_SERVICE_E@, @B_android#content#Context#CLIPBOARD_SERVICE_E@, @B_android#content#Context#INPUT_METHOD_SERVICE_E@, @B_android#content#Context#TEXT_SERVICES_MANAGER_SERVICE_E@, @B_android#content#Context#TEXT_CLASSIFICATION_SERVICE_E@, @B_android#content#Context#APPWIDGET_SERVICE_E@, android.content.Context.ROLLBACK_SERVICE, @B_android#content#Context#DROPBOX_SERVICE_E@, @B_android#content#Context#DEVICE_POLICY_SERVICE_E@, @B_android#content#Context#UI_MODE_SERVICE_E@, @B_android#content#Context#DOWNLOAD_SERVICE_E@, @B_android#content#Context#NFC_SERVICE_E@, @B_android#content#Context#BLUETOOTH_SERVICE_E@, @B_android#content#Context#USB_SERVICE_E@, @B_android#content#Context#LAUNCHER_APPS_SERVICE_E@, @B_android#content#Context#INPUT_SERVICE_E@, @B_android#content#Context#DISPLAY_SERVICE_E@, @B_android#content#Context#USER_SERVICE_E@, @B_android#content#Context#RESTRICTIONS_SERVICE_E@, @B_android#content#Context#APP_OPS_SERVICE_E@, @B_android#content#Context#ROLE_SERVICE_E@, @B_android#content#Context#CAMERA_SERVICE_E@, @B_android#content#Context#PRINT_SERVICE_E@, @B_android#content#Context#CONSUMER_IR_SERVICE_E@, @B_android#content#Context#TV_INPUT_SERVICE_E@, @B_android#content#Context#USAGE_STATS_SERVICE_E@, @B_android#content#Context#MEDIA_SESSION_SERVICE_E@, @B_android#content#Context#BATTERY_SERVICE_E@, @B_android#content#Context#JOB_SCHEDULER_SERVICE_E@, @B_android#content#Context#MEDIA_PROJECTION_SERVICE_E@, @B_android#content#Context#MIDI_SERVICE_E@, android.content.Context.RADIO_SERVICE, @B_android#content#Context#HARDWARE_PROPERTIES_SERVICE_E@, @B_android#content#Context#SHORTCUT_SERVICE_E@, @B_android#content#Context#SYSTEM_HEALTH_SERVICE_E@, @B_android#content#Context#COMPANION_DEVICE_SERVICE_E@, @B_android#content#Context#CROSS_PROFILE_APPS_SERVICE_E@, or android.content.Context.PERMISSION_SERVICE This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context_E@", "@B_android#view#WindowManager_E@", "@B_android#view#LayoutInflater_E@", "@B_android#app#ActivityManager_E@", "@B_android#os#PowerManager_E@", "@B_android#app#AlarmManager_E@", "@B_android#app#NotificationManager_E@", "@B_android#app#KeyguardManager_E@", "@B_android#location#LocationManager_E@", "@B_android#app#SearchManager_E@", "@B_android#hardware#SensorManager_E@", "@B_android#os#storage#StorageManager_E@", "@B_android#os#Vibrator_E@", "@B_android#net#ConnectivityManager_E@", "@B_android#net#wifi#WifiManager_E@", "@B_android#media#AudioManager_E@", "@B_android#media#MediaRouter_E@", "@B_android#telephony#TelephonyManager_E@", "@B_android#telephony#SubscriptionManager_E@", "@B_android#telephony#CarrierConfigManager_E@", "@B_android#view#inputmethod#InputMethodManager_E@", "@B_android#app#UiModeManager_E@", "@B_android#app#DownloadManager_E@", "@B_android#os#BatteryManager_E@", "@B_android#app#job#JobScheduler_E@", "@B_android#app#usage#NetworkStatsManager_E@", "@B_android#os#HardwarePropertiesManager_E@"], "Permissions": [], "Description": "Return the handle to a system-level service by name. The class of the returned object varies by the requested name. Currently available names are: Note: System services obtained via this API may be closely associated with the Context in which they are obtained from. In general, do not share the service objects between various different contexts (Activities, Applications, Services, Providers, etc.) Note: Instant apps, for which @B_android#content#pm#PackageManager#isInstantApp_E@ returns true, don't have access to the following system services: @B_android#content#Context#DEVICE_POLICY_SERVICE_E@, @B_android#content#Context#FINGERPRINT_SERVICE_E@, @B_android#content#Context#KEYGUARD_SERVICE_E@, @B_android#content#Context#SHORTCUT_SERVICE_E@, @B_android#content#Context#USB_SERVICE_E@, @B_android#content#Context#WALLPAPER_SERVICE_E@, @B_android#content#Context#WIFI_P2P_SERVICE_E@, @B_android#content#Context#WIFI_SERVICE_E@, @B_android#content#Context#WIFI_AWARE_SERVICE_E@. For these services this method will return null. Generally, if you are running as an instant app you should always check whether the result of this method is null. Note: When implementing this method, keep in mind that new services can be added on newer Android releases, so if you're looking for just the explicit names mentioned above, make sure to return null when you don't recognize the name \u2014 if you throw a @B_java#lang#RuntimeException_E@ exception instead, you're app might break on new Android releases.", "history": "Added in API level 1", "FullName": "public abstract Object getSystemService (String name)"}, "getTheme()": {"Returns": [["@B_android#content#res#Resources#Theme_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the Theme object associated with this Context.", "history": "Added in API level 1", "FullName": "public abstract Resources.Theme getTheme ()"}, "peekWallpaper()": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#app#WallpaperManager#peekDrawable_E@ instead.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public abstract Drawable peekWallpaper ()"}, "getDrawable(int)": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "An object that can be used to draw this resource. This value may be null."]], "Parameters": [["int", "int: The desired resource identifier, as generated by the aapt tool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier."]], "Throws": [["@B_android#content#res#Resources#NotFoundException_E@", "if the given ID does not exist."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a drawable object associated with a particular resource ID and styled for the current theme.", "history": "Added in API level 21", "FullName": "public final Drawable getDrawable (int id)"}, "isDeviceProtectedStorage()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#createDeviceProtectedStorageContext_E@"], "Permissions": [], "Description": "Indicates if the storage APIs of this Context are backed by device-protected storage.", "history": "Added in API level 24", "FullName": "public abstract boolean isDeviceProtectedStorage ()"}, "getMainLooper()": {"Returns": [["@B_android#os#Looper_E@", "The main looper."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the Looper for the main thread of the current process. This is the thread used to dispatch calls to application components (activities, services, etc). By definition, this method returns the same result as would be obtained by calling @B_android#os#Looper#getMainLooper_E@.", "history": "Added in API level 1", "FullName": "public abstract Looper getMainLooper ()"}, "getFileStreamPath(java.lang.String)": {"Returns": [["@B_java#io#File_E@", "An absolute path to the given file."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the file for which you would like to get its path."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#openFileOutput_E@", "@B_android#content#Context#getFilesDir_E@", "@B_android#content#Context#getDir_E@"], "Permissions": [], "Description": "Returns the absolute path on the filesystem where a file created with @B_android#content#Context#openFileOutput_E@ is stored. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted.", "history": "Added in API level 1", "FullName": "public abstract File getFileStreamPath (String name)"}, "openOrCreateDatabase(java.lang.String,int,android.database.sqlite.SQLiteDatabase.CursorFactory)": {"Returns": [["@B_android#database#sqlite#SQLiteDatabase_E@", "The contents of a newly created database with the given name."]], "Parameters": [["@B_java#lang#String_E@", "String: The name (unique in the application package) of the database."], ["int", "int: Operating mode. Value is either 0 or a combination of @B_android#content#Context#MODE_PRIVATE_E@, @B_android#content#Context#MODE_WORLD_READABLE_E@, @B_android#content#Context#MODE_WORLD_WRITEABLE_E@, @B_android#content#Context#MODE_ENABLE_WRITE_AHEAD_LOGGING_E@, and @B_android#content#Context#MODE_NO_LOCALIZED_COLLATORS_E@"], ["@B_android#database#sqlite#SQLiteDatabase#CursorFactory_E@", "SQLiteDatabase.CursorFactory: An optional factory class that is called to instantiate a cursor when query is called."]], "Throws": [["@B_android#database#sqlite#SQLiteException_E@", "if the database file could not be opened."]], "SeeAlso": ["@B_android#content#Context_E@", "@B_android#content#Context#deleteDatabase_E@"], "Permissions": [], "Description": "Open a new private SQLiteDatabase associated with this Context's application package. Create the database file if it doesn't exist.", "history": "Added in API level 1", "FullName": "public abstract SQLiteDatabase openOrCreateDatabase (String name, int mode, SQLiteDatabase.CursorFactory factory)"}, "databaseList()": {"Returns": [["@B_java#lang#String_E@", "Array of strings naming the private databases."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#openOrCreateDatabase_E@", "@B_android#content#Context#deleteDatabase_E@"], "Permissions": [], "Description": "Returns an array of strings naming the private databases associated with this Context's application package.", "history": "Added in API level 1", "FullName": "public abstract String[] databaseList ()"}, "getWallpaperDesiredMinimumWidth()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#app#WallpaperManager#getDesiredMinimumWidth_E@ instead.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public abstract int getWallpaperDesiredMinimumWidth ()"}, "removeStickyBroadcastAsUser(android.content.Intent,android.os.UserHandle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent that was previously broadcast."], ["@B_android#os#UserHandle_E@", "UserHandle: UserHandle to remove the sticky broadcast from."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendStickyBroadcastAsUser_E@"], "Permissions": ["@B_android#Manifest#permission#BROADCAST_STICKY_E@"], "Description": "Sticky broadcasts should not be used. They provide no security (anyone can access them), no protection (anyone can modify them), and many other problems. The recommended pattern is to use a non-sticky broadcast to report that something has changed, with another mechanism for apps to retrieve the current value whenever desired. Version of @B_android#content#Context#removeStickyBroadcast_E@ that allows you to specify the user the broadcast will be sent to. This is not available to applications that are not pre-installed on the system image. You must hold the @B_android#Manifest#permission#BROADCAST_STICKY_E@ permission in order to use this API. If you do not hold that permission, @B_java#lang#SecurityException_E@ will be thrown. Requires android.Manifest.permission.INTERACT_ACROSS_USERS and @B_android#Manifest#permission#BROADCAST_STICKY_E@", "history": "Added in API level 17 Deprecated in API level 21", "FullName": "public abstract void removeStickyBroadcastAsUser (Intent intent, UserHandle user)"}, "sendOrderedBroadcast(android.content.Intent,java.lang.String,android.content.BroadcastReceiver,android.os.Handler,int,java.lang.String,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast. This value must never be null."], ["@B_java#lang#String_E@", "String: String naming a permissions that a receiver must hold in order to receive your broadcast. If null, no permission is required. This value may be null."], ["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: Your own BroadcastReceiver to treat as the final receiver of the broadcast. This value may be null."], ["@B_android#os#Handler_E@", "Handler: A custom Handler with which to schedule the resultReceiver callback; if null it will be scheduled in the Context's main thread. This value may be null."], ["int", "int: An initial value for the result code. Often Activity.RESULT_OK."], ["@B_java#lang#String_E@", "String: An initial value for the result data. Often null. This value may be null."], ["@B_android#os#Bundle_E@", "Bundle: An initial value for the result extras. Often null. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#sendOrderedBroadcast_E@", "@B_android#content#BroadcastReceiver_E@", "@B_android#content#Context#registerReceiver_E@", "@B_android#app#Activity_E@"], "Permissions": [], "Description": "Version of @B_android#content#Context#sendBroadcast_E@ that allows you to receive data back from the broadcast. This is accomplished by supplying your own BroadcastReceiver when calling, which will be treated as a final receiver at the end of the broadcast -- its @B_android#content#BroadcastReceiver#onReceive_E@ method will be called with the result values collected from the other receivers. The broadcast will be serialized in the same way as calling @B_android#content#Context#sendOrderedBroadcast_E@. Like @B_android#content#Context#sendBroadcast_E@, this method is asynchronous; it will return before resultReceiver.onReceive() is called. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts.", "history": "Added in API level 1", "FullName": "public abstract void sendOrderedBroadcast (Intent intent, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)"}, "getString(int, java.lang.Object...)": {"Returns": [["@B_java#lang#String_E@", "The string data associated with the resource, formatted and stripped of styled text information. This value will never be null."]], "Parameters": [["int", "int: Resource id for the format string"], ["@B_java#lang#Object_E@", "Object: The format arguments that will be used for substitution."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a localized formatted string from the application's package's default string table, substituting the format arguments as defined in @B_java#util#Formatter_E@ and @B_java#lang#String#format_E@.", "history": "added in API level 1", "FullName": "public final String getString (int resId, Object... formatArgs)"}, "getApplicationInfo()": {"Returns": [["@B_android#content#pm#ApplicationInfo_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the full application info for this context's package.", "history": "Added in API level 4", "FullName": "public abstract ApplicationInfo getApplicationInfo ()"}, "deleteSharedPreferences(java.lang.String)": {"Returns": [["boolean", "true if the shared preferences file was successfully deleted; else false."]], "Parameters": [["@B_java#lang#String_E@", "String: The name (unique in the application package) of the shared preferences file."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#getSharedPreferences_E@"], "Permissions": [], "Description": "Delete an existing shared preferences file.", "history": "Added in API level 24", "FullName": "public abstract boolean deleteSharedPreferences (String name)"}, "getExternalFilesDir(java.lang.String)": {"Returns": [["@B_java#io#File_E@", "the absolute path to application-specific directory. May return null if shared storage is not currently available."]], "Parameters": [["@B_java#lang#String_E@", "String: The type of files directory to return. May be null for the root of the files directory or one of the following constants for a subdirectory: @B_android#os#Environment#DIRECTORY_MUSIC_E@, @B_android#os#Environment#DIRECTORY_PODCASTS_E@, @B_android#os#Environment#DIRECTORY_RINGTONES_E@, @B_android#os#Environment#DIRECTORY_ALARMS_E@, @B_android#os#Environment#DIRECTORY_NOTIFICATIONS_E@, @B_android#os#Environment#DIRECTORY_PICTURES_E@, or @B_android#os#Environment#DIRECTORY_MOVIES_E@. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#getFilesDir_E@", "@B_android#content#Context#getExternalFilesDirs_E@", "@B_android#os#Environment#getExternalStorageState_E@", "@B_android#os#Environment#isExternalStorageEmulated_E@", "@B_android#os#Environment#isExternalStorageRemovable_E@"], "Permissions": ["@B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@", "@B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@"], "Description": "Returns the absolute path to the directory on the primary shared/external storage device where the application can place persistent files it owns. These files are internal to the applications, and not typically visible to the user as media. This is like @B_android#content#Context#getFilesDir_E@ in that these files will be deleted when the application is uninstalled, however there are some important differences: Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using @B_android#os#Environment#getExternalStorageState_E@. There is no security enforced with these files. For example, any application holding @B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@ can write to these files. If a shared storage device is emulated (as determined by @B_android#os#Environment#isExternalStorageEmulated_E@), it's contents are backed by a private user data partition, which means there is little benefit to storing data here instead of the private directories returned by @B_android#content#Context#getFilesDir_E@, etc. Starting in @B_android#os#Build#VERSION_CODES#KITKAT_E@, no permissions are required to read or write to the returned path; it's always accessible to the calling app. This only applies to paths generated for package name of the calling application. To access paths belonging to other packages, @B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@ and/or @B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@ are required. On devices with multiple users (as described by @B_android#os#UserManager_E@), each user has their own isolated shared storage. Applications only have access to the shared storage for the user they're running as. The returned path may change over time if different shared storage media is inserted, so only relative paths should be persisted. Here is an example of typical code to manipulate a file in an application's shared storage: If you supply a non-null @B_android#media#MediaScannerConnection#scanFile_E@. Note that this is not the same as @B_android#os#Environment#getExternalStoragePublicDirectory_E@, which provides directories of media shared by all applications. The directories returned here are owned by the application, and their contents will be removed when the application is uninstalled. Unlike @B_android#os#Environment#getExternalStoragePublicDirectory_E@, the directory returned here will be automatically created for you. Here is an example of typical code to manipulate a picture in an application's shared storage and add it to the media database:", "history": "Added in API level 8", "FullName": "public abstract File getExternalFilesDir (String type)"}, "getExternalMediaDirs()": {"Returns": [["@B_java#io#File_E@", "the absolute paths to application-specific directories. Some individual paths may be null if that shared storage is not currently available."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#os#Environment#getExternalStorageState_E@", "@B_android#os#Environment#isExternalStorageEmulated_E@", "@B_android#os#Environment#isExternalStorageRemovable_E@"], "Permissions": ["@B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@"], "Description": "Returns absolute paths to application-specific directories on all shared/external storage devices where the application can place media files. These files are scanned and made available to other apps through @B_android#provider#MediaStore_E@. This is like @B_android#content#Context#getExternalFilesDirs_E@ in that these files will be deleted when the application is uninstalled, however there are some important differences: Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using @B_android#os#Environment#getExternalStorageState_E@. There is no security enforced with these files. For example, any application holding @B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@ can write to these files. Shared storage devices returned here are considered a stable part of the device, including physical media slots under a protective cover. The returned paths do not include transient devices, such as USB flash drives connected to handheld devices. An application may store data on any or all of the returned devices. For example, an app may choose to store large files on the device with the most available space, as measured by @B_android#os#StatFs_E@. No additional permissions are required for the calling app to read or write files under the returned path. Write access outside of these paths on secondary external storage devices is not available. The returned paths may change over time if different shared storage media is inserted, so only relative paths should be persisted.", "history": "Added in API level 21", "FullName": "public abstract File[] getExternalMediaDirs ()"}, "startInstrumentation(android.content.ComponentName,java.lang.String,android.os.Bundle)": {"Returns": [["boolean", "true if the instrumentation was successfully started, else false if it could not be found."]], "Parameters": [["@B_android#content#ComponentName_E@", "ComponentName: Name of the Instrumentation component to be run. This value must never be null."], ["@B_java#lang#String_E@", "String: Optional path to write profiling data as the instrumentation runs, or null for no profiling. This value may be null."], ["@B_android#os#Bundle_E@", "Bundle: Additional optional arguments to pass to the instrumentation, or null. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Start executing an @B_android#app#Instrumentation_E@ class. The given Instrumentation component will be run by killing its target application (if currently running), starting the target process, instantiating the instrumentation component, and then letting it drive the application. This function is not synchronous -- it returns as soon as the instrumentation has started and while it is running. Instrumentation is normally only allowed to run against a package that is either unsigned or signed with a signature that the the instrumentation package is also signed with (ensuring the target trusts the instrumentation).", "history": "Added in API level 1", "FullName": "public abstract boolean startInstrumentation (ComponentName className, String profileFile, Bundle arguments)"}, "isRestricted()": {"Returns": [["boolean", "true if this Context is restricted, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context_E@"], "Permissions": [], "Description": "Indicates whether this Context is restricted.", "history": "Added in API level 4", "FullName": "public boolean isRestricted ()"}, "enforceUriPermission(android.net.Uri,int,int,int,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."], ["int", "int: The access modes to enforce. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"], ["@B_java#lang#String_E@", "String: A message to include in the exception if it is thrown."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkUriPermission_E@"], "Permissions": [], "Description": "If a particular process and user ID has not been granted permission to access a specific URI, throw @B_java#lang#SecurityException_E@. This only checks for permissions that have been explicitly granted -- if the given process/uid has more general access to the URI's content provider then this check will always fail.", "history": "Added in API level 1", "FullName": "public abstract void enforceUriPermission (Uri uri, int pid, int uid, int modeFlags, String message)"}, "enforceUriPermission(android.net.Uri,java.lang.String,java.lang.String,int,int,int,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#net#Uri_E@", "Uri: The Uri whose permission is to be checked, or null to not do this check. This value may be null."], ["@B_java#lang#String_E@", "String: The permission that provides overall read access, or null to not do this check. This value may be null."], ["@B_java#lang#String_E@", "String: The permission that provides overall write access, or null to not do this check. This value may be null."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."], ["int", "int: The access modes to enforce. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"], ["@B_java#lang#String_E@", "String: A message to include in the exception if it is thrown. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkUriPermission_E@"], "Permissions": [], "Description": "Enforce both a Uri and normal permission. This allows you to perform both @B_android#content#Context#enforcePermission_E@ and @B_android#content#Context#enforceUriPermission_E@ in one call.", "history": "Added in API level 1", "FullName": "public abstract void enforceUriPermission (Uri uri, String readPermission, String writePermission, int pid, int uid, int modeFlags, String message)"}, "checkSelfPermission(java.lang.String)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if you have the permission, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if not. Value is @B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@"]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the permission being checked. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#pm#PackageManager#checkPermission_E@", "@B_android#content#Context#checkCallingPermission_E@"], "Permissions": [], "Description": "Determine whether you have been granted a particular permission.", "history": "Added in API level 23", "FullName": "public abstract int checkSelfPermission (String permission)"}, "clearWallpaper()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#SET_WALLPAPER_E@"], "Description": "Use @B_android#app#WallpaperManager#clear_E@ instead. This method requires the caller to hold the permission @B_android#Manifest#permission#SET_WALLPAPER_E@.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public abstract void clearWallpaper ()"}, "createPackageContext(java.lang.String, int)": {"Returns": [["@B_android#content#Context_E@", "A @B_android#content#Context_E@ for the application."]], "Parameters": [["@B_java#lang#String_E@", "String: Name of the application's package."], ["int", "int: Option flags.Value is either 0 or combination of CONTEXT_INCLUDE_CODE, CONTEXT_IGNORE_SECURITY or CONTEXT_RESTRICTED."]], "Throws": [["@B_java#lang#SecurityException_E@", ""], ["", "if there is no application with the given package name."], ["@B_android#content#pm#PackageManager#NameNotFoundException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Return a new Context object for the given application name. This Context is the same as what the named application gets when it is launched, containing the same resources and class loader. Each call to this method returns a new instance of a Context object; Context objects are not shared, however they share common state (Resources, ClassLoader, etc) so the Context instance itself is fairly lightweight. Throws @B_android#content#pm#PackageManager#NameNotFoundException_E@ if there is no application with the given package name. Throws @B_java#lang#SecurityException_E@ if the Context requested can not be loaded into the caller's process for security reasons (see @B_android#content#Context#CONTEXT_INCLUDE_CODE_E@ for more information}.", "history": "added in API level 1", "FullName": "public abstract Context createPackageContext (String packageName, int flags)"}, "registerComponentCallbacks(android.content.ComponentCallbacks)": {"Returns": [], "Parameters": [["@B_android#content#ComponentCallbacks_E@", "ComponentCallbacks: The interface to call. This can be either a @B_android#content#ComponentCallbacks_E@ or @B_android#content#ComponentCallbacks2_E@ interface."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add a new @B_android#content#ComponentCallbacks_E@ to the base application of the Context, which will be called at the same times as the ComponentCallbacks methods of activities and other components are called. Note that you must be sure to use @B_android#content#Context#unregisterComponentCallbacks_E@ when appropriate in the future; this will not be removed for you.", "history": "Added in API level 14", "FullName": "public void registerComponentCallbacks (ComponentCallbacks callback)"}, "setWallpaper(android.graphics.Bitmap)": {"Returns": [], "Parameters": [["@B_android#graphics#Bitmap_E@", "Bitmap no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#SET_WALLPAPER_E@"], "Description": "Use @B_android#app#WallpaperManager#setBitmap_E@ instead. This method requires the caller to hold the permission @B_android#Manifest#permission#SET_WALLPAPER_E@.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public abstract void setWallpaper (Bitmap bitmap)"}, "unregisterReceiver(android.content.BroadcastReceiver)": {"Returns": [], "Parameters": [["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: The BroadcastReceiver to unregister."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#registerReceiver_E@"], "Permissions": [], "Description": "Unregister a previously registered BroadcastReceiver. All filters that have been registered for this BroadcastReceiver will be removed.", "history": "Added in API level 1", "FullName": "public abstract void unregisterReceiver (BroadcastReceiver receiver)"}, "getExternalCacheDirs()": {"Returns": [["@B_java#io#File_E@", "the absolute paths to application-specific directories. Some individual paths may be null if that shared storage is not currently available. The first path returned is the same as @B_android#content#Context#getExternalCacheDir_E@."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#getExternalCacheDir_E@", "@B_android#os#Environment#getExternalStorageState_E@", "@B_android#os#Environment#isExternalStorageEmulated_E@", "@B_android#os#Environment#isExternalStorageRemovable_E@"], "Permissions": ["@B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@"], "Description": "Returns absolute paths to application-specific directories on all shared/external storage devices where the application can place cache files it owns. These files are internal to the application, and not typically visible to the user as media. This is like @B_android#content#Context#getCacheDir_E@ in that these files will be deleted when the application is uninstalled, however there are some important differences: The platform does not always monitor the space available in shared storage, and thus may not automatically delete these files. Apps should always manage the maximum space used in this location. Currently the only time files here will be deleted by the platform is when running on @B_android#os#Build#VERSION_CODES#JELLY_BEAN_MR1_E@ or later and @B_android#os#Environment#isExternalStorageEmulated_E@ returns true. Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using @B_android#os#Environment#getExternalStorageState_E@. There is no security enforced with these files. For example, any application holding @B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@ can write to these files. If a shared storage device is emulated (as determined by @B_android#os#Environment#isExternalStorageEmulated_E@), it's contents are backed by a private user data partition, which means there is little benefit to storing data here instead of the private directory returned by @B_android#content#Context#getCacheDir_E@. Shared storage devices returned here are considered a stable part of the device, including physical media slots under a protective cover. The returned paths do not include transient devices, such as USB flash drives connected to handheld devices. An application may store data on any or all of the returned devices. For example, an app may choose to store large files on the device with the most available space, as measured by @B_android#os#StatFs_E@. No additional permissions are required for the calling app to read or write files under the returned path. Write access outside of these paths on secondary external storage devices is not available. The returned paths may change over time if different shared storage media is inserted, so only relative paths should be persisted.", "history": "Added in API level 19", "FullName": "public abstract File[] getExternalCacheDirs ()"}, "registerReceiver(android.content.BroadcastReceiver,android.content.IntentFilter,int)": {"Returns": [["@B_android#content#Intent_E@", "The first sticky intent found that matches filter, or null if there are none."]], "Parameters": [["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: The BroadcastReceiver to handle the broadcast. This value may be null."], ["@B_android#content#IntentFilter_E@", "IntentFilter: Selects the Intent broadcasts to be received."], ["int", "int: Additional options for the receiver. May be 0 or @B_android#content#Context#RECEIVER_VISIBLE_TO_INSTANT_APPS_E@. Value is either 0 or @B_android#content#Context#RECEIVER_VISIBLE_TO_INSTANT_APPS_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context#registerReceiver_E@", "@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#unregisterReceiver_E@"], "Permissions": [], "Description": "Register to receive intent broadcasts, with the receiver optionally being exposed to Instant Apps. See @B_android#content#Context#registerReceiver_E@ for more information. By default Instant Apps cannot interact with receivers in other applications, this allows you to expose a receiver that Instant Apps can interact with. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts. As of @B_android#os#Build#VERSION_CODES#ICE_CREAM_SANDWICH_E@, receivers registered with this method will correctly respect the @B_android#content#Intent#setPackage_E@ specified for an Intent being broadcast. Prior to that, it would be ignored and delivered to all matching registered receivers. Be careful if using this for security.", "history": "Added in API level 26", "FullName": "public abstract Intent registerReceiver (BroadcastReceiver receiver, IntentFilter filter, int flags)"}, "startActivity(android.content.Intent,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The description of the activity to start."], ["@B_android#os#Bundle_E@", "Bundle: Additional options for how the Activity should be started. May be null if there are no options. See @B_android#app#ActivityOptions_E@ for how to build the Bundle supplied here; there are no supported definitions for building it manually. This value may be null."]], "Throws": [["@B_android#content#ActivityNotFoundException_E@", ""]], "SeeAlso": ["@B_android#content#Context#startActivity_E@", "@B_android#content#pm#PackageManager#resolveActivity_E@"], "Permissions": [], "Description": "Launch a new activity. You will not receive any information about when the activity exits. Note that if this method is being called from outside of an @B_android#app#Activity_E@ Context, then the Intent must include the @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@ launch flag. This is because, without being started from an existing Activity, there is no existing task in which to place the new activity and thus it needs to be placed in its own separate task. This method throws @B_android#content#ActivityNotFoundException_E@ if there was no Activity found to run the given Intent.", "history": "Added in API level 16", "FullName": "public abstract void startActivity (Intent intent, Bundle options)"}, "checkPermission(java.lang.String, int, int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the given pid/uid is allowed that permission, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not.Value is PERMISSION_GRANTED or PERMISSION_DENIED."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the permission being checked.This value must never be null."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."]], "Throws": [], "SeeAlso": ["@B_android#content#pm#PackageManager#checkPermission_E@", "@B_android#content#Context#checkCallingPermission_E@"], "Permissions": [], "Description": "Determine whether the given permission is allowed for a particular process and user ID running in the system.", "history": "added in API level 1", "FullName": "public abstract int checkPermission (String permission, int pid, int uid)"}, "openFileInput(java.lang.String)": {"Returns": [["@B_java#io#FileInputStream_E@", "The resulting @B_java#io#FileInputStream_E@."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the file to open; can not contain path separators."]], "Throws": [["@B_java#io#FileNotFoundException_E@", ""]], "SeeAlso": ["@B_android#content#Context#openFileOutput_E@", "@B_android#content#Context#fileList_E@", "@B_android#content#Context#deleteFile_E@", "@B_java#io#FileInputStream#FileInputStream_E@"], "Permissions": [], "Description": "Open a private file associated with this Context's application package for reading.", "history": "Added in API level 1", "FullName": "public abstract FileInputStream openFileInput (String name)"}, "obtainStyledAttributes(int,int[])": {"Returns": [["@B_android#content#res#TypedArray_E@", "This value will never be null."]], "Parameters": [["int", "int no parameter comment"], ["int[]", "int: This value must never be null."]], "Throws": [["@B_android#content#res#Resources#NotFoundException_E@", ""]], "SeeAlso": ["@B_android#content#res#Resources#Theme#obtainStyledAttributes_E@"], "Permissions": [], "Description": "Retrieve styled attribute information in this Context's theme. See @B_android#content#res#Resources#Theme#obtainStyledAttributes_E@ for more information.", "history": "Added in API level 1", "FullName": "public final TypedArray obtainStyledAttributes (int resid, int[] attrs)"}, "getExternalCacheDir()": {"Returns": [["@B_java#io#File_E@", "the absolute path to application-specific directory. May return null if shared storage is not currently available."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#getCacheDir_E@", "@B_android#content#Context#getExternalCacheDirs_E@", "@B_android#os#Environment#getExternalStorageState_E@", "@B_android#os#Environment#isExternalStorageEmulated_E@", "@B_android#os#Environment#isExternalStorageRemovable_E@"], "Permissions": ["@B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@", "@B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@"], "Description": "Returns absolute path to application-specific directory on the primary shared/external storage device where the application can place cache files it owns. These files are internal to the application, and not typically visible to the user as media. This is like @B_android#content#Context#getCacheDir_E@ in that these files will be deleted when the application is uninstalled, however there are some important differences: The platform does not always monitor the space available in shared storage, and thus may not automatically delete these files. Apps should always manage the maximum space used in this location. Currently the only time files here will be deleted by the platform is when running on @B_android#os#Build#VERSION_CODES#JELLY_BEAN_MR1_E@ or later and @B_android#os#Environment#isExternalStorageEmulated_E@ returns true. Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using @B_android#os#Environment#getExternalStorageState_E@. There is no security enforced with these files. For example, any application holding @B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@ can write to these files. If a shared storage device is emulated (as determined by @B_android#os#Environment#isExternalStorageEmulated_E@), its contents are backed by a private user data partition, which means there is little benefit to storing data here instead of the private directory returned by @B_android#content#Context#getCacheDir_E@. Starting in @B_android#os#Build#VERSION_CODES#KITKAT_E@, no permissions are required to read or write to the returned path; it's always accessible to the calling app. This only applies to paths generated for package name of the calling application. To access paths belonging to other packages, @B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@ and/or @B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@ are required. On devices with multiple users (as described by @B_android#os#UserManager_E@), each user has their own isolated shared storage. Applications only have access to the shared storage for the user they're running as. The returned path may change over time if different shared storage media is inserted, so only relative paths should be persisted.", "history": "Added in API level 8", "FullName": "public abstract File getExternalCacheDir ()"}, "fileList()": {"Returns": [["@B_java#lang#String_E@", "Array of strings naming the private files."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#openFileInput_E@", "@B_android#content#Context#openFileOutput_E@", "@B_android#content#Context#deleteFile_E@"], "Permissions": [], "Description": "Returns an array of strings naming the private files associated with this Context's application package.", "history": "Added in API level 1", "FullName": "public abstract String[] fileList ()"}, "registerReceiver(android.content.BroadcastReceiver,android.content.IntentFilter,java.lang.String,android.os.Handler,int)": {"Returns": [["@B_android#content#Intent_E@", "The first sticky intent found that matches filter, or null if there are none."]], "Parameters": [["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: The BroadcastReceiver to handle the broadcast."], ["@B_android#content#IntentFilter_E@", "IntentFilter: Selects the Intent broadcasts to be received."], ["@B_java#lang#String_E@", "String: String naming a permissions that a broadcaster must hold in order to send an Intent to you. If null, no permission is required. This value may be null."], ["@B_android#os#Handler_E@", "Handler: Handler identifying the thread that will receive the Intent. If null, the main thread of the process will be used. This value may be null."], ["int", "int: Additional options for the receiver. May be 0 or @B_android#content#Context#RECEIVER_VISIBLE_TO_INSTANT_APPS_E@. Value is either 0 or @B_android#content#Context#RECEIVER_VISIBLE_TO_INSTANT_APPS_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context#registerReceiver_E@", "@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#unregisterReceiver_E@"], "Permissions": [], "Description": "Register to receive intent broadcasts, to run in the context of @B_android#content#Context#registerReceiver_E@ and @B_android#content#Context#registerReceiver_E@ for more information. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts. As of @B_android#os#Build#VERSION_CODES#ICE_CREAM_SANDWICH_E@, receivers registered with this method will correctly respect the @B_android#content#Intent#setPackage_E@ specified for an Intent being broadcast. Prior to that, it would be ignored and delivered to all matching registered receivers. Be careful if using this for security.", "history": "Added in API level 26", "FullName": "public abstract Intent registerReceiver (BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler, int flags)"}, "createPackageContext(java.lang.String,int)": {"Returns": [["@B_android#content#Context_E@", "A @B_android#content#Context_E@ for the application."]], "Parameters": [["@B_java#lang#String_E@", "String: Name of the application's package."], ["int", "int: Option flags. Value is either 0 or a combination of @B_android#content#Context#CONTEXT_INCLUDE_CODE_E@, @B_android#content#Context#CONTEXT_IGNORE_SECURITY_E@, @B_android#content#Context#CONTEXT_RESTRICTED_E@, android.content.Context.CONTEXT_DEVICE_PROTECTED_STORAGE, android.content.Context.CONTEXT_CREDENTIAL_PROTECTED_STORAGE, and android.content.Context.CONTEXT_REGISTER_PACKAGE"]], "Throws": [["@B_java#lang#SecurityException_E@", ""], ["@B_android#content#pm#PackageManager#NameNotFoundException_E@", "if there is no application with the given package name."]], "SeeAlso": [], "Permissions": [], "Description": "Return a new Context object for the given application name. This Context is the same as what the named application gets when it is launched, containing the same resources and class loader. Each call to this method returns a new instance of a Context object; Context objects are not shared, however they share common state (Resources, ClassLoader, etc) so the Context instance itself is fairly lightweight. Throws @B_android#content#pm#PackageManager#NameNotFoundException_E@ if there is no application with the given package name. Throws @B_java#lang#SecurityException_E@ if the Context requested can not be loaded into the caller's process for security reasons (see @B_android#content#Context#CONTEXT_INCLUDE_CODE_E@ for more information}.", "history": "Added in API level 1", "FullName": "public abstract Context createPackageContext (String packageName, int flags)"}, "startActivities(android.content.Intent[])": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: An array of Intents to be started."]], "Throws": [["@B_android#content#ActivityNotFoundException_E@", ""]], "SeeAlso": ["@B_android#content#Context#startActivities_E@", "@B_android#content#pm#PackageManager#resolveActivity_E@"], "Permissions": [], "Description": "Same as @B_android#content#Context#startActivities_E@ with no options specified.", "history": "Added in API level 11", "FullName": "public abstract void startActivities (Intent[] intents)"}, "startIntentSender(android.content.IntentSender,android.content.Intent,int,int,int)": {"Returns": [], "Parameters": [["@B_android#content#IntentSender_E@", "IntentSender: The IntentSender to launch."], ["@B_android#content#Intent_E@", "Intent: If non-null, this will be provided as the intent parameter to @B_android#content#IntentSender#sendIntent_E@. This value may be null."], ["int", "int: Intent flags in the original IntentSender that you would like to change. Value is either 0 or a combination of @B_android#content#Intent#FLAG_FROM_BACKGROUND_E@, @B_android#content#Intent#FLAG_DEBUG_LOG_RESOLUTION_E@, @B_android#content#Intent#FLAG_EXCLUDE_STOPPED_PACKAGES_E@, @B_android#content#Intent#FLAG_INCLUDE_STOPPED_PACKAGES_E@, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, @B_android#content#Intent#FLAG_ACTIVITY_MATCH_EXTERNAL_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_HISTORY_E@, @B_android#content#Intent#FLAG_ACTIVITY_SINGLE_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_MULTIPLE_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_FORWARD_RESULT_E@, @B_android#content#Intent#FLAG_ACTIVITY_PREVIOUS_IS_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS_E@, @B_android#content#Intent#FLAG_ACTIVITY_BROUGHT_TO_FRONT_E@, @B_android#content#Intent#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED_E@, @B_android#content#Intent#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET_E@, @B_android#content#Intent#FLAG_ACTIVITY_NEW_DOCUMENT_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_USER_ACTION_E@, @B_android#content#Intent#FLAG_ACTIVITY_REORDER_TO_FRONT_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_ANIMATION_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_TASK_ON_HOME_E@, @B_android#content#Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS_E@, @B_android#content#Intent#FLAG_ACTIVITY_LAUNCH_ADJACENT_E@, @B_android#content#Intent#FLAG_RECEIVER_REGISTERED_ONLY_E@, @B_android#content#Intent#FLAG_RECEIVER_REPLACE_PENDING_E@, @B_android#content#Intent#FLAG_RECEIVER_FOREGROUND_E@, @B_android#content#Intent#FLAG_RECEIVER_NO_ABORT_E@, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, @B_android#content#Intent#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS_E@, and android.content.Intent.FLAG_RECEIVER_OFFLOAD"], ["int", "int: Desired values for any bits set in flagsMask Value is either 0 or a combination of @B_android#content#Intent#FLAG_FROM_BACKGROUND_E@, @B_android#content#Intent#FLAG_DEBUG_LOG_RESOLUTION_E@, @B_android#content#Intent#FLAG_EXCLUDE_STOPPED_PACKAGES_E@, @B_android#content#Intent#FLAG_INCLUDE_STOPPED_PACKAGES_E@, android.content.Intent.FLAG_DEBUG_TRIAGED_MISSING, android.content.Intent.FLAG_IGNORE_EPHEMERAL, @B_android#content#Intent#FLAG_ACTIVITY_MATCH_EXTERNAL_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_HISTORY_E@, @B_android#content#Intent#FLAG_ACTIVITY_SINGLE_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_NEW_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_MULTIPLE_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_FORWARD_RESULT_E@, @B_android#content#Intent#FLAG_ACTIVITY_PREVIOUS_IS_TOP_E@, @B_android#content#Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS_E@, @B_android#content#Intent#FLAG_ACTIVITY_BROUGHT_TO_FRONT_E@, @B_android#content#Intent#FLAG_ACTIVITY_RESET_TASK_IF_NEEDED_E@, @B_android#content#Intent#FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET_E@, @B_android#content#Intent#FLAG_ACTIVITY_NEW_DOCUMENT_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_USER_ACTION_E@, @B_android#content#Intent#FLAG_ACTIVITY_REORDER_TO_FRONT_E@, @B_android#content#Intent#FLAG_ACTIVITY_NO_ANIMATION_E@, @B_android#content#Intent#FLAG_ACTIVITY_CLEAR_TASK_E@, @B_android#content#Intent#FLAG_ACTIVITY_TASK_ON_HOME_E@, @B_android#content#Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS_E@, @B_android#content#Intent#FLAG_ACTIVITY_LAUNCH_ADJACENT_E@, @B_android#content#Intent#FLAG_RECEIVER_REGISTERED_ONLY_E@, @B_android#content#Intent#FLAG_RECEIVER_REPLACE_PENDING_E@, @B_android#content#Intent#FLAG_RECEIVER_FOREGROUND_E@, @B_android#content#Intent#FLAG_RECEIVER_NO_ABORT_E@, android.content.Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT, android.content.Intent.FLAG_RECEIVER_BOOT_UPGRADE, android.content.Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND, android.content.Intent.FLAG_RECEIVER_FROM_SHELL, @B_android#content#Intent#FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS_E@, and android.content.Intent.FLAG_RECEIVER_OFFLOAD"], ["int", "int: Always set to 0."]], "Throws": [["@B_android#content#IntentSender#SendIntentException_E@", ""]], "SeeAlso": ["@B_android#content#Context#startActivity_E@", "@B_android#content#Context#startIntentSender_E@"], "Permissions": [], "Description": "Same as @B_android#content#Context#startIntentSender_E@ with no options specified.", "history": "Added in API level 5", "FullName": "public abstract void startIntentSender (IntentSender intent, Intent fillInIntent, int flagsMask, int flagsValues, int extraFlags)"}, "obtainStyledAttributes(int, int[])": {"Returns": [["@B_android#content#res#TypedArray_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"], ["int[]", "int no parameter comment"]], "Throws": [["@B_android#content#res#Resources#NotFoundException_E@", ""]], "SeeAlso": ["@B_android#content#res#Resources#Theme#obtainStyledAttributes_E@"], "Permissions": [], "Description": "Retrieve styled attribute information in this Context's theme. See @B_android#content#res#Resources#Theme#obtainStyledAttributes_E@ for more information.", "history": "added in API level 1", "FullName": "public final TypedArray obtainStyledAttributes (int resid, int[] attrs)"}, "sendBroadcastAsUser(android.content.Intent,android.os.UserHandle,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast."], ["@B_android#os#UserHandle_E@", "UserHandle: UserHandle to send the intent to."], ["@B_java#lang#String_E@", "String: (optional) String naming a permission that a receiver must hold in order to receive your broadcast. If null, no permission is required. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendBroadcast_E@"], "Permissions": [], "Description": "Version of @B_android#content#Context#sendBroadcast_E@ that allows you to specify the user the broadcast will be sent to. This is not available to applications that are not pre-installed on the system image. Requires android.Manifest.permission.INTERACT_ACROSS_USERS", "history": "Added in API level 17", "FullName": "public abstract void sendBroadcastAsUser (Intent intent, UserHandle user, String receiverPermission)"}, "getObbDir()": {"Returns": [["@B_java#io#File_E@", "the absolute path to application-specific directory. May return null if shared storage is not currently available."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#getObbDirs_E@", "@B_android#os#Environment#getExternalStorageState_E@", "@B_android#os#Environment#isExternalStorageEmulated_E@", "@B_android#os#Environment#isExternalStorageRemovable_E@"], "Permissions": ["@B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@", "@B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@"], "Description": "Return the primary shared/external storage directory where this application's OBB files (if there are any) can be found. Note if the application does not have any OBB files, this directory may not exist. This is like @B_android#content#Context#getFilesDir_E@ in that these files will be deleted when the application is uninstalled, however there are some important differences: Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using @B_android#os#Environment#getExternalStorageState_E@. There is no security enforced with these files. For example, any application holding @B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@ can write to these files. Starting in @B_android#os#Build#VERSION_CODES#KITKAT_E@, no permissions are required to read or write to the path that this method returns. However, starting from @B_android#os#Build#VERSION_CODES#M_E@, to read the OBB expansion files, you must declare the @B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@ permission in the app manifest and ask for permission at runtime as follows: <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" android:maxSdkVersion=\"23\" /> Starting from @B_android#os#Build#VERSION_CODES#N_E@, @B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@ permission is not required, so don\u2019t ask for this permission at runtime. To handle both cases, your app must first try to read the OBB file, and if it fails, you must request @B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@ permission at runtime. The following code snippet shows how to do this: @B_android#os#UserManager_E@), multiple users may share the same OBB storage location. Applications should ensure that multiple instances running under different users don't interfere with each other.", "history": "Added in API level 11", "FullName": "public abstract File getObbDir ()"}, "getDir(java.lang.String,int)": {"Returns": [["@B_java#io#File_E@", "A @B_java#io#File_E@ object for the requested directory. The directory will have been created if it does not already exist."]], "Parameters": [["@B_java#lang#String_E@", "String: Name of the directory to retrieve. This is a directory that is created as part of your application data."], ["int", "int: Operating mode. Value is either 0 or a combination of @B_android#content#Context#MODE_PRIVATE_E@, @B_android#content#Context#MODE_WORLD_READABLE_E@, @B_android#content#Context#MODE_WORLD_WRITEABLE_E@, and @B_android#content#Context#MODE_APPEND_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context#openFileOutput_E@"], "Permissions": [], "Description": "Retrieve, creating if needed, a new directory in which the application can place its own custom data files. You can use the returned File object to create and access files in this directory. Note that files created through a File object will only be accessible by your own application; you can only set the mode of the entire directory, not of individual files. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted. Apps require no extra permissions to read or write to the returned path, since this path lives in their private storage.", "history": "Added in API level 1", "FullName": "public abstract File getDir (String name, int mode)"}, "enforcePermission(java.lang.String,int,int,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The name of the permission being checked. This value must never be null."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."], ["@B_java#lang#String_E@", "String: A message to include in the exception if it is thrown. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkPermission_E@"], "Permissions": [], "Description": "If the given permission is not allowed for a particular process and user ID running in the system, throw a @B_java#lang#SecurityException_E@.", "history": "Added in API level 1", "FullName": "public abstract void enforcePermission (String permission, int pid, int uid, String message)"}, "getExternalFilesDirs(java.lang.String)": {"Returns": [["@B_java#io#File_E@", "the absolute paths to application-specific directories. Some individual paths may be null if that shared storage is not currently available. The first path returned is the same as @B_android#content#Context#getExternalFilesDir_E@."]], "Parameters": [["@B_java#lang#String_E@", "String: The type of files directory to return. May be null for the root of the files directory or one of the following constants for a subdirectory: @B_android#os#Environment#DIRECTORY_MUSIC_E@, @B_android#os#Environment#DIRECTORY_PODCASTS_E@, @B_android#os#Environment#DIRECTORY_RINGTONES_E@, @B_android#os#Environment#DIRECTORY_ALARMS_E@, @B_android#os#Environment#DIRECTORY_NOTIFICATIONS_E@, @B_android#os#Environment#DIRECTORY_PICTURES_E@, or @B_android#os#Environment#DIRECTORY_MOVIES_E@."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#getExternalFilesDir_E@", "@B_android#os#Environment#getExternalStorageState_E@", "@B_android#os#Environment#isExternalStorageEmulated_E@", "@B_android#os#Environment#isExternalStorageRemovable_E@"], "Permissions": ["@B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@"], "Description": "Returns absolute paths to application-specific directories on all shared/external storage devices where the application can place persistent files it owns. These files are internal to the application, and not typically visible to the user as media. This is like @B_android#content#Context#getFilesDir_E@ in that these files will be deleted when the application is uninstalled, however there are some important differences: Shared storage may not always be available, since removable media can be ejected by the user. Media state can be checked using @B_android#os#Environment#getExternalStorageState_E@. There is no security enforced with these files. For example, any application holding @B_android#Manifest#permission#WRITE_EXTERNAL_STORAGE_E@ can write to these files. If a shared storage device is emulated (as determined by @B_android#os#Environment#isExternalStorageEmulated_E@), it's contents are backed by a private user data partition, which means there is little benefit to storing data here instead of the private directories returned by @B_android#content#Context#getFilesDir_E@, etc. Shared storage devices returned here are considered a stable part of the device, including physical media slots under a protective cover. The returned paths do not include transient devices, such as USB flash drives connected to handheld devices. An application may store data on any or all of the returned devices. For example, an app may choose to store large files on the device with the most available space, as measured by @B_android#os#StatFs_E@. No additional permissions are required for the calling app to read or write files under the returned path. Write access outside of these paths on secondary external storage devices is not available. The returned path may change over time if different shared storage media is inserted, so only relative paths should be persisted.", "history": "Added in API level 19", "FullName": "public abstract File[] getExternalFilesDirs (String type)"}, "getString(int)": {"Returns": [["@B_java#lang#String_E@", "The string data associated with the resource, stripped of styled text information. This value will never be null."]], "Parameters": [["int", "int: Resource id for the string"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a localized string from the application's package's default string table.", "history": "Added in API level 1", "FullName": "public final String getString (int resId)"}, "setWallpaper(java.io.InputStream)": {"Returns": [], "Parameters": [["@B_java#io#InputStream_E@", "InputStream no parameter comment"]], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": ["@B_android#Manifest#permission#SET_WALLPAPER_E@"], "Description": "Use @B_android#app#WallpaperManager#setStream_E@ instead. This method requires the caller to hold the permission @B_android#Manifest#permission#SET_WALLPAPER_E@.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public abstract void setWallpaper (InputStream data)"}, "getWallpaper()": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#app#WallpaperManager#getDrawable_E@ instead.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public abstract Drawable getWallpaper ()"}, "sendBroadcast(android.content.Intent,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast."], ["@B_java#lang#String_E@", "String: (optional) String naming a permission that a receiver must hold in order to receive your broadcast. If null, no permission is required. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#BroadcastReceiver_E@", "@B_android#content#Context#registerReceiver_E@", "@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#sendOrderedBroadcast_E@"], "Permissions": [], "Description": "Broadcast the given intent to all interested BroadcastReceivers, allowing an optional required permission to be enforced. This call is asynchronous; it returns immediately, and you will continue executing while the receivers are run. No results are propagated from receivers and receivers can not abort the broadcast. If you want to allow receivers to propagate results or abort the broadcast, you must send an ordered broadcast using @B_android#content#Context#sendOrderedBroadcast_E@. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts.", "history": "Added in API level 1", "FullName": "public abstract void sendBroadcast (Intent intent, String receiverPermission)"}, "deleteFile(java.lang.String)": {"Returns": [["boolean", "true if the file was successfully deleted; else false."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the file to delete; can not contain path separators."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#openFileInput_E@", "@B_android#content#Context#openFileOutput_E@", "@B_android#content#Context#fileList_E@", "@B_java#io#File#delete_E@"], "Permissions": [], "Description": "Delete the given private file associated with this Context's application package.", "history": "Added in API level 1", "FullName": "public abstract boolean deleteFile (String name)"}, "sendOrderedBroadcast(android.content.Intent,java.lang.String)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast."], ["@B_java#lang#String_E@", "String: (optional) String naming a permissions that a receiver must hold in order to receive your broadcast. If null, no permission is required. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#BroadcastReceiver_E@", "@B_android#content#Context#registerReceiver_E@", "@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#sendOrderedBroadcast_E@"], "Permissions": [], "Description": "Broadcast the given intent to all interested BroadcastReceivers, delivering them one at a time to allow more preferred receivers to consume the broadcast before it is delivered to less preferred receivers. This call is asynchronous; it returns immediately, and you will continue executing while the receivers are run. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts.", "history": "Added in API level 1", "FullName": "public abstract void sendOrderedBroadcast (Intent intent, String receiverPermission)"}, "sendBroadcast(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast."]], "Throws": [], "SeeAlso": ["@B_android#content#BroadcastReceiver_E@", "@B_android#content#Context#registerReceiver_E@", "@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#sendOrderedBroadcast_E@"], "Permissions": [], "Description": "Broadcast the given intent to all interested BroadcastReceivers. This call is asynchronous; it returns immediately, and you will continue executing while the receivers are run. No results are propagated from receivers and receivers can not abort the broadcast. If you want to allow receivers to propagate results or abort the broadcast, you must send an ordered broadcast using @B_android#content#Context#sendOrderedBroadcast_E@. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts.", "history": "Added in API level 1", "FullName": "public abstract void sendBroadcast (Intent intent)"}, "getMainExecutor()": {"Returns": [["@B_java#util#concurrent#Executor_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return an @B_java#util#concurrent#Executor_E@ that will run enqueued tasks on the main thread associated with this context. This is the thread used to dispatch calls to application components (activities, services, etc).", "history": "Added in API level 28", "FullName": "public Executor getMainExecutor ()"}, "getCacheDir()": {"Returns": [["@B_java#io#File_E@", "The path of the directory holding application cache files."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#openFileOutput_E@", "@B_android#content#Context#getFileStreamPath_E@", "@B_android#content#Context#getDir_E@", "@B_android#content#Context#getExternalCacheDir_E@"], "Permissions": [], "Description": "Returns the absolute path to the application specific cache directory on the filesystem. The system will automatically delete files in this directory as disk space is needed elsewhere on the device. The system will always delete older files first, as reported by @B_java#io#File#lastModified_E@. If desired, you can exert more control over how files are deleted using @B_android#os#storage#StorageManager#setCacheBehaviorGroup_E@ and @B_android#os#storage#StorageManager#setCacheBehaviorTombstone_E@. Apps are strongly encouraged to keep their usage of cache space below the quota returned by @B_android#os#storage#StorageManager#getCacheQuotaBytes_E@. If your app goes above this quota, your cached files will be some of the first to be deleted when additional disk space is needed. Conversely, if your app stays under this quota, your cached files will be some of the last to be deleted when additional disk space is needed. Note that your cache quota will change over time depending on how frequently the user interacts with your app, and depending on how much system-wide disk space is used. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted. Apps require no extra permissions to read or write to the returned path, since this path lives in their private storage.", "history": "Added in API level 1", "FullName": "public abstract File getCacheDir ()"}, "getSystemServiceName(java.lang.Class<?>)": {"Returns": [["@B_java#lang#String_E@", "The service name or null if the class is not a supported system service."]], "Parameters": [["@B_java#lang#Class_E@", "Class: The class of the desired service. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the name of the system-level service that is represented by the specified class.", "history": "Added in API level 23", "FullName": "public abstract String getSystemServiceName (Class<?> serviceClass)"}, "registerReceiver(android.content.BroadcastReceiver,android.content.IntentFilter,java.lang.String,android.os.Handler)": {"Returns": [["@B_android#content#Intent_E@", "The first sticky intent found that matches filter, or null if there are none."]], "Parameters": [["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: The BroadcastReceiver to handle the broadcast."], ["@B_android#content#IntentFilter_E@", "IntentFilter: Selects the Intent broadcasts to be received."], ["@B_java#lang#String_E@", "String: String naming a permissions that a broadcaster must hold in order to send an Intent to you. If null, no permission is required. This value may be null."], ["@B_android#os#Handler_E@", "Handler: Handler identifying the thread that will receive the Intent. If null, the main thread of the process will be used. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#registerReceiver_E@", "@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#unregisterReceiver_E@"], "Permissions": [], "Description": "Register to receive intent broadcasts, to run in the context of @B_android#content#Context#registerReceiver_E@ for more information. This allows you to enforce permissions on who can broadcast intents to your receiver, or have the receiver run in a different thread than the main application thread. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts. As of @B_android#os#Build#VERSION_CODES#ICE_CREAM_SANDWICH_E@, receivers registered with this method will correctly respect the @B_android#content#Intent#setPackage_E@ specified for an Intent being broadcast. Prior to that, it would be ignored and delivered to all matching registered receivers. Be careful if using this for security.", "history": "Added in API level 1", "FullName": "public abstract Intent registerReceiver (BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)"}, "revokeUriPermission(java.lang.String,android.net.Uri,int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The package you had previously granted access to."], ["@B_android#net#Uri_E@", "Uri: The Uri you would like to revoke access to."], ["int", "int: The access modes to revoke. Value is either 0 or a combination of @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@, and @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@"]], "Throws": [], "SeeAlso": ["@B_android#content#Context#grantUriPermission_E@"], "Permissions": [], "Description": "Remove permissions to access a particular content provider Uri that were previously added with @B_android#content#Context#grantUriPermission_E@ for a specific target package. The given Uri will match all previously granted Uris that are the same or a sub-path of the given Uri. That is, revoking \"content://foo/target\" will revoke both \"content://foo/target\" and \"content://foo/target/sub\", but not \"content://foo\". It will not remove any prefix grants that exist at a higher level. Unlike @B_android#content#Context#revokeUriPermission_E@, this method will only revoke permissions that had been explicitly granted through @B_android#content#Context#grantUriPermission_E@ and only for the package specified. Any matching grants that have happened through other mechanisms (clipboard, activity launching, service starting, etc) will not be removed.", "history": "Added in API level 26", "FullName": "public abstract void revokeUriPermission (String toPackage, Uri uri, int modeFlags)"}, "deleteDatabase(java.lang.String)": {"Returns": [["boolean", "true if the database was successfully deleted; else false."]], "Parameters": [["@B_java#lang#String_E@", "String: The name (unique in the application package) of the database."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#openOrCreateDatabase_E@"], "Permissions": [], "Description": "Delete an existing private SQLiteDatabase associated with this Context's application package.", "history": "Added in API level 1", "FullName": "public abstract boolean deleteDatabase (String name)"}, "getPackageName()": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the name of this application's package.", "history": "Added in API level 1", "FullName": "public abstract String getPackageName ()"}, "getString(int,java.lang.Object...)": {"Returns": [["@B_java#lang#String_E@", "The string data associated with the resource, formatted and stripped of styled text information. This value will never be null."]], "Parameters": [["int", "int: Resource id for the format string"], ["@B_java#lang#Object_E@", "Object: The format arguments that will be used for substitution."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a localized formatted string from the application's package's default string table, substituting the format arguments as defined in @B_java#util#Formatter_E@ and @B_java#lang#String#format_E@.", "history": "Added in API level 1", "FullName": "public final String getString (int resId, Object... formatArgs)"}, "getColor(int)": {"Returns": [["int", "A single color value in the form 0xAARRGGBB."]], "Parameters": [["int", "int: The desired resource identifier, as generated by the aapt tool. This integer encodes the package, type, and resource entry. The value 0 is an invalid identifier."]], "Throws": [["@B_android#content#res#Resources#NotFoundException_E@", "if the given ID does not exist."]], "SeeAlso": [], "Permissions": [], "Description": "Returns a color associated with a particular resource ID and styled for the current theme.", "history": "Added in API level 23", "FullName": "public final int getColor (int id)"}, "bindService(android.content.Intent,int,java.util.concurrent.Executor,android.content.ServiceConnection)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#content#Intent_E@", "Intent: This value must never be null."], ["int", "int: Value is either 0 or a combination of @B_android#content#Context#BIND_AUTO_CREATE_E@, @B_android#content#Context#BIND_DEBUG_UNBIND_E@, @B_android#content#Context#BIND_NOT_FOREGROUND_E@, @B_android#content#Context#BIND_ABOVE_CLIENT_E@, @B_android#content#Context#BIND_ALLOW_OOM_MANAGEMENT_E@, @B_android#content#Context#BIND_WAIVE_PRIORITY_E@, @B_android#content#Context#BIND_IMPORTANT_E@, @B_android#content#Context#BIND_ADJUST_WITH_ACTIVITY_E@, @B_android#content#Context#BIND_NOT_PERCEPTIBLE_E@, and @B_android#content#Context#BIND_INCLUDE_CAPABILITIES_E@"], ["@B_java#util#concurrent#Executor_E@", "Executor: Callbacks on ServiceConnection will be called on executor. Must use same instance for the same instance of ServiceConnection. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#content#ServiceConnection_E@", "ServiceConnection: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Same as @B_android#content#Context#bindService_E@ with executor to control ServiceConnection callbacks.", "history": "Added in API level 29", "FullName": "public boolean bindService (Intent service, int flags, Executor executor, ServiceConnection conn)"}, "obtainStyledAttributes(int[])": {"Returns": [["@B_android#content#res#TypedArray_E@", "This value will never be null."]], "Parameters": [["int[]", "int: This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#content#res#Resources#Theme#obtainStyledAttributes_E@"], "Permissions": [], "Description": "Retrieve styled attribute information in this Context's theme. See @B_android#content#res#Resources#Theme#obtainStyledAttributes_E@ for more information.", "history": "Added in API level 1", "FullName": "public final TypedArray obtainStyledAttributes (int[] attrs)"}, "sendOrderedBroadcastAsUser(android.content.Intent,android.os.UserHandle,java.lang.String,android.content.BroadcastReceiver,android.os.Handler,int,java.lang.String,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast."], ["@B_android#os#UserHandle_E@", "UserHandle: UserHandle to send the intent to."], ["@B_java#lang#String_E@", "String: String naming a permissions that a receiver must hold in order to receive your broadcast. If null, no permission is required. This value may be null."], ["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: Your own BroadcastReceiver to treat as the final receiver of the broadcast."], ["@B_android#os#Handler_E@", "Handler: A custom Handler with which to schedule the resultReceiver callback; if null it will be scheduled in the Context's main thread. This value may be null."], ["int", "int: An initial value for the result code. Often Activity.RESULT_OK."], ["@B_java#lang#String_E@", "String: An initial value for the result data. Often null. This value may be null."], ["@B_android#os#Bundle_E@", "Bundle: An initial value for the result extras. Often null. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendOrderedBroadcast_E@"], "Permissions": [], "Description": "Version of @B_android#content#Context#sendOrderedBroadcast_E@ that allows you to specify the user the broadcast will be sent to. This is not available to applications that are not pre-installed on the system image. See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts. Requires android.Manifest.permission.INTERACT_ACROSS_USERS", "history": "Added in API level 17", "FullName": "public abstract void sendOrderedBroadcastAsUser (Intent intent, UserHandle user, String receiverPermission, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras)"}, "getFilesDir()": {"Returns": [["@B_java#io#File_E@", "The path of the directory holding application files."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Context#openFileOutput_E@", "@B_android#content#Context#getFileStreamPath_E@", "@B_android#content#Context#getDir_E@"], "Permissions": [], "Description": "Returns the absolute path to the directory on the filesystem where files created with @B_android#content#Context#openFileOutput_E@ are stored. The returned path may change over time if the calling app is moved to an adopted storage device, so only relative paths should be persisted. No additional permissions are required for the calling app to read or write files under the returned path.", "history": "Added in API level 1", "FullName": "public abstract File getFilesDir ()"}, "registerReceiver(android.content.BroadcastReceiver,android.content.IntentFilter)": {"Returns": [["@B_android#content#Intent_E@", "The first sticky intent found that matches filter, or null if there are none."]], "Parameters": [["@B_android#content#BroadcastReceiver_E@", "BroadcastReceiver: The BroadcastReceiver to handle the broadcast. This value may be null."], ["@B_android#content#IntentFilter_E@", "IntentFilter: Selects the Intent broadcasts to be received."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#registerReceiver_E@", "@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#unregisterReceiver_E@"], "Permissions": [], "Description": "Register a BroadcastReceiver to be run in the main activity thread. The The system may broadcast Intents that are \"sticky\" -- these stay around after the broadcast has finished, to be sent to any later registrations. If your IntentFilter matches one of these sticky Intents, that Intent will be returned by this function There may be multiple sticky Intents that match If you know the Intent your are registering for is sticky, you can supply null for your See @B_android#content#BroadcastReceiver_E@ for more information on Intent broadcasts. As of @B_android#os#Build#VERSION_CODES#ICE_CREAM_SANDWICH_E@, receivers registered with this method will correctly respect the @B_android#content#Intent#setPackage_E@ specified for an Intent being broadcast. Prior to that, it would be ignored and delivered to all matching registered receivers. Be careful if using this for security. Note: this method cannot be called from a @B_android#content#BroadcastReceiver_E@ component; that is, from a BroadcastReceiver that is declared in an application's manifest. It is okay, however, to call this method from another BroadcastReceiver that has itself been registered at run time with @B_android#content#Context#registerReceiver_E@, since the lifetime of such a registered BroadcastReceiver is tied to the object that registered it.", "history": "Added in API level 1", "FullName": "public abstract Intent registerReceiver (BroadcastReceiver receiver, IntentFilter filter)"}, "checkUriPermission(android.net.Uri, int, int, int)": {"Returns": [["int", "@B_android#content#pm#PackageManager#PERMISSION_GRANTED_E@ if the given pid/uid is allowed to access that uri, or @B_android#content#pm#PackageManager#PERMISSION_DENIED_E@ if it is not.Value is PERMISSION_GRANTED or PERMISSION_DENIED."]], "Parameters": [["@B_android#net#Uri_E@", "Uri: The uri that is being checked."], ["int", "int: The process ID being checked against. Must be > 0."], ["int", "int: The user ID being checked against. A uid of 0 is the root user, which will pass every permission check."], ["int", "int: The access modes to check.Value is either 0 or combination of FLAG_GRANT_READ_URI_PERMISSION or FLAG_GRANT_WRITE_URI_PERMISSION."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#checkCallingUriPermission_E@"], "Permissions": [], "Description": "Determine whether a particular process and user ID has been granted permission to access a specific URI. This only checks for permissions that have been explicitly granted -- if the given process/uid has more general access to the URI's content provider then this check will always fail.", "history": "added in API level 1", "FullName": "public abstract int checkUriPermission (Uri uri, int pid, int uid, int modeFlags)"}, "sendStickyBroadcast(android.content.Intent)": {"Returns": [], "Parameters": [["@B_android#content#Intent_E@", "Intent: The Intent to broadcast; all receivers matching this Intent will receive the broadcast, and the Intent will be held to be re-broadcast to future receivers."]], "Throws": [], "SeeAlso": ["@B_android#content#Context#sendBroadcast_E@", "@B_android#content#Context#sendStickyOrderedBroadcast_E@"], "Permissions": ["@B_android#Manifest#permission#BROADCAST_STICKY_E@"], "Description": "Sticky broadcasts should not be used. They provide no security (anyone can access them), no protection (anyone can modify them), and many other problems. The recommended pattern is to use a non-sticky broadcast to report that something has changed, with another mechanism for apps to retrieve the current value whenever desired. Perform a @B_android#content#Context#sendBroadcast_E@ that is \"sticky,\" meaning the Intent you are sending stays around after the broadcast is complete, so that others can quickly retrieve that data through the return value of @B_android#content#Context#registerReceiver_E@. In all other ways, this behaves the same as @B_android#content#Context#sendBroadcast_E@. Requires @B_android#Manifest#permission#BROADCAST_STICKY_E@", "history": "Added in API level 1 Deprecated in API level 21", "FullName": "public abstract void sendStickyBroadcast (Intent intent)"}}, "Inheritance": [], "ClassName": "android.content.Context", "ClassDesc": "Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc."}