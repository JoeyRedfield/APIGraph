{"Functions": {"toString()": {"Returns": [["@B_java#lang#String_E@", "the String representation of the current value"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the String representation of the current value.", "history": "Added in API level 24", "FullName": "public String toString ()"}, "LongAccumulator(java.util.function.LongBinaryOperator,long)": {"Returns": [], "Parameters": [["@B_java#util#function#LongBinaryOperator_E@", "LongBinaryOperator: a side-effect-free function of two arguments"], ["long", "long: identity (initial value) for the accumulator function"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a new instance using the given accumulator function and identity element.", "history": "Added in API level 24", "FullName": "public LongAccumulator (LongBinaryOperator accumulatorFunction, long identity)"}, "accumulate(long)": {"Returns": [], "Parameters": [["long", "long: the value"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Updates with the given value.", "history": "Added in API level 24", "FullName": "public void accumulate (long x)"}, "intValue()": {"Returns": [["int", "the numeric value represented by this object after conversion to type int."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the int after a narrowing primitive conversion.", "history": "Added in API level 24", "FullName": "public int intValue ()"}, "reset()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Resets variables maintaining updates to the identity value. This method may be a useful alternative to creating a new updater, but is only effective if there are no concurrent updates. Because this method is intrinsically racy, it should only be used when it is known that no threads are concurrently updating.", "history": "Added in API level 24", "FullName": "public void reset ()"}, "doubleValue()": {"Returns": [["double", "the numeric value represented by this object after conversion to type double."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the double after a widening primitive conversion.", "history": "Added in API level 24", "FullName": "public double doubleValue ()"}, "get()": {"Returns": [["long", "the current value"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current value. The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the value is being calculated might not be incorporated.", "history": "Added in API level 24", "FullName": "public long get ()"}, "floatValue()": {"Returns": [["float", "the numeric value represented by this object after conversion to type float."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the float after a widening primitive conversion.", "history": "Added in API level 24", "FullName": "public float floatValue ()"}, "getThenReset()": {"Returns": [["long", "the value before reset"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent in effect to @B_java#util#concurrent#atomic#LongAccumulator#get_E@ followed by @B_java#util#concurrent#atomic#LongAccumulator#reset_E@. This method may apply for example during quiescent points between multithreaded computations. If there are updates concurrent with this method, the returned value is not guaranteed to be the final value occurring before the reset.", "history": "Added in API level 24", "FullName": "public long getThenReset ()"}, "longValue()": {"Returns": [["long", "the current value"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Equivalent to @B_java#util#concurrent#atomic#LongAccumulator#get_E@.", "history": "Added in API level 24", "FullName": "public long longValue ()"}}, "Inheritance": ["@B_java#lang#Number_E@"], "ClassName": "java.util.concurrent.atomic.LongAccumulator", "ClassDesc": "One or more variables that together maintain a running long value updated using a supplied function. When updates (method @B_java#util#concurrent#atomic#LongAccumulator#accumulate_E@) are contended across threads, the set of variables may grow dynamically to reduce contention. Method @B_java#util#concurrent#atomic#LongAccumulator#get_E@ (or, equivalently, @B_java#util#concurrent#atomic#LongAccumulator#longValue_E@) returns the current value across the variables maintaining updates. This class is usually preferable to @B_java#util#concurrent#atomic#AtomicLong_E@ when multiple threads update a common value that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption. The order of accumulation within or across threads is not guaranteed and cannot be depended upon, so this class is only applicable to functions for which the order of accumulation does not matter. The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply Long::max along with Long.MIN_VALUE as the identity. Class @B_java#util#concurrent#atomic#LongAdder_E@ provides analogs of the functionality of this class for the common special case of maintaining counts and sums. The call new LongAdder() is equivalent to new LongAccumulator((x, y) -> x + y, 0L. This class extends @B_java#lang#Number_E@, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys."}