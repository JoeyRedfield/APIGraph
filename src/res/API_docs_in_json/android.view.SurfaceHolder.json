{"Functions": {"setKeepScreenOn(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Set to true to force the screen to stay on, false to allow it to turn off."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable option to keep the screen turned on while this surface is displayed. The default is false, allowing it to turn off. This is safe to call from any thread.", "history": "Added in API level 1", "FullName": "public abstract void setKeepScreenOn (boolean screenOn)"}, "setFixedSize(int, int)": {"Returns": [], "Parameters": [["int", "int: The surface's width."], ["int", "int: The surface's height."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Make the surface a fixed size. It will never change from this size. When working with a @B_android#view#SurfaceView_E@, this must be called from the same thread running the SurfaceView's window.", "history": "added in API level 1", "FullName": "public abstract void setFixedSize (int width, int height)"}, "setType(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "this is ignored, this value is set automatically when needed. Sets the surface's type.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public abstract void setType (int type)"}, "setFixedSize(int,int)": {"Returns": [], "Parameters": [["int", "int: The surface's width."], ["int", "int: The surface's height."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Make the surface a fixed size. It will never change from this size. When working with a @B_android#view#SurfaceView_E@, this must be called from the same thread running the SurfaceView's window.", "history": "Added in API level 1", "FullName": "public abstract void setFixedSize (int width, int height)"}, "setSizeFromLayout()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Allow the surface to resized based on layout of its container (this is the default). When this is enabled, you should monitor @B_android#view#SurfaceHolder#Callback#surfaceChanged_E@ for changes to the size of the surface. When working with a @B_android#view#SurfaceView_E@, this must be called from the same thread running the SurfaceView's window.", "history": "Added in API level 1", "FullName": "public abstract void setSizeFromLayout ()"}, "removeCallback(android.view.SurfaceHolder.Callback)": {"Returns": [], "Parameters": [["@B_android#view#SurfaceHolder#Callback_E@", "SurfaceHolder.Callback: The Callback interface to remove."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Removes a previously added Callback interface from this holder.", "history": "Added in API level 1", "FullName": "public abstract void removeCallback (SurfaceHolder.Callback callback)"}, "lockCanvas(android.graphics.Rect)": {"Returns": [["@B_android#graphics#Canvas_E@", "Canvas Use to draw into the surface."]], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: Area of the Surface that will be modified."]], "Throws": [], "SeeAlso": ["@B_android#view#SurfaceHolder#lockCanvas_E@"], "Permissions": [], "Description": "Just like @B_android#view#SurfaceHolder#lockCanvas_E@ but allows specification of a dirty rectangle. Every pixel within that rectangle must be written; however pixels outside the dirty rectangle will be preserved by the next call to lockCanvas().", "history": "Added in API level 1", "FullName": "public abstract Canvas lockCanvas (Rect dirty)"}, "lockHardwareCanvas()": {"Returns": [["@B_android#graphics#Canvas_E@", "Canvas Use to draw into the surface."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "If the canvas cannot be locked."]], "SeeAlso": [], "Permissions": [], "Description": "Just like @B_android#view#SurfaceHolder#lockCanvas_E@ but the returned canvas is hardware-accelerated. See the", "history": "Added in API level 26", "FullName": "public Canvas lockHardwareCanvas ()"}, "isCreating()": {"Returns": [["boolean", "true if the surface is in the process of being created."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use this method to find out if the surface is in the process of being created from Callback methods. This is intended to be used with @B_android#view#SurfaceHolder#Callback#surfaceChanged_E@.", "history": "Added in API level 1", "FullName": "public abstract boolean isCreating ()"}, "addCallback(android.view.SurfaceHolder.Callback)": {"Returns": [], "Parameters": [["@B_android#view#SurfaceHolder#Callback_E@", "SurfaceHolder.Callback: The new Callback interface."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add a Callback interface for this holder. There can several Callback interfaces associated with a holder.", "history": "Added in API level 1", "FullName": "public abstract void addCallback (SurfaceHolder.Callback callback)"}, "getSurface()": {"Returns": [["@B_android#view#Surface_E@", "Surface The surface."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Direct access to the surface object. The Surface may not always be available -- for example when using a @B_android#view#SurfaceView_E@ the holder's Surface is not created until the view has been attached to the window manager and performed a layout in order to determine the dimensions and screen position of the Surface. You will thus usually need to implement @B_android#view#SurfaceHolder#Callback#surfaceCreated_E@ to find out when the Surface is available for use. Note that if you directly access the Surface from another thread, it is critical that you correctly implement @B_android#view#SurfaceHolder#Callback#surfaceCreated_E@ and @B_android#view#SurfaceHolder#Callback#surfaceDestroyed_E@ to ensure that thread only accesses the Surface while it is valid, and that the Surface does not get destroyed while the thread is using it. This method is intended to be used by frameworks which often need direct access to the Surface object (usually to pass it to native code).", "history": "Added in API level 1", "FullName": "public abstract Surface getSurface ()"}, "getSurfaceFrame()": {"Returns": [["@B_android#graphics#Rect_E@", "Rect The surface's dimensions. The left and top are always 0."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the current size of the surface. Note: do not modify the returned Rect. This is only safe to call from the thread of @B_android#view#SurfaceView_E@'s window, or while inside of @B_android#view#SurfaceHolder#lockCanvas_E@.", "history": "Added in API level 1", "FullName": "public abstract Rect getSurfaceFrame ()"}, "setFormat(int)": {"Returns": [], "Parameters": [["int", "int: A constant from PixelFormat."]], "Throws": [], "SeeAlso": ["@B_android#graphics#PixelFormat_E@"], "Permissions": [], "Description": "Set the desired PixelFormat of the surface. The default is OPAQUE. When working with a @B_android#view#SurfaceView_E@, this must be called from the same thread running the SurfaceView's window.", "history": "Added in API level 1", "FullName": "public abstract void setFormat (int format)"}, "lockCanvas()": {"Returns": [["@B_android#graphics#Canvas_E@", "Canvas Use to draw into the surface."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Start editing the pixels in the surface. The returned Canvas can be used to draw into the surface's bitmap. A null is returned if the surface has not been created or otherwise cannot be edited. You will usually need to implement @B_android#view#SurfaceHolder#Callback#surfaceCreated_E@ to find out when the Surface is available for use. The content of the Surface is never preserved between unlockCanvas() and lockCanvas(), for this reason, every pixel within the Surface area must be written. The only exception to this rule is when a dirty rectangle is specified, in which case, non-dirty pixels will be preserved. If you call this repeatedly when the Surface is not ready (before @B_android#view#SurfaceHolder#Callback#surfaceCreated_E@ or after @B_android#view#SurfaceHolder#Callback#surfaceDestroyed_E@), your calls will be throttled to a slow rate in order to avoid consuming CPU. If null is not returned, this function internally holds a lock until the corresponding @B_android#view#SurfaceHolder#unlockCanvasAndPost_E@ call, preventing @B_android#view#SurfaceView_E@ from creating, destroying, or modifying the surface while it is being drawn. This can be more convenient than accessing the Surface directly, as you do not need to do special synchronization with a drawing thread in @B_android#view#SurfaceHolder#Callback#surfaceDestroyed_E@.", "history": "Added in API level 1", "FullName": "public abstract Canvas lockCanvas ()"}, "unlockCanvasAndPost(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: The Canvas previously returned by lockCanvas()."]], "Throws": [], "SeeAlso": ["@B_android#view#SurfaceHolder#lockCanvas_E@"], "Permissions": [], "Description": "Finish editing pixels in the surface. After this call, the surface's current pixels will be shown on the screen, but its content is lost, in particular there is no guarantee that the content of the Surface will remain unchanged when lockCanvas() is called again.", "history": "Added in API level 1", "FullName": "public abstract void unlockCanvasAndPost (Canvas canvas)"}}, "Inheritance": [], "ClassName": "android.view.SurfaceHolder", "ClassDesc": "Abstract interface to someone holding a display surface. Allows you to control the surface size and format, edit the pixels in the surface, and monitor changes to the surface. This interface is typically available through the @B_android#view#SurfaceView_E@ class. When using this interface from a thread other than the one running its @B_android#view#SurfaceView_E@, you will want to carefully read the methods @B_android#view#SurfaceHolder#lockCanvas_E@ and @B_android#view#SurfaceHolder#Callback#surfaceCreated_E@."}