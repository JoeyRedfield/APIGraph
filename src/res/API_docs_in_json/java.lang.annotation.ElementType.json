{"Functions": {"valueOf(java.lang.String)": {"Returns": [["@B_java#lang#annotation#ElementType_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static ElementType valueOf (String name)"}, "values()": {"Returns": [["@B_java#lang#annotation#ElementType_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static final ElementType[] values ()"}}, "Inheritance": ["@B_java#lang#Enum_E@"], "ClassName": "java.lang.annotation.ElementType", "ClassDesc": "The constants of this enumerated type provide a simple classification of the syntactic locations where annotations may appear in a Java program. These constants are used in @B_java#lang#annotation#Target_E@ meta-annotations to specify where it is legal to write annotations of a given type. The syntactic locations where annotations may appear are split into declaration contexts , where annotations apply to declarations, and type contexts , where annotations apply to types used in declarations and expressions. The constants @B_java#lang#annotation#ElementType#ANNOTATION_TYPE_E@ , @B_java#lang#annotation#ElementType#CONSTRUCTOR_E@ , @B_java#lang#annotation#ElementType#FIELD_E@ , @B_java#lang#annotation#ElementType#LOCAL_VARIABLE_E@ , @B_java#lang#annotation#ElementType#METHOD_E@ , @B_java#lang#annotation#ElementType#PACKAGE_E@ , @B_java#lang#annotation#ElementType#PARAMETER_E@ , @B_java#lang#annotation#ElementType#TYPE_E@ , and @B_java#lang#annotation#ElementType#TYPE_PARAMETER_E@ correspond to the declaration contexts in JLS 9.6.4.1. For example, an annotation whose type is meta-annotated with @Target(ElementType.FIELD) may only be written as a modifier for a field declaration. The constant @B_java#lang#annotation#ElementType#TYPE_USE_E@ corresponds to the 15 type contexts in JLS 4.11, as well as to two declaration contexts: type declarations (including annotation type declarations) and type parameter declarations. For example, an annotation whose type is meta-annotated with @Target(ElementType.TYPE_USE) may be written on the type of a field (or within the type of the field, if it is a nested, parameterized, or array type), and may also appear as a modifier for, say, a class declaration. The TYPE_USE constant includes type declarations and type parameter declarations as a convenience for designers of type checkers which give semantics to annotation types. For example, if the annotation type NonNull is meta-annotated with @Target(ElementType.TYPE_USE), then @NonNull class C {...} could be treated by a type checker as indicating that all variables of class C are non-null, while still allowing variables of other classes to be non-null or not non-null based on whether @NonNull appears at the variable's declaration."}