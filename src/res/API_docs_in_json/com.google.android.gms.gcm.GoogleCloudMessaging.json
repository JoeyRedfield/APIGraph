{"Functions": {"GoogleCloudMessaging()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "", "FullName": "public GoogleCloudMessaging ()"}, "getMessageType(android.content.Intent)": {"Returns": [["", "The message type or null if the intent is not a GCM intent"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the message type from an intent passed into a client app's broadcast receiver. There are two general categories of messages passed from the server: regular GCM messages, and special GCM status messages. The possible types are: @B_com#google#android#gms#gcm#GoogleCloudMessaging#MESSAGE_TYPE_MESSAGE_E@\u2014regular message from your server. @B_com#google#android#gms#gcm#GoogleCloudMessaging#MESSAGE_TYPE_DELETED_E@\u2014special status message indicating that some messages have been discarded because they exceeded the storage limits. @B_com#google#android#gms#gcm#GoogleCloudMessaging#MESSAGE_TYPE_SEND_ERROR_E@\u2014special status message indicating that there were errors sending one of the messages. You can use this method to filter based on message type. Since it is likely that GCM will be extended in the future with new message types, just ignore any message types you're not interested in, or that you don't recognize.", "history": "", "FullName": "public String getMessageType (Intent intent)"}, "send(java.lang.String, java.lang.String, long, android.os.Bundle)": {"Returns": [], "Parameters": [["String", "string identifying the receiver of the message in the format of SENDER_ID@gcm.googleapis.com. The SENDER_ID should be one of the sender IDs used in register()."], ["String", "ID of the message. This is generated by the application. It must be unique for each message. This allows error callbacks and debugging."], ["long", "If 0, we'll attempt to send immediately and return an error if we're not connected. Otherwise, the message will be queued. As for server-side messages, we don't return an error if the message has been dropped because of TTL\u2014this can happen on the server side, and it would require extra communication."], ["Bundle", "key/value pairs to be sent. Values must be String, any other type will be ignored."]], "Throws": [["IllegalArgumentException", ""], ["IOException", ""]], "SeeAlso": [], "Permissions": [], "Description": "Send an upstream (\"device to cloud\") message. You can only use the upstream feature if your GCM implementation uses the XMPP-based", "history": "", "FullName": "public void send (String to, String msgId, long timeToLive, Bundle data)"}, "send(java.lang.String, java.lang.String, android.os.Bundle)": {"Returns": [], "Parameters": [["String", "string identifying the receiver of the message in the format of SENDER_ID@gcm.googleapis.com. The SENDER_ID should be one of the sender IDs used in register()."], ["String", "ID of the message. This is generated by the application. It must be unique for each message. This allows error callbacks and debugging."], ["Bundle", "key/value pairs to be sent. Values must be String\u2014any other type will be ignored."]], "Throws": [["", "IllegalArgumentException"], ["IOException", ""]], "SeeAlso": [], "Permissions": [], "Description": "Send an upstream (\"device to cloud\") message. You can only use the upstream feature if your GCM implementation uses the XMPP-based", "history": "", "FullName": "public void send (String to, String msgId, Bundle data)"}, "unregister()": {"Returns": [], "Parameters": [], "Throws": [["IOException", "if we can't connect to server to unregister."]], "SeeAlso": [], "Permissions": [], "Description": "Unregister the application. Calling unregister() stops any messages from the server. This is a blocking call\u2014you shouldn't call it from the UI thread. You should rarely (if ever) need to call this method. Not only is it expensive in terms of resources, but it invalidates all your registration IDs returned from register() or subscribe(). This should not be done unnecessarily. A better approach is to simply have your server stop sending messages. Only use unregister if you want to change your sender ID.", "history": "", "FullName": "public synchronized void unregister ()"}, "close()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Must be called when your application is done using GCM, to release internal resources.", "history": "", "FullName": "public void close ()"}, "getInstance(android.content.Context)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the singleton instance of GCM.", "history": "", "FullName": "public static synchronized GoogleCloudMessaging getInstance (Context context)"}, "register(java.lang.String...)": {"Returns": [["", "registration id"]], "Parameters": [["String...", "list of project numbers or Google accounts identifying who is allowed to send messages to this application."]], "Throws": [["IOException", ""]], "SeeAlso": [], "Permissions": [], "Description": "Register the application for GCM and return the registration ID. You must call this once, when your application is installed, and send the returned registration ID to the server. Repeated calls to this method will return the original registration ID. If you want to modify the list of senders, you must call unregister() first. Most applications use a single sender ID. You may use multiple senders if different servers may send messages to the app or for testing.", "history": "", "FullName": "public synchronized String register (String... senderIds)"}}, "Inheritance": ["java.lang.Object"], "ClassName": "com.google.android.gms.gcm.GoogleCloudMessaging", "ClassDesc": "The class you use to write a GCM-enabled client application that runs on an Android device. Client applications can receive and send messages to the server. This class requires Google Play services version 3.1 or higher. For a detailed discussion of how to write a GCM client app, see To send or receive messages, your application first needs to get a registration ID. The registration ID identifies the device and application, and also determines which 3rd-party application servers are allowed to send messages to this application instance. To get a registration ID, you must supply one or more sender IDs. A sender ID is a project number you acquire from the API console, as described in @B_com#google#android#gms#gcm#GoogleCloudMessaging#register_E@ method. For a more comprehensive example, see In order to receive GCM messages, you need to declare a permission and a BroadcastReceiver in your manifest. This is a backward-compatible subset of what was required in previous versions of GCM. To allow the application to use GCM, add this permission to the manifest: GCM delivers messages as a broadcast. The receivers must be registered in the manifest in order to wake up the application. The com.google.android.c2dm.permission.SEND permission is held by Google Play services. This prevents other code from invoking the broadcast receiver. Here is an excerpt from a sample manifest: When a GCM connection server delivers the message to your client app, the BroadcastReceiver receives the message as an intent. You can either process the intent in the BroadcastReceiver, or you can pass off the work of processing the intent to a service (typically, an IntentService). If you use a service, your broadcast receiver should be an instance of WakefulBroadcastReceiver, to hold a wake lock while the service is doing its work. When processing the intent GCM passes into your app's broadcast receiver, you can determine the message type by calling @B_com#google#android#gms#gcm#GoogleCloudMessaging#getMessageType_E@. For example: If you are using the XMPP-based"}