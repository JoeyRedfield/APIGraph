{"Functions": {"MessageFormat(java.lang.String, java.util.Locale)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the pattern for this message format"], ["@B_java#util#Locale_E@", "Locale: the locale for this message format"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a MessageFormat for the specified locale and pattern. Sets the locale and calls applyPattern(pattern).", "history": "added in API level 24", "FullName": "public MessageFormat (String pattern, Locale locale)"}, "parseToMap(java.lang.String)": {"Returns": [["@B_java#util#Map_E@", "A Map parsed from the string."]], "Parameters": [["@B_java#lang#String_E@", "String: A String whose beginning should be parsed."]], "Throws": [["@B_java#text#ParseException_E@", "if the beginning of the specified string cannot be parsed."]], "SeeAlso": ["@B_android#icu#text#MessageFormat#parseToMap_E@"], "Permissions": [], "Description": "See the @B_android#icu#text#MessageFormat#parse_E@ method for more information on message parsing.", "history": "Added in API level 24", "FullName": "public Map<String, Object> parseToMap (String source)"}, "getArgumentNames()": {"Returns": [["@B_java#util#Set_E@", "a Set of argument names"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "@B_android#icu#text#MessageFormat#setFormatByArgumentName_E@.", "history": "Added in API level 24", "FullName": "public Set<String> getArgumentNames ()"}, "clone()": {"Returns": [["@B_java#lang#Object_E@", "a clone of this instance."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates and returns a copy of this object.", "history": "Added in API level 24", "FullName": "public Object clone ()"}, "format(java.lang.Object[],java.lang.StringBuffer,java.text.FieldPosition)": {"Returns": [["@B_java#lang#StringBuffer_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#Object_E@", "Object: an array of objects to be formatted and substituted."], ["@B_java#lang#StringBuffer_E@", "StringBuffer: where text is appended."], ["@B_java#text#FieldPosition_E@", "FieldPosition: On input: an alignment field, if desired. On output: the offsets of the alignment field."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if a value in the arguments array is not of the type expected by the corresponding argument or custom Format object."], ["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Formats an array of objects and appends the MessageFormat's pattern, with arguments replaced by the formatted objects, to the provided StringBuffer. The text substituted for the individual format elements is derived from the current subformat of the format element and the arguments element at the format element's argument index as indicated by the first matching line of the following table. An argument is arguments is null or has fewer than argumentIndex+1 elements. When an argument is unavailable no substitution is performed. If pos is non-null, and refers to Field.ARGUMENT, the location of the first formatted string will be returned. This method is only supported when the format does not use named arguments, otherwise an IllegalArgumentException is thrown.", "history": "Added in API level 24", "FullName": "public final StringBuffer format (Object[] arguments, StringBuffer result, FieldPosition pos)"}, "setFormat(int,java.text.Format)": {"Returns": [], "Parameters": [["int", "int: the index of a format element within the pattern"], ["@B_java#text#Format_E@", "Format: the format to use for the specified format element"]], "Throws": [["@B_java#lang#ArrayIndexOutOfBoundsException_E@", "if formatElementIndex is equal to or larger than the number of format elements in the pattern string"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the Format object to use for the format element with the given format element index within the previously set pattern string. The format element index is the zero-based number of the format element counting from the start of the pattern string. Since the order of format elements in a pattern string often changes during localization, it is generally better to use the @B_android#icu#text#MessageFormat#setFormatByArgumentIndex_E@ method, which accesses format elements based on the argument index they specify.", "history": "Added in API level 24", "FullName": "public void setFormat (int formatElementIndex, Format newFormat)"}, "MessageFormat(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the pattern for this message format"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"]], "SeeAlso": ["@B_android#icu#util#ULocale#Category_E@"], "Permissions": [], "Description": "Constructs a MessageFormat for the default FORMAT locale and the specified pattern. Sets the locale and calls applyPattern(pattern).", "history": "Added in API level 24", "FullName": "public MessageFormat (String pattern)"}, "MessageFormat(java.lang.String,java.util.Locale)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the pattern for this message format"], ["@B_java#util#Locale_E@", "Locale: the locale for this message format"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a MessageFormat for the specified locale and pattern. Sets the locale and calls applyPattern(pattern).", "history": "Added in API level 24", "FullName": "public MessageFormat (String pattern, Locale locale)"}, "getFormatsByArgumentIndex()": {"Returns": [["@B_java#text#Format_E@", "the formats used for the arguments within the pattern"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the Format objects used for the values passed into format methods or returned from parse methods. The indices of elements in the returned array correspond to the argument indices used in the previously set pattern string. The order of formats in the returned array thus corresponds to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods. If an argument index is used for more than one format element in the pattern string, then the format used for the last such format element is returned in the array. If an argument index is not used for any format element in the pattern string, then null is returned in the array. This method is only supported when exclusively numbers are used for argument names. Otherwise an IllegalArgumentException is thrown.", "history": "Added in API level 24", "FullName": "public Format[] getFormatsByArgumentIndex ()"}, "setFormatsByArgumentName(java.util.Map<java.lang.String,java.text.Format>)": {"Returns": [], "Parameters": [["@B_java#util#Map_E@", "Map: a map from String to Format providing new formats for named arguments."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "format methods or returned from parse methods. The keys in newFormats are the argument names in the previously set pattern string, and the values are the formats. Only argument names from the pattern string are considered. Extra keys in newFormats that do not correspond to an argument name are ignored. Similarly, if there is no format in newFormats for an argument name, the formatter for that argument remains unchanged. This may be called on formats that do not use named arguments. In this case the map will be queried for key Strings that represent argument indices, e.g. \"0\", \"1\", \"2\" etc.", "history": "Added in API level 24", "FullName": "public void setFormatsByArgumentName (Map<String, Format> newFormats)"}, "setFormatByArgumentIndex(int,java.text.Format)": {"Returns": [], "Parameters": [["int", "int: the argument index for which to use the new format"], ["@B_java#text#Format_E@", "Format: the new format to use"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the Format object to use for the format elements within the previously set pattern string that use the given argument index. The argument index is part of the format element definition and represents an index into the arguments array passed to the format methods or the result array returned by the parse methods. If the argument index is used for more than one format element in the pattern string, then the new format is used for all such format elements. If the argument index is not used for any format element in the pattern string, then the new format is ignored. This method is only supported when exclusively numbers are used for argument names. Otherwise an IllegalArgumentException is thrown.", "history": "Added in API level 24", "FullName": "public void setFormatByArgumentIndex (int argumentIndex, Format newFormat)"}, "parse(java.lang.String, java.text.ParsePosition)": {"Returns": [["@B_java#lang#Object_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"], ["@B_java#text#ParsePosition_E@", "ParsePosition no parameter comment"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Parses the string. Caveats: The parse may fail in a number of circumstances. For example: If one of the arguments does not occur in the pattern. If the format of an argument loses information, such as with a choice format where a large number formats to \"many\". Does not yet handle recursion (where the substituted strings contain {n} references.) Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the pattern \"{1},{2}\" is used with the string arguments {\"a,b\", \"c\"}, it will format as \"a,b,c\". When the result is parsed, it will return {\"a\", \"b,c\"}. If a single argument is parsed more than once in the string, then the later parse wins. When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string did the parsing failed. The returned error index is the starting offset of the sub-patterns that the string is comparing with. For example, if the parsing string \"AAA {0} BBB\" is comparing against the pattern \"AAD {0} BBB\", the error index is 0. When an error occurs, the call to this method will return null. If the source is null, return an empty array.", "history": "added in API level 24", "FullName": "public Object[] parse (String source, ParsePosition pos)"}, "format(java.util.Map<java.lang.String,java.lang.Object>,java.lang.StringBuffer,java.text.FieldPosition)": {"Returns": [["@B_java#lang#StringBuffer_E@", "the passed-in StringBuffer"]], "Parameters": [["@B_java#util#Map_E@", "Map: a map of objects to be formatted and substituted."], ["@B_java#lang#StringBuffer_E@", "StringBuffer: where text is appended."], ["@B_java#text#FieldPosition_E@", "FieldPosition: On input: an alignment field, if desired. On output: the offsets of the alignment field."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if a value in the arguments array is not of the type expected by the corresponding argument or custom Format object."]], "SeeAlso": [], "Permissions": [], "Description": "Formats a map of objects and appends the MessageFormat's pattern, with arguments replaced by the formatted objects, to the provided StringBuffer. The text substituted for the individual format elements is derived from the current subformat of the format element and the arguments value corresopnding to the format element's argument name. A numbered pattern argument is matched with a map key that contains that number as an ASCII-decimal-digit string (without leading zero). An argument is arguments is null or does not have a value corresponding to an argument name in the pattern. When an argument is unavailable no substitution is performed.", "history": "Added in API level 24", "FullName": "public final StringBuffer format (Map<String, Object> arguments, StringBuffer result, FieldPosition pos)"}, "parse(java.lang.String)": {"Returns": [["@B_java#lang#Object_E@", "An Object array parsed from the string."]], "Parameters": [["@B_java#lang#String_E@", "String: A String whose beginning should be parsed."]], "Throws": [["@B_java#text#ParseException_E@", "if the beginning of the specified string cannot be parsed."], ["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Parses text from the beginning of the given string to produce an object array. The method may not use the entire text of the given string. See the @B_android#icu#text#MessageFormat#parse_E@ method for more information on message parsing.", "history": "Added in API level 24", "FullName": "public Object[] parse (String source)"}, "getULocale()": {"Returns": [["@B_android#icu#util#ULocale_E@", "the locale used when creating or comparing subformats"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public ULocale getULocale ()"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if this object is the same as the obj argument; false otherwise."]], "Parameters": [["@B_java#lang#Object_E@", "Object: the reference object with which to compare."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether some other object is \"equal to\" this one. The equals method implements an equivalence relation on non-null object references: It is x, x.equals(x) should return true. It is x and y, x.equals(y) should return true if and only if y.equals(x) returns true. It is x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. It is x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. For any non-null reference value x, x.equals(null) should return false. The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true). Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.", "history": "Added in API level 24", "FullName": "public boolean equals (Object obj)"}, "applyPattern(java.lang.String,android.icu.text.MessagePattern.ApostropheMode)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the pattern for this message format"], ["@B_android#icu#text#MessagePattern#ApostropheMode_E@", "MessagePattern.ApostropheMode: the new ApostropheMode"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"]], "SeeAlso": ["@B_android#icu#text#MessagePattern#ApostropheMode_E@"], "Permissions": [], "Description": "This method is best used only once on a given object to avoid confusion about the mode, and after constructing the object with an empty pattern string to minimize overhead.", "history": "Added in API level 24", "FullName": "public void applyPattern (String pattern, MessagePattern.ApostropheMode aposMode)"}, "getApostropheMode()": {"Returns": [["@B_android#icu#text#MessagePattern#ApostropheMode_E@", "this instance's ApostropheMode."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public MessagePattern.ApostropheMode getApostropheMode ()"}, "setLocale(android.icu.util.ULocale)": {"Returns": [], "Parameters": [["@B_android#icu#util#ULocale_E@", "ULocale: the locale to be used when creating or comparing subformats"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the locale to be used for creating argument Format objects. This affects subsequent calls to the @B_android#icu#text#MessageFormat#applyPattern_E@ method as well as to the format and @B_android#icu#text#MessageFormat#formatToCharacterIterator_E@ methods.", "history": "Added in API level 24", "FullName": "public void setLocale (ULocale locale)"}, "applyPattern(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the pattern for this message format"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the pattern used by this message format. Parses the pattern and caches Format objects for simple argument types. Patterns and their interpretation are specified in the", "history": "Added in API level 24", "FullName": "public void applyPattern (String pttrn)"}, "hashCode()": {"Returns": [["int", "a hash code value for this object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by @B_java#util#HashMap_E@. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the @B_java#lang#Object#equals_E@ method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java\u2122 programming language.)", "history": "Added in API level 24", "FullName": "public int hashCode ()"}, "setFormat(int, java.text.Format)": {"Returns": [], "Parameters": [["int", "int: the index of a format element within the pattern"], ["@B_java#text#Format_E@", "Format: the format to use for the specified format element"]], "Throws": [["@B_java#lang#ArrayIndexOutOfBoundsException_E@", "if formatElementIndex is equal to or larger than the number of format elements in the pattern string"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the Format object to use for the format element with the given format element index within the previously set pattern string. The format element index is the zero-based number of the format element counting from the start of the pattern string. Since the order of format elements in a pattern string often changes during localization, it is generally better to use the @B_android#icu#text#MessageFormat#setFormatByArgumentIndex_E@ method, which accesses format elements based on the argument index they specify.", "history": "added in API level 24", "FullName": "public void setFormat (int formatElementIndex, Format newFormat)"}, "setFormatsByArgumentIndex(java.text.Format[])": {"Returns": [], "Parameters": [["@B_java#text#Format_E@", "Format: the new formats to use"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if newFormats is null"], ["@B_java#lang#IllegalArgumentException_E@", "if this formatter uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the Format objects to use for the values passed into format methods or returned from parse methods. The indices of elements in newFormats correspond to the argument indices used in the previously set pattern string. The order of formats in newFormats thus corresponds to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods. If an argument index is used for more than one format element in the pattern string, then the corresponding new format is used for all such format elements. If an argument index is not used for any format element in the pattern string, then the corresponding new format is ignored. If fewer formats are provided than needed, then only the formats for argument indices less than newFormats.length are replaced. This method is only supported if the format does not use named arguments, otherwise an IllegalArgumentException is thrown.", "history": "Added in API level 24", "FullName": "public void setFormatsByArgumentIndex (Format[] newFormats)"}, "usesNamedArguments()": {"Returns": [["boolean", "true if named arguments are used."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public boolean usesNamedArguments ()"}, "parse(java.lang.String,java.text.ParsePosition)": {"Returns": [["@B_java#lang#Object_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"], ["@B_java#text#ParsePosition_E@", "ParsePosition no parameter comment"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Parses the string. Caveats: The parse may fail in a number of circumstances. For example: If one of the arguments does not occur in the pattern. If the format of an argument loses information, such as with a choice format where a large number formats to \"many\". Does not yet handle recursion (where the substituted strings contain {n} references.) Will not always find a match (or the correct match) if some part of the parse is ambiguous. For example, if the pattern \"{1},{2}\" is used with the string arguments {\"a,b\", \"c\"}, it will format as \"a,b,c\". When the result is parsed, it will return {\"a\", \"b,c\"}. If a single argument is parsed more than once in the string, then the later parse wins. When the parse fails, use ParsePosition.getErrorIndex() to find out where in the string did the parsing failed. The returned error index is the starting offset of the sub-patterns that the string is comparing with. For example, if the parsing string \"AAA {0} BBB\" is comparing against the pattern \"AAD {0} BBB\", the error index is 0. When an error occurs, the call to this method will return null. If the source is null, return an empty array.", "history": "Added in API level 24", "FullName": "public Object[] parse (String source, ParsePosition pos)"}, "parseToMap(java.lang.String,java.text.ParsePosition)": {"Returns": [["@B_java#util#Map_E@", "a Map containing key/value pairs for each parsed argument."]], "Parameters": [["@B_java#lang#String_E@", "String: the text to parse"], ["@B_java#text#ParsePosition_E@", "ParsePosition: the position at which to start parsing. on return, contains the result of the parse."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 24", "FullName": "public Map<String, Object> parseToMap (String source, ParsePosition pos)"}, "setFormats(java.text.Format[])": {"Returns": [], "Parameters": [["@B_java#text#Format_E@", "Format: the new formats to use"]], "Throws": [["@B_java#lang#NullPointerException_E@", "if newFormats is null"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the Format objects to use for the format elements in the previously set pattern string. The order of formats in newFormats corresponds to the order of format elements in the pattern string. If more formats are provided than needed by the pattern string, the remaining ones are ignored. If fewer formats are provided than needed, then only the first newFormats.length formats are replaced. Since the order of format elements in a pattern string often changes during localization, it is generally better to use the @B_android#icu#text#MessageFormat#setFormatsByArgumentIndex_E@ method, which assumes an order of formats corresponding to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods.", "history": "Added in API level 24", "FullName": "public void setFormats (Format[] newFormats)"}, "setFormatByArgumentIndex(int, java.text.Format)": {"Returns": [], "Parameters": [["int", "int: the argument index for which to use the new format"], ["@B_java#text#Format_E@", "Format: the new format to use"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Sets the Format object to use for the format elements within the previously set pattern string that use the given argument index. The argument index is part of the format element definition and represents an index into the arguments array passed to the format methods or the result array returned by the parse methods. If the argument index is used for more than one format element in the pattern string, then the new format is used for all such format elements. If the argument index is not used for any format element in the pattern string, then the new format is ignored. This method is only supported when exclusively numbers are used for argument names. Otherwise an IllegalArgumentException is thrown.", "history": "added in API level 24", "FullName": "public void setFormatByArgumentIndex (int argumentIndex, Format newFormat)"}, "getLocale()": {"Returns": [["@B_java#util#Locale_E@", "the locale used when creating or comparing subformats"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the locale that's used when creating or comparing subformats.", "history": "Added in API level 24", "FullName": "public Locale getLocale ()"}, "getFormats()": {"Returns": [["@B_java#text#Format_E@", "the formats used for the format elements in the pattern"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the Format objects used for the format elements in the previously set pattern string. The order of formats in the returned array corresponds to the order of format elements in the pattern string. Since the order of format elements in a pattern string often changes during localization, it's generally better to use the @B_android#icu#text#MessageFormat#getFormatsByArgumentIndex_E@ method, which assumes an order of formats corresponding to the order of elements in the arguments array passed to the format methods or the result array returned by the parse methods. This method is only supported when exclusively numbers are used for argument names. Otherwise an IllegalArgumentException is thrown.", "history": "Added in API level 24", "FullName": "public Format[] getFormats ()"}, "format(java.lang.String, java.lang.Object...)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"], ["@B_java#lang#Object_E@", "Object no parameter comment"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"], ["@B_java#lang#IllegalArgumentException_E@", "if a value in the arguments array is not of the type expected by the corresponding argument or custom Format object."], ["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Creates a MessageFormat with the given pattern and uses it to format the given arguments. This is equivalent to", "history": "added in API level 24", "FullName": "public static String format (String pattern, Object... arguments)"}, "format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)": {"Returns": [["@B_java#lang#StringBuffer_E@", "the string buffer passed in as toAppendTo, with formatted text appended"]], "Parameters": [["@B_java#lang#Object_E@", "Object: a map or array of objects to be formatted"], ["@B_java#lang#StringBuffer_E@", "StringBuffer: where text is appended"], ["@B_java#text#FieldPosition_E@", "FieldPosition: On input: an alignment field, if desired On output: the offsets of the alignment field"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if an argument in arguments is not of the type expected by the format element(s) that use it"], ["@B_java#lang#IllegalArgumentException_E@", "if arguments is an array of Object and this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Formats a map or array of objects and appends the MessageFormat's pattern, with format elements replaced by the formatted objects, to the provided StringBuffer. This is equivalent to either of", "history": "Added in API level 24", "FullName": "public final StringBuffer format (Object arguments, StringBuffer result, FieldPosition pos)"}, "formatToCharacterIterator(java.lang.Object)": {"Returns": [["@B_java#text#AttributedCharacterIterator_E@", "AttributedCharacterIterator describing the formatted value."]], "Parameters": [["@B_java#lang#Object_E@", "Object: an array of objects to be formatted and substituted."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if arguments is null."], ["@B_java#lang#IllegalArgumentException_E@", "if a value in the arguments array is not of the type expected by the corresponding argument or custom Format object."]], "SeeAlso": [], "Permissions": [], "Description": "Formats an array of objects and inserts them into the MessageFormat's pattern, producing an AttributedCharacterIterator. You can use the returned AttributedCharacterIterator to build the resulting String, as well as to determine information about the resulting String. The text of the returned AttributedCharacterIterator is the same that would be returned by In addition, the AttributedCharacterIterator contains at least attributes indicating where text was generated from an argument in the arguments array. The keys of these attributes are of type MessageFormat.Field, their values are Integer objects indicating the index in the arguments array of the argument from which the text was generated. The attributes/value from the underlying Format instances that MessageFormat uses will also be placed in the resulting AttributedCharacterIterator. This allows you to not only find where an argument is placed in the resulting String, but also which fields it contains in turn.", "history": "Added in API level 24", "FullName": "public AttributedCharacterIterator formatToCharacterIterator (Object arguments)"}, "setFormatByArgumentName(java.lang.String,java.text.Format)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the name of the argument to change"], ["@B_java#text#Format_E@", "Format: the new format to use"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If the argument name is used for more than one format element in the pattern string, then the new format is used for all such format elements. If the argument name is not used for any format element in the pattern string, then the new format is ignored. This API may be used on formats that do not use named arguments. In this case argumentName should be a String that names an argument index, e.g. \"0\", \"1\", \"2\"... etc. If it does not name a valid index, the format will be ignored. No error is thrown.", "history": "Added in API level 24", "FullName": "public void setFormatByArgumentName (String argumentName, Format newFormat)"}, "parseObject(java.lang.String,java.text.ParsePosition)": {"Returns": [["@B_java#lang#Object_E@", "An Object parsed from the string, either an array of Object, or a Map, depending on whether named arguments are used. This can be queried using usesNamedArguments. In case of error, returns null."]], "Parameters": [["@B_java#lang#String_E@", "String: A String, part of which should be parsed."], ["@B_java#text#ParsePosition_E@", "ParsePosition: A ParsePosition object with index and error index information as described above."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if pos is null."]], "SeeAlso": [], "Permissions": [], "Description": "Parses text from a string to produce an object array or Map. The method attempts to parse text starting at the index given by pos. If parsing succeeds, then the index of pos is updated to the index after the last character used (parsing does not necessarily use all characters up to the end of the string), and the parsed object array is returned. The updated pos can be used to indicate the starting point for the next call to this method. If an error occurs, then the index of pos is not changed, the error index of pos is set to the index of the character where the error occurred, and null is returned. See the @B_android#icu#text#MessageFormat#parse_E@ method for more information on message parsing.", "history": "Added in API level 24", "FullName": "public Object parseObject (String source, ParsePosition pos)"}, "format(java.lang.String,java.lang.Object...)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"], ["@B_java#lang#Object_E@", "Object no parameter comment"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"], ["@B_java#lang#IllegalArgumentException_E@", "if a value in the arguments array is not of the type expected by the corresponding argument or custom Format object."], ["@B_java#lang#IllegalArgumentException_E@", "if this format uses named arguments"]], "SeeAlso": [], "Permissions": [], "Description": "Creates a MessageFormat with the given pattern and uses it to format the given arguments. This is equivalent to", "history": "Added in API level 24", "FullName": "public static String format (String pattern, Object... arguments)"}, "getFormatByArgumentName(java.lang.String)": {"Returns": [["@B_java#text#Format_E@", "the Format associated with the name, or null if there isn't one."]], "Parameters": [["@B_java#lang#String_E@", "String: The name of the desired argument."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "@B_android#icu#text#MessageFormat#setFormatByArgumentName_E@.", "history": "Added in API level 24", "FullName": "public Format getFormatByArgumentName (String argumentName)"}, "toPattern()": {"Returns": [["@B_java#lang#String_E@", "the pattern string"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "after custom Format objects have been set via setFormat() or similar APIs"]], "SeeAlso": [], "Permissions": [], "Description": "Returns the applied pattern string.", "history": "Added in API level 24", "FullName": "public String toPattern ()"}, "format(java.lang.String,java.util.Map<java.lang.String,java.lang.Object>)": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#String_E@", "String no parameter comment"], ["@B_java#util#Map_E@", "Map no parameter comment"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"], ["@B_java#lang#IllegalArgumentException_E@", "if a value in the arguments array is not of the type expected by the corresponding argument or custom Format object."]], "SeeAlso": ["@B_android#icu#text#MessageFormat#format_E@"], "Permissions": [], "Description": "Creates a MessageFormat with the given pattern and uses it to format the given arguments. The pattern must identifyarguments by name instead of by number.", "history": "Added in API level 24", "FullName": "public static String format (String pattern, Map<String, Object> arguments)"}, "autoQuoteApostrophe(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "the standard equivalent of the original pattern"]], "Parameters": [["@B_java#lang#String_E@", "String: the 'apostrophe-friendly' pattern to convert"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is obsolete for ICU 4.8 and higher MessageFormat pattern strings. It can still be useful together with @B_java#text#MessageFormat_E@. See the class description for more about apostrophes and quoting, and differences between ICU and @B_java#text#MessageFormat_E@. @B_java#text#MessageFormat_E@ and ICU 4.6 and earlier MessageFormat treat all ASCII apostrophes as quotes, which is problematic in some languages, e.g. French, where apostrophe is commonly used. This utility assumes that only an unpaired apostrophe immediately before a brace is a true quote. Other unpaired apostrophes are paired, and the resulting standard pattern string is returned.", "history": "Added in API level 24", "FullName": "public static String autoQuoteApostrophe (String pattern)"}, "setLocale(java.util.Locale)": {"Returns": [], "Parameters": [["@B_java#util#Locale_E@", "Locale: the locale to be used when creating or comparing subformats"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the locale to be used for creating argument Format objects. This affects subsequent calls to the @B_android#icu#text#MessageFormat#applyPattern_E@ method as well as to the format and @B_android#icu#text#MessageFormat#formatToCharacterIterator_E@ methods.", "history": "Added in API level 24", "FullName": "public void setLocale (Locale locale)"}, "MessageFormat(java.lang.String,android.icu.util.ULocale)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the pattern for this message format"], ["@B_android#icu#util#ULocale_E@", "ULocale: the locale for this message format"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the pattern is invalid"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a MessageFormat for the specified locale and pattern. Sets the locale and calls applyPattern(pattern).", "history": "Added in API level 24", "FullName": "public MessageFormat (String pattern, ULocale locale)"}}, "Inheritance": ["@B_java#text#Format_E@", "@B_android#icu#text#UFormat_E@"], "ClassName": "android.icu.text.MessageFormat", "ClassDesc": "@B_java#text#MessageFormat_E@. Methods, fields, and other functionality specific to ICU are labeled 'MessageFormat prepares strings for display to users, with optional arguments (variables/placeholders). The arguments can occur in any order, which is necessary for translation into languages with different grammars. A MessageFormat is constructed from a pattern string with arguments in {curly braces} which will be replaced by formatted values. MessageFormat differs from the other Format classes in that you create a MessageFormat object with one of its constructors (not with a getInstance style factory method). Factory methods aren't necessary because MessageFormat itself doesn't implement locale-specific behavior. Any locale-specific behavior is defined by the pattern that you provide and the subformats used for inserted arguments. Arguments can be named (using identifiers) or numbered (using small ASCII-digit integers). Some of the API methods work only with argument numbers and throw an exception if the pattern has named arguments (see @B_android#icu#text#MessageFormat#usesNamedArguments_E@). An argument might not specify any format type. In this case, a Number value is formatted with a default (for the locale) NumberFormat, a Date value is formatted with a default (for the locale) DateFormat, and for any other value its toString() value is used. An argument might specify a \"simple\" type for which the specified Format object is created, cached and used. An argument might have a \"complex\" type with nested MessageFormat sub-patterns. During formatting, one of these sub-messages is selected according to the argument value and recursively formatted. After construction, a custom Format object can be set for a top-level argument, overriding the default formatting and parsing behavior for that argument. However, custom formatting can be achieved more simply by writing a typeless argument in the pattern string and supplying it with a preformatted string value. When formatting, MessageFormat takes a collection of argument values and writes an output string. The argument values may be passed as an array (when the pattern contains only numbered arguments) or as a Map (which works for both named and numbered arguments). Each argument is matched with one of the input values by array index or map key and formatted according to its pattern specification (or using a custom Format object if one was set). A numbered pattern argument is matched with a map key that contains that number as an ASCII-decimal-digit string (without leading zero). MessageFormat uses patterns of the following form: messageText can contain quoted literal strings including syntax characters. A quoted literal string begins with an ASCII apostrophe and a syntax character (usually a {curly brace}) and continues until the next single apostrophe. A double ASCII apostrohpe inside or outside of a quoted string represents one literal apostrophe. Quotable syntax characters are the {curly braces} in all messageText parts, plus the '#' sign in a messageText immediately inside a pluralStyle, and the '|' symbol in a messageText immediately inside a choiceStyle. See also @B_android#icu#text#MessagePattern#ApostropheMode_E@ In argStyleText, every single ASCII apostrophe begins and ends quoted literal text, and unquoted {curly braces} must occur in matched pairs. Recommendation: Use the real apostrophe (single quote) character \\\\u2019 for human-readable text, and use the ASCII apostrophe (\\\\u0027 ' ) only in program syntax, like quoting in MessageFormat. See the annotations for U+0027 Apostrophe in The Unicode Standard. The choice argument type is deprecated. Use plural arguments for proper plural selection, and select arguments for simple selection among a fixed set of choices. The argType and argStyle values are used to create a Format instance for the format element. The following table shows how the values map to Format instances. Combinations not shown in the table are illegal. Any argStyleText must be a valid pattern string for the Format subclass used. The ICU MessageFormat supports both named and numbered arguments, while the JDK MessageFormat only supports numbered arguments. Named arguments make patterns more readable. ICU implements a more user-friendly apostrophe quoting syntax. In message text, an apostrophe only begins quoting literal text if it immediately precedes a syntax character (mostly {curly braces}). In the JDK MessageFormat, an apostrophe always begins quoting, which requires common text like \"don't\" and \"aujourd'hui\" to be written with doubled apostrophes like \"don''t\" and \"aujourd''hui\". For more details see @B_android#icu#text#MessagePattern#ApostropheMode_E@. ICU does not create a ChoiceFormat object for a choiceArg, pluralArg or selectArg but rather handles such arguments itself. The JDK MessageFormat does create and use a ChoiceFormat object (new ChoiceFormat(argStyleText)). The JDK does not support plural and select arguments at all. Here are some examples of usage: Example 2: For messages that include plural forms, you can use a plural argument: @B_android#icu#text#PluralFormat_E@ and @B_android#icu#text#PluralRules_E@ for details. MessageFormats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally."}