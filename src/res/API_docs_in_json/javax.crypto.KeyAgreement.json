{"Functions": {"getAlgorithm()": {"Returns": [["@B_java#lang#String_E@", "the algorithm name of this KeyAgreement object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the algorithm name of this KeyAgreement object. This is the same name that was specified in one of the getInstance calls that created this KeyAgreement object.", "history": "Added in API level 1", "FullName": "public final String getAlgorithm ()"}, "init(java.security.Key,java.security.spec.AlgorithmParameterSpec)": {"Returns": [], "Parameters": [["@B_java#security#Key_E@", "Key: the party's private information. For example, in the case of the Diffie-Hellman key agreement, this would be the party's own Diffie-Hellman private key."], ["@B_java#security#spec#AlgorithmParameterSpec_E@", "AlgorithmParameterSpec: the key agreement parameters"]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this key agreement, e.g., is of the wrong type or has an incompatible algorithm type."], ["@B_java#security#InvalidAlgorithmParameterException_E@", "if the given parameters are inappropriate for this key agreement."]], "SeeAlso": [], "Permissions": [], "Description": "Initializes this key agreement with the given key and set of algorithm parameters. If this key agreement requires any random bytes, it will get them using the @B_java#security#SecureRandom_E@ implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.)", "history": "Added in API level 1", "FullName": "public final void init (Key key, AlgorithmParameterSpec params)"}, "getInstance(java.lang.String,java.security.Provider)": {"Returns": [["@B_javax#crypto#KeyAgreement_E@", "the new KeyAgreement object."]], "Parameters": [["@B_java#lang#String_E@", "String: the standard name of the requested key agreement algorithm. See the KeyAgreement section in the Java Cryptography Architecture Standard Algorithm Name Documentation for information about standard algorithm names."], ["@B_java#security#Provider_E@", "Provider: the provider."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if the specified algorithm is null."], ["@B_java#security#NoSuchAlgorithmException_E@", "if a KeyAgreementSpi implementation for the specified algorithm is not available from the specified Provider object."], ["@B_java#lang#IllegalArgumentException_E@", "if the provider is null."]], "SeeAlso": ["@B_java#security#Provider_E@"], "Permissions": [], "Description": "Returns a KeyAgreement object that implements the specified key agreement algorithm. A new KeyAgreement object encapsulating the KeyAgreementSpi implementation from the specified Provider object is returned. Note that the specified Provider object does not have to be registered in the provider list.", "history": "Added in API level 1", "FullName": "public static final KeyAgreement getInstance (String algorithm, Provider provider)"}, "getProvider()": {"Returns": [["@B_java#security#Provider_E@", "the provider of this KeyAgreement object"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the provider of this KeyAgreement object.", "history": "Added in API level 1", "FullName": "public final Provider getProvider ()"}, "getInstance(java.lang.String, java.lang.String)": {"Returns": [["@B_javax#crypto#KeyAgreement_E@", "the new KeyAgreement object."]], "Parameters": [["@B_java#lang#String_E@", "String: the standard name of the requested key agreement algorithm. See the KeyAgreement section in the Java Cryptography Architecture Standard Algorithm Name Documentation for information about standard algorithm names."], ["@B_java#lang#String_E@", "String: the name of the provider."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if the specified algorithm is null."], ["@B_java#security#NoSuchAlgorithmException_E@", "if a KeyAgreementSpi implementation for the specified algorithm is not available from the specified provider."], ["@B_java#security#NoSuchProviderException_E@", "if the specified provider is not registered in the security provider list."], ["@B_java#lang#IllegalArgumentException_E@", "if the provider is null or empty."]], "SeeAlso": ["@B_java#security#Provider_E@"], "Permissions": [], "Description": "Returns a KeyAgreement object that implements the specified key agreement algorithm. A new KeyAgreement object encapsulating the KeyAgreementSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list. Note that the list of registered providers may be retrieved via the @B_java#security#Security#getProviders_E@ method.", "history": "added in API level 1", "FullName": "public static final KeyAgreement getInstance (String algorithm, String provider)"}, "init(java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom)": {"Returns": [], "Parameters": [["@B_java#security#Key_E@", "Key: the party's private information. For example, in the case of the Diffie-Hellman key agreement, this would be the party's own Diffie-Hellman private key."], ["@B_java#security#spec#AlgorithmParameterSpec_E@", "AlgorithmParameterSpec: the key agreement parameters"], ["@B_java#security#SecureRandom_E@", "SecureRandom: the source of randomness"]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this key agreement, e.g., is of the wrong type or has an incompatible algorithm type."], ["@B_java#security#InvalidAlgorithmParameterException_E@", "if the given parameters are inappropriate for this key agreement."]], "SeeAlso": [], "Permissions": [], "Description": "Initializes this key agreement with the given key, set of algorithm parameters, and source of randomness.", "history": "Added in API level 1", "FullName": "public final void init (Key key, AlgorithmParameterSpec params, SecureRandom random)"}, "init(java.security.Key)": {"Returns": [], "Parameters": [["@B_java#security#Key_E@", "Key: the party's private information. For example, in the case of the Diffie-Hellman key agreement, this would be the party's own Diffie-Hellman private key."]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this key agreement, e.g., is of the wrong type or has an incompatible algorithm type."]], "SeeAlso": [], "Permissions": [], "Description": "Initializes this key agreement with the given key, which is required to contain all the algorithm parameters required for this key agreement. If this key agreement requires any random bytes, it will get them using the @B_java#security#SecureRandom_E@ implementation of the highest-priority installed provider as the source of randomness. (If none of the installed providers supply an implementation of SecureRandom, a system-provided source of randomness will be used.)", "history": "Added in API level 1", "FullName": "public final void init (Key key)"}, "generateSecret(java.lang.String)": {"Returns": [["@B_javax#crypto#SecretKey_E@", "the shared secret key"]], "Parameters": [["@B_java#lang#String_E@", "String: the requested secret-key algorithm"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been completed yet"], ["@B_java#security#NoSuchAlgorithmException_E@", "if the specified secret-key algorithm is not available"], ["@B_java#security#InvalidKeyException_E@", "if the shared secret-key material cannot be used to generate a secret key of the specified algorithm (e.g., the key material is too short)"]], "SeeAlso": [], "Permissions": [], "Description": "Creates the shared secret and returns it as a SecretKey object of the specified algorithm. This method resets this KeyAgreement object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the init methods, the same private information and algorithm parameters will be used for subsequent key agreements.", "history": "Added in API level 1", "FullName": "public final SecretKey generateSecret (String algorithm)"}, "getInstance(java.lang.String)": {"Returns": [["@B_javax#crypto#KeyAgreement_E@", "the new KeyAgreement object."]], "Parameters": [["@B_java#lang#String_E@", "String: the standard name of the requested key agreement algorithm. See the KeyAgreement section in the Java Cryptography Architecture Standard Algorithm Name Documentation for information about standard algorithm names."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if the specified algorithm is null."], ["@B_java#security#NoSuchAlgorithmException_E@", "if no Provider supports a KeyAgreementSpi implementation for the specified algorithm."]], "SeeAlso": ["@B_java#security#Provider_E@"], "Permissions": [], "Description": "Returns a KeyAgreement object that implements the specified key agreement algorithm. This method traverses the list of registered security Providers, starting with the most preferred Provider. A new KeyAgreement object encapsulating the KeyAgreementSpi implementation from the first Provider that supports the specified algorithm is returned. Note that the list of registered providers may be retrieved via the @B_java#security#Security#getProviders_E@ method.", "history": "Added in API level 1", "FullName": "public static final KeyAgreement getInstance (String algorithm)"}, "generateSecret(byte[],int)": {"Returns": [["int", "the number of bytes placed into sharedSecret"]], "Parameters": [["byte[]", "byte: the buffer for the shared secret"], ["int", "int: the offset in sharedSecret where the shared secret will be stored"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been completed yet"], ["@B_javax#crypto#ShortBufferException_E@", "if the given output buffer is too small to hold the secret"]], "SeeAlso": [], "Permissions": [], "Description": "Generates the shared secret, and places it into the buffer sharedSecret, beginning at offset inclusive. If the sharedSecret buffer is too small to hold the result, a ShortBufferException is thrown. In this case, this call should be repeated with a larger output buffer. This method resets this KeyAgreement object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the init methods, the same private information and algorithm parameters will be used for subsequent key agreements.", "history": "Added in API level 1", "FullName": "public final int generateSecret (byte[] sharedSecret, int offset)"}, "generateSecret()": {"Returns": [["byte[]", "the new buffer with the shared secret"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been completed yet"]], "SeeAlso": [], "Permissions": [], "Description": "Generates the shared secret and returns it in a new buffer. This method resets this KeyAgreement object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the init methods, the same private information and algorithm parameters will be used for subsequent key agreements.", "history": "Added in API level 1", "FullName": "public final byte[] generateSecret ()"}, "getInstance(java.lang.String,java.lang.String)": {"Returns": [["@B_javax#crypto#KeyAgreement_E@", "the new KeyAgreement object."]], "Parameters": [["@B_java#lang#String_E@", "String: the standard name of the requested key agreement algorithm. See the KeyAgreement section in the Java Cryptography Architecture Standard Algorithm Name Documentation for information about standard algorithm names."], ["@B_java#lang#String_E@", "String: the name of the provider."]], "Throws": [["@B_java#lang#NullPointerException_E@", "if the specified algorithm is null."], ["@B_java#security#NoSuchAlgorithmException_E@", "if a KeyAgreementSpi implementation for the specified algorithm is not available from the specified provider."], ["@B_java#security#NoSuchProviderException_E@", "if the specified provider is not registered in the security provider list."], ["@B_java#lang#IllegalArgumentException_E@", "if the provider is null or empty."]], "SeeAlso": ["@B_java#security#Provider_E@"], "Permissions": [], "Description": "Returns a KeyAgreement object that implements the specified key agreement algorithm. A new KeyAgreement object encapsulating the KeyAgreementSpi implementation from the specified provider is returned. The specified provider must be registered in the security provider list. Note that the list of registered providers may be retrieved via the @B_java#security#Security#getProviders_E@ method.", "history": "Added in API level 1", "FullName": "public static final KeyAgreement getInstance (String algorithm, String provider)"}, "init(java.security.Key,java.security.SecureRandom)": {"Returns": [], "Parameters": [["@B_java#security#Key_E@", "Key: the party's private information. For example, in the case of the Diffie-Hellman key agreement, this would be the party's own Diffie-Hellman private key."], ["@B_java#security#SecureRandom_E@", "SecureRandom: the source of randomness"]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this key agreement, e.g., is of the wrong type or has an incompatible algorithm type."]], "SeeAlso": [], "Permissions": [], "Description": "Initializes this key agreement with the given key and source of randomness. The given key is required to contain all the algorithm parameters required for this key agreement. If the key agreement algorithm requires random bytes, it gets them from the given source of randomness, random. However, if the underlying algorithm implementation does not require any random bytes, random is ignored.", "history": "Added in API level 1", "FullName": "public final void init (Key key, SecureRandom random)"}, "generateSecret(byte[], int)": {"Returns": [["int", "the number of bytes placed into sharedSecret"]], "Parameters": [["byte[]", "byte: the buffer for the shared secret"], ["int", "int: the offset in sharedSecret where the shared secret will be stored"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been completed yet"], ["@B_javax#crypto#ShortBufferException_E@", "if the given output buffer is too small to hold the secret"]], "SeeAlso": [], "Permissions": [], "Description": "Generates the shared secret, and places it into the buffer sharedSecret, beginning at offset inclusive. If the sharedSecret buffer is too small to hold the result, a ShortBufferException is thrown. In this case, this call should be repeated with a larger output buffer. This method resets this KeyAgreement object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the init methods, the same private information and algorithm parameters will be used for subsequent key agreements.", "history": "added in API level 1", "FullName": "public final int generateSecret (byte[] sharedSecret, int offset)"}, "doPhase(java.security.Key, boolean)": {"Returns": [["@B_java#security#Key_E@", "the (intermediate) key resulting from this phase, or null if this phase does not yield a key"]], "Parameters": [["@B_java#security#Key_E@", "Key: the key for this phase. For example, in the case of Diffie-Hellman between 2 parties, this would be the other party's Diffie-Hellman public key."], ["boolean", "boolean: flag which indicates whether or not this is the last phase of this key agreement."]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this phase."], ["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Executes the next phase of this key agreement with the given key that was received from one of the other parties involved in this key agreement.", "history": "added in API level 1", "FullName": "public final Key doPhase (Key key, boolean lastPhase)"}, "KeyAgreement(javax.crypto.KeyAgreementSpi,java.security.Provider,java.lang.String)": {"Returns": [], "Parameters": [["@B_javax#crypto#KeyAgreementSpi_E@", "KeyAgreementSpi: the delegate"], ["@B_java#security#Provider_E@", "Provider: the provider"], ["@B_java#lang#String_E@", "String: the algorithm"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a KeyAgreement object.", "history": "Added in API level 1", "FullName": "protected KeyAgreement (KeyAgreementSpi keyAgreeSpi, Provider provider, String algorithm)"}, "doPhase(java.security.Key,boolean)": {"Returns": [["@B_java#security#Key_E@", "the (intermediate) key resulting from this phase, or null if this phase does not yield a key"]], "Parameters": [["@B_java#security#Key_E@", "Key: the key for this phase. For example, in the case of Diffie-Hellman between 2 parties, this would be the other party's Diffie-Hellman public key."], ["boolean", "boolean: flag which indicates whether or not this is the last phase of this key agreement."]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this phase."], ["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Executes the next phase of this key agreement with the given key that was received from one of the other parties involved in this key agreement.", "history": "Added in API level 1", "FullName": "public final Key doPhase (Key key, boolean lastPhase)"}}, "Inheritance": [], "ClassName": "javax.crypto.KeyAgreement", "ClassDesc": "This class provides the functionality of a key agreement (or key exchange) protocol. The keys involved in establishing a shared secret are created by one of the key generators (KeyPairGenerator or KeyGenerator), a KeyFactory, or as a result from an intermediate phase of the key agreement protocol. For each of the correspondents in the key exchange, doPhase needs to be called. For example, if this key exchange is with one other party, doPhase needs to be called once, with the lastPhase flag set to true. If this key exchange is with two other parties, doPhase needs to be called twice, the first time setting the lastPhase flag to false, and the second time setting it to true. There may be any number of parties involved in a key exchange. Android provides the following KeyAgreement algorithms:"}