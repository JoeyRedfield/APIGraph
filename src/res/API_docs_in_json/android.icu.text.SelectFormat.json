{"Functions": {"toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of the object. In general, the toString method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:", "history": "Added in API level 24", "FullName": "public String toString ()"}, "SelectFormat(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the pattern for this SelectFormat."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Creates a new SelectFormat for a given pattern string.", "history": "Added in API level 24", "FullName": "public SelectFormat (String pattern)"}, "format(java.lang.Object,java.lang.StringBuffer,java.text.FieldPosition)": {"Returns": [["@B_java#lang#StringBuffer_E@", "the string buffer passed in as toAppendTo, with formatted text appended."]], "Parameters": [["@B_java#lang#Object_E@", "Object: a phrase selection keyword."], ["@B_java#lang#StringBuffer_E@", "StringBuffer: the selected phrase will be appended to this StringBuffer."], ["@B_java#text#FieldPosition_E@", "FieldPosition: will be ignored by this method."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when the given keyword is not a String or not a \"pattern identifier\""]], "SeeAlso": [], "Permissions": [], "Description": "Selects the phrase for the given keyword. and appends the formatted message to the given StringBuffer.", "history": "Added in API level 24", "FullName": "public StringBuffer format (Object keyword, StringBuffer toAppendTo, FieldPosition pos)"}, "format(java.lang.String)": {"Returns": [["@B_java#lang#String_E@", "the string containing the formatted select message."]], "Parameters": [["@B_java#lang#String_E@", "String: a phrase selection keyword."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when the given keyword is not a \"pattern identifier\""]], "SeeAlso": [], "Permissions": [], "Description": "Selects the phrase for the given keyword.", "history": "Added in API level 24", "FullName": "public final String format (String keyword)"}, "parseObject(java.lang.String,java.text.ParsePosition)": {"Returns": [["@B_java#lang#Object_E@", "nothing because this method is not supported."]], "Parameters": [["@B_java#lang#String_E@", "String: the string to be parsed."], ["@B_java#text#ParsePosition_E@", "ParsePosition: defines the position where parsing is to begin, and upon return, the position where parsing left off. If the position has not changed upon return, then parsing failed."]], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "thrown always."]], "SeeAlso": [], "Permissions": [], "Description": "This method is not supported by SelectFormat.", "history": "Added in API level 24", "FullName": "public Object parseObject (String source, ParsePosition pos)"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if this object is the same as the obj argument; false otherwise."]], "Parameters": [["@B_java#lang#Object_E@", "Object: the reference object with which to compare."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether some other object is \"equal to\" this one. The equals method implements an equivalence relation on non-null object references: It is x, x.equals(x) should return true. It is x and y, x.equals(y) should return true if and only if y.equals(x) returns true. It is x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. It is x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. For any non-null reference value x, x.equals(null) should return false. The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true). Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.", "history": "Added in API level 24", "FullName": "public boolean equals (Object obj)"}, "toPattern()": {"Returns": [["@B_java#lang#String_E@", "the pattern string"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the pattern for this SelectFormat", "history": "Added in API level 24", "FullName": "public String toPattern ()"}, "applyPattern(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the pattern for this select format."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when the pattern is not a valid select format pattern."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the pattern used by this select format. Patterns and their interpretation are specified in the class description.", "history": "Added in API level 24", "FullName": "public void applyPattern (String pattern)"}, "hashCode()": {"Returns": [["int", "a hash code value for this object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by @B_java#util#HashMap_E@. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the @B_java#lang#Object#equals_E@ method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java\u2122 programming language.)", "history": "Added in API level 24", "FullName": "public int hashCode ()"}}, "Inheritance": ["@B_java#text#Format_E@"], "ClassName": "android.icu.text.SelectFormat", "ClassDesc": "SelectFormat supports the creation of internationalized messages by selecting phrases based on keywords. The pattern specifies how to map keywords to phrases and provides a default phrase. The object provided to the format method is a string that's matched against the keywords. If there is a match, the corresponding phrase is selected; otherwise, the default phrase is used. Note: Typically, select formatting is done via MessageFormat with a select argument type, rather than using a stand-alone SelectFormat. The main use case for the select format is gender based inflection. When names or nouns are inserted into sentences, their gender can affect pronouns, verb forms, articles, and adjectives. Special care needs to be taken for the case where the gender cannot be determined. The impact varies between languages: English has three genders, and unknown gender is handled as a special case. Names use the gender of the named person (if known), nouns referring to people use natural gender, and inanimate objects are usually neutral. The gender only affects pronouns: \"he\", \"she\", \"it\", \"they\". German differs from English in that the gender of nouns is rather arbitrary, even for nouns referring to people (\"M\u00e4dchen\", girl, is neutral). The gender affects pronouns (\"er\", \"sie\", \"es\"), articles (\"der\", \"die\", \"das\"), and adjective forms (\"guter Mann\", \"gute Frau\", \"gutes M\u00e4dchen\"). French has only two genders; as in German the gender of nouns is rather arbitrary - for sun and moon, the genders are the opposite of those in German. The gender affects pronouns (\"il\", \"elle\"), articles (\"le\", \"la\"), adjective forms (\"bon\", \"bonne\"), and sometimes verb forms (\"all\u00e9\", \"all\u00e9e\"). Polish distinguishes five genders (or noun classes), human masculine, animate non-human masculine, inanimate masculine, feminine, and neuter. Some other languages have noun classes that are not related to gender, but similar in grammatical use. Some African languages have around 20 noun classes. To enable localizers to create sentence patterns that take their language's gender dependencies into consideration, software has to provide information about the gender associated with a noun or name to MessageFormat. Two main cases can be distinguished: For people, natural gender information should be maintained for each person. Keywords like \"male\", \"female\", \"mixed\" (for groups of people) and \"unknown\" could be used. For nouns, grammatical gender information should be maintained for each noun and per language, e.g., in resource bundles. The keywords \"masculine\", \"feminine\", and \"neuter\" are commonly used, but some languages may require other keywords. The resulting keyword is provided to MessageFormat as a parameter separate from the name or noun it's associated with. For example, to generate a message such as \"Jean went to Paris\", three separate arguments would be provided: The name of the person as argument 0, the gender of the person as argument 1, and the name of the city as argument 2. The sentence pattern for English, where the gender of the person has no impact on this simple sentence, would not refer to argument 1 at all: The sentence pattern for French, where the gender of the person affects the form of the participle, uses a select format based on argument 1: Patterns can be nested, so that it's possible to handle interactions of number and gender where necessary. For example, if the above sentence should allow for the names of several people to be inserted, the following sentence pattern can be used (with argument 0 the list of people's names, argument 1 the number of people, argument 2 their combined gender, and argument 3 the city name): The SelectFormat pattern string defines the phrase output for each user-defined keyword. The pattern is a sequence of (keyword, message) pairs. A keyword is a \"pattern identifier\": [^[[:Pattern_Syntax:][:Pattern_White_Space:]]]+ Each message is a MessageFormat pattern string enclosed in {curly braces}. You always have to define a phrase for the default keyword other; this phrase is returned when the keyword provided to the format method matches no other keyword. If a pattern does not provide a phrase for other, the method it's provided to returns the error U_DEFAULT_KEYWORD_MISSING. Pattern_White_Space between keywords and messages is ignored. Pattern_White_Space within a message is preserved and output. Produces the output: Kirti est all\u00e9e \u00e0 Paris."}