{"Functions": {"stateSetMatches(int[], int[])": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int[]", "int: an array of required (if positive) or prohibited (if negative) @B_android#view#View_E@ states."], ["int[]", "int: an array of @B_android#view#View_E@ states"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return whether the stateSet matches the desired stateSpec.", "history": "added in API level 1", "FullName": "public static boolean stateSetMatches (int[] stateSpec, int[] stateSet)"}, "stateSetMatches(int[],int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int[]", "int: an array of required (if positive) or prohibited (if negative) @B_android#view#View_E@ states."], ["int", "int: a @B_android#view#View_E@ state"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return whether the state matches the desired stateSpec.", "history": "Added in API level 1", "FullName": "public static boolean stateSetMatches (int[] stateSpec, int state)"}, "dump(int[])": {"Returns": [["@B_java#lang#String_E@", "no returns description in source"]], "Parameters": [["int[]", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static String dump (int[] states)"}, "isWildCard(int[])": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int[]", "int: a state set or state spec."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return whether the stateSetOrSpec is matched by all StateSets.", "history": "Added in API level 1", "FullName": "public static boolean isWildCard (int[] stateSetOrSpec)"}, "stateSetMatches(int[], int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int[]", "int: an array of required (if positive) or prohibited (if negative) @B_android#view#View_E@ states."], ["int", "int: a @B_android#view#View_E@ state"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return whether the state matches the desired stateSpec.", "history": "added in API level 1", "FullName": "public static boolean stateSetMatches (int[] stateSpec, int state)"}, "trimStateSet(int[], int)": {"Returns": [["int[]", "no returns description in source"]], "Parameters": [["int[]", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public static int[] trimStateSet (int[] states, int newSize)"}, "stateSetMatches(int[],int[])": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int[]", "int: an array of required (if positive) or prohibited (if negative) @B_android#view#View_E@ states."], ["int[]", "int: an array of @B_android#view#View_E@ states"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return whether the stateSet matches the desired stateSpec.", "history": "Added in API level 1", "FullName": "public static boolean stateSetMatches (int[] stateSpec, int[] stateSet)"}, "trimStateSet(int[],int)": {"Returns": [["int[]", "no returns description in source"]], "Parameters": [["int[]", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public static int[] trimStateSet (int[] states, int newSize)"}}, "Inheritance": [], "ClassName": "android.util.StateSet", "ClassDesc": "State sets are arrays of positive ints where each element represents the state of a @B_android#view#View_E@ (e.g. focused, selected, visible, etc.). A @B_android#view#View_E@ may be in one or more of those states. A state spec is an array of signed ints where each element represents a required (if positive) or an undesired (if negative) @B_android#view#View_E@ state. Utils dealing with state sets. In theory we could encapsulate the state set and state spec arrays and not have static methods here but there is some concern about performance since these methods are called during view drawing."}