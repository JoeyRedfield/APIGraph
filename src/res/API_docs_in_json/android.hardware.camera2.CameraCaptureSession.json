{"Functions": {"CameraCaptureSession()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 21", "FullName": "public CameraCaptureSession ()"}, "prepare(android.view.Surface)": {"Returns": [], "Parameters": [["@B_android#view#Surface_E@", "Surface: the output Surface for which buffers should be pre-allocated. Must be one of the output Surfaces used to create this session. This value must never be null."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "if the Surface is invalid, not part of this Session, or has already been used as a target of a CaptureRequest in this session or immediately prior sessions."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#StateCallback#onSurfacePrepared_E@"], "Permissions": [], "Description": "Pre-allocate all buffers for an output Surface. Normally, the image buffers for a given output Surface are allocated on-demand, to minimize startup latency and memory overhead. However, in some cases, it may be desirable for the buffers to be allocated before any requests targeting the Surface are actually submitted to the device. Large buffers may take some time to allocate, which can result in delays in submitting requests until sufficient buffers are allocated to reach steady-state behavior. Such delays can cause bursts to take longer than desired, or cause skips or stutters in preview output. The prepare() method can be used to perform this preallocation. It may only be called for a given output Surface before that Surface is used as a target for a request. The number of buffers allocated is the sum of the count needed by the consumer providing the output Surface, and the maximum number needed by the camera device to fill its pipeline. Since this may be a larger number than what is actually required for steady-state operation, using prepare may result in higher memory consumption than the normal on-demand behavior results in. Prepare() will also delay the time to first output to a given Surface, in exchange for smoother frame rate once the allocation is complete. For example, an application that creates an @B_android#media#ImageReader#newInstance_E@ with a maxImages argument of 10, but only uses 3 simultaneous Images at once would normally only cause those 3 images to be allocated (plus what is needed by the camera device for smooth operation). But using prepare() on the ImageReader Surface will result in all 10 Images being allocated. So applications using this method should take care to request only the number of buffers actually necessary for their application. If the same output Surface is used in consecutive sessions (without closing the first session explicitly), then its already-allocated buffers are carried over, and if it was used as a target of a capture request in the first session, prepare cannot be called on it in the second session. Once allocation is complete, @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onSurfacePrepared_E@ will be invoked with the Surface provided to this method. Between the prepare call and the onSurfacePrepared call, the Surface provided to prepare must not be used as a target of a CaptureRequest submitted to this session. Note that if 2 surfaces share the same stream via @B_android#hardware#camera2#params#OutputConfiguration#enableSurfaceSharing_E@ and @B_android#hardware#camera2#params#OutputConfiguration#addSurface_E@, prepare() only needs to be called on one surface, and {link StateCallback#onSurfacePrepared} will be triggered for both surfaces. @B_android#hardware#camera2#CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY_E@ devices cannot pre-allocate output buffers; for those devices, @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onSurfacePrepared_E@ will be immediately called, and no preallocation is done.", "history": "Added in API level 23", "FullName": "public abstract void prepare (Surface surface)"}, "setRepeatingRequest(android.hardware.camera2.CaptureRequest,android.hardware.camera2.CameraCaptureSession.CaptureCallback,android.os.Handler)": {"Returns": [["int", "int A unique capture sequence ID used by @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureSequenceCompleted_E@."]], "Parameters": [["@B_android#hardware#camera2#CaptureRequest_E@", "CaptureRequest: the request to repeat indefinitely This value must never be null."], ["@B_android#hardware#camera2#CameraCaptureSession#CaptureCallback_E@", "CameraCaptureSession.CaptureCallback: The callback object to notify every time the request finishes processing. If null, no metadata will be produced for this stream of requests, although image data will still be produced. This value may be null."], ["@B_android#os#Handler_E@", "Handler: the handler on which the listener should be invoked, or null to use the current thread's @B_android#os#Looper_E@. This value may be null."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "If the request references no Surfaces or references Surfaces that are not currently configured as outputs; or the request is a reprocess capture request; or the capture targets a Surface in the middle of being @B_android#hardware#camera2#CameraCaptureSession#prepare_E@; or the handler is null, the listener is not null, and the calling thread has no looper; or no requests were passed in."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#capture_E@", "@B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#stopRepeating_E@", "@B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@"], "Permissions": [], "Description": "Request endlessly repeating capture of images by this capture session. With this method, the camera device will continually capture images using the settings in the provided @B_android#hardware#camera2#CaptureRequest_E@, at the maximum rate possible. Repeating requests are a simple way for an application to maintain a preview or other continuous stream of frames, without having to continually submit identical requests through @B_android#hardware#camera2#CameraCaptureSession#capture_E@. Repeat requests have lower priority than those submitted through @B_android#hardware#camera2#CameraCaptureSession#capture_E@ or @B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@, so if @B_android#hardware#camera2#CameraCaptureSession#capture_E@ is called when a repeating request is active, the capture request will be processed before any further repeating requests are processed. To stop the repeating capture, call @B_android#hardware#camera2#CameraCaptureSession#stopRepeating_E@. Calling @B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@ will also clear the request. Calling this method will replace any earlier repeating request or burst set up by this method or @B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@, although any in-progress burst will be completed before the new repeat request will be used. This method does not support reprocess capture requests because each reprocess @B_android#hardware#camera2#CaptureRequest_E@ must be created from the @B_android#hardware#camera2#TotalCaptureResult_E@ that matches the input image to be reprocessed. This is either the @B_android#hardware#camera2#TotalCaptureResult_E@ of capture that is sent for reprocessing, or one of the @B_android#hardware#camera2#TotalCaptureResult_E@ of a set of captures, when data from the whole set is combined by the application into a single reprocess input image. The request must be capturing images from the camera. If a reprocess capture request is submitted, this method will throw IllegalArgumentException.", "history": "Added in API level 21", "FullName": "public abstract int setRepeatingRequest (CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)"}, "setRepeatingBurst(java.util.List<android.hardware.camera2.CaptureRequest>,android.hardware.camera2.CameraCaptureSession.CaptureCallback,android.os.Handler)": {"Returns": [["int", "int A unique capture sequence ID used by @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureSequenceCompleted_E@."]], "Parameters": [["@B_java#util#List_E@", "List: the list of requests to cycle through indefinitely This value must never be null."], ["@B_android#hardware#camera2#CameraCaptureSession#CaptureCallback_E@", "CameraCaptureSession.CaptureCallback: The callback object to notify each time one of the requests in the repeating bursts has finished processing. If null, no metadata will be produced for this stream of requests, although image data will still be produced. This value may be null."], ["@B_android#os#Handler_E@", "Handler: the handler on which the listener should be invoked, or null to use the current thread's @B_android#os#Looper_E@. This value may be null."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "If the requests reference no Surfaces or reference Surfaces not currently configured as outputs; or one of the requests is a reprocess capture request; or one of the captures targets a Surface in the middle of being @B_android#hardware#camera2#CameraCaptureSession#prepare_E@; or the handler is null, the listener is not null, and the calling thread has no looper; or no requests were passed in."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#capture_E@", "@B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@", "@B_android#hardware#camera2#CameraCaptureSession#stopRepeating_E@", "@B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@"], "Permissions": [], "Description": "Request endlessly repeating capture of a sequence of images by this capture session. With this method, the camera device will continually capture images, cycling through the settings in the provided list of @B_android#hardware#camera2#CaptureRequest_E@, at the maximum rate possible. If a request is submitted through @B_android#hardware#camera2#CameraCaptureSession#capture_E@ or @B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@, the current repetition of the request list will be completed before the higher-priority request is handled. This guarantees that the application always receives a complete repeat burst captured in minimal time, instead of bursts interleaved with higher-priority captures, or incomplete captures. Repeating burst requests are a simple way for an application to maintain a preview or other continuous stream of frames where each request is different in a predicatable way, without having to continually submit requests through @B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@. To stop the repeating capture, call @B_android#hardware#camera2#CameraCaptureSession#stopRepeating_E@. Any ongoing burst will still be completed, however. Calling @B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@ will also clear the request. Calling this method will replace a previously-set repeating request or burst set up by this method or @B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@, although any in-progress burst will be completed before the new repeat burst will be used. This method does not support reprocess capture requests because each reprocess @B_android#hardware#camera2#CaptureRequest_E@ must be created from the @B_android#hardware#camera2#TotalCaptureResult_E@ that matches the input image to be reprocessed. This is either the @B_android#hardware#camera2#TotalCaptureResult_E@ of capture that is sent for reprocessing, or one of the @B_android#hardware#camera2#TotalCaptureResult_E@ of a set of captures, when data from the whole set is combined by the application into a single reprocess input image. The request must be capturing images from the camera. If a reprocess capture request is submitted, this method will throw IllegalArgumentException.", "history": "Added in API level 21", "FullName": "public abstract int setRepeatingBurst (List<CaptureRequest> requests, CameraCaptureSession.CaptureCallback listener, Handler handler)"}, "capture(android.hardware.camera2.CaptureRequest,android.hardware.camera2.CameraCaptureSession.CaptureCallback,android.os.Handler)": {"Returns": [["int", "int A unique capture sequence ID used by @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureSequenceCompleted_E@."]], "Parameters": [["@B_android#hardware#camera2#CaptureRequest_E@", "CaptureRequest: the settings for this capture This value must never be null."], ["@B_android#hardware#camera2#CameraCaptureSession#CaptureCallback_E@", "CameraCaptureSession.CaptureCallback: The callback object to notify once this request has been processed. If null, no metadata will be produced for this capture, although image data will still be produced. This value may be null."], ["@B_android#os#Handler_E@", "Handler: the handler on which the listener should be invoked, or null to use the current thread's @B_android#os#Looper_E@. This value may be null."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "if the request targets no Surfaces or Surfaces that are not configured as outputs for this session; or the request targets a set of Surfaces that cannot be submitted simultaneously in a reprocessable capture session; or a reprocess capture request is submitted in a non-reprocessable capture session; or the reprocess capture request was created with a @B_android#hardware#camera2#TotalCaptureResult_E@ from a different session; or the capture targets a Surface in the middle of being @B_android#hardware#camera2#CameraCaptureSession#prepare_E@; or the handler is null, the listener is not null, and the calling thread has no looper."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@", "@B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@"], "Permissions": [], "Description": "Submit a request for an image to be captured by the camera device. The request defines all the parameters for capturing the single image, including sensor, lens, flash, and post-processing settings. Each request will produce one @B_android#hardware#camera2#CaptureResult_E@ and produce new frames for one or more target Surfaces, set with the CaptureRequest builder's @B_android#hardware#camera2#CaptureRequest#Builder#addTarget_E@ method. The target surfaces (set with @B_android#hardware#camera2#CaptureRequest#Builder#addTarget_E@) must be a subset of the surfaces provided when this capture session was created. Multiple regular and reprocess requests can be in progress at once. If there are only regular requests or reprocess requests in progress, they are processed in first-in, first-out order. If there are both regular and reprocess requests in progress, regular requests are processed in first-in, first-out order and reprocess requests are processed in first-in, first-out order, respectively. However, the processing order of a regular request and a reprocess request in progress is not specified. In other words, a regular request will always be processed before regular requets that are submitted later. A reprocess request will always be processed before reprocess requests that are submitted later. However, a regular request may not be processed before reprocess requests that are submitted later. Requests submitted through this method have higher priority than those submitted through @B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@ or @B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@, and will be processed as soon as the current repeat/repeatBurst processing completes. All capture sessions can be used for capturing images from the camera but only capture sessions created by @B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@ can submit reprocess capture requests. Submitting a reprocess request to a regular capture session will result in an @B_java#lang#IllegalArgumentException_E@.", "history": "Added in API level 21", "FullName": "public abstract int capture (CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)"}, "close()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Close this capture session asynchronously. Closing a session frees up the target output Surfaces of the session for reuse with either a new session, or to other APIs that can draw to Surfaces. Note that creating a new capture session with @B_android#hardware#camera2#CameraDevice#createCaptureSession_E@ will close any existing capture session automatically, and call the older session listener's @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onClosed_E@ callback. Using @B_android#hardware#camera2#CameraDevice#createCaptureSession_E@ directly without closing is the recommended approach for quickly switching to a new session, since unchanged target outputs can be reused more efficiently. Once a session is closed, all methods on it will throw an IllegalStateException, and any repeating requests or bursts are stopped (as if @B_android#hardware#camera2#CameraCaptureSession#stopRepeating_E@ was called). However, any in-progress capture requests submitted to the session will be completed as normal; once all captures have completed and the session has been torn down, @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onClosed_E@ will be called. Closing a session is idempotent; closing more than once has no effect.", "history": "Added in API level 21", "FullName": "public abstract void close ()"}, "setSingleRepeatingRequest(android.hardware.camera2.CaptureRequest,java.util.concurrent.Executor,android.hardware.camera2.CameraCaptureSession.CaptureCallback)": {"Returns": [["int", "int A unique capture sequence ID used by @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureSequenceCompleted_E@."]], "Parameters": [["@B_android#hardware#camera2#CaptureRequest_E@", "CaptureRequest: the request to repeat indefinitely This value must never be null."], ["@B_java#util#concurrent#Executor_E@", "Executor: the executor which will be used for invoking the listener. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#hardware#camera2#CameraCaptureSession#CaptureCallback_E@", "CameraCaptureSession.CaptureCallback: The callback object to notify every time the request finishes processing. This value must never be null."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "If the request references no Surfaces or references Surfaces that are not currently configured as outputs; or the request is a reprocess capture request; or the capture targets a Surface in the middle of being @B_android#hardware#camera2#CameraCaptureSession#prepare_E@; or the executor is null; or the listener is null."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#capture_E@", "@B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#stopRepeating_E@", "@B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@"], "Permissions": [], "Description": "Request endlessly repeating capture of images by this capture session. The behavior of this method matches that of @B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@, except that it uses @B_java#util#concurrent#Executor_E@ as an argument instead of @B_android#os#Handler_E@.", "history": "Added in API level 28", "FullName": "public int setSingleRepeatingRequest (CaptureRequest request, Executor executor, CameraCaptureSession.CaptureCallback listener)"}, "finalizeOutputConfigurations(java.util.List<android.hardware.camera2.params.OutputConfiguration>)": {"Returns": [], "Parameters": [["@B_java#util#List_E@", "List: a list of @B_android#hardware#camera2#params#OutputConfiguration_E@ that have had @B_android#hardware#camera2#params#OutputConfiguration#addSurface_E@ invoked with a valid output Surface after @B_android#hardware#camera2#CameraDevice#createCaptureSessionByOutputConfigurations_E@."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error."], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created, or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "for invalid output configurations, including ones where the source of the Surface is no longer valid or the Surface is from a unsupported source. Or if one of the output configuration was already finished with an included surface in a prior call."]], "SeeAlso": [], "Permissions": [], "Description": "Finalize the output configurations that now have their deferred and/or extra Surfaces included. For camera use cases where a preview and other output configurations need to be configured, it can take some time for the preview Surface to be ready. For example, if the preview Surface is obtained from @B_android#view#SurfaceView_E@, the SurfaceView will only be ready after the UI layout is done, potentially delaying camera startup. To speed up camera startup time, the application can configure the @B_android#hardware#camera2#CameraCaptureSession_E@ with the eventual preview size (via @B_android#hardware#camera2#params#OutputConfiguration#OutputConfiguration_E@), and defer the preview output configuration until the Surface is ready. After the @B_android#hardware#camera2#CameraCaptureSession_E@ is created successfully with this deferred output and other normal outputs, the application can start submitting requests as long as they do not include deferred output Surfaces. Once a deferred Surface is ready, the application can add the Surface to the deferred output configuration with the @B_android#hardware#camera2#params#OutputConfiguration#addSurface_E@ method, and then update the deferred output configuration via this method, before it can submit capture requests with this output target. This function can also be called in case where multiple surfaces share the same OutputConfiguration, and one of the surfaces becomes available after the @B_android#hardware#camera2#CameraCaptureSession_E@ is created. In that case, the application must first create the OutputConfiguration with the available Surface, then enable further surface sharing via @B_android#hardware#camera2#params#OutputConfiguration#enableSurfaceSharing_E@, before creating the CameraCaptureSession. After the CameraCaptureSession is created, and once the extra Surface becomes available, the application must then call @B_android#hardware#camera2#params#OutputConfiguration#addSurface_E@ before finalizing the configuration with this method. If the provided OutputConfigurations are unchanged from session creation, this function call has no effect. This function must only be called once for a particular output configuration. The output Surfaces included by this list of @B_android#hardware#camera2#params#OutputConfiguration_E@ can be used as @B_android#hardware#camera2#CaptureRequest_E@ targets as soon as this call returns. This method is not supported by @B_android#hardware#camera2#CameraMetadata#INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY_E@-level devices.", "history": "Added in API level 26", "FullName": "public abstract void finalizeOutputConfigurations (List<OutputConfiguration> outputConfigs)"}, "stopRepeating()": {"Returns": [], "Parameters": [], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#StateCallback#onReady_E@"], "Permissions": [], "Description": "Cancel any ongoing repeating capture set by either @B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@ or @B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@. Has no effect on requests submitted through @B_android#hardware#camera2#CameraCaptureSession#capture_E@ or @B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@. Any currently in-flight captures will still complete, as will any burst that is mid-capture. To ensure that the device has finished processing all of its capture requests and is in ready state, wait for the @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onReady_E@ callback after calling this method.", "history": "Added in API level 21", "FullName": "public abstract void stopRepeating ()"}, "abortCaptures()": {"Returns": [], "Parameters": [], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@", "@B_android#hardware#camera2#CameraDevice#createCaptureSession_E@", "@B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@"], "Permissions": [], "Description": "Discard all captures currently pending and in-progress as fast as possible. The camera device will discard all of its current work as fast as possible. Some in-flight captures may complete successfully and call @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureCompleted_E@, while others will trigger their @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureFailed_E@ callbacks. If a repeating request or a repeating burst is set, it will be cleared. This method is the fastest way to switch the camera device to a new session with @B_android#hardware#camera2#CameraDevice#createCaptureSession_E@ or @B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@, at the cost of discarding in-progress work. It must be called before the new session is created. Once all pending requests are either completed or thrown away, the @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onReady_E@ callback will be called, if the session has not been closed. Otherwise, the @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onClosed_E@ callback will be fired when a new session is created by the camera device. Cancelling will introduce at least a brief pause in the stream of data from the camera device, since once the camera device is emptied, the first new request has to make it through the entire camera pipeline before new output buffers are produced. This means that using abortCaptures() to simply remove pending requests is not recommended; it's best used for quickly switching output configurations, or for cancelling long in-progress requests (such as a multi-second capture).", "history": "Added in API level 21", "FullName": "public abstract void abortCaptures ()"}, "setRepeatingBurstRequests(java.util.List<android.hardware.camera2.CaptureRequest>,java.util.concurrent.Executor,android.hardware.camera2.CameraCaptureSession.CaptureCallback)": {"Returns": [["int", "int A unique capture sequence ID used by @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureSequenceCompleted_E@."]], "Parameters": [["@B_java#util#List_E@", "List: the list of requests to cycle through indefinitely This value must never be null."], ["@B_java#util#concurrent#Executor_E@", "Executor: the executor which will be used for invoking the listener. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#hardware#camera2#CameraCaptureSession#CaptureCallback_E@", "CameraCaptureSession.CaptureCallback: The callback object to notify each time one of the requests in the repeating bursts has finished processing. This value must never be null."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "If the requests reference no Surfaces or reference Surfaces not currently configured as outputs; or one of the requests is a reprocess capture request; or one of the captures targets a Surface in the middle of being @B_android#hardware#camera2#CameraCaptureSession#prepare_E@; or the executor is null; or the listener is null."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#capture_E@", "@B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@", "@B_android#hardware#camera2#CameraCaptureSession#stopRepeating_E@", "@B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@"], "Permissions": [], "Description": "Request endlessly repeating capture of a sequence of images by this capture session. The behavior of this method matches that of @B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@, except that it uses @B_java#util#concurrent#Executor_E@ as an argument instead of @B_android#os#Handler_E@.", "history": "Added in API level 28", "FullName": "public int setRepeatingBurstRequests (List<CaptureRequest> requests, Executor executor, CameraCaptureSession.CaptureCallback listener)"}, "captureSingleRequest(android.hardware.camera2.CaptureRequest,java.util.concurrent.Executor,android.hardware.camera2.CameraCaptureSession.CaptureCallback)": {"Returns": [["int", "int A unique capture sequence ID used by @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureSequenceCompleted_E@."]], "Parameters": [["@B_android#hardware#camera2#CaptureRequest_E@", "CaptureRequest: the settings for this capture This value must never be null."], ["@B_java#util#concurrent#Executor_E@", "Executor: the executor which will be used for invoking the listener. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#hardware#camera2#CameraCaptureSession#CaptureCallback_E@", "CameraCaptureSession.CaptureCallback: The callback object to notify once this request has been processed. This value must never be null."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "if the request targets no Surfaces or Surfaces that are not configured as outputs for this session; or the request targets a set of Surfaces that cannot be submitted simultaneously in a reprocessable capture session; or a reprocess capture request is submitted in a non-reprocessable capture session; or the reprocess capture request was created with a @B_android#hardware#camera2#TotalCaptureResult_E@ from a different session; or the capture targets a Surface in the middle of being @B_android#hardware#camera2#CameraCaptureSession#prepare_E@; or the executor is null, or the listener is not null."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@", "@B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@"], "Permissions": [], "Description": "Submit a request for an image to be captured by the camera device. The behavior of this method matches that of @B_android#hardware#camera2#CameraCaptureSession#capture_E@, except that it uses @B_java#util#concurrent#Executor_E@ as an argument instead of @B_android#os#Handler_E@.", "history": "Added in API level 28", "FullName": "public int captureSingleRequest (CaptureRequest request, Executor executor, CameraCaptureSession.CaptureCallback listener)"}, "captureBurst(java.util.List<android.hardware.camera2.CaptureRequest>,android.hardware.camera2.CameraCaptureSession.CaptureCallback,android.os.Handler)": {"Returns": [["int", "int A unique capture sequence ID used by @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureSequenceCompleted_E@."]], "Parameters": [["@B_java#util#List_E@", "List: the list of settings for this burst capture This value must never be null."], ["@B_android#hardware#camera2#CameraCaptureSession#CaptureCallback_E@", "CameraCaptureSession.CaptureCallback: The callback object to notify each time one of the requests in the burst has been processed. If null, no metadata will be produced for any requests in this burst, although image data will still be produced. This value may be null."], ["@B_android#os#Handler_E@", "Handler: the handler on which the listener should be invoked, or null to use the current thread's @B_android#os#Looper_E@. This value may be null."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "If the requests target no Surfaces, or the requests target Surfaces not currently configured as outputs; or one of the requests targets a set of Surfaces that cannot be submitted simultaneously in a reprocessable capture session; or a reprocess capture request is submitted in a non-reprocessable capture session; or one of the reprocess capture requests was created with a @B_android#hardware#camera2#TotalCaptureResult_E@ from a different session; or one of the captures targets a Surface in the middle of being @B_android#hardware#camera2#CameraCaptureSession#prepare_E@; or if the handler is null, the listener is not null, and the calling thread has no looper."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#capture_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@"], "Permissions": [], "Description": "Submit a list of requests to be captured in sequence as a burst. The burst will be captured in the minimum amount of time possible, and will not be interleaved with requests submitted by other capture or repeat calls. Regular and reprocess requests can be mixed together in a single burst. Regular requests will be captured in order and reprocess requests will be processed in order, respectively. However, the processing order between a regular request and a reprocess request is not specified. Each capture produces one @B_android#hardware#camera2#CaptureResult_E@ and image buffers for one or more target @B_android#view#Surface_E@. The target surfaces (set with @B_android#hardware#camera2#CaptureRequest#Builder#addTarget_E@) must be a subset of the surfaces provided when this capture session was created. The main difference between this method and simply calling @B_android#hardware#camera2#CameraCaptureSession#capture_E@ repeatedly is that this method guarantees that no other requests will be interspersed with the burst. All capture sessions can be used for capturing images from the camera but only capture sessions created by @B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@ can submit reprocess capture requests. Submitting a reprocess request to a regular capture session will result in an @B_java#lang#IllegalArgumentException_E@.", "history": "Added in API level 21", "FullName": "public abstract int captureBurst (List<CaptureRequest> requests, CameraCaptureSession.CaptureCallback listener, Handler handler)"}, "isReprocessable()": {"Returns": [["boolean", "true if the application can submit reprocess capture requests with this camera capture session. false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@"], "Permissions": [], "Description": "Return if the application can submit reprocess capture requests with this camera capture session.", "history": "Added in API level 23", "FullName": "public abstract boolean isReprocessable ()"}, "getDevice()": {"Returns": [["@B_android#hardware#camera2#CameraDevice_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the camera device that this session is created for.", "history": "Added in API level 21", "FullName": "public abstract CameraDevice getDevice ()"}, "updateOutputConfiguration(android.hardware.camera2.params.OutputConfiguration)": {"Returns": [], "Parameters": [["@B_android#hardware#camera2#params#OutputConfiguration_E@", "OutputConfiguration: Modified output configuration."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error."], ["@B_java#lang#IllegalArgumentException_E@", "if an attempt was made to add a @B_android#view#Surface_E@ already in use by another buffer-producing API, such as MediaCodec or a different camera device or @B_android#hardware#camera2#params#OutputConfiguration_E@; or new surfaces are not compatible (see @B_android#hardware#camera2#params#OutputConfiguration#enableSurfaceSharing_E@); or a @B_android#view#Surface_E@ that was removed from the modified @B_android#hardware#camera2#params#OutputConfiguration_E@ still has pending requests."], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."]], "SeeAlso": [], "Permissions": [], "Description": "Update @B_android#hardware#camera2#params#OutputConfiguration_E@ after configuration finalization see @B_android#hardware#camera2#CameraCaptureSession#finalizeOutputConfigurations_E@. Any @B_android#hardware#camera2#params#OutputConfiguration_E@ that has been modified via calls to @B_android#hardware#camera2#params#OutputConfiguration#addSurface_E@ or @B_android#hardware#camera2#params#OutputConfiguration#removeSurface_E@ must be updated. After the update call returns without throwing exceptions any newly added surfaces can be referenced in subsequent capture requests. Surfaces that get removed must not be part of any active repeating or single/burst request or have any pending results. Consider updating any repeating requests first via @B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@ or @B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@ and then wait for the last frame number when the sequence completes @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureSequenceCompleted_E@ before calling updateOutputConfiguration to remove a previously active Surface. Surfaces that get added must not be part of any other registered @B_android#hardware#camera2#params#OutputConfiguration_E@.", "history": "Added in API level 28", "FullName": "public void updateOutputConfiguration (OutputConfiguration config)"}, "getInputSurface()": {"Returns": [["@B_android#view#Surface_E@", "The @B_android#view#Surface_E@ where reprocessing capture requests get the input images from. If this is not a reprocess capture session, null will be returned."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@", "@B_android#media#ImageWriter_E@", "@B_android#media#ImageReader_E@"], "Permissions": [], "Description": "Get the input Surface associated with a reprocessable capture session. Each reprocessable capture session has an input @B_android#view#Surface_E@ where the reprocess capture requests get the input images from, rather than the camera device. The application can create a @B_android#media#ImageWriter_E@ with this input @B_android#view#Surface_E@ and use it to provide input images for reprocess capture requests. When the reprocessable capture session is closed, the input @B_android#view#Surface_E@ is abandoned and becomes invalid.", "history": "Added in API level 23", "FullName": "public abstract Surface getInputSurface ()"}, "captureBurstRequests(java.util.List<android.hardware.camera2.CaptureRequest>,java.util.concurrent.Executor,android.hardware.camera2.CameraCaptureSession.CaptureCallback)": {"Returns": [["int", "int A unique capture sequence ID used by @B_android#hardware#camera2#CameraCaptureSession#CaptureCallback#onCaptureSequenceCompleted_E@."]], "Parameters": [["@B_java#util#List_E@", "List: the list of settings for this burst capture This value must never be null."], ["@B_java#util#concurrent#Executor_E@", "Executor: the executor which will be used for invoking the listener. This value must never be null. Callback and listener events are dispatched through this @B_java#util#concurrent#Executor_E@, providing an easy way to control which thread is used. To dispatch events through the main thread of your application, you can use @B_android#content#Context#getMainExecutor_E@. To dispatch events through a shared thread pool, you can use @B_android#os#AsyncTask#THREAD_POOL_EXECUTOR_E@."], ["@B_android#hardware#camera2#CameraCaptureSession#CaptureCallback_E@", "CameraCaptureSession.CaptureCallback: The callback object to notify each time one of the requests in the burst has been processed. This value must never be null."]], "Throws": [["@B_android#hardware#camera2#CameraAccessException_E@", "if the camera device is no longer connected or has encountered a fatal error"], ["@B_java#lang#IllegalStateException_E@", "if this session is no longer active, either because the session was explicitly closed, a new session has been created or the camera device has been closed."], ["@B_java#lang#IllegalArgumentException_E@", "If the requests target no Surfaces, or the requests target Surfaces not currently configured as outputs; or one of the requests targets a set of Surfaces that cannot be submitted simultaneously in a reprocessable capture session; or a reprocess capture request is submitted in a non-reprocessable capture session; or one of the reprocess capture requests was created with a @B_android#hardware#camera2#TotalCaptureResult_E@ from a different session; or one of the captures targets a Surface in the middle of being @B_android#hardware#camera2#CameraCaptureSession#prepare_E@; or if the executor is null; or if the listener is null."]], "SeeAlso": ["@B_android#hardware#camera2#CameraCaptureSession#capture_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingRequest_E@", "@B_android#hardware#camera2#CameraCaptureSession#setRepeatingBurst_E@", "@B_android#hardware#camera2#CameraCaptureSession#abortCaptures_E@"], "Permissions": [], "Description": "Submit a list of requests to be captured in sequence as a burst. The burst will be captured in the minimum amount of time possible, and will not be interleaved with requests submitted by other capture or repeat calls. The behavior of this method matches that of @B_android#hardware#camera2#CameraCaptureSession#captureBurst_E@, except that it uses @B_java#util#concurrent#Executor_E@ as an argument instead of @B_android#os#Handler_E@.", "history": "Added in API level 28", "FullName": "public int captureBurstRequests (List<CaptureRequest> requests, Executor executor, CameraCaptureSession.CaptureCallback listener)"}}, "Inheritance": [], "ClassName": "android.hardware.camera2.CameraCaptureSession", "ClassDesc": "A configured capture session for a @B_android#hardware#camera2#CameraDevice_E@, used for capturing images from the camera or reprocessing images captured from the camera in the same session previously. A CameraCaptureSession is created by providing a set of target output surfaces to @B_android#hardware#camera2#CameraDevice#createCaptureSession_E@, or by providing an @B_android#hardware#camera2#params#InputConfiguration_E@ and a set of target output surfaces to @B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@ for a reprocessable capture session. Once created, the session is active until a new session is created by the camera device, or the camera device is closed. All capture sessions can be used for capturing images from the camera but only reprocessable capture sessions can reprocess images captured from the camera in the same session previously. Creating a session is an expensive operation and can take several hundred milliseconds, since it requires configuring the camera device's internal pipelines and allocating memory buffers for sending images to the desired targets. Therefore the setup is done asynchronously, and @B_android#hardware#camera2#CameraDevice#createCaptureSession_E@ and @B_android#hardware#camera2#CameraDevice#createReprocessableCaptureSession_E@ will send the ready-to-use CameraCaptureSession to the provided listener's @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onConfigured_E@ callback. If configuration cannot be completed, then the @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onConfigureFailed_E@ is called, and the session will not become active. If a new session is created by the camera device, then the previous session is closed, and its associated @B_android#hardware#camera2#CameraCaptureSession#StateCallback#onClosed_E@ callback will be invoked. All of the session methods will throw an IllegalStateException if called once the session is closed. A closed session clears any repeating requests (as if @B_android#hardware#camera2#CameraCaptureSession#stopRepeating_E@ had been called), but will still complete all of its in-progress capture requests as normal, before a newly created session takes over and reconfigures the camera device."}