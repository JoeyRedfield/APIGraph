{"Functions": {"getBaseFile()": {"Returns": [["@B_java#io#File_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the path to the base file. You should not generally use this, as the data at that path may not be valid.", "history": "added in version 22.0.0", "FullName": "File getBaseFile ()"}, "readFully()": {"Returns": [["byte[]", "no returns description in source"]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "A convenience for @B_android#support#v4#util#AtomicFile#openRead_E@ that also reads all of the file contents into a byte array which is returned.", "history": "added in version 22.0.0", "FullName": "byte[] readFully ()"}, "delete()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Delete the atomic file. This deletes both the base and backup files.", "history": "added in version 22.0.0", "FullName": "void delete ()"}, "AtomicFile(java.io.File)": {"Returns": [], "Parameters": [["@B_java#io#File_E@", "File no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new AtomicFile for a file located at the given File path. The secondary backup file will be the same file path with \".bak\" appended.", "history": "added in version 22.0.0", "FullName": "AtomicFile (File baseName)"}, "failWrite(java.io.FileOutputStream)": {"Returns": [], "Parameters": [["@B_java#io#FileOutputStream_E@", "FileOutputStream no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call when you have failed for some reason at writing to the stream returned by @B_android#support#v4#util#AtomicFile#startWrite_E@. This will close the current write stream, and roll back to the previous state of the file.", "history": "added in version 22.0.0", "FullName": "void failWrite (FileOutputStream str)"}, "finishWrite(java.io.FileOutputStream)": {"Returns": [], "Parameters": [["@B_java#io#FileOutputStream_E@", "FileOutputStream no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call when you have successfully finished writing to the stream returned by @B_android#support#v4#util#AtomicFile#startWrite_E@. This will close, sync, and commit the new data. The next attempt to read the atomic file will return the new file stream.", "history": "added in version 22.0.0", "FullName": "void finishWrite (FileOutputStream str)"}, "openRead()": {"Returns": [["@B_java#io#FileInputStream_E@", "no returns description in source"]], "Parameters": [], "Throws": [["@B_java#io#FileNotFoundException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Open the atomic file for reading. If there previously was an incomplete write, this will roll back to the last good data before opening for read. You should call close() on the FileInputStream when you are done reading from it. Note that if another thread is currently performing a write, this will incorrectly consider it to be in the state of a bad write and roll back, causing the new data currently being written to be dropped. You must do your own threading protection for access to AtomicFile.", "history": "added in version 22.0.0", "FullName": "FileInputStream openRead ()"}, "startWrite()": {"Returns": [["@B_java#io#FileOutputStream_E@", "no returns description in source"]], "Parameters": [], "Throws": [["@B_java#io#IOException_E@", ""]], "SeeAlso": [], "Permissions": [], "Description": "Start a new write operation on the file. This returns a FileOutputStream to which you can write the new file data. The existing file is replaced with the new data. You must not directly close the given FileOutputStream; instead call either @B_android#support#v4#util#AtomicFile#finishWrite_E@ or @B_android#support#v4#util#AtomicFile#failWrite_E@. Note that if another thread is currently performing a write, this will simply replace whatever that thread is writing with the new file being written by this thread, and when the other thread finishes the write the new write operation will no longer be safe (or will be lost). You must do your own threading protection for access to AtomicFile.", "history": "added in version 22.0.0", "FullName": "FileOutputStream startWrite ()"}}, "Inheritance": ["java.lang.Object"], "ClassName": "android.support.v4.util.AtomicFile", "ClassDesc": "Static library support version of the framework's https:##developer#android#com@B_android#util#AtomicFile_E@, a helper class for performing atomic operations on a file by creating a backup file until a write has successfully completed. Atomic file guarantees file integrity by ensuring that a file has been completely written and sync'd to disk before removing its backup. As long as the backup file exists, the original file is considered to be invalid (left over from a previous attempt to write the file). Atomic file does not confer any file locking semantics. Do not use this class when the file may be accessed or modified concurrently by multiple threads or processes. The caller is responsible for ensuring appropriate mutual exclusion invariants whenever it accesses the file."}