{"Functions": {"create(java.lang.String)": {"Returns": [["@B_java#net#URI_E@", "The new URI"]], "Parameters": [["@B_java#lang#String_E@", "String: The string to be parsed into a URI"]], "Throws": [["@B_java#lang#NullPointerException_E@", "If str is null"], ["@B_java#lang#IllegalArgumentException_E@", "If the given string violates RFC 2396"]], "SeeAlso": [], "Permissions": [], "Description": "Creates a URI by parsing the given string. This convenience factory method works as if by invoking the @B_java#net#URI#URI_E@ constructor; any @B_java#net#URISyntaxException_E@ thrown by the constructor is caught and wrapped in a new @B_java#lang#IllegalArgumentException_E@ object, which is then thrown. This method is provided for use in situations where it is known that the given string is a legal URI, for example for URI constants declared within in a program, and so it would be considered a programming error for the string not to parse as such. The constructors, which throw @B_java#net#URISyntaxException_E@ directly, should be used situations where a URI is being constructed from user input or from some other source that may be prone to errors.", "history": "Added in API level 1", "FullName": "public static URI create (String str)"}, "getRawSchemeSpecificPart()": {"Returns": [["@B_java#lang#String_E@", "The raw scheme-specific part of this URI (never null)"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the raw scheme-specific part of this URI. The scheme-specific part is never undefined, though it may be empty. The scheme-specific part of a URI only contains legal URI characters.", "history": "Added in API level 1", "FullName": "public String getRawSchemeSpecificPart ()"}, "isOpaque()": {"Returns": [["boolean", "true if, and only if, this URI is opaque"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells whether or not this URI is opaque. A URI is opaque if, and only if, it is absolute and its scheme-specific part does not begin with a slash character ('/'). An opaque URI has a scheme, a scheme-specific part, and possibly a fragment; all other components are undefined.", "history": "Added in API level 1", "FullName": "public boolean isOpaque ()"}, "getScheme()": {"Returns": [["@B_java#lang#String_E@", "The scheme component of this URI, or null if the scheme is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the scheme component of this URI. The scheme component of a URI, if defined, only contains characters in the \"-.+\". A scheme always starts with an The scheme component of a URI cannot contain escaped octets, hence this method does not perform any decoding.", "history": "Added in API level 1", "FullName": "public String getScheme ()"}, "getPort()": {"Returns": [["int", "The port component of this URI, or -1 if the port is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the port number of this URI. The port component of a URI, if defined, is a non-negative integer.", "history": "Added in API level 1", "FullName": "public int getPort ()"}, "toASCIIString()": {"Returns": [["@B_java#lang#String_E@", "The string form of this URI, encoded as needed so that it only contains characters in the US-ASCII charset"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the content of this URI as a US-ASCII string. If this URI does not contain any characters in the @B_java#net#URI#toString_E@ method. Otherwise this method works as if by invoking that method and then", "history": "Added in API level 1", "FullName": "public String toASCIIString ()"}, "toURL()": {"Returns": [["@B_java#net#URL_E@", "A URL constructed from this URI"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "If this URL is not absolute"], ["@B_java#net#MalformedURLException_E@", "If a protocol handler for the URL could not be found, or if some other error occurred while constructing the URL"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a URL from this URI. This convenience method works as if invoking it were equivalent to evaluating the expression new URL(this.toString()) after first checking that this URI is absolute.", "history": "Added in API level 1", "FullName": "public URL toURL ()"}, "getRawUserInfo()": {"Returns": [["@B_java#lang#String_E@", "The raw user-information component of this URI, or null if the user information is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the raw user-information component of this URI. The user-information component of a URI, if defined, only contains characters in the", "history": "Added in API level 1", "FullName": "public String getRawUserInfo ()"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if, and only if, the given object is a URI that is identical to this URI"]], "Parameters": [["@B_java#lang#Object_E@", "Object: The object to which this object is to be compared"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tests this URI for equality with another object. If the given object is not a URI then this method immediately returns false. For two URIs to be considered equal requires that either both are opaque or both are hierarchical. Their schemes must either both be undefined or else be equal without regard to case. Their fragments must either both be undefined or else be equal. For two opaque URIs to be considered equal, their scheme-specific parts must be equal. For two hierarchical URIs to be considered equal, their paths must be equal and their queries must either both be undefined or else be equal. Their authorities must either both be undefined, or both be registry-based, or both be server-based. If their authorities are defined and are registry-based, then they must be equal. If their authorities are defined and are server-based, then their hosts must be equal without regard to case, their port numbers must be equal, and their user-information components must be equal. When testing the user-information, path, query, fragment, authority, or scheme-specific parts of two URIs for equality, the raw forms rather than the encoded forms of these components are compared and the hexadecimal digits of escaped octets are compared without regard to case. This method satisfies the general contract of the @B_java#lang#Object#equals_E@ method.", "history": "Added in API level 1", "FullName": "public boolean equals (Object ob)"}, "URI(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Scheme name"], ["@B_java#lang#String_E@", "String: Authority"], ["@B_java#lang#String_E@", "String: Path"], ["@B_java#lang#String_E@", "String: Query"], ["@B_java#lang#String_E@", "String: Fragment"]], "Throws": [["@B_java#net#URISyntaxException_E@", "If both a scheme and a path are given but the path is relative, if the URI string constructed from the given components violates RFC 2396, or if the authority component of the string is present but cannot be parsed as a server-based authority"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a hierarchical URI from the given components. If a scheme is given then the path, if also given, must either be empty or begin with a slash character ('/'). Otherwise a component of the new URI may be left undefined by passing null for the corresponding parameter. This constructor first builds a URI string from the given components according to the rules specified in The resulting URI string is then parsed as if by invoking the @B_java#net#URI#URI_E@ constructor and then invoking the @B_java#net#URI#parseServerAuthority_E@ method upon the result; this may cause a @B_java#net#URISyntaxException_E@ to be thrown.", "history": "Added in API level 1", "FullName": "public URI (String scheme, String authority, String path, String query, String fragment)"}, "URI(java.lang.String,java.lang.String,java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Scheme name"], ["@B_java#lang#String_E@", "String: Host name"], ["@B_java#lang#String_E@", "String: Path"], ["@B_java#lang#String_E@", "String: Fragment"]], "Throws": [["@B_java#net#URISyntaxException_E@", "If the URI string constructed from the given components violates RFC 2396"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a hierarchical URI from the given components. A component may be left undefined by passing null. This convenience constructor works as if by invoking the seven-argument constructor as follows:", "history": "Added in API level 1", "FullName": "public URI (String scheme, String host, String path, String fragment)"}, "parseServerAuthority()": {"Returns": [["@B_java#net#URI_E@", "A URI whose authority field has been parsed as a server-based authority"]], "Parameters": [], "Throws": [["@B_java#net#URISyntaxException_E@", "If the authority component of this URI is defined but cannot be parsed as a server-based authority according to RFC 2396"]], "SeeAlso": [], "Permissions": [], "Description": "Attempts to parse this URI's authority component, if defined, into user-information, host, and port components. If this URI's authority component has already been recognized as being server-based then it will already have been parsed into user-information, host, and port components. In this case, or if this URI has no authority component, this method simply returns this URI. Otherwise this method attempts once more to parse the authority component into user-information, host, and port components, and throws an exception describing why the authority component could not be parsed in that way. This method is provided because the generic URI syntax specified in \"//foo:bar\", for example, is not a legal server-based authority but it is legal as a registry-based authority. In many common situations, for example when working URIs that are known to be either URNs or URLs, the hierarchical URIs being used will always be server-based. They therefore must either be parsed as such or treated as an error. In these cases a statement such as can be used to ensure that", "history": "Added in API level 1", "FullName": "public URI parseServerAuthority ()"}, "URI(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Scheme name"], ["@B_java#lang#String_E@", "String: User name and authorization information"], ["@B_java#lang#String_E@", "String: Host name"], ["int", "int: Port number"], ["@B_java#lang#String_E@", "String: Path"], ["@B_java#lang#String_E@", "String: Query"], ["@B_java#lang#String_E@", "String: Fragment"]], "Throws": [["@B_java#net#URISyntaxException_E@", "If both a scheme and a path are given but the path is relative, if the URI string constructed from the given components violates RFC 2396, or if the authority component of the string is present but cannot be parsed as a server-based authority"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a hierarchical URI from the given components. If a scheme is given then the path, if also given, must either be empty or begin with a slash character ('/'). Otherwise a component of the new URI may be left undefined by passing null for the corresponding parameter or, in the case of the port parameter, by passing -1. This constructor first builds a URI string from the given components according to the rules specified in The resulting URI string is then parsed as if by invoking the @B_java#net#URI#URI_E@ constructor and then invoking the @B_java#net#URI#parseServerAuthority_E@ method upon the result; this may cause a @B_java#net#URISyntaxException_E@ to be thrown.", "history": "Added in API level 1", "FullName": "public URI (String scheme, String userInfo, String host, int port, String path, String query, String fragment)"}, "getAuthority()": {"Returns": [["@B_java#lang#String_E@", "The decoded authority component of this URI, or null if the authority is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the decoded authority component of this URI. The string returned by this method is equal to that returned by the @B_java#net#URI#getRawAuthority_E@ method except that all sequences of escaped octets are", "history": "Added in API level 1", "FullName": "public String getAuthority ()"}, "getRawPath()": {"Returns": [["@B_java#lang#String_E@", "The path component of this URI, or null if the path is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the raw path component of this URI. The path component of a URI, if defined, only contains the slash character ('/'), the commercial-at character ('@'), and characters in the", "history": "Added in API level 1", "FullName": "public String getRawPath ()"}, "URI(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The string to be parsed into a URI"]], "Throws": [["@B_java#lang#NullPointerException_E@", "If str is null"], ["@B_java#net#URISyntaxException_E@", "If the given string violates RFC 2396, as augmented by the above deviations"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a URI by parsing the given string. This constructor parses the given string exactly as specified by the grammar in An empty authority component is permitted as long as it is followed by a non-empty path, a query component, or a fragment component. This allows the parsing of URIs such as \"file:///foo/bar\", which seems to be the intent of RFC 2396 although the grammar does not permit it. If the authority component is empty then the user-information, host, and port components are undefined. Empty relative paths are permitted; this seems to be the intent of RFC 2396 although the grammar does not permit it. The primary consequence of this deviation is that a standalone fragment such as \"#foo\" parses as a relative URI with an empty path and the given fragment, and can be usefully IPv4 addresses in host components are parsed rigorously, as specified by Hostnames in host components that comprise only a single domain label are permitted to start with an s://123, will parse as a server-based authority. IPv6 addresses are permitted for the host component. An IPv6 address must be enclosed in square brackets ('[' and ']') as specified by Characters in the", "history": "Added in API level 1", "FullName": "public URI (String str)"}, "compareTo(java.net.URI)": {"Returns": [["int", "A negative integer, zero, or a positive integer as this URI is less than, equal to, or greater than the given URI"]], "Parameters": [["@B_java#net#URI_E@", "URI: The object to which this URI is to be compared"]], "Throws": [["@B_java#lang#ClassCastException_E@", "If the given object is not a URI"]], "SeeAlso": [], "Permissions": [], "Description": "Compares this URI to another object, which must be a URI. When comparing corresponding components of two URIs, if one component is undefined but the other is defined then the first is considered to be less than the second. Unless otherwise noted, string components are ordered according to their natural, case-sensitive ordering as defined by the @B_java#lang#Comparable#compareTo_E@ method. String components that are subject to encoding are compared by comparing their raw forms rather than their encoded forms. The ordering of URIs is defined as follows: Two URIs with different schemes are ordered according the ordering of their schemes, without regard to case. A hierarchical URI is considered to be less than an opaque URI with an identical scheme. Two opaque URIs with identical schemes are ordered according to the ordering of their scheme-specific parts. Two opaque URIs with identical schemes and scheme-specific parts are ordered according to the ordering of their fragments. Two hierarchical URIs with identical schemes are ordered according to the ordering of their authority components: If both authority components are server-based then the URIs are ordered according to their user-information components; if these components are identical then the URIs are ordered according to the ordering of their hosts, without regard to case; if the hosts are identical then the URIs are ordered according to the ordering of their ports. If one or both authority components are registry-based then the URIs are ordered according to the ordering of their authority components. Finally, two hierarchical URIs with identical schemes and authority components are ordered according to the ordering of their paths; if their paths are identical then they are ordered according to the ordering of their queries; if the queries are identical then they are ordered according to the order of their fragments. This method satisfies the general contract of the @B_java#lang#Comparable#compareTo_E@ method.", "history": "Added in API level 1", "FullName": "public int compareTo (URI that)"}, "URI(java.lang.String,java.lang.String,java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Scheme name"], ["@B_java#lang#String_E@", "String: Scheme-specific part"], ["@B_java#lang#String_E@", "String: Fragment"]], "Throws": [["@B_java#net#URISyntaxException_E@", "If the URI string constructed from the given components violates RFC 2396"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a URI from the given components. A component may be left undefined by passing null. This constructor first builds a URI in string form using the given components as follows: The resulting URI string is then parsed in order to create the new URI instance as if by invoking the @B_java#net#URI#URI_E@ constructor; this may cause a @B_java#net#URISyntaxException_E@ to be thrown.", "history": "Added in API level 1", "FullName": "public URI (String scheme, String ssp, String fragment)"}, "hashCode()": {"Returns": [["int", "A hash-code value for this URI"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash-code value for this URI. The hash code is based upon all of the URI's components, and satisfies the general contract of the @B_java#lang#Object#hashCode_E@ method.", "history": "Added in API level 1", "FullName": "public int hashCode ()"}, "getRawQuery()": {"Returns": [["@B_java#lang#String_E@", "The raw query component of this URI, or null if the query is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the raw query component of this URI. The query component of a URI, if defined, only contains legal URI characters.", "history": "Added in API level 1", "FullName": "public String getRawQuery ()"}, "getUserInfo()": {"Returns": [["@B_java#lang#String_E@", "The decoded user-information component of this URI, or null if the user information is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the decoded user-information component of this URI. The string returned by this method is equal to that returned by the @B_java#net#URI#getRawUserInfo_E@ method except that all sequences of escaped octets are", "history": "Added in API level 1", "FullName": "public String getUserInfo ()"}, "getFragment()": {"Returns": [["@B_java#lang#String_E@", "The decoded fragment component of this URI, or null if the fragment is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the decoded fragment component of this URI. The string returned by this method is equal to that returned by the @B_java#net#URI#getRawFragment_E@ method except that all sequences of escaped octets are", "history": "Added in API level 1", "FullName": "public String getFragment ()"}, "getQuery()": {"Returns": [["@B_java#lang#String_E@", "The decoded query component of this URI, or null if the query is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the decoded query component of this URI. The string returned by this method is equal to that returned by the @B_java#net#URI#getRawQuery_E@ method except that all sequences of escaped octets are", "history": "Added in API level 1", "FullName": "public String getQuery ()"}, "resolve(java.net.URI)": {"Returns": [["@B_java#net#URI_E@", "The resulting URI"]], "Parameters": [["@B_java#net#URI_E@", "URI: The URI to be resolved against this URI"]], "Throws": [["@B_java#lang#NullPointerException_E@", "If uri is null"]], "SeeAlso": [], "Permissions": [], "Description": "Resolves the given URI against this URI. If the given URI is already absolute, or if this URI is opaque, then the given URI is returned. \"#foo\", to be usefully resolved against a base URI. Otherwise this method constructs a new hierarchical URI in a manner consistent with The result of this method is absolute if, and only if, either this URI is absolute or the given URI is absolute.", "history": "Added in API level 1", "FullName": "public URI resolve (URI uri)"}, "relativize(java.net.URI)": {"Returns": [["@B_java#net#URI_E@", "The resulting URI"]], "Parameters": [["@B_java#net#URI_E@", "URI: The URI to be relativized against this URI"]], "Throws": [["@B_java#lang#NullPointerException_E@", "If uri is null"]], "SeeAlso": [], "Permissions": [], "Description": "Relativizes the given URI against this URI. The relativization of the given URI against this URI is computed as follows:", "history": "Added in API level 1", "FullName": "public URI relativize (URI uri)"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "The string form of this URI"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the content of this URI as a string. If this URI was created by invoking one of the constructors in this class then a string equivalent to the original input string, or to the string computed from the originally-given components, as appropriate, is returned. Otherwise this URI was created by normalization, resolution, or relativization, and so a string is constructed from this URI's components according to the rules specified in", "history": "Added in API level 1", "FullName": "public String toString ()"}, "getRawAuthority()": {"Returns": [["@B_java#lang#String_E@", "The raw authority component of this URI, or null if the authority is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the raw authority component of this URI. The authority component of a URI, if defined, only contains the commercial-at character ('@') and characters in the", "history": "Added in API level 1", "FullName": "public String getRawAuthority ()"}, "getSchemeSpecificPart()": {"Returns": [["@B_java#lang#String_E@", "The decoded scheme-specific part of this URI (never null)"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the decoded scheme-specific part of this URI. The string returned by this method is equal to that returned by the @B_java#net#URI#getRawSchemeSpecificPart_E@ method except that all sequences of escaped octets are", "history": "Added in API level 1", "FullName": "public String getSchemeSpecificPart ()"}, "resolve(java.lang.String)": {"Returns": [["@B_java#net#URI_E@", "The resulting URI"]], "Parameters": [["@B_java#lang#String_E@", "String: The string to be parsed into a URI"]], "Throws": [["@B_java#lang#NullPointerException_E@", "If str is null"], ["@B_java#lang#IllegalArgumentException_E@", "If the given string violates RFC 2396"]], "SeeAlso": [], "Permissions": [], "Description": "Constructs a new URI by parsing the given string and then resolving it against this URI. This convenience method works as if invoking it were equivalent to evaluating the expression @B_java#net#URI#resolve_E@(URI.@B_java#net#URI#create_E@(str)).", "history": "Added in API level 1", "FullName": "public URI resolve (String str)"}, "getRawFragment()": {"Returns": [["@B_java#lang#String_E@", "The raw fragment component of this URI, or null if the fragment is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the raw fragment component of this URI. The fragment component of a URI, if defined, only contains legal URI characters.", "history": "Added in API level 1", "FullName": "public String getRawFragment ()"}, "normalize()": {"Returns": [["@B_java#net#URI_E@", "A URI equivalent to this URI, but whose path is in normal form"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Normalizes this URI's path. If this URI is opaque, or if its path is already in normal form, then this URI is returned. Otherwise a new URI is constructed that is identical to this URI except that its path is computed by normalizing this URI's path in a manner consistent with A normalized path will begin with one or more \"..\" segments if there were insufficient non-\"..\" segments preceding them to allow their removal. A normalized path will begin with a \".\" segment if one was inserted by step 3 above. Otherwise, a normalized path will not contain any \".\" or \"..\" segments.", "history": "Added in API level 1", "FullName": "public URI normalize ()"}, "getHost()": {"Returns": [["@B_java#lang#String_E@", "The host component of this URI, or null if the host is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the host component of this URI. The host component of a URI, if defined, will have one of the following forms: A domain name consisting of one or more '.'), optionally followed by a period character. Each label consists of '-'), though hyphens never occur as the first or last characters in a label. The rightmost label of a domain name consisting of two or more labels, begins with an A dotted-quad IPv4 address of the form +.+.+.+, where no An IPv6 address enclosed in square brackets ('[' and ']') and consisting of hexadecimal digits, colon characters (':'), and possibly an embedded IPv4 address. The full syntax of IPv6 addresses is specified in The host component of a URI cannot contain escaped octets, hence this method does not perform any decoding.", "history": "Added in API level 1", "FullName": "public String getHost ()"}, "isAbsolute()": {"Returns": [["boolean", "true if, and only if, this URI is absolute"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells whether or not this URI is absolute. A URI is absolute if, and only if, it has a scheme component.", "history": "Added in API level 1", "FullName": "public boolean isAbsolute ()"}, "getPath()": {"Returns": [["@B_java#lang#String_E@", "The decoded path component of this URI, or null if the path is undefined"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the decoded path component of this URI. The string returned by this method is equal to that returned by the @B_java#net#URI#getRawPath_E@ method except that all sequences of escaped octets are", "history": "Added in API level 1", "FullName": "public String getPath ()"}}, "Inheritance": [], "ClassName": "java.net.URI", "ClassDesc": "Represents a Uniform Resource Identifier (URI) reference. Aside from some minor deviations noted below, an instance of this class represents a URI reference as defined by An An '/'). Opaque URIs are not subject to further parsing. Some examples of opaque URIs are: A A hierarchical URI is subject to further parsing according to the syntax The authority component of a hierarchical URI is, if specified, either The path component of a hierarchical URI is itself said to be absolute if it begins with a slash character ('/'); otherwise it is relative. The path of a hierarchical URI that is either absolute or specifies an authority is always absolute. All told, then, a URI instance has the following nine components: null, while undefined integer components are represented by -1. A string component may be defined to have the empty string as its value; this is not equivalent to that component being undefined. Whether a particular component is or is not defined in an instance depends upon the type of the URI being represented. An absolute URI has a scheme component. An opaque URI has a scheme, a scheme-specific part, and possibly a fragment, but has no other components. A hierarchical URI always has a path (though it may be empty) and a scheme-specific-part (which at least contains the path), and may have any of the other components. If the authority component is present and is server-based then the host component will be defined and the user-information and port components may be defined. \".\" and \"..\" segments from the path component of a hierarchical URI. Each \".\" segment is simply removed. A \"..\" segment is removed only if it is preceded by a non-\"..\" segment. Normalization has no effect upon opaque URIs. http://java.sun.com/j2se/1.3/ is the result URI file:///~calendar against any other URI simply yields the original URI, since it is absolute. Resolving the relative URI (2) above against the relative base URI (1) yields the normalized, but still relative, URI docs/guide/index.html. To To These purposes are served in this class by three related operations: '\\u20AC'), for example, is encoded as \"%E2%82%AC\". \"%20\". UTF-8 contains US-ASCII, hence for US-ASCII characters this transformation has exactly the effect required by RFC 2396. '\\uFFFD', the Unicode replacement character. These operations are exposed in the constructors and methods of this class as follows: The The '%') is always quoted by these constructors. Any The @B_java#net#URI#getRawUserInfo_E@, @B_java#net#URI#getRawPath_E@, @B_java#net#URI#getRawQuery_E@, @B_java#net#URI#getRawFragment_E@, @B_java#net#URI#getRawAuthority_E@, and @B_java#net#URI#getRawSchemeSpecificPart_E@ methods return the values of their corresponding components in raw form, without interpreting any escaped octets. The strings returned by these methods may contain both escaped octets and The @B_java#net#URI#getUserInfo_E@, @B_java#net#URI#getPath_E@, @B_java#net#URI#getQuery_E@, @B_java#net#URI#getFragment_E@, @B_java#net#URI#getAuthority_E@, and @B_java#net#URI#getSchemeSpecificPart_E@ methods decode any escaped octets in their corresponding components. The strings returned by these methods may contain both The @B_java#net#URI#toString_E@ method returns a URI string with all necessary quotation but which may contain The @B_java#net#URI#toASCIIString_E@ method returns a fully quoted and encoded URI string that does not contain any file:///tmp/ ) or a colon following a host name but no port (as in http://java.sun.com: ), and that does not encode characters except those that must be quoted, the following identities also hold: mailto, news, and isbn URIs shown above are examples of URNs. The conceptual distinction between URIs and URLs is reflected in the differences between this class and the @B_java#net#URL_E@ class. An instance of this class represents a URI reference in the syntactic sense defined by RFC 2396. A URI may be either absolute or relative. A URI string is parsed according to the generic syntax without regard to the scheme, if any, that it specifies. No lookup of the host, if any, is performed, and no scheme-dependent stream handler is constructed. Equality, hashing, and comparison are defined strictly in terms of the character content of the instance. In other words, a URI instance is little more than a structured string that supports the syntactic, scheme-independent operations of comparison, normalization, resolution, and relativization. An instance of the @B_java#net#URL_E@ class, by contrast, represents the syntactic components of a URL together with some of the information required to access the resource that it describes. A URL must be absolute, that is, it must always specify a scheme. A URL string is parsed according to its scheme. A stream handler is always established for a URL, and in fact it is impossible to create a URL instance for a scheme for which no handler is available. Equality and hashing depend upon both the scheme and the Internet address of the host, if any; comparison is not defined. In other words, a URL is a structured string that supports the syntactic operation of resolution as well as the network I/O operations of looking up the host and opening a connection to the specified resource."}