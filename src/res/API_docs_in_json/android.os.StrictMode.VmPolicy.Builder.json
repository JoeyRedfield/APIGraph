{"Functions": {"detectLeakedRegistrationObjects()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detect when a @B_android#content#BroadcastReceiver_E@ or @B_android#content#ServiceConnection_E@ is leaked during @B_android#content#Context_E@ teardown.", "history": "Added in API level 16", "FullName": "public StrictMode.VmPolicy.Builder detectLeakedRegistrationObjects ()"}, "StrictMode.VmPolicy.Builder()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 9", "FullName": "public StrictMode.VmPolicy.Builder ()"}, "detectLeakedClosableObjects()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detect when an @B_java#io#Closeable_E@ or other object with an explicit termination method is finalized without having been closed. You always want to explicitly close such objects to avoid unnecessary resources leaks.", "history": "Added in API level 11", "FullName": "public StrictMode.VmPolicy.Builder detectLeakedClosableObjects ()"}, "detectAll()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detect everything that's potentially suspect. In the Honeycomb release this includes leaks of SQLite cursors, Activities, and other closable objects but will likely expand in future releases.", "history": "Added in API level 9", "FullName": "public StrictMode.VmPolicy.Builder detectAll ()"}, "penaltyDropBox()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Enable detected violations log a stacktrace and timing data to the @B_android#os#DropBoxManager_E@ on policy violation. Intended mostly for platform integrators doing beta user field data collection.", "history": "Added in API level 9", "FullName": "public StrictMode.VmPolicy.Builder penaltyDropBox ()"}, "detectUntaggedSockets()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#net#TrafficStats#setThreadStatsTag_E@", "@B_android#net#TrafficStats#tagSocket_E@", "@B_android#net#TrafficStats#tagDatagramSocket_E@"], "Permissions": [], "Description": "Detect any sockets in the calling app which have not been tagged using @B_android#net#TrafficStats_E@. Tagging sockets can help you investigate network usage inside your app, such as a narrowing down heavy usage to a specific library or component. This currently does not detect sockets created in native code.", "history": "Added in API level 26", "FullName": "public StrictMode.VmPolicy.Builder detectUntaggedSockets ()"}, "detectNonSdkApiUsage()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detect reflective usage of APIs that are not part of the public Android SDK. Note that any non-SDK APIs that this processes accesses before this detection is enabled may not be detected. To ensure that all such API accesses are detected, you should apply this policy as early as possible after process creation.", "history": "Added in API level 28", "FullName": "public StrictMode.VmPolicy.Builder detectNonSdkApiUsage ()"}, "detectActivityLeaks()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detect leaks of @B_android#app#Activity_E@ subclasses.", "history": "Added in API level 11", "FullName": "public StrictMode.VmPolicy.Builder detectActivityLeaks ()"}, "penaltyLog()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Log detected violations to the system log.", "history": "Added in API level 9", "FullName": "public StrictMode.VmPolicy.Builder penaltyLog ()"}, "penaltyDeathOnCleartextNetwork()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#os#StrictMode#VmPolicy#Builder#detectCleartextNetwork_E@"], "Permissions": [], "Description": "Crashes the whole process when cleartext network traffic is detected.", "history": "Added in API level 23", "FullName": "public StrictMode.VmPolicy.Builder penaltyDeathOnCleartextNetwork ()"}, "detectCredentialProtectedWhileLocked()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["_E@", "@B_android#content#Context#createDeviceProtectedStorageContext_E@"], "Permissions": [], "Description": "Detect access to filesystem paths stored in credential protected storage areas while the user is locked. When a user is locked, credential protected storage is unavailable, and files stored in these locations appear to not exist, which can result in subtle app bugs if they assume default behaviors or empty states. Instead, apps should store data needed while a user is locked under device protected storage areas.", "history": "Added in API level 29", "FullName": "public StrictMode.VmPolicy.Builder detectCredentialProtectedWhileLocked ()"}, "penaltyListener(java.util.concurrent.Executor,android.os.StrictMode.OnVmViolationListener)": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [["@B_java#util#concurrent#Executor_E@", "Executor: This value must never be null."], ["@B_android#os#StrictMode#OnVmViolationListener_E@", "StrictMode.OnVmViolationListener: This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call #@B_android#os#StrictMode#OnVmViolationListener#onVmViolation_E@ on every violation.", "history": "Added in API level 28", "FullName": "public StrictMode.VmPolicy.Builder penaltyListener (Executor executor, StrictMode.OnVmViolationListener listener)"}, "build()": {"Returns": [["@B_android#os#StrictMode#VmPolicy_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Construct the VmPolicy instance. Note: if no penalties are enabled before calling build, @B_android#os#StrictMode#VmPolicy#Builder#penaltyLog_E@ is implicitly set.", "history": "Added in API level 9", "FullName": "public StrictMode.VmPolicy build ()"}, "detectCleartextNetwork()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detect any network traffic from the calling app which is not wrapped in SSL/TLS. This can help you detect places that your app is inadvertently sending cleartext data across the network. Using @B_android#os#StrictMode#VmPolicy#Builder#penaltyDeath_E@ or @B_android#os#StrictMode#VmPolicy#Builder#penaltyDeathOnCleartextNetwork_E@ will block further traffic on that socket to prevent accidental data leakage, in addition to crashing your process. Using @B_android#os#StrictMode#VmPolicy#Builder#penaltyDropBox_E@ will log the raw contents of the packet that triggered the violation. This inspects both IPv4/IPv6 and TCP/UDP network traffic, but it may be subject to false positives, such as when STARTTLS protocols or HTTP proxies are used.", "history": "Added in API level 23", "FullName": "public StrictMode.VmPolicy.Builder detectCleartextNetwork ()"}, "detectImplicitDirectBoot()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detect any implicit reliance on Direct Boot automatic filtering of @B_android#content#pm#PackageManager_E@ values. Violations are only triggered when implicit calls are made while the user is locked. Apps becoming Direct Boot aware need to carefully inspect each query site and explicitly decide which combination of flags they want to use: @B_android#content#pm#PackageManager#MATCH_DIRECT_BOOT_AWARE_E@ @B_android#content#pm#PackageManager#MATCH_DIRECT_BOOT_UNAWARE_E@ @B_android#content#pm#PackageManager#MATCH_DIRECT_BOOT_AUTO_E@", "history": "Added in API level 29", "FullName": "public StrictMode.VmPolicy.Builder detectImplicitDirectBoot ()"}, "setClassInstanceLimit(java.lang.Class,int)": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [["@B_java#lang#Class_E@", "Class no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set an upper bound on how many instances of a class can be in memory at once. Helps to prevent object leaks.", "history": "Added in API level 11", "FullName": "public StrictMode.VmPolicy.Builder setClassInstanceLimit (Class klass, int instanceLimit)"}, "detectFileUriExposure()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["https:##developer#android#com@B_android#support#v4#content#FileProvider_E@", "@B_android#content#Intent_E@"], "Permissions": ["@B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@"], "Description": "Detect when the calling application exposes a file:// @B_android#net#Uri_E@ to another app. This exposure is discouraged since the receiving app may not have access to the shared path. For example, the receiving app may not have requested the @B_android#Manifest#permission#READ_EXTERNAL_STORAGE_E@ runtime permission, or the platform may be sharing the @B_android#net#Uri_E@ across user profile boundaries. Instead, apps should use content:// Uris so the platform can extend temporary permission for the receiving app to access the resource.", "history": "Added in API level 18", "FullName": "public StrictMode.VmPolicy.Builder detectFileUriExposure ()"}, "penaltyDeath()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Crashes the whole process on violation. This penalty runs at the end of all enabled penalties so you'll still get your logging or other violations before the process dies.", "history": "Added in API level 9", "FullName": "public StrictMode.VmPolicy.Builder penaltyDeath ()"}, "detectLeakedSqlLiteObjects()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detect when an @B_android#database#sqlite#SQLiteCursor_E@ or other SQLite object is finalized without having been closed. You always want to explicitly close your SQLite cursors to avoid unnecessary database contention and temporary memory leaks.", "history": "Added in API level 9", "FullName": "public StrictMode.VmPolicy.Builder detectLeakedSqlLiteObjects ()"}, "setClassInstanceLimit(java.lang.Class, int)": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "no returns description in source"]], "Parameters": [["@B_java#lang#Class_E@", "Class no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set an upper bound on how many instances of a class can be in memory at once. Helps to prevent object leaks.", "history": "added in API level 11", "FullName": "public StrictMode.VmPolicy.Builder setClassInstanceLimit (Class klass, int instanceLimit)"}, "penaltyDeathOnFileUriExposure()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#os#StrictMode#VmPolicy#Builder#detectFileUriExposure_E@"], "Permissions": [], "Description": "Crashes the whole process when a file:// @B_android#net#Uri_E@ is exposed beyond this app.", "history": "Added in API level 24", "FullName": "public StrictMode.VmPolicy.Builder penaltyDeathOnFileUriExposure ()"}, "detectContentUriWithoutPermission()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#content#Intent_E@"], "Permissions": [], "Description": "Detect when the calling application sends a content:// @B_android#net#Uri_E@ to another app without setting @B_android#content#Intent#FLAG_GRANT_READ_URI_PERMISSION_E@ or @B_android#content#Intent#FLAG_GRANT_WRITE_URI_PERMISSION_E@. Forgetting to include one or more of these flags when sending an intent is typically an app bug.", "history": "Added in API level 26", "FullName": "public StrictMode.VmPolicy.Builder detectContentUriWithoutPermission ()"}, "permitNonSdkApiUsage()": {"Returns": [["@B_android#os#StrictMode#VmPolicy#Builder_E@", "This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Permit reflective usage of APIs that are not part of the public Android SDK. Note that this StrictMode, the underlying runtime may continue to restrict or warn on access to methods that are not part of the public SDK.", "history": "Added in API level 28", "FullName": "public StrictMode.VmPolicy.Builder permitNonSdkApiUsage ()"}, "StrictMode.VmPolicy.Builder(android.os.StrictMode.VmPolicy)": {"Returns": [], "Parameters": [["@B_android#os#StrictMode#VmPolicy_E@", "StrictMode.VmPolicy no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Build upon an existing VmPolicy.", "history": "Added in API level 11", "FullName": "public StrictMode.VmPolicy.Builder (StrictMode.VmPolicy base)"}}, "Inheritance": [], "ClassName": "android.os.StrictMode.VmPolicy.Builder", "ClassDesc": "Creates @B_android#os#StrictMode#VmPolicy_E@ instances. Methods whose names start with detect specify what problems we should look for. Methods whose names start with penalty specify what we should do when we detect a problem. You can call as many detect and penalty methods as you like. Currently order is insignificant: all penalties apply to all detected problems. For example, detect everything and log anything that's found:"}