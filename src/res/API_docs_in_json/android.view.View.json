{"Functions": {"setBackground(android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: The Drawable to use as the background, or null to remove the background"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the background to a given Drawable, or remove the background. If the background has padding, this View's padding is set to the background's padding. However, when a background is removed, this View's padding isn't touched. If setting the padding is desired, please use @B_android#view#View#setPadding_E@.", "history": "Added in API level 16", "FullName": "public void setBackground (Drawable background)"}, "scrollBy(int, int)": {"Returns": [], "Parameters": [["int", "int: the amount of pixels to scroll by horizontally"], ["int", "int: the amount of pixels to scroll by vertically"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Move the scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated.", "history": "added in API level 1", "FullName": "public void scrollBy (int x, int y)"}, "hasExplicitFocusable()": {"Returns": [["boolean", "true if the view is focusable or if the view contains a focusable view, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#hasFocusable_E@"], "Permissions": [], "Description": "Returns true if this view is focusable or if it contains a reachable View for which @B_android#view#View#hasExplicitFocusable_E@ returns true. A \"reachable hasExplicitFocusable()\" is a view whose parents do not block descendants focus. Only @B_android#view#View#VISIBLE_E@ views for which @B_android#view#View#getFocusable_E@ would return @B_android#view#View#FOCUSABLE_E@ are considered focusable. This method preserves the pre-@B_android#os#Build#VERSION_CODES#O_E@ behavior of @B_android#view#View#hasFocusable_E@ in that only views explicitly set focusable will cause this method to return true. A view set to @B_android#view#View#FOCUSABLE_AUTO_E@ that resolves to focusable will not.", "history": "Added in API level 26", "FullName": "public boolean hasExplicitFocusable ()"}, "getRotationY()": {"Returns": [["float", "The degrees of Y rotation."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@", "@B_android#view#View#setRotationY_E@"], "Permissions": [], "Description": "The degrees that the view is rotated around the vertical axis through the pivot point.", "history": "Added in API level 11", "FullName": "public float getRotationY ()"}, "onVisibilityAggregated(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if this view and all of its ancestors are @B_android#view#View#VISIBLE_E@ and this view's window is also visible"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the user-visibility of this View is potentially affected by a change to this view itself, an ancestor view or the window this view is attached to. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 24", "FullName": "public void onVisibilityAggregated (boolean isVisible)"}, "getAccessibilityNodeProvider()": {"Returns": [["@B_android#view#accessibility#AccessibilityNodeProvider_E@", "The provider."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#accessibility#AccessibilityNodeProvider_E@"], "Permissions": [], "Description": "Gets the provider for managing a virtual view hierarchy rooted at this View and reported to @B_android#accessibilityservice#AccessibilityService_E@s that explore the window content. If this method returns an instance, this instance is responsible for managing @B_android#view#accessibility#AccessibilityNodeInfo_E@s describing the virtual sub-tree rooted at this View including the one representing the View itself. Similarly the returned instance is responsible for performing accessibility actions on any virtual view or the root view itself. If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#getAccessibilityNodeProvider_E@ is responsible for handling this call.", "history": "Added in API level 16", "FullName": "public AccessibilityNodeProvider getAccessibilityNodeProvider ()"}, "removeOnUnhandledKeyEventListener(android.view.View.OnUnhandledKeyEventListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnUnhandledKeyEventListener_E@", "View.OnUnhandledKeyEventListener: a receiver of unhandled @B_android#view#KeyEvent_E@s."]], "Throws": [], "SeeAlso": ["@B_android#view#View#addOnUnhandledKeyEventListener_E@"], "Permissions": [], "Description": "Removes a listener which will receive unhandled @B_android#view#KeyEvent_E@s. This must be called on the UI thread.", "history": "Added in API level 28", "FullName": "public void removeOnUnhandledKeyEventListener (View.OnUnhandledKeyEventListener listener)"}, "getLayerType()": {"Returns": [["int", "@B_android#view#View#LAYER_TYPE_NONE_E@, @B_android#view#View#LAYER_TYPE_SOFTWARE_E@ or @B_android#view#View#LAYER_TYPE_HARDWARE_E@ Value is @B_android#view#View#LAYER_TYPE_NONE_E@, @B_android#view#View#LAYER_TYPE_SOFTWARE_E@, or @B_android#view#View#LAYER_TYPE_HARDWARE_E@"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setLayerType_E@", "@B_android#view#View#buildLayer_E@", "@B_android#view#View_E@"], "Permissions": [], "Description": "Indicates what type of layer is currently associated with this view. By default a view does not have a layer, and the layer type is @B_android#view#View#LAYER_TYPE_NONE_E@. Refer to the documentation of @B_android#view#View#setLayerType_E@ for more information on the different types of layers.", "history": "Added in API level 11", "FullName": "public int getLayerType ()"}, "dispatchWindowVisibilityChanged(int)": {"Returns": [], "Parameters": [["int", "int: The new visibility of the window. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View#onWindowVisibilityChanged_E@"], "Permissions": [], "Description": "Dispatch a window visibility change down the view hierarchy. ViewGroups should override to route to their children.", "history": "Added in API level 1", "FullName": "public void dispatchWindowVisibilityChanged (int visibility)"}, "findViewById(int)": {"Returns": [["T", "a view with given ID if found, or null otherwise"]], "Parameters": [["int", "int: the ID to search for"]], "Throws": [], "SeeAlso": ["@B_android#view#View#requireViewById_E@"], "Permissions": [], "Description": "Finds the first descendant view with the given ID, the view itself if the ID matches @B_android#view#View#getId_E@, or null if the ID is invalid (< 0) or there is no matching view in the hierarchy.", "history": "Added in API level 1", "FullName": "public final T findViewById (int id)"}, "dispatchHoverEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a hover event. Do not call this method directly. Call @B_android#view#View#dispatchGenericMotionEvent_E@ instead.", "history": "Added in API level 14", "FullName": "protected boolean dispatchHoverEvent (MotionEvent event)"}, "getScrollX()": {"Returns": [["int", "The left edge of the displayed part of your view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the scrolled left position of this view. This is the left edge of the displayed part of your view. You do not need to draw any pixels farther left, since those are outside of the frame of your view on screen.", "history": "Added in API level 1", "FullName": "public final int getScrollX ()"}, "saveHierarchyState(android.util.SparseArray<android.os.Parcelable>)": {"Returns": [], "Parameters": [["@B_android#util#SparseArray_E@", "SparseArray: The SparseArray in which to save the view's state."]], "Throws": [], "SeeAlso": ["@B_android#view#View#restoreHierarchyState_E@", "@B_android#view#View#dispatchSaveInstanceState_E@", "@B_android#view#View#onSaveInstanceState_E@"], "Permissions": [], "Description": "Store this view hierarchy's frozen state into the given container.", "history": "Added in API level 1", "FullName": "public void saveHierarchyState (SparseArray<Parcelable> container)"}, "setFocusable(int)": {"Returns": [], "Parameters": [["int", "int: One of @B_android#view#View#NOT_FOCUSABLE_E@, @B_android#view#View#FOCUSABLE_E@, or @B_android#view#View#FOCUSABLE_AUTO_E@. Value is @B_android#view#View#NOT_FOCUSABLE_E@, @B_android#view#View#FOCUSABLE_E@, or @B_android#view#View#FOCUSABLE_AUTO_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setFocusableInTouchMode_E@"], "Permissions": [], "Description": "Sets whether this view can receive focus. Setting this to @B_android#view#View#FOCUSABLE_AUTO_E@ tells the framework to determine focusability automatically based on the view's interactivity. This is the default. Setting this to NOT_FOCUSABLE will ensure that this view is also not focusable in touch mode.", "history": "Added in API level 26", "FullName": "public void setFocusable (int focusable)"}, "drawableHotspotChanged(float, float)": {"Returns": [], "Parameters": [["float", "float: hotspot x coordinate"], ["float", "float: hotspot y coordinate"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function is called whenever the view hotspot changes and needs to be propagated to drawables or child views managed by the view. Dispatching to child views is handled by @B_android#view#View#dispatchDrawableHotspotChanged_E@. Be sure to call through to the superclass when overriding this function.If you override this method you must call through to the superclass implementation.", "history": "added in API level 21", "FullName": "public void drawableHotspotChanged (float x, float y)"}, "setForegroundTintMode(android.graphics.PorterDuff.Mode)": {"Returns": [], "Parameters": [["@B_android#graphics#PorterDuff#Mode_E@", "PorterDuff.Mode: the blending mode used to apply the tint, may be null to clear tint This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getForegroundTintMode_E@", "@B_android#graphics#drawable#Drawable#setTintMode_E@"], "Permissions": [], "Description": "Specifies the blending mode used to apply the tint specified by @B_android#view#View#setForegroundTintList_E@} to the background drawable. The default mode is @B_android#graphics#PorterDuff#Mode#SRC_IN_E@.", "history": "Added in API level 23", "FullName": "public void setForegroundTintMode (PorterDuff.Mode tintMode)"}, "setVerticalScrollbarTrackDrawable(android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@", "@B_android#view#View#isVerticalScrollBarEnabled_E@", "@B_android#view#View#setVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Defines the vertical scrollbar track drawable", "history": "Added in API level 29", "FullName": "public void setVerticalScrollbarTrackDrawable (Drawable drawable)"}, "dispatchConfigurationChanged(android.content.res.Configuration)": {"Returns": [], "Parameters": [["@B_android#content#res#Configuration_E@", "Configuration: The new resource configuration."]], "Throws": [], "SeeAlso": ["@B_android#view#View#onConfigurationChanged_E@"], "Permissions": [], "Description": "Dispatch a notification about a resource configuration change down the view hierarchy. ViewGroups should override to route to their children.", "history": "Added in API level 8", "FullName": "public void dispatchConfigurationChanged (Configuration newConfig)"}, "onKeyMultiple(int, int, android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: A key code that represents the button pressed, from @B_android#view#KeyEvent_E@."], ["int", "int: The number of times the action was made."], ["@B_android#view#KeyEvent_E@", "KeyEvent: The KeyEvent object that defines the button action."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyMultiple_E@: always returns false (doesn't handle the event). Key presses in software keyboards will generally NOT trigger this listener, although some may elect to do so in some situations. Do not rely on this to catch software key presses.", "history": "added in API level 1", "FullName": "public boolean onKeyMultiple (int keyCode, int repeatCount, KeyEvent event)"}, "callOnClick()": {"Returns": [["boolean", "True there was an assigned OnClickListener that was called, false otherwise is returned."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Directly call any attached OnClickListener. Unlike @B_android#view#View#performClick_E@, this only calls the listener, and does not do any associated clicking actions like reporting an accessibility event.", "history": "Added in API level 15", "FullName": "public boolean callOnClick ()"}, "dispatchNestedFling(float, float, boolean)": {"Returns": [["boolean", "true if the nested scrolling parent consumed or otherwise reacted to the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"], ["boolean", "boolean: true if the child consumed the fling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent. This method should be used to indicate that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling.", "history": "added in API level 21", "FullName": "public boolean dispatchNestedFling (float velocityX, float velocityY, boolean consumed)"}, "performAccessibilityAction(int,android.os.Bundle)": {"Returns": [["boolean", "Whether the action was performed."]], "Parameters": [["int", "int: The action to perform."], ["@B_android#os#Bundle_E@", "Bundle: Optional action arguments."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Performs the specified accessibility action on the view. For possible accessibility actions look at @B_android#view#accessibility#AccessibilityNodeInfo_E@. If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#performAccessibilityAction_E@ is responsible for handling this call. The default implementation will delegate @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_SCROLL_BACKWARD_E@ and @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_SCROLL_FORWARD_E@ to nested scrolling parents if @B_android#view#View#isNestedScrollingEnabled_E@ on this view.", "history": "Added in API level 16", "FullName": "public boolean performAccessibilityAction (int action, Bundle arguments)"}, "setDrawingCacheBackgroundColor(int)": {"Returns": [], "Parameters": [["int", "int: The background color to use for the drawing cache's bitmap"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setDrawingCacheEnabled_E@", "@B_android#view#View#buildDrawingCache_E@", "@B_android#view#View#getDrawingCache_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Setting a solid background color for the drawing cache's bitmaps will improve performance and memory usage. Note, though that this should only be used if this view will always be drawn on top of a solid color.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public void setDrawingCacheBackgroundColor (int color)"}, "getOutlineSpotShadowColor()": {"Returns": [["int", "The shadow color set by @B_android#view#View#setOutlineSpotShadowColor_E@, or black if nothing was set"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 28", "FullName": "public int getOutlineSpotShadowColor ()"}, "getNextFocusLeftId()": {"Returns": [["int", "The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the id of the view to use when the next focus is @B_android#view#View#FOCUS_LEFT_E@.", "history": "Added in API level 1", "FullName": "public int getNextFocusLeftId ()"}, "onDetachedFromWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#onAttachedToWindow_E@"], "Permissions": [], "Description": "This is called when the view is detached from a window. At this point it no longer has a surface for drawing. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onDetachedFromWindow ()"}, "fitSystemWindows(android.graphics.Rect)": {"Returns": [["boolean", "true if this view applied the insets and it should not continue propagating further down the hierarchy, false otherwise."]], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: Current content insets of the window. Prior to @B_android#os#Build#VERSION_CODES#JELLY_BEAN_E@ you must not modify the insets or else you and Android will be unhappy."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getFitsSystemWindows_E@", "@B_android#view#View#setFitsSystemWindows_E@", "@B_android#view#View#setSystemUiVisibility_E@"], "Permissions": [], "Description": "As of API 20 use @B_android#view#View#dispatchApplyWindowInsets_E@ to apply insets to views. Views should override @B_android#view#View#onApplyWindowInsets_E@ or use @B_android#view#View#setOnApplyWindowInsetsListener_E@ to implement handling their own insets. Called by the view hierarchy when the content insets for a window have changed, to allow it to adjust its content to fit within those windows. The content insets tell you the space that the status bar, input method, and other system windows infringe on the application's window. You do not normally need to deal with this function, since the default window decoration given to applications takes care of applying it to the content of the window. If you use @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN_E@ or @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION_E@ this will not be the case, and your content can be placed under those system elements. You can then use this method within your view hierarchy if you have parts of your UI which you would like to ensure are not being covered. The default implementation of this method simply applies the content insets to the view's padding, consuming that content (modifying the insets to be 0), and returning true. This behavior is off by default, but can be enabled through @B_android#view#View#setFitsSystemWindows_E@. This function's traversal down the hierarchy is depth-first. The same content insets object is propagated down the hierarchy, so any changes made to it will be seen by all following views (including potentially ones above in the hierarchy since this is a depth-first traversal). The first view that returns true will abort the entire traversal. The default implementation works well for a situation where it is used with a container that covers the entire window, allowing it to apply the appropriate insets to its content on all edges. If you need a more complicated layout (such as two different views fitting system windows, one on the top of the window, and one on the bottom), you can override the method and handle the insets however you would like. Note that the insets provided by the framework are always relative to the far edges of the window, not accounting for the location of the called view within that window. (In fact when this method is called you do not yet know where the layout will place the view, as it is done before layout happens.) Note: unlike many View methods, there is no dispatch phase to this call. If you are overriding it in a ViewGroup and want to allow the call to continue to your children, you must be sure to call the super implementation. Here is a sample layout that makes use of fitting system windows to have controls for a video view placed inside of the window decorations that it hides and shows. This can be used with code like the second sample (video player) shown in @B_android#view#View#setSystemUiVisibility_E@.", "history": "Added in API level 1 Deprecated in API level 20", "FullName": "protected boolean fitSystemWindows (Rect insets)"}, "dispatchProvideAutofillStructure(android.view.ViewStructure,int)": {"Returns": [], "Parameters": [["@B_android#view#ViewStructure_E@", "ViewStructure: fill in with structured view data for autofill purposes. This value must never be null."], ["int", "int: optional flags. Value is either 0 or @B_android#view#View#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Dispatches creation of a @B_android#view#ViewStructure_E@s for autofill purposes down the hierarchy, when an Assist structure is being created as part of an autofill request. The default implementation does the following: Sets the @B_android#view#autofill#AutofillId_E@ in the structure. Calls @B_android#view#View#onProvideAutofillStructure_E@. Calls @B_android#view#View#onProvideAutofillVirtualStructure_E@. Typically, this method should only be overridden by subclasses that provide a view hierarchy (such as @B_android#view#ViewGroup_E@) - other classes should override @B_android#view#View#onProvideAutofillStructure_E@ or @B_android#view#View#onProvideAutofillVirtualStructure_E@ instead. When overridden, it must: Either call super.dispatchProvideAutofillStructure(structure, flags) or explicitly set the @B_android#view#autofill#AutofillId_E@ in the structure (for example, by calling structure.setAutofillId(getAutofillId())). Decide how to handle the @B_android#view#View#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS_E@ flag - when set, all views in the structure should be considered important for autofill, regardless of what @B_android#view#View#isImportantForAutofill_E@ returns. We encourage you to respect this flag to provide a better user experience - this flag is typically used when an user explicitly requested autofill. If the flag is not set, then only views marked as important for autofill should be included in the structure - skipping non-important views optimizes the overall autofill performance.", "history": "Added in API level 26", "FullName": "public void dispatchProvideAutofillStructure (ViewStructure structure, int flags)"}, "getHorizontalScrollbarThumbDrawable()": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@", "@B_android#view#View#isHorizontalScrollBarEnabled_E@", "@B_android#view#View#setHorizontalScrollBarEnabled_E@"], "Permissions": [], "Description": "Returns the currently configured Drawable for the thumb of the horizontal scroll bar if it exists, null otherwise.", "history": "Added in API level 29", "FullName": "public Drawable getHorizontalScrollbarThumbDrawable ()"}, "onPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent)": {"Returns": [], "Parameters": [["@B_android#view#accessibility#AccessibilityEvent_E@", "AccessibilityEvent: The accessibility event which to populate."]], "Throws": [], "SeeAlso": ["@B_android#view#View#sendAccessibilityEvent_E@", "@B_android#view#View#dispatchPopulateAccessibilityEvent_E@"], "Permissions": [], "Description": "Called from @B_android#view#View#dispatchPopulateAccessibilityEvent_E@ giving a chance to this View to populate the accessibility event with its text content. While this method is free to modify event attributes other than text content, doing so should normally be performed in @B_android#view#View#onInitializeAccessibilityEvent_E@. Example: Adding formatted date string to an accessibility event in addition to the text added by the super implementation: If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#onPopulateAccessibilityEvent_E@ is responsible for handling this call. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 14", "FullName": "public void onPopulateAccessibilityEvent (AccessibilityEvent event)"}, "setPadding(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: the left padding in pixels"], ["int", "int: the top padding in pixels"], ["int", "int: the right padding in pixels"], ["int", "int: the bottom padding in pixels"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the padding. The view may add on the space required to display the scrollbars, depending on the style and visibility of the scrollbars. So the values returned from @B_android#view#View#getPaddingLeft_E@, @B_android#view#View#getPaddingTop_E@, @B_android#view#View#getPaddingRight_E@ and @B_android#view#View#getPaddingBottom_E@ may be different from the values set in this call.", "history": "Added in API level 1", "FullName": "public void setPadding (int left, int top, int right, int bottom)"}, "hasOnClickListeners()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return whether this view has an attached OnClickListener. Returns true if there is a listener, false if there is none.", "history": "Added in API level 15", "FullName": "public boolean hasOnClickListeners ()"}, "setOnGenericMotionListener(android.view.View.OnGenericMotionListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnGenericMotionListener_E@", "View.OnGenericMotionListener: the generic motion listener to attach to this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when a generic motion event is sent to this view.", "history": "Added in API level 12", "FullName": "public void setOnGenericMotionListener (View.OnGenericMotionListener l)"}, "setOutlineSpotShadowColor(int)": {"Returns": [], "Parameters": [["int", "int: The color this View will cast for its elevation spot shadow."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the color of the spot shadow that is drawn when the view has a positive Z or elevation value. By default the shadow color is black. Generally, this color will be opaque so the intensity of the shadow is consistent between different views with different colors. The opacity of the final spot shadow is a function of the shadow caster height, the alpha channel of the outlineSpotShadowColor (typically opaque), and the @B_android#R#attr#spotShadowAlpha_E@ theme attribute.", "history": "Added in API level 28", "FullName": "public void setOutlineSpotShadowColor (int color)"}, "setPointerIcon(android.view.PointerIcon)": {"Returns": [], "Parameters": [["@B_android#view#PointerIcon_E@", "PointerIcon: A PointerIcon instance which will be shown when the mouse hovers."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the pointer icon for the current view. Passing null will restore the pointer icon to its default value.", "history": "Added in API level 24", "FullName": "public void setPointerIcon (PointerIcon pointerIcon)"}, "setLayerPaint(android.graphics.Paint)": {"Returns": [], "Parameters": [["@B_android#graphics#Paint_E@", "Paint: The paint used to compose the layer. This argument is optional and can be null. It is ignored when the layer type is @B_android#view#View#LAYER_TYPE_NONE_E@ This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setLayerType_E@"], "Permissions": [], "Description": "Updates the @B_android#graphics#Paint_E@ object used with the current layer (used only if the current layer type is not set to @B_android#view#View#LAYER_TYPE_NONE_E@). Changed properties of the Paint provided to @B_android#view#View#setLayerType_E@ will be used the next time the View is redrawn, but @B_android#view#View#setLayerPaint_E@ must be called to ensure that the view gets redrawn immediately. A layer is associated with an optional @B_android#graphics#Paint_E@ instance that controls how the layer is composed on screen. The following properties of the paint are taken into account when composing the layer: @B_android#graphics#Paint#getAlpha_E@ @B_android#graphics#Paint#getXfermode_E@ @B_android#graphics#Paint#getColorFilter_E@ If this view has an alpha value set to < 1.0 by calling @B_android#view#View#setAlpha_E@, the alpha value of the layer's paint is superseded by this view's alpha value.", "history": "Added in API level 17", "FullName": "public void setLayerPaint (Paint paint)"}, "getHeight()": {"Returns": [["int", "The height of your view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the height of your view.", "history": "Added in API level 1", "FullName": "public final int getHeight ()"}, "setVerticalScrollBarEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the vertical scrollbar should be painted"]], "Throws": [], "SeeAlso": ["@B_android#view#View#isVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Define whether the vertical scrollbar should be drawn or not. The scrollbar is not drawn by default.", "history": "Added in API level 1", "FullName": "public void setVerticalScrollBarEnabled (boolean verticalScrollBarEnabled)"}, "setSystemGestureExclusionRects(java.util.List<android.graphics.Rect>)": {"Returns": [], "Parameters": [["@B_java#util#List_E@", "List: A list of precision gesture regions that this view needs to function correctly This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets a list of areas within this view's post-layout coordinate space where the system should not intercept touch or other pointing device gestures. This method should be called by @B_android#view#View#onLayout_E@ or @B_android#view#View#onDraw_E@. Use this to tell the system which specific sub-areas of a view need to receive gesture input in order to function correctly in the presence of global system gestures that may conflict. For example, if the system wishes to capture swipe-in-from-screen-edge gestures to provide system-level navigation functionality, a view such as a navigation drawer container can mark the left (or starting) edge of itself as requiring gesture capture priority using this API. The system may then choose to relax its own gesture recognition to allow the app to consume the user's gesture. It is not necessary for an app to register exclusion rects for broadly spanning regions such as the entirety of a ScrollView or for simple press and release click targets such as Button. Mark an exclusion rect when interacting with a view requires a precision touch gesture in a small area in either the X or Y dimension, such as an edge swipe or dragging a SeekBar thumb. Do not modify the provided list after this method is called. Note: the system will put a limit of 200dp on the vertical extent of the exclusions it takes into account. The limit does not apply while the navigation bar is @B_android#view#View#SYSTEM_UI_FLAG_IMMERSIVE_STICKY_E@ hidden, nor to the @B_android#inputmethodservice#InputMethodService_E@ and @B_android#content#Intent#CATEGORY_HOME_E@.", "history": "Added in API level 29", "FullName": "public void setSystemGestureExclusionRects (List<Rect> rects)"}, "setOnDragListener(android.view.View.OnDragListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnDragListener_E@", "View.OnDragListener: An implementation of @B_android#view#View#OnDragListener_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a drag event listener callback object for this View. The parameter is an implementation of @B_android#view#View#OnDragListener_E@. To send a drag event to a View, the system calls the @B_android#view#View#OnDragListener#onDrag_E@ method.", "history": "Added in API level 11", "FullName": "public void setOnDragListener (View.OnDragListener l)"}, "getMeasuredHeightAndState()": {"Returns": [["int", "The measured height of this view as a bit mask."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the full height measurement information for this view as computed by the most recent call to @B_android#view#View#measure_E@. This result is a bit mask as defined by @B_android#view#View#MEASURED_SIZE_MASK_E@ and @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@. This should be used during measurement and layout calculations only. Use @B_android#view#View#getHeight_E@ to see how wide a view is after layout.", "history": "Added in API level 11", "FullName": "public final int getMeasuredHeightAndState ()"}, "dispatchKeyEventPreIme(android.view.KeyEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a key event before it is processed by any input method associated with the view hierarchy. This can be used to intercept key events in special situations before the IME consumes them; a typical example would be handling the BACK key to update the application's UI instead of allowing the IME to see it and close itself.", "history": "Added in API level 3", "FullName": "public boolean dispatchKeyEventPreIme (KeyEvent event)"}, "getSolidColor()": {"Returns": [["int", "The known solid color background for this view, or 0 if the color may vary"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setVerticalFadingEdgeEnabled_E@", "@B_android#view#View#setHorizontalFadingEdgeEnabled_E@"], "Permissions": [], "Description": "Override this if your view is known to always be drawn on top of a solid color background, and needs to draw fading edges. Returning a non-zero color enables the view system to optimize the drawing of the fading edges. If you do return a non-zero color, the alpha should be set to 0xFF.", "history": "Added in API level 1", "FullName": "public int getSolidColor ()"}, "isKeyboardNavigationCluster()": {"Returns": [["boolean", "True if this view is a root of a cluster, or false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether this View is a root of a keyboard navigation cluster.", "history": "Added in API level 26", "FullName": "public final boolean isKeyboardNavigationCluster ()"}, "getLayoutDirection()": {"Returns": [["int", "@B_android#view#View#LAYOUT_DIRECTION_RTL_E@ if the layout direction is RTL or returns @B_android#view#View#LAYOUT_DIRECTION_LTR_E@ if the layout direction is not RTL. For compatibility, this will return @B_android#view#View#LAYOUT_DIRECTION_LTR_E@ if API version is lower than @B_android#os#Build#VERSION_CODES#JELLY_BEAN_MR1_E@. Value is @B_android#view#View#LAYOUT_DIRECTION_LTR_E@, or @B_android#view#View#LAYOUT_DIRECTION_RTL_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the resolved layout direction for this view.", "history": "Added in API level 17", "FullName": "public int getLayoutDirection ()"}, "setHorizontalScrollbarThumbDrawable(android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@", "@B_android#view#View#isHorizontalScrollBarEnabled_E@", "@B_android#view#View#setHorizontalScrollBarEnabled_E@"], "Permissions": [], "Description": "Defines the horizontal thumb drawable", "history": "Added in API level 29", "FullName": "public void setHorizontalScrollbarThumbDrawable (Drawable drawable)"}, "getOutlineAmbientShadowColor()": {"Returns": [["int", "The shadow color set by @B_android#view#View#setOutlineAmbientShadowColor_E@, or black if nothing was set"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 28", "FullName": "public int getOutlineAmbientShadowColor ()"}, "setDrawingCacheEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to enable the drawing cache, false otherwise"]], "Throws": [], "SeeAlso": ["@B_android#view#View#isDrawingCacheEnabled_E@", "@B_android#view#View#getDrawingCache_E@", "@B_android#view#View#buildDrawingCache_E@", "@B_android#view#View#setLayerType_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Enables or disables the drawing cache. When the drawing cache is enabled, the next call to @B_android#view#View#getDrawingCache_E@ or @B_android#view#View#buildDrawingCache_E@ will draw the view in a bitmap. Calling @B_android#view#View#draw_E@ will not draw from the cache when the cache is enabled. To benefit from the cache, you must request the drawing cache by calling @B_android#view#View#getDrawingCache_E@ and draw it on screen if the returned bitmap is not null. Enabling the drawing cache is similar to @B_android#view#View#setLayerType_E@ when hardware acceleration is turned off. When hardware acceleration is turned on, enabling the drawing cache has no effect on rendering because the system uses a different mechanism for acceleration which ignores the flag. If you want to use a Bitmap for the view, even when hardware acceleration is enabled, see @B_android#view#View#setLayerType_E@ for information on how to enable software and hardware layers. This API can be used to manually generate a bitmap copy of this view, by setting the flag to true and calling @B_android#view#View#getDrawingCache_E@.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public void setDrawingCacheEnabled (boolean enabled)"}, "onSizeChanged(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: Current width of this view."], ["int", "int: Current height of this view."], ["int", "int: Old width of this view."], ["int", "int: Old height of this view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0.", "history": "added in API level 1", "FullName": "protected void onSizeChanged (int w, int h, int oldw, int oldh)"}, "isDuplicateParentStateEnabled()": {"Returns": [["boolean", "True if this view's drawable state is duplicated from the parent, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getDrawableState_E@", "@B_android#view#View#setDuplicateParentStateEnabled_E@"], "Permissions": [], "Description": "Indicates whether this duplicates its drawable state from its parent.", "history": "Added in API level 1", "FullName": "public boolean isDuplicateParentStateEnabled ()"}, "isLaidOut()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has been through at least one layout since it was last attached to or detached from a window.", "history": "Added in API level 19", "FullName": "public boolean isLaidOut ()"}, "clearFocus()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when this view wants to give up focus. If focus is cleared @B_android#view#View#onFocusChanged_E@ is called.", "history": "Added in API level 1", "FullName": "public void clearFocus ()"}, "setLayoutParams(android.view.ViewGroup.LayoutParams)": {"Returns": [], "Parameters": [["@B_android#view#ViewGroup#LayoutParams_E@", "ViewGroup.LayoutParams: The layout parameters for this view, cannot be null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the layout parameters associated with this view. These supply parameters to the", "history": "Added in API level 1", "FullName": "public void setLayoutParams (ViewGroup.LayoutParams params)"}, "setLayoutDirection(int)": {"Returns": [], "Parameters": [["int", "int: the layout direction to set. Should be one of: @B_android#view#View#LAYOUT_DIRECTION_LTR_E@, @B_android#view#View#LAYOUT_DIRECTION_RTL_E@, @B_android#view#View#LAYOUT_DIRECTION_INHERIT_E@, @B_android#view#View#LAYOUT_DIRECTION_LOCALE_E@. Resolution will be done if the value is set to LAYOUT_DIRECTION_INHERIT. The resolution proceeds up the parent chain of the view to get the value. If there is no parent, then it will return the default @B_android#view#View#LAYOUT_DIRECTION_LTR_E@. Value is @B_android#view#View#LAYOUT_DIRECTION_LTR_E@, @B_android#view#View#LAYOUT_DIRECTION_RTL_E@, @B_android#view#View#LAYOUT_DIRECTION_INHERIT_E@, or @B_android#view#View#LAYOUT_DIRECTION_LOCALE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the layout direction for this view. This will propagate a reset of layout direction resolution to the view's children and resolve layout direction for this view.", "history": "Added in API level 17", "FullName": "public void setLayoutDirection (int layoutDirection)"}, "onTrackballEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle trackball motion events. The relative movement of the trackball since the last event can be retrieve with @B_android#view#MotionEvent#getX_E@ and @B_android#view#MotionEvent#getY_E@. These are normalized so that a movement of 1 corresponds to the user pressing one DPAD key (so they will often be fractional values, representing the more fine-grained movement information available from a trackball).", "history": "Added in API level 1", "FullName": "public boolean onTrackballEvent (MotionEvent event)"}, "setX(float)": {"Returns": [], "Parameters": [["float", "float: The visual x position of this view, in pixels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the visual x position of this view, in pixels. This is equivalent to setting the @B_android#view#View#setTranslationX_E@ property to be the difference between the x value passed in and the current @B_android#view#View#getLeft_E@ property.", "history": "Added in API level 11", "FullName": "public void setX (float x)"}, "willNotCacheDrawing()": {"Returns": [["boolean", "true if this view does not cache its drawing, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Returns whether or not this View can cache its drawing or not.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public boolean willNotCacheDrawing ()"}, "getTouchables()": {"Returns": [["@B_java#util#ArrayList_E@", "A list of touchable views"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find and return all touchable views that are descendants of this view, possibly including this view if it is touchable itself.", "history": "Added in API level 1", "FullName": "public ArrayList<View> getTouchables ()"}, "getTopPaddingOffset()": {"Returns": [["int", "The top padding offset in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#isPaddingOffsetRequired_E@"], "Permissions": [], "Description": "Amount by which to extend the top fading region. Called only when @B_android#view#View#isPaddingOffsetRequired_E@ returns true.", "history": "Added in API level 2", "FullName": "protected int getTopPaddingOffset ()"}, "isVisibleToUserForAutofill(int)": {"Returns": [["boolean", "Whether the view is visible on the screen."]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Computes whether this virtual autofill view is visible to the user. true, but views providing a virtual hierarchy view must override it.", "history": "Added in API level 28", "FullName": "public boolean isVisibleToUserForAutofill (int virtualId)"}, "requestFocus()": {"Returns": [["boolean", "Whether this view or one of its descendants actually took focus."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this to try to give focus to a specific view or to one of its descendants. A view will not actually take focus if it is not focusable (@B_android#view#View#isFocusable_E@ returns false), or if it can't be focused due to other conditions (not focusable in touch mode (@B_android#view#View#isFocusableInTouchMode_E@) while the device is in touch mode, not visible, not enabled, or has no size). See also @B_android#view#View#focusSearch_E@, which is what you call to say that you have focus, and you want your parent to look for the next one. This is equivalent to calling @B_android#view#View#requestFocus_E@ with arguments @B_android#view#View#FOCUS_DOWN_E@ and null.", "history": "Added in API level 1", "FullName": "public final boolean requestFocus ()"}, "dispatchDraw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: the canvas on which to draw the view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by draw to draw the child views. This may be overridden by derived classes to gain control just before its children are drawn (but after its own view has been drawn).", "history": "Added in API level 1", "FullName": "protected void dispatchDraw (Canvas canvas)"}, "setDuplicateParentStateEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True to enable duplication of the parent's drawable state, false to disable it."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getDrawableState_E@", "@B_android#view#View#isDuplicateParentStateEnabled_E@"], "Permissions": [], "Description": "Enables or disables the duplication of the parent's state into this view. When duplication is enabled, this view gets its drawable state from its parent rather than from its own internal properties. Note: in the current implementation, setting this property to true after the view was added to a ViewGroup might have no effect at all. This property should always be used from XML or set to true before adding this view to a ViewGroup. Note: if this view's parent addStateFromChildren property is enabled and this property is enabled, an exception will be thrown. Note: if the child view uses and updates additional states which are unknown to the parent, these states should not be affected by this method.", "history": "Added in API level 1", "FullName": "public void setDuplicateParentStateEnabled (boolean enabled)"}, "getRootView()": {"Returns": [["@B_android#view#View_E@", "the topmost view containing this view"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finds the topmost view in the current view hierarchy.", "history": "Added in API level 1", "FullName": "public View getRootView ()"}, "setVerticalScrollbarThumbDrawable(android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@", "@B_android#view#View#isVerticalScrollBarEnabled_E@", "@B_android#view#View#setVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Defines the vertical scrollbar thumb drawable", "history": "Added in API level 29", "FullName": "public void setVerticalScrollbarThumbDrawable (Drawable drawable)"}, "forceHasOverlappingRendering(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: The value for overlapping rendering to be used internally instead of that returned by @B_android#view#View#hasOverlappingRendering_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the behavior for overlapping rendering for this view (see @B_android#view#View#hasOverlappingRendering_E@ for more details on this behavior). Calling this method is an alternative to overriding @B_android#view#View#hasOverlappingRendering_E@ in a subclass, providing the value which is then used internally. That is, when @B_android#view#View#forceHasOverlappingRendering_E@ is called, the value of @B_android#view#View#hasOverlappingRendering_E@ is ignored and the value passed into this method is used instead.", "history": "Added in API level 24", "FullName": "public void forceHasOverlappingRendering (boolean hasOverlappingRendering)"}, "isAttachedToWindow()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view is currently attached to a window.", "history": "Added in API level 19", "FullName": "public boolean isAttachedToWindow ()"}, "getGlobalVisibleRect(android.graphics.Rect,android.graphics.Point)": {"Returns": [["boolean", "true if r is non-empty (i.e. part of the view is visible at the root level."]], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: If true is returned, r holds the global coordinates of the visible portion of this view."], ["@B_android#graphics#Point_E@", "Point: If true is returned, globalOffset holds the dx,dy between this view and its root. globalOffet may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If some part of this view is not clipped by any of its parents, then return that area in r in global (root) coordinates. To convert r to local coordinates (without taking possible View rotations into account), offset it by -globalOffset (e.g. r.offset(-globalOffset.x, -globalOffset.y)). If the view is completely clipped or translated out, return false.", "history": "Added in API level 1", "FullName": "public boolean getGlobalVisibleRect (Rect r, Point globalOffset)"}, "setClickable(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to make the view clickable, false otherwise"]], "Throws": [], "SeeAlso": ["@B_android#view#View#isClickable_E@"], "Permissions": [], "Description": "Enables or disables click events for this view. When a view is clickable it will change its state to \"pressed\" on every click. Subclasses should set the view clickable to visually react to user's clicks.", "history": "Added in API level 1", "FullName": "public void setClickable (boolean clickable)"}, "onKeyDown(int, android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: a key code that represents the button pressed, from @B_android#view#KeyEvent_E@"], ["@B_android#view#KeyEvent_E@", "KeyEvent: the KeyEvent object that defines the button action"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyDown_E@: perform press of the view when @B_android#view#KeyEvent#KEYCODE_DPAD_CENTER_E@ or @B_android#view#KeyEvent#KEYCODE_ENTER_E@ is released, if the view is enabled and clickable. Key presses in software keyboards will generally NOT trigger this listener, although some may elect to do so in some situations. Do not rely on this to catch software key presses.", "history": "added in API level 1", "FullName": "public boolean onKeyDown (int keyCode, KeyEvent event)"}, "sendAccessibilityEvent(int)": {"Returns": [], "Parameters": [["int", "int: The type of the event to send, as defined by several types from @B_android#view#accessibility#AccessibilityEvent_E@, such as @B_android#view#accessibility#AccessibilityEvent#TYPE_VIEW_CLICKED_E@ or @B_android#view#accessibility#AccessibilityEvent#TYPE_VIEW_HOVER_ENTER_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#View#onInitializeAccessibilityEvent_E@", "@B_android#view#View#dispatchPopulateAccessibilityEvent_E@", "@B_android#view#ViewParent#requestSendAccessibilityEvent_E@", "@B_android#view#View#AccessibilityDelegate_E@"], "Permissions": [], "Description": "Sends an accessibility event of the given type. If accessibility is not enabled this method has no effect. The default implementation calls @B_android#view#View#onInitializeAccessibilityEvent_E@ first to populate information about the event source (this View), then calls @B_android#view#View#dispatchPopulateAccessibilityEvent_E@ to populate the text content of the event source including its descendants, and last calls @B_android#view#ViewParent#requestSendAccessibilityEvent_E@ on its parent to request sending of the event to interested parties. If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#sendAccessibilityEvent_E@ is responsible for handling this call.", "history": "Added in API level 4", "FullName": "public void sendAccessibilityEvent (int eventType)"}, "onWindowVisibilityChanged(int)": {"Returns": [], "Parameters": [["int", "int: The new visibility of the window. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the window containing has change its visibility (between @B_android#view#View#GONE_E@, @B_android#view#View#INVISIBLE_E@, and @B_android#view#View#VISIBLE_E@). Note that this tells you whether or not your window is being made visible to the window manager; this does not tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.", "history": "Added in API level 1", "FullName": "protected void onWindowVisibilityChanged (int visibility)"}, "getBackgroundTintBlendMode()": {"Returns": [["@B_android#graphics#BlendMode_E@", "the blending mode used to apply the tint to the background drawable, null if no blend has previously been configured"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setBackgroundTintBlendMode_E@"], "Permissions": [], "Description": "Return the blending mode used to apply the tint to the background drawable, if specified.", "history": "Added in API level 29", "FullName": "public BlendMode getBackgroundTintBlendMode ()"}, "getScaleY()": {"Returns": [["float", "The scaling factor."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "The amount that the view is scaled in y around the pivot point, as a proportion of the view's unscaled height. A value of 1, the default, means that no scaling is applied. By default, this is 1.0f.", "history": "Added in API level 11", "FullName": "public float getScaleY ()"}, "setMinimumWidth(int)": {"Returns": [], "Parameters": [["int", "int: The minimum width the view will try to be, in pixels"]], "Throws": [], "SeeAlso": ["@B_android#view#View#getMinimumWidth_E@"], "Permissions": [], "Description": "Sets the minimum width of the view. It is not guaranteed the view will be able to achieve this minimum width (for example, if its parent layout constrains it with less available width).", "history": "Added in API level 1", "FullName": "public void setMinimumWidth (int minWidth)"}, "getAutofillId()": {"Returns": [["@B_android#view#autofill#AutofillId_E@", "The View's autofill id."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the unique, logical identifier of this view in the activity, for autofill purposes. The autofill id is created on demand, unless it is explicitly set by @B_android#view#View#setAutofillId_E@. See @B_android#view#View#setAutofillId_E@ for more info.", "history": "Added in API level 26", "FullName": "public final AutofillId getAutofillId ()"}, "getContextMenuInfo()": {"Returns": [["@B_android#view#ContextMenu#ContextMenuInfo_E@", "Extra information about the item for which the context menu should be shown. This information will vary across different subclasses of View."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Views should implement this if they have extra information to associate with the context menu. The return result is supplied as a parameter to the @B_android#view#View#OnCreateContextMenuListener#onCreateContextMenu_E@ callback.", "history": "Added in API level 1", "FullName": "protected ContextMenu.ContextMenuInfo getContextMenuInfo ()"}, "setOnHoverListener(android.view.View.OnHoverListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnHoverListener_E@", "View.OnHoverListener: the hover listener to attach to this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when a hover event is sent to this view.", "history": "Added in API level 14", "FullName": "public void setOnHoverListener (View.OnHoverListener l)"}, "getScaleX()": {"Returns": [["float", "The scaling factor."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "The amount that the view is scaled in x around the pivot point, as a proportion of the view's unscaled width. A value of 1, the default, means that no scaling is applied. By default, this is 1.0f.", "history": "Added in API level 11", "FullName": "public float getScaleX ()"}, "getLocationOnScreen(int[])": {"Returns": [], "Parameters": [["int[]", "int: an array of two integers in which to hold the coordinates"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Computes the coordinates of this view on the screen. The argument must be an array of two integers. After the method returns, the array contains the x and y location in that order.", "history": "Added in API level 1", "FullName": "public void getLocationOnScreen (int[] outLocation)"}, "onHoverEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the view handled the hover event."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event that describes the hover."]], "Throws": [], "SeeAlso": ["@B_android#view#View#isHovered_E@", "@B_android#view#View#setHovered_E@", "@B_android#view#View#onHoverChanged_E@"], "Permissions": [], "Description": "Implement this method to handle hover events. This method is called whenever a pointer is hovering into, over, or out of the bounds of a view and the view is not currently being touched. Hover events are represented as pointer events with action @B_android#view#MotionEvent#ACTION_HOVER_ENTER_E@, @B_android#view#MotionEvent#ACTION_HOVER_MOVE_E@, or @B_android#view#MotionEvent#ACTION_HOVER_EXIT_E@. The view receives a hover event with action @B_android#view#MotionEvent#ACTION_HOVER_ENTER_E@ when the pointer enters the bounds of the view. The view receives a hover event with action @B_android#view#MotionEvent#ACTION_HOVER_MOVE_E@ when the pointer has already entered the bounds of the view and has moved. The view receives a hover event with action @B_android#view#MotionEvent#ACTION_HOVER_EXIT_E@ when the pointer has exited the bounds of the view or when the pointer is about to go down due to a button click, tap, or similar user action that causes the view to be touched. The view should implement this method to return true to indicate that it is handling the hover event, such as by changing its drawable state. The default implementation calls @B_android#view#View#setHovered_E@ to update the hovered state of the view when a hover enter or hover exit event is received, if the view is enabled and is clickable. The default implementation also sends hover accessibility events.", "history": "Added in API level 14", "FullName": "public boolean onHoverEvent (MotionEvent event)"}, "getAccessibilityClassName()": {"Returns": [["@B_java#lang#CharSequence_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the class name of this object to be used for accessibility purposes. Subclasses should only override this if they are implementing something that should be seen as a completely new class of view when used by accessibility, unrelated to the class it is deriving from. This is used to fill in @B_android#view#accessibility#AccessibilityNodeInfo#setClassName_E@.", "history": "Added in API level 23", "FullName": "public CharSequence getAccessibilityClassName ()"}, "requestFocus(int, android.graphics.Rect)": {"Returns": [["boolean", "Whether this view or one of its descendants actually took focus."]], "Parameters": [["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT"], ["@B_android#graphics#Rect_E@", "Rect: The rectangle (in this View's coordinate system) to give a finer grained hint about where focus is coming from. May be null if there is no hint."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from. The rectangle can help give larger views a finer grained hint about where focus is coming from, and therefore, where to show selection, or forward focus change internally. A view will not actually take focus if it is not focusable (@B_android#view#View#isFocusable_E@ returns false), or if it is focusable and it is not focusable in touch mode (@B_android#view#View#isFocusableInTouchMode_E@) while the device is in touch mode. A View will not take focus if it is not visible. A View will not take focus if one of its parents has @B_android#view#ViewGroup#getDescendantFocusability_E@ equal to @B_android#view#ViewGroup#FOCUS_BLOCK_DESCENDANTS_E@. See also @B_android#view#View#focusSearch_E@, which is what you call to say that you have focus, and you want your parent to look for the next one. You may wish to override this method if your custom @B_android#view#View_E@ has an internal @B_android#view#View_E@ that it wishes to forward the request to.", "history": "added in API level 1", "FullName": "public boolean requestFocus (int direction, Rect previouslyFocusedRect)"}, "getMinimumWidth()": {"Returns": [["int", "the minimum width the view will try to be, in pixels"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setMinimumWidth_E@"], "Permissions": [], "Description": "Returns the minimum width of the view.", "history": "Added in API level 16", "FullName": "public int getMinimumWidth ()"}, "getX()": {"Returns": [["float", "The visual x position of this view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The visual x position of this view, in pixels. This is equivalent to the @B_android#view#View#setTranslationX_E@ property plus the current @B_android#view#View#getLeft_E@ property.", "history": "Added in API level 11", "FullName": "public float getX ()"}, "onProvideAutofillStructure(android.view.ViewStructure,int)": {"Returns": [], "Parameters": [["@B_android#view#ViewStructure_E@", "ViewStructure: fill in with structured view data for autofill purposes."], ["int", "int: optional flags. Value is either 0 or @B_android#view#View#AUTOFILL_FLAG_INCLUDE_NOT_IMPORTANT_VIEWS_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Populates a @B_android#view#ViewStructure_E@ to fullfil an autofill request. The structure should contain at least the following properties: Autofill id (@B_android#view#ViewStructure#setAutofillId_E@). Autofill type (@B_android#view#ViewStructure#setAutofillType_E@). Autofill value (@B_android#view#ViewStructure#setAutofillValue_E@). Whether the data is sensitive (@B_android#view#ViewStructure#setDataIsSensitive_E@). It's also recommended to set the following properties - the more properties the structure has, the higher the changes of an @B_android#service#autofill#AutofillService_E@ properly using the structure: Autofill hints (@B_android#view#ViewStructure#setAutofillHints_E@). Autofill options (@B_android#view#ViewStructure#setAutofillOptions_E@) when the view can only be filled with predefined values (typically used when the autofill type is @B_android#view#View#AUTOFILL_TYPE_LIST_E@). Resource id (@B_android#view#ViewStructure#setId_E@). Class name (@B_android#view#ViewStructure#setClassName_E@). Content description (@B_android#view#ViewStructure#setContentDescription_E@). Visual properties such as visibility (@B_android#view#ViewStructure#setVisibility_E@), dimensions (@B_android#view#ViewStructure#setDimens_E@), and opacity (@B_android#view#ViewStructure#setOpaque_E@). For views representing text fields, text properties such as the text itself (@B_android#view#ViewStructure#setText_E@), text hints (@B_android#view#ViewStructure#setHint_E@, input type (@B_android#view#ViewStructure#setInputType_E@), For views representing HTML nodes, its web domain (@B_android#view#ViewStructure#setWebDomain_E@) and HTML properties ((@B_android#view#ViewStructure#setHtmlInfo_E@). The default implementation of this method already sets most of these properties based on related @B_android#view#View_E@ methods (for example, the autofill id is set using @B_android#view#View#getAutofillId_E@, the autofill type set using @B_android#view#View#getAutofillType_E@, etc.), and views in the standard Android widgets library also override it to set their relevant properties (for example, @B_android#widget#TextView_E@ already sets the text properties), so it's recommended to only override this method (and call super.onProvideAutofillStructure()) when: The view contents does not include PII (Personally Identifiable Information), so it can call @B_android#view#ViewStructure#setDataIsSensitive_E@ passing false. The view can only be autofilled with predefined options, so it can call @B_android#view#ViewStructure#setAutofillOptions_E@. left and top values set in @B_android#view#ViewStructure#setDimens_E@ must be relative to the next @B_android#view#View#isImportantForAutofill_E@ predecessor view included in the structure. Views support the Autofill Framework mainly by: Providing the metadata defining what the view means and how it can be autofilled. Notifying the Android System when the view value changed by calling @B_android#view#autofill#AutofillManager#notifyValueChanged_E@. Implementing the methods that autofill the view. This method is responsible for the former; @B_android#view#View#autofill_E@ is responsible for the latter.", "history": "Added in API level 26", "FullName": "public void onProvideAutofillStructure (ViewStructure structure, int flags)"}, "setKeepScreenOn(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Supply true to set @B_android#view#View#KEEP_SCREEN_ON_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getKeepScreenOn_E@"], "Permissions": [], "Description": "Controls whether the screen should remain on, modifying the value of @B_android#view#View#KEEP_SCREEN_ON_E@.", "history": "Added in API level 1", "FullName": "public void setKeepScreenOn (boolean keepScreenOn)"}, "getLeft()": {"Returns": [["int", "The left edge of this view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Left position of this view relative to its parent.", "history": "Added in API level 1", "FullName": "public final int getLeft ()"}, "postOnAnimationDelayed(java.lang.Runnable,long)": {"Returns": [], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: The Runnable that will be executed."], ["long", "long: The delay (in milliseconds) until the Runnable will be executed."]], "Throws": [], "SeeAlso": ["@B_android#view#View#postOnAnimation_E@", "@B_android#view#View#removeCallbacks_E@"], "Permissions": [], "Description": "Causes the Runnable to execute on the next animation time step, after the specified amount of time elapses. The runnable will be run on the user interface thread.", "history": "Added in API level 16", "FullName": "public void postOnAnimationDelayed (Runnable action, long delayMillis)"}, "isInEditMode()": {"Returns": [["boolean", "True if this View is in edit mode, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether this View is currently in edit mode. A View is usually in edit mode when displayed within a developer tool. For instance, if this View is being drawn by a visual user interface builder, this method should return true. Subclasses should check the return value of this method to provide different behaviors if their normal behavior might interfere with the host environment. For instance: the class spawns a thread in its constructor, the drawing code relies on device-specific features, etc. This method is usually checked in the drawing code of custom widgets.", "history": "Added in API level 3", "FullName": "public boolean isInEditMode ()"}, "setLayerType(int,android.graphics.Paint)": {"Returns": [], "Parameters": [["int", "int: The type of layer to use with this view, must be one of @B_android#view#View#LAYER_TYPE_NONE_E@, @B_android#view#View#LAYER_TYPE_SOFTWARE_E@ or @B_android#view#View#LAYER_TYPE_HARDWARE_E@ Value is @B_android#view#View#LAYER_TYPE_NONE_E@, @B_android#view#View#LAYER_TYPE_SOFTWARE_E@, or @B_android#view#View#LAYER_TYPE_HARDWARE_E@"], ["@B_android#graphics#Paint_E@", "Paint: The paint used to compose the layer. This argument is optional and can be null. It is ignored when the layer type is @B_android#view#View#LAYER_TYPE_NONE_E@ This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getLayerType_E@", "@B_android#view#View_E@", "@B_android#view#View#setAlpha_E@"], "Permissions": [], "Description": "Specifies the type of layer backing this view. The layer can be @B_android#view#View#LAYER_TYPE_NONE_E@, @B_android#view#View#LAYER_TYPE_SOFTWARE_E@ or @B_android#view#View#LAYER_TYPE_HARDWARE_E@. A layer is associated with an optional @B_android#graphics#Paint_E@ instance that controls how the layer is composed on screen. The following properties of the paint are taken into account when composing the layer: @B_android#graphics#Paint#getAlpha_E@ @B_android#graphics#Paint#getXfermode_E@ @B_android#graphics#Paint#getColorFilter_E@ If this view has an alpha value set to < 1.0 by calling @B_android#view#View#setAlpha_E@, the alpha value of the layer's paint is superseded by this view's alpha value. Refer to the documentation of @B_android#view#View#LAYER_TYPE_NONE_E@, @B_android#view#View#LAYER_TYPE_SOFTWARE_E@ and @B_android#view#View#LAYER_TYPE_HARDWARE_E@ for more information on when and how to use layers.", "history": "Added in API level 11", "FullName": "public void setLayerType (int layerType, Paint paint)"}, "setPaddingRelative(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: the start padding in pixels"], ["int", "int: the top padding in pixels"], ["int", "int: the end padding in pixels"], ["int", "int: the bottom padding in pixels"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the relative padding. The view may add on the space required to display the scrollbars, depending on the style and visibility of the scrollbars. So the values returned from @B_android#view#View#getPaddingStart_E@, @B_android#view#View#getPaddingTop_E@, @B_android#view#View#getPaddingEnd_E@ and @B_android#view#View#getPaddingBottom_E@ may be different from the values set in this call.", "history": "Added in API level 17", "FullName": "public void setPaddingRelative (int start, int top, int end, int bottom)"}, "setFocusableInTouchMode(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: If true, this view can receive the focus while in touch mode."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setFocusable_E@"], "Permissions": [], "Description": "Set whether this view can receive focus while in touch mode. Setting this to true will also ensure that this view is focusable.", "history": "Added in API level 1", "FullName": "public void setFocusableInTouchMode (boolean focusableInTouchMode)"}, "focusSearch(int)": {"Returns": [["@B_android#view#View_E@", "The nearest focusable in the specified direction, or null if none can be found."]], "Parameters": [["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT Value is @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_RIGHT_E@, or @B_android#view#View#FOCUS_DOWN_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the nearest view in the specified direction that can take focus. This does not actually give focus to that view.", "history": "Added in API level 1", "FullName": "public View focusSearch (int direction)"}, "postInvalidate()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#invalidate_E@", "@B_android#view#View#postInvalidateDelayed_E@"], "Permissions": [], "Description": "Cause an invalidate to happen on a subsequent cycle through the event loop. Use this to invalidate the View from a non-UI thread. This method can be invoked from outside of the UI thread only when this View is attached to a window.", "history": "Added in API level 1", "FullName": "public void postInvalidate ()"}, "layout(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Assign a size and position to a view and all of its descendants This is the second phase of the layout mechanism. (The first is measuring). In this phase, each parent calls layout on all of its children to position them. This is typically done using the child measurements that were stored in the measure pass(). Derived classes should not override this method. Derived classes with children should override onLayout. In that method, they should call layout on each of their children.", "history": "added in API level 1", "FullName": "public void layout (int l, int t, int r, int b)"}, "getMeasuredHeight()": {"Returns": [["int", "The raw measured height of this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#view#View#getMeasuredHeightAndState_E@, but only returns the raw height component (that is the result is masked by @B_android#view#View#MEASURED_SIZE_MASK_E@).", "history": "Added in API level 1", "FullName": "public final int getMeasuredHeight ()"}, "onFilterTouchEventForSecurity(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event should be dispatched, false if the event should be dropped."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be filtered."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getFilterTouchesWhenObscured_E@"], "Permissions": [], "Description": "Filter the touch event to apply security policies.", "history": "Added in API level 9", "FullName": "public boolean onFilterTouchEventForSecurity (MotionEvent event)"}, "setBackgroundDrawable(android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "use @B_android#view#View#setBackground_E@ instead", "history": "Added in API level 1 Deprecated in API level 16", "FullName": "public void setBackgroundDrawable (Drawable background)"}, "performAccessibilityAction(int, android.os.Bundle)": {"Returns": [["boolean", "Whether the action was performed."]], "Parameters": [["int", "int: The action to perform."], ["@B_android#os#Bundle_E@", "Bundle: Optional action arguments."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Performs the specified accessibility action on the view. For possible accessibility actions look at @B_android#view#accessibility#AccessibilityNodeInfo_E@. If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#performAccessibilityAction_E@ is responsible for handling this call. The default implementation will delegate @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_SCROLL_BACKWARD_E@ and @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_SCROLL_FORWARD_E@ to nested scrolling parents if @B_android#view#View#isNestedScrollingEnabled_E@ on this view.", "history": "added in API level 16", "FullName": "public boolean performAccessibilityAction (int action, Bundle arguments)"}, "setKeyboardNavigationCluster(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: If true, this view is a root of a cluster."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set whether this view is a root of a keyboard navigation cluster.", "history": "Added in API level 26", "FullName": "public void setKeyboardNavigationCluster (boolean isCluster)"}, "dispatchRestoreInstanceState(android.util.SparseArray<android.os.Parcelable>)": {"Returns": [], "Parameters": [["@B_android#util#SparseArray_E@", "SparseArray: The SparseArray which holds previously saved state."]], "Throws": [], "SeeAlso": ["@B_android#view#View#dispatchSaveInstanceState_E@", "@B_android#view#View#restoreHierarchyState_E@", "@B_android#view#View#onRestoreInstanceState_E@"], "Permissions": [], "Description": "Called by @B_android#view#View#restoreHierarchyState_E@ to retrieve the state for this view and its children. May be overridden to modify how restoring happens to a view's children; for example, some views may want to not store state for their children.", "history": "Added in API level 1", "FullName": "protected void dispatchRestoreInstanceState (SparseArray<Parcelable> container)"}, "canResolveLayoutDirection()": {"Returns": [["boolean", "true if layout direction resolution can be done otherwise return false."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if layout direction resolution can be done.", "history": "Added in API level 19", "FullName": "public boolean canResolveLayoutDirection ()"}, "isScreenReaderFocusable()": {"Returns": [["boolean", "Whether the view should be treated as a focusable unit by screen reader."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setScreenReaderFocusable_E@"], "Permissions": [], "Description": "Returns whether the view should be treated as a focusable unit by screen reader accessibility tools.", "history": "Added in API level 28", "FullName": "public boolean isScreenReaderFocusable ()"}, "getClipBounds(android.graphics.Rect)": {"Returns": [["boolean", "true if successful or false if the view's clip bounds are null"]], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: rectangle in which to place the clip bounds of the view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Populates an output rectangle with the clip bounds of the view, returning true if successful or false if the view's clip bounds are null.", "history": "Added in API level 23", "FullName": "public boolean getClipBounds (Rect outRect)"}, "getWindowVisibility()": {"Returns": [["int", "Returns the current visibility of the view's window. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current visibility of the window this view is attached to (either @B_android#view#View#GONE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#VISIBLE_E@).", "history": "Added in API level 1", "FullName": "public int getWindowVisibility ()"}, "setTag(int,java.lang.Object)": {"Returns": [], "Parameters": [["int", "int: The key identifying the tag"], ["@B_java#lang#Object_E@", "Object: An Object to tag the view with"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "If they specified key is not valid"]], "SeeAlso": ["@B_android#view#View#setTag_E@", "@B_android#view#View#getTag_E@"], "Permissions": [], "Description": "Sets a tag associated with this view and a key. A tag can be used to mark a view in its hierarchy and does not have to be unique within the hierarchy. Tags can also be used to store data within a view without resorting to another data structure. The specified key should be an id declared in the resources of the application to ensure it is unique (see the @B_java#lang#IllegalArgumentException_E@ to be thrown.", "history": "Added in API level 4", "FullName": "public void setTag (int key, Object tag)"}, "computeVerticalScrollRange()": {"Returns": [["int", "the total vertical range represented by the vertical scrollbar The default range is the drawing height of this view."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#computeVerticalScrollExtent_E@", "@B_android#view#View#computeVerticalScrollOffset_E@"], "Permissions": [], "Description": "Compute the vertical range that the vertical scrollbar represents. The range is expressed in arbitrary units that must be the same as the units used by @B_android#view#View#computeVerticalScrollExtent_E@ and @B_android#view#View#computeVerticalScrollOffset_E@.", "history": "Added in API level 1", "FullName": "protected int computeVerticalScrollRange ()"}, "isClickable()": {"Returns": [["boolean", "true if the view is clickable, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setClickable_E@"], "Permissions": [], "Description": "Indicates whether this view reacts to click events or not.", "history": "Added in API level 1", "FullName": "public boolean isClickable ()"}, "dispatchWindowFocusChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the window containing this view now has focus, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the window containing this view gains or loses window focus. ViewGroups should override to route to their children.", "history": "Added in API level 1", "FullName": "public void dispatchWindowFocusChanged (boolean hasFocus)"}, "saveAttributeDataForStyleable(android.content.Context,int[],android.util.AttributeSet,android.content.res.TypedArray,int,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: Context under which this view is created. This value must never be null."], ["int[]", "int: A reference to styleable array R.styleable.Foo This value must never be null."], ["@B_android#util#AttributeSet_E@", "AttributeSet: AttributeSet used to construct this view. This value may be null."], ["@B_android#content#res#TypedArray_E@", "TypedArray: Resolved @B_android#content#res#TypedArray_E@ returned by a call to @B_android#content#res#Resources#obtainAttributes_E@. This value must never be null."], ["int", "int: Default style attribute passed into the view constructor."], ["int", "int: Default style resource passed into the view constructor."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Stores debugging information about attributes. This should be called in a constructor by every custom @B_android#view#View_E@ that uses a custom styleable. If the custom view does not call it, then the custom attributes used by this view will not be visible in layout inspection tools.", "history": "Added in API level 29", "FullName": "public final void saveAttributeDataForStyleable (Context context, int[] styleable, AttributeSet attrs, TypedArray t, int defStyleAttr, int defStyleRes)"}, "startDragAndDrop(android.content.ClipData,android.view.View.DragShadowBuilder,java.lang.Object,int)": {"Returns": [["boolean", "true if the method completes successfully, or false if it fails anywhere. Returning false means the system was unable to do a drag because of another ongoing operation or some other reasons."]], "Parameters": [["@B_android#content#ClipData_E@", "ClipData: A @B_android#content#ClipData_E@ object pointing to the data to be transferred by the drag and drop operation."], ["@B_android#view#View#DragShadowBuilder_E@", "View.DragShadowBuilder: A @B_android#view#View#DragShadowBuilder_E@ object for building the drag shadow."], ["@B_java#lang#Object_E@", "Object: An @B_java#lang#Object_E@ containing local data about the drag and drop operation. When dispatching drag events to views in the same activity this object will be available through @B_android#view#DragEvent#getLocalState_E@. Views in other activities will not have access to this data (@B_android#view#DragEvent#getLocalState_E@ will return null). myLocalState is a lightweight mechanism for the sending information from the dragged View to the target Views. For example, it can contain flags that differentiate between a a copy operation and a move operation."], ["int", "int: Flags that control the drag and drop operation. This can be set to 0 for no flags, or any combination of the following: DRAG_FLAG_GLOBAL DRAG_FLAG_GLOBAL_PERSISTABLE_URI_PERMISSION DRAG_FLAG_GLOBAL_PREFIX_URI_PERMISSION DRAG_FLAG_GLOBAL_URI_READ DRAG_FLAG_GLOBAL_URI_WRITE DRAG_FLAG_OPAQUE"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Starts a drag and drop operation. When your application calls this method, it passes a @B_android#view#View#DragShadowBuilder_E@ object to the system. The system calls this object's @B_android#view#View#DragShadowBuilder#onProvideShadowMetrics_E@ to get metrics for the drag shadow, and then calls the object's @B_android#view#View#DragShadowBuilder#onDrawShadow_E@ to draw the drag shadow itself. Once the system has the drag shadow, it begins the drag and drop operation by sending drag events to all the View objects in your application that are currently visible. It does this either by calling the View object's drag listener (an implementation of @B_android#view#View#OnDragListener#onDrag_E@ or by calling the View object's @B_android#view#View#onDragEvent_E@ method. Both are passed a @B_android#view#DragEvent_E@ object that has a @B_android#view#DragEvent#getAction_E@ value of @B_android#view#DragEvent#ACTION_DRAG_STARTED_E@. Your application can invoke @B_android#view#View#startDragAndDrop_E@ on any attached View object. The View object does not need to be the one used in @B_android#view#View#DragShadowBuilder_E@, nor does it need to be related to the View the user selected for dragging.", "history": "Added in API level 24", "FullName": "public final boolean startDragAndDrop (ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)"}, "getUniqueDrawingId()": {"Returns": [["long", "A long that uniquely identifies this view's drawing component"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#graphics#RenderNode#getUniqueId_E@"], "Permissions": [], "Description": "Get the identifier used for this view by the drawing system.", "history": "Added in API level 29", "FullName": "public long getUniqueDrawingId ()"}, "setSystemUiVisibility(int)": {"Returns": [], "Parameters": [["int", "int: Bitwise-or of flags @B_android#view#View#SYSTEM_UI_FLAG_LOW_PROFILE_E@, @B_android#view#View#SYSTEM_UI_FLAG_HIDE_NAVIGATION_E@, @B_android#view#View#SYSTEM_UI_FLAG_FULLSCREEN_E@, @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_STABLE_E@, @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION_E@, @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN_E@, @B_android#view#View#SYSTEM_UI_FLAG_IMMERSIVE_E@, and @B_android#view#View#SYSTEM_UI_FLAG_IMMERSIVE_STICKY_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request that the visibility of the status bar or other screen/window decorations be changed. This method is used to put the over device UI into temporary modes where the user's attention is focused more on the application content, by dimming or hiding surrounding system affordances. This is typically used in conjunction with @B_android#view#Window#FEATURE_ACTION_BAR_OVERLAY_E@, allowing the applications content to be placed behind the action bar (and with these flags other system affordances) so that smooth transitions between hiding and showing them can be done. Two representative examples of the use of system UI visibility is implementing a content browsing application (like a magazine reader) and a video playing application. The first code shows a typical implementation of a View in a content browsing application. In this implementation, the application goes into a content-oriented mode by hiding the status bar and action bar, and putting the navigation elements into lights out mode. The user can then interact with content while in this mode. Such an application should provide an easy way for the user to toggle out of the mode (such as to check information in the status bar or access notifications). In the implementation here, this is done simply by tapping on the content. This second code sample shows a typical implementation of a View in a video playing application. In this situation, while the video is playing the application would like to go into a complete full-screen mode, to use as much of the display as possible for the video. When in this state the user can not interact with the application; the system intercepts touching on the screen to pop the UI out of full screen mode. See @B_android#view#View#fitSystemWindows_E@ for a sample layout that goes with this code.", "history": "Added in API level 11", "FullName": "public void setSystemUiVisibility (int visibility)"}, "getOnFocusChangeListener()": {"Returns": [["@B_android#view#View#OnFocusChangeListener_E@", "The callback, or null if one is not registered."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the focus-change callback registered for this view.", "history": "Added in API level 1", "FullName": "public View.OnFocusChangeListener getOnFocusChangeListener ()"}, "getWindowId()": {"Returns": [["@B_android#view#WindowId_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the @B_android#view#WindowId_E@ for the window this view is currently attached to.", "history": "Added in API level 18", "FullName": "public WindowId getWindowId ()"}, "onCreateDrawableState(int)": {"Returns": [["int[]", "Returns an array holding the current @B_android#graphics#drawable#Drawable_E@ state of the view."]], "Parameters": [["int", "int: if non-zero, this is the number of extra entries you would like in the returned array in which you can place your own states."]], "Throws": [], "SeeAlso": ["@B_android#view#View#mergeDrawableStates_E@"], "Permissions": [], "Description": "Generate the new @B_android#graphics#drawable#Drawable_E@ state for this view. This is called by the view system when the cached Drawable state is determined to be invalid. To retrieve the current state, you should use @B_android#view#View#getDrawableState_E@.", "history": "Added in API level 1", "FullName": "protected int[] onCreateDrawableState (int extraSpace)"}, "setHovered(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the view is hovered."]], "Throws": [], "SeeAlso": ["@B_android#view#View#isHovered_E@", "@B_android#view#View#onHoverChanged_E@"], "Permissions": [], "Description": "Sets whether the view is currently hovered. Calling this method also changes the drawable state of the view. This enables the view to react to hover by using different drawable resources to change its appearance. The @B_android#view#View#onHoverChanged_E@ method is called when the hovered state changes.", "history": "Added in API level 14", "FullName": "public void setHovered (boolean hovered)"}, "onProvideStructure(android.view.ViewStructure)": {"Returns": [], "Parameters": [["@B_android#view#ViewStructure_E@", "ViewStructure: Fill in with structured view data. The default implementation fills in all data that can be inferred from the view itself."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when assist structure is being retrieved from a view as part of @B_android#app#Activity#onProvideAssistData_E@.", "history": "Added in API level 23", "FullName": "public void onProvideStructure (ViewStructure structure)"}, "canResolveTextAlignment()": {"Returns": [["boolean", "true if text alignment resolution can be done otherwise return false."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if text alignment resolution can be done.", "history": "Added in API level 19", "FullName": "public boolean canResolveTextAlignment ()"}, "onKeyPreIme(int, android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handle a key event before it is processed by any input method associated with the view hierarchy. This can be used to intercept key events in special situations before the IME consumes them; a typical example would be handling the BACK key to update the application's UI instead of allowing the IME to see it and close itself.", "history": "added in API level 3", "FullName": "public boolean onKeyPreIme (int keyCode, KeyEvent event)"}, "onScrollChanged(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: Current horizontal scroll origin."], ["int", "int: Current vertical scroll origin."], ["int", "int: Previous horizontal scroll origin."], ["int", "int: Previous vertical scroll origin."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called in response to an internal scroll in this view (i.e., the view scrolled its own contents). This is typically as a result of @B_android#view#View#scrollBy_E@ or @B_android#view#View#scrollTo_E@ having been called.", "history": "added in API level 1", "FullName": "protected void onScrollChanged (int l, int t, int oldl, int oldt)"}, "draw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: The Canvas to which the View is rendered."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Manually render this view (and all of its children) to the given Canvas. The view must have already done a full layout before this function is called. When implementing a view, implement @B_android#view#View#onDraw_E@ instead of overriding this method. If you do need to override this method, call the superclass version. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "public void draw (Canvas canvas)"}, "setAutofillId(android.view.autofill.AutofillId)": {"Returns": [], "Parameters": [["@B_android#view#autofill#AutofillId_E@", "AutofillId: an autofill ID that is unique in the @B_android#app#Activity_E@ hosting the view, or null to reset it. Usually it's an id previously allocated to another view (and obtained through @B_android#view#View#getAutofillId_E@), or a new value obtained through @B_android#view#autofill#AutofillManager#getNextAutofillId_E@. This value may be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the view is already @B_android#view#View#isAttachedToWindow_E@."], ["@B_java#lang#IllegalArgumentException_E@", "if the id is an autofill id associated with a virtual view."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the unique, logical identifier of this view in the activity, for autofill purposes. The autofill id is created on demand, and this method should only be called when a view is reused after @B_android#view#View#dispatchProvideAutofillStructure_E@ is called, as that method creates a snapshot of the view that is passed along to the autofill service. This method is typically used when view subtrees are recycled to represent different content* \u2014in this case, the autofill id can be saved before the view content is swapped out, and restored later when it's swapped back in. For example:", "history": "Added in API level 28", "FullName": "public void setAutofillId (AutofillId id)"}, "isAccessibilityFocused()": {"Returns": [["boolean", "True if this View is accessibility focused."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether this View is accessibility focused.", "history": "Added in API level 21", "FullName": "public boolean isAccessibilityFocused ()"}, "isAccessibilityHeading()": {"Returns": [["boolean", "true if the view is a heading, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets whether this view is a heading for accessibility purposes.", "history": "Added in API level 28", "FullName": "public boolean isAccessibilityHeading ()"}, "isHovered()": {"Returns": [["boolean", "True if the view is currently hovered."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setHovered_E@", "@B_android#view#View#onHoverChanged_E@"], "Permissions": [], "Description": "Returns true if the view is currently hovered.", "history": "Added in API level 14", "FullName": "public boolean isHovered ()"}, "setHapticFeedbackEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: whether haptic feedback enabled for this view."]], "Throws": [], "SeeAlso": ["@B_android#view#View#isHapticFeedbackEnabled_E@", "@B_android#view#View#performHapticFeedback_E@"], "Permissions": [], "Description": "Set whether this view should have haptic feedback for events such as long presses. You may wish to disable haptic feedback if your view already controls its own haptic feedback.", "history": "Added in API level 3", "FullName": "public void setHapticFeedbackEnabled (boolean hapticFeedbackEnabled)"}, "getAutofillValue()": {"Returns": [["@B_android#view#autofill#AutofillValue_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#onProvideAutofillStructure_E@", "@B_android#view#View#autofill_E@"], "Permissions": [], "Description": "Gets the @B_android#view#View_E@'s current autofill value. By default returns null, but subclasses should override it and return an appropriate value to properly support the Autofill Framework.", "history": "Added in API level 26", "FullName": "public AutofillValue getAutofillValue ()"}, "setWillNotDraw(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: whether or not this View draw on its own"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "If this view doesn't do any drawing on its own, set this flag to allow further optimizations. By default, this flag is not set on View, but could be set on some View subclasses such as ViewGroup. Typically, if you override @B_android#view#View#onDraw_E@ you should clear this flag.", "history": "Added in API level 1", "FullName": "public void setWillNotDraw (boolean willNotDraw)"}, "getTouchDelegate()": {"Returns": [["@B_android#view#TouchDelegate_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the TouchDelegate for this View.", "history": "Added in API level 1", "FullName": "public TouchDelegate getTouchDelegate ()"}, "getOverlay()": {"Returns": [["@B_android#view#ViewOverlay_E@", "The ViewOverlay object for this view."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewOverlay_E@"], "Permissions": [], "Description": "Returns the overlay for this view, creating it if it does not yet exist. Adding drawables to the overlay will cause them to be displayed whenever the view itself is redrawn. Objects in the overlay should be actively managed: remove them when they should not be displayed anymore. The overlay will always have the same size as its host view. Note: Overlays do not currently work correctly with @B_android#view#SurfaceView_E@ or @B_android#view#TextureView_E@; contents in overlays for these types of views may not display correctly.", "history": "Added in API level 18", "FullName": "public ViewOverlay getOverlay ()"}, "postInvalidateOnAnimation()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#invalidate_E@"], "Permissions": [], "Description": "Cause an invalidate to happen on the next animation time step, typically the next display frame. This method can be invoked from outside of the UI thread only when this View is attached to a window.", "history": "Added in API level 16", "FullName": "public void postInvalidateOnAnimation ()"}, "onRestoreInstanceState(android.os.Parcelable)": {"Returns": [], "Parameters": [["@B_android#os#Parcelable_E@", "Parcelable: The frozen state that had previously been returned by @B_android#view#View#onSaveInstanceState_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#View#onSaveInstanceState_E@", "@B_android#view#View#restoreHierarchyState_E@", "@B_android#view#View#dispatchRestoreInstanceState_E@"], "Permissions": [], "Description": "Hook allowing a view to re-apply a representation of its internal state that had previously been generated by @B_android#view#View#onSaveInstanceState_E@. This function will never be called with a null state. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onRestoreInstanceState (Parcelable state)"}, "postOnAnimation(java.lang.Runnable)": {"Returns": [], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: The Runnable that will be executed."]], "Throws": [], "SeeAlso": ["@B_android#view#View#postOnAnimationDelayed_E@", "@B_android#view#View#removeCallbacks_E@"], "Permissions": [], "Description": "Causes the Runnable to execute on the next animation time step. The runnable will be run on the user interface thread.", "history": "Added in API level 16", "FullName": "public void postOnAnimation (Runnable action)"}, "getVerticalScrollbarPosition()": {"Returns": [["int", "The position where the vertical scroll bar will show, if applicable."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setVerticalScrollbarPosition_E@"], "Permissions": [], "Description": "", "history": "Added in API level 11", "FullName": "public int getVerticalScrollbarPosition ()"}, "setScrollBarSize(int)": {"Returns": [], "Parameters": [["int", "int: - the scrollbar size"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Define the scrollbar size.", "history": "Added in API level 16", "FullName": "public void setScrollBarSize (int scrollBarSize)"}, "setLabelFor(int)": {"Returns": [], "Parameters": [["int", "int: The labeled view id."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the id of a view for which this view serves as a label for accessibility purposes.", "history": "Added in API level 17", "FullName": "public void setLabelFor (int id)"}, "bringToFront()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup#bringChildToFront_E@"], "Permissions": [], "Description": "Change the view's z order in the tree, so it's on top of other sibling views. This ordering change may affect layout, if the parent container uses an order-dependent layout scheme (e.g., LinearLayout). Prior to @B_android#os#Build#VERSION_CODES#KITKAT_E@ this method should be followed by calls to @B_android#view#View#requestLayout_E@ and @B_android#view#View#invalidate_E@ on the view's parent to force the parent to redraw with the new child ordering.", "history": "Added in API level 1", "FullName": "public void bringToFront ()"}, "getStateListAnimator()": {"Returns": [["@B_android#animation#StateListAnimator_E@", "StateListAnimator or null if it does not exists"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setStateListAnimator_E@"], "Permissions": [], "Description": "Returns the current StateListAnimator if exists.", "history": "Added in API level 21", "FullName": "public StateListAnimator getStateListAnimator ()"}, "layout(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Assign a size and position to a view and all of its descendants This is the second phase of the layout mechanism. (The first is measuring). In this phase, each parent calls layout on all of its children to position them. This is typically done using the child measurements that were stored in the measure pass(). Derived classes should not override this method. Derived classes with children should override onLayout. In that method, they should call layout on each of their children.", "history": "Added in API level 1", "FullName": "public void layout (int l, int t, int r, int b)"}, "resolveSize(int,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Version of @B_android#view#View#resolveSizeAndState_E@ returning only the @B_android#view#View#MEASURED_SIZE_MASK_E@ bits of the result.", "history": "Added in API level 1", "FullName": "public static int resolveSize (int size, int measureSpec)"}, "isVerticalScrollBarEnabled()": {"Returns": [["boolean", "true if the vertical scrollbar should be painted, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Indicate whether the vertical scrollbar should be drawn or not. The scrollbar is not drawn by default.", "history": "Added in API level 1", "FullName": "public boolean isVerticalScrollBarEnabled ()"}, "getFocusables(int)": {"Returns": [["@B_java#util#ArrayList_E@", "A list of focusable views"]], "Parameters": [["int", "int: The direction of the focus Value is @B_android#view#View#FOCUS_BACKWARD_E@, @B_android#view#View#FOCUS_FORWARD_E@, @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_RIGHT_E@, or @B_android#view#View#FOCUS_DOWN_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find and return all focusable views that are descendants of this view, possibly including this view if it is focusable itself.", "history": "Added in API level 1", "FullName": "public ArrayList<View> getFocusables (int direction)"}, "onKeyShortcut(int, android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called on the focused view when a key shortcut event is not handled. Override this method to implement local key shortcuts for the View. Key shortcuts can also be implemented by setting the @B_android#view#MenuItem#setShortcut_E@ property of menu items.", "history": "added in API level 1", "FullName": "public boolean onKeyShortcut (int keyCode, KeyEvent event)"}, "setTranslationX(float)": {"Returns": [], "Parameters": [["float", "float: The horizontal position of this view relative to its left position, in pixels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the horizontal location of this view relative to its @B_android#view#View#getLeft_E@ position. This effectively positions the object post-layout, in addition to wherever the object's layout placed it.", "history": "Added in API level 11", "FullName": "public void setTranslationX (float translationX)"}, "awakenScrollBars()": {"Returns": [["boolean", "true if the animation is played, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@", "@B_android#view#View#scrollBy_E@", "@B_android#view#View#scrollTo_E@", "@B_android#view#View#isHorizontalScrollBarEnabled_E@", "@B_android#view#View#isVerticalScrollBarEnabled_E@", "@B_android#view#View#setHorizontalScrollBarEnabled_E@", "@B_android#view#View#setVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Trigger the scrollbars to draw. When invoked this method starts an animation to fade the scrollbars out after a default delay. If a subclass provides animated scrolling, the start delay should equal the duration of the scrolling animation. The animation starts only if at least one of the scrollbars is enabled, as specified by @B_android#view#View#isHorizontalScrollBarEnabled_E@ and @B_android#view#View#isVerticalScrollBarEnabled_E@. When the animation is started, this method returns true, and false otherwise. If the animation is started, this method calls @B_android#view#View#invalidate_E@; in that case the caller should not call @B_android#view#View#invalidate_E@. This method should be invoked every time a subclass directly updates the scroll parameters. This method is automatically invoked by @B_android#view#View#scrollBy_E@ and @B_android#view#View#scrollTo_E@.", "history": "Added in API level 5", "FullName": "protected boolean awakenScrollBars ()"}, "onLayout(boolean, int, int, int, int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "added in API level 1", "FullName": "protected void onLayout (boolean changed, int left, int top, int right, int bottom)"}, "setOnTouchListener(android.view.View.OnTouchListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnTouchListener_E@", "View.OnTouchListener: the touch listener to attach to this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when a touch event is sent to this view.", "history": "Added in API level 1", "FullName": "public void setOnTouchListener (View.OnTouchListener l)"}, "checkInputConnectionProxy(android.view.View)": {"Returns": [["boolean", "Return true to allow the call, false to reject."]], "Parameters": [["@B_android#view#View_E@", "View: The View that is making the InputMethodManager call."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the @B_android#view#inputmethod#InputMethodManager_E@ when a view who is not the current input connection target is trying to make a call on the manager. The default implementation returns false; you can override this to return true for certain views if you are performing InputConnection proxying to them.", "history": "Added in API level 3", "FullName": "public boolean checkInputConnectionProxy (View view)"}, "setAccessibilityTraversalAfter(int)": {"Returns": [], "Parameters": [["int", "int: The id of a view this one succedees in accessibility traversal."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setImportantForAccessibility_E@"], "Permissions": [], "Description": "Sets the id of a view after which this one is visited in accessibility traversal. A screen-reader must visit the content of the other view before the content of this one. For example, if view B is set to be after view A, then a screen-reader will traverse the entire content of A before traversing the entire content of B, regardles of what traversal strategy it is using. Views that do not have specified before/after relationships are traversed in order determined by the screen-reader. Setting that this view is after a view that is not important for accessibility or if this view is not important for accessibility will have no effect as the screen-reader is not aware of unimportant views.", "history": "Added in API level 22", "FullName": "public void setAccessibilityTraversalAfter (int afterId)"}, "invalidateDrawable(android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: the drawable to invalidate This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Invalidates the specified Drawable.", "history": "Added in API level 1", "FullName": "public void invalidateDrawable (Drawable drawable)"}, "dispatchNestedFling(float,float,boolean)": {"Returns": [["boolean", "true if the nested scrolling parent consumed or otherwise reacted to the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"], ["boolean", "boolean: true if the child consumed the fling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent. This method should be used to indicate that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling.", "history": "Added in API level 21", "FullName": "public boolean dispatchNestedFling (float velocityX, float velocityY, boolean consumed)"}, "getMatrix()": {"Returns": [["@B_android#graphics#Matrix_E@", "The current transform matrix for the view"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getRotation_E@", "@B_android#view#View#getScaleX_E@", "@B_android#view#View#getScaleY_E@", "@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "The transform matrix of this view, which is calculated based on the current rotation, scale, and pivot properties.", "history": "Added in API level 11", "FullName": "public Matrix getMatrix ()"}, "getCameraDistance()": {"Returns": [["float", "The distance along the Z axis."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setCameraDistance_E@"], "Permissions": [], "Description": "Gets the distance along the Z axis from the camera to this view.", "history": "Added in API level 16", "FullName": "public float getCameraDistance ()"}, "getRootWindowInsets()": {"Returns": [["@B_android#view#WindowInsets_E@", "WindowInsets from the top of the view hierarchy or null if View is detached"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Provide original WindowInsets that are dispatched to the view hierarchy. The insets are only available if the view is attached.", "history": "Added in API level 23", "FullName": "public WindowInsets getRootWindowInsets ()"}, "getNextFocusDownId()": {"Returns": [["int", "The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the id of the view to use when the next focus is @B_android#view#View#FOCUS_DOWN_E@.", "history": "Added in API level 1", "FullName": "public int getNextFocusDownId ()"}, "dispatchGenericMotionEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a generic motion event. Generic motion events with source class @B_android#view#InputDevice#SOURCE_CLASS_POINTER_E@ are delivered to the view under the pointer. All other generic motion events are delivered to the focused view. Hover events are handled specially and are delivered to @B_android#view#View#onHoverEvent_E@.", "history": "Added in API level 12", "FullName": "public boolean dispatchGenericMotionEvent (MotionEvent event)"}, "setId(int)": {"Returns": [], "Parameters": [["int", "int: a number used to identify the view"]], "Throws": [], "SeeAlso": ["@B_android#view#View_E@", "@B_android#view#View#getId_E@", "@B_android#view#View#findViewById_E@"], "Permissions": [], "Description": "Sets the identifier for this view. The identifier does not have to be unique in this view's hierarchy. The identifier should be a positive number.", "history": "Added in API level 1", "FullName": "public void setId (int id)"}, "requestApplyInsets()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask that a new dispatch of @B_android#view#View#onApplyWindowInsets_E@ be performed.", "history": "Added in API level 20", "FullName": "public void requestApplyInsets ()"}, "onKeyUp(int,android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: A key code that represents the button pressed, from @B_android#view#KeyEvent_E@."], ["@B_android#view#KeyEvent_E@", "KeyEvent: The KeyEvent object that defines the button action."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyUp_E@: perform clicking of the view when @B_android#view#KeyEvent#KEYCODE_DPAD_CENTER_E@, @B_android#view#KeyEvent#KEYCODE_ENTER_E@ or @B_android#view#KeyEvent#KEYCODE_SPACE_E@ is released. Key presses in software keyboards will generally NOT trigger this listener, although some may elect to do so in some situations. Do not rely on this to catch software key presses.", "history": "Added in API level 1", "FullName": "public boolean onKeyUp (int keyCode, KeyEvent event)"}, "setPressed(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Pass true to set the View's internal state to \"pressed\", or false to reverts the View's internal state from a previously set \"pressed\" state."]], "Throws": [], "SeeAlso": ["@B_android#view#View#isClickable_E@", "@B_android#view#View#setClickable_E@"], "Permissions": [], "Description": "Sets the pressed state for this view.", "history": "Added in API level 1", "FullName": "public void setPressed (boolean pressed)"}, "onCheckIsTextEditor()": {"Returns": [["boolean", "Returns true if this view is a text editor, else false."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check whether the called view is a text editor, in which case it would make sense to automatically display a soft input window for it. Subclasses should override this if they implement @B_android#view#View#onCreateInputConnection_E@ to return true if a call on that method would return a non-null InputConnection, and they are really a first-class editor that the user would normally start typing on when the go into a window containing your view. The default implementation always returns false. This does not mean that its @B_android#view#View#onCreateInputConnection_E@ will not be called or the user can not otherwise perform edits on your view; it is just a hint to the system that this is not the primary purpose of this view.", "history": "Added in API level 3", "FullName": "public boolean onCheckIsTextEditor ()"}, "inflate(android.content.Context,int,android.view.ViewGroup)": {"Returns": [["@B_android#view#View_E@", "no returns description in source"]], "Parameters": [["@B_android#content#Context_E@", "Context: The Context object for your activity or application."], ["int", "int: The resource ID to inflate"], ["@B_android#view#ViewGroup_E@", "ViewGroup: A view group that will be the parent. Used to properly inflate the layout_* parameters."]], "Throws": [], "SeeAlso": ["@B_android#view#LayoutInflater_E@"], "Permissions": [], "Description": "Inflate a view from an XML resource. This convenience method wraps the @B_android#view#LayoutInflater_E@ class, which provides a full range of options for view inflation.", "history": "Added in API level 1", "FullName": "public static View inflate (Context context, int resource, ViewGroup root)"}, "getLocationInWindow(int[])": {"Returns": [], "Parameters": [["int[]", "int: an array of two integers in which to hold the coordinates"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Computes the coordinates of this view in its window. The argument must be an array of two integers. After the method returns, the array contains the x and y location in that order.", "history": "Added in API level 1", "FullName": "public void getLocationInWindow (int[] outLocation)"}, "setForegroundTintBlendMode(android.graphics.BlendMode)": {"Returns": [], "Parameters": [["@B_android#graphics#BlendMode_E@", "BlendMode: the blending mode used to apply the tint, may be null to clear tint This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getForegroundTintMode_E@", "@B_android#graphics#drawable#Drawable#setTintBlendMode_E@"], "Permissions": [], "Description": "Specifies the blending mode used to apply the tint specified by @B_android#view#View#setForegroundTintList_E@} to the background drawable. The default mode is @B_android#graphics#BlendMode#SRC_IN_E@.", "history": "Added in API level 29", "FullName": "public void setForegroundTintBlendMode (BlendMode blendMode)"}, "getImportantForAccessibility()": {"Returns": [["int", "The mode for determining whether a view is important for accessibility, one of @B_android#view#View#IMPORTANT_FOR_ACCESSIBILITY_AUTO_E@, @B_android#view#View#IMPORTANT_FOR_ACCESSIBILITY_YES_E@, @B_android#view#View#IMPORTANT_FOR_ACCESSIBILITY_NO_E@, or @B_android#view#View#IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS_E@."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Gets the mode for determining whether this View is important for accessibility. A view is important for accessibility if it fires accessibility events and if it is reported to accessibility services that query the screen.", "history": "Added in API level 16", "FullName": "public int getImportantForAccessibility ()"}, "buildLayer()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "If this view is not attached to a window"]], "SeeAlso": ["@B_android#view#View#setLayerType_E@"], "Permissions": [], "Description": "Forces this view's layer to be created and this view to be rendered into its layer. If this view's layer type is set to @B_android#view#View#LAYER_TYPE_NONE_E@, invoking this method will have no effect. This method can for instance be used to render a view into its layer before starting an animation. If this view is complex, rendering into the layer before starting the animation will avoid skipping frames.", "history": "Added in API level 12", "FullName": "public void buildLayer ()"}, "setLayerType(int, android.graphics.Paint)": {"Returns": [], "Parameters": [["int", "int: The type of layer to use with this view, must be one of @B_android#view#View#LAYER_TYPE_NONE_E@, @B_android#view#View#LAYER_TYPE_SOFTWARE_E@ or @B_android#view#View#LAYER_TYPE_HARDWARE_E@"], ["@B_android#graphics#Paint_E@", "Paint: The paint used to compose the layer. This argument is optional and can be null. It is ignored when the layer type is @B_android#view#View#LAYER_TYPE_NONE_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View#getLayerType_E@", "@B_android#view#View_E@", "@B_android#view#View#setAlpha_E@"], "Permissions": [], "Description": "Specifies the type of layer backing this view. The layer can be @B_android#view#View#LAYER_TYPE_NONE_E@, @B_android#view#View#LAYER_TYPE_SOFTWARE_E@ or @B_android#view#View#LAYER_TYPE_HARDWARE_E@. A layer is associated with an optional @B_android#graphics#Paint_E@ instance that controls how the layer is composed on screen. The following properties of the paint are taken into account when composing the layer: @B_android#graphics#Paint#getAlpha_E@ @B_android#graphics#Paint#getXfermode_E@ @B_android#graphics#Paint#getColorFilter_E@ If this view has an alpha value set to < 1.0 by calling @B_android#view#View#setAlpha_E@, the alpha value of the layer's paint is superseded by this view's alpha value. Refer to the documentation of @B_android#view#View#LAYER_TYPE_NONE_E@, @B_android#view#View#LAYER_TYPE_SOFTWARE_E@ and @B_android#view#View#LAYER_TYPE_HARDWARE_E@ for more information on when and how to use layers.", "history": "added in API level 11", "FullName": "public void setLayerType (int layerType, Paint paint)"}, "setFadingEdgeLength(int)": {"Returns": [], "Parameters": [["int", "int: The size in pixels of the faded edge used to indicate that more content in this view is visible."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the size of the faded edge used to indicate that more content in this view is available. Will not change whether the fading edge is enabled; use @B_android#view#View#setVerticalFadingEdgeEnabled_E@ or @B_android#view#View#setHorizontalFadingEdgeEnabled_E@ to enable the fading edge for the vertical or horizontal fading edges.", "history": "Added in API level 1", "FullName": "public void setFadingEdgeLength (int length)"}, "postInvalidateDelayed(long,int,int,int,int)": {"Returns": [], "Parameters": [["long", "long: the duration in milliseconds to delay the invalidation by"], ["int", "int: The left coordinate of the rectangle to invalidate."], ["int", "int: The top coordinate of the rectangle to invalidate."], ["int", "int: The right coordinate of the rectangle to invalidate."], ["int", "int: The bottom coordinate of the rectangle to invalidate."]], "Throws": [], "SeeAlso": ["@B_android#view#View#invalidate_E@", "@B_android#view#View#postInvalidate_E@"], "Permissions": [], "Description": "Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop. Waits for the specified amount of time. This method can be invoked from outside of the UI thread only when this View is attached to a window.", "history": "Added in API level 1", "FullName": "public void postInvalidateDelayed (long delayMilliseconds, int left, int top, int right, int bottom)"}, "onCreateInputConnection(android.view.inputmethod.EditorInfo)": {"Returns": [["@B_android#view#inputmethod#InputConnection_E@", "no returns description in source"]], "Parameters": [["@B_android#view#inputmethod#EditorInfo_E@", "EditorInfo: Fill in with attribute information about the connection."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new InputConnection for an InputMethod to interact with the view. The default implementation returns null, since it doesn't support input methods. You can override this to implement such support. This is only needed for views that take focus and text input. When implementing this, you probably also want to implement @B_android#view#View#onCheckIsTextEditor_E@ to indicate you will return a non-null InputConnection. Also, take good care to fill in the @B_android#view#inputmethod#EditorInfo_E@ object correctly and in its entirety, so that the connected IME can rely on its values. For example, @B_android#view#inputmethod#EditorInfo#initialSelStart_E@ and @B_android#view#inputmethod#EditorInfo#initialSelEnd_E@ members must be filled in with the correct cursor position for IMEs to work correctly with your application.", "history": "Added in API level 3", "FullName": "public InputConnection onCreateInputConnection (EditorInfo outAttrs)"}, "getScrollBarFadeDuration()": {"Returns": [["int", "the scrollbar fade duration, in milliseconds"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the scrollbar fade duration.", "history": "Added in API level 16", "FullName": "public int getScrollBarFadeDuration ()"}, "getDrawingCacheQuality()": {"Returns": [["int", "One of @B_android#view#View#DRAWING_CACHE_QUALITY_AUTO_E@, @B_android#view#View#DRAWING_CACHE_QUALITY_LOW_E@, or @B_android#view#View#DRAWING_CACHE_QUALITY_HIGH_E@ Value is @B_android#view#View#DRAWING_CACHE_QUALITY_LOW_E@, @B_android#view#View#DRAWING_CACHE_QUALITY_HIGH_E@, or @B_android#view#View#DRAWING_CACHE_QUALITY_AUTO_E@"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setDrawingCacheQuality_E@", "@B_android#view#View#setDrawingCacheEnabled_E@", "@B_android#view#View#isDrawingCacheEnabled_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Returns the quality of the drawing cache.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public int getDrawingCacheQuality ()"}, "dispatchNestedPreScroll(int,int,int[],int[])": {"Returns": [["boolean", "true if the parent consumed some or all of the scroll delta"]], "Parameters": [["int", "int: Horizontal scroll distance in pixels"], ["int", "int: Vertical scroll distance in pixels"], ["int[]", "int: Output. If not null, consumed[0] will contain the consumed component of dx and consumed[1] the consumed dy. This value may be null."], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#dispatchNestedScroll_E@"], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress before this view consumes any portion of it. Nested pre-scroll events are to nested scroll events what touch intercept is to touch. dispatchNestedPreScroll offers an opportunity for the parent view in a nested scrolling operation to consume some or all of the scroll operation before the child view consumes it.", "history": "Added in API level 21", "FullName": "public boolean dispatchNestedPreScroll (int dx, int dy, int[] consumed, int[] offsetInWindow)"}, "setContentCaptureSession(android.view.contentcapture.ContentCaptureSession)": {"Returns": [], "Parameters": [["@B_android#view#contentcapture#ContentCaptureSession_E@", "ContentCaptureSession: a session created by @B_android#view#contentcapture#ContentCaptureSession#createContentCaptureSession_E@. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the (optional) @B_android#view#contentcapture#ContentCaptureSession_E@ associated with this view. This method should be called when you need to associate a @B_android#view#contentcapture#ContentCaptureContext_E@ to the content capture events associated with this view or its view hierarchy (if it's a @B_android#view#ViewGroup_E@). For example, if your activity is associated with a web domain, first you would need to set the context for the main DOM: Then if the page had an IFRAME, you would create a new session for it:", "history": "Added in API level 29", "FullName": "public void setContentCaptureSession (ContentCaptureSession contentCaptureSession)"}, "unscheduleDrawable(android.graphics.drawable.Drawable,java.lang.Runnable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: the recipient of the action This value must never be null."], ["@B_java#lang#Runnable_E@", "Runnable: the action to cancel This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Cancels a scheduled action on a drawable.", "history": "Added in API level 1", "FullName": "public void unscheduleDrawable (Drawable who, Runnable what)"}, "setVerticalScrollbarPosition(int)": {"Returns": [], "Parameters": [["int", "int: Where the vertical scroll bar should be positioned."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the position of the vertical scroll bar. Should be one of @B_android#view#View#SCROLLBAR_POSITION_DEFAULT_E@, @B_android#view#View#SCROLLBAR_POSITION_LEFT_E@ or @B_android#view#View#SCROLLBAR_POSITION_RIGHT_E@.", "history": "Added in API level 11", "FullName": "public void setVerticalScrollbarPosition (int position)"}, "performClick()": {"Returns": [["boolean", "True there was an assigned OnClickListener that was called, false otherwise is returned."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this view's OnClickListener, if it is defined. Performs all normal actions associated with clicking: reporting accessibility event, playing a sound, etc.", "history": "Added in API level 1", "FullName": "public boolean performClick ()"}, "postDelayed(java.lang.Runnable,long)": {"Returns": [["boolean", "true if the Runnable was successfully placed in to the message queue. Returns false on failure, usually because the looper processing the message queue is exiting. Note that a result of true does not mean the Runnable will be processed -- if the looper is quit before the delivery time of the message occurs then the message will be dropped."]], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: The Runnable that will be executed."], ["long", "long: The delay (in milliseconds) until the Runnable will be executed."]], "Throws": [], "SeeAlso": ["@B_android#view#View#post_E@", "@B_android#view#View#removeCallbacks_E@"], "Permissions": [], "Description": "Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses. The runnable will be run on the user interface thread.", "history": "Added in API level 1", "FullName": "public boolean postDelayed (Runnable action, long delayMillis)"}, "setZ(float)": {"Returns": [], "Parameters": [["float", "float: The visual z position of this view, in pixels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the visual z position of this view, in pixels. This is equivalent to setting the @B_android#view#View#setTranslationZ_E@ property to be the difference between the z value passed in and the current @B_android#view#View#getElevation_E@ property.", "history": "Added in API level 21", "FullName": "public void setZ (float z)"}, "dispatchUnhandledMove(android.view.View,int)": {"Returns": [["boolean", "True if the this view consumed this unhandled move."]], "Parameters": [["@B_android#view#View_E@", "View: The currently focused view."], ["int", "int: The direction focus wants to move. One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT. Value is @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_RIGHT_E@, or @B_android#view#View#FOCUS_DOWN_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is the last chance for the focused view and its ancestors to respond to an arrow key. This is called when the focused view did not consume the key internally, nor could the view system find a new view in the requested direction to give focus to.", "history": "Added in API level 1", "FullName": "public boolean dispatchUnhandledMove (View focused, int direction)"}, "removeOnLayoutChangeListener(android.view.View.OnLayoutChangeListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnLayoutChangeListener_E@", "View.OnLayoutChangeListener: The listener for layout bounds change."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove a listener for layout changes.", "history": "Added in API level 11", "FullName": "public void removeOnLayoutChangeListener (View.OnLayoutChangeListener listener)"}, "setForegroundGravity(int)": {"Returns": [], "Parameters": [["int", "int: see @B_android#view#Gravity_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View#getForegroundGravity_E@"], "Permissions": [], "Description": "Describes how the foreground is positioned. Defaults to START and TOP.", "history": "Added in API level 23", "FullName": "public void setForegroundGravity (int gravity)"}, "setY(float)": {"Returns": [], "Parameters": [["float", "float: The visual y position of this view, in pixels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the visual y position of this view, in pixels. This is equivalent to setting the @B_android#view#View#setTranslationY_E@ property to be the difference between the y value passed in and the current @B_android#view#View#getTop_E@ property.", "history": "Added in API level 11", "FullName": "public void setY (float y)"}, "isImportantForAutofill()": {"Returns": [["boolean", "whether the view is considered important for autofill."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hints the Android System whether the @B_android#app#assist#AssistStructure#ViewNode_E@ associated with this view is considered important for autofill purposes. Generally speaking, a view is important for autofill if:", "history": "Added in API level 26", "FullName": "public final boolean isImportantForAutofill ()"}, "getForegroundTintMode()": {"Returns": [["@B_android#graphics#PorterDuff#Mode_E@", "the blending mode used to apply the tint to the foreground drawable This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setForegroundTintMode_E@"], "Permissions": [], "Description": "Return the blending mode used to apply the tint to the foreground drawable, if specified.", "history": "Added in API level 23", "FullName": "public PorterDuff.Mode getForegroundTintMode ()"}, "hasTransientState()": {"Returns": [["boolean", "true if the view has transient state"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether the view is currently tracking transient state that the app should not need to concern itself with saving and restoring, but that the framework should take special note to preserve when possible. A view with transient state cannot be trivially rebound from an external data source, such as an adapter binding item views in a list. This may be because the view is performing an animation, tracking user selection of content, or similar.", "history": "Added in API level 16", "FullName": "public boolean hasTransientState ()"}, "getApplicationWindowToken()": {"Returns": [["@B_android#os#IBinder_E@", "Returns the associated window token, either @B_android#view#View#getWindowToken_E@ or the containing window's token."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a unique token identifying the top-level \"real\" window of the window that this view is attached to. That is, this is like @B_android#view#View#getWindowToken_E@, except if the window this view in is a panel window (attached to another containing window), then the token of the containing window is returned instead.", "history": "Added in API level 1", "FullName": "public IBinder getApplicationWindowToken ()"}, "performContextClick()": {"Returns": [["boolean", "True if there was an assigned OnContextClickListener that consumed the event, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this view's OnContextClickListener, if it is defined.", "history": "Added in API level 23", "FullName": "public boolean performContextClick ()"}, "getScrollBarStyle()": {"Returns": [["int", "the current scrollbar style Value is @B_android#view#View#SCROLLBARS_INSIDE_OVERLAY_E@, @B_android#view#View#SCROLLBARS_INSIDE_INSET_E@, @B_android#view#View#SCROLLBARS_OUTSIDE_OVERLAY_E@, or @B_android#view#View#SCROLLBARS_OUTSIDE_INSET_E@"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Returns the current scrollbar style.", "history": "Added in API level 1", "FullName": "public int getScrollBarStyle ()"}, "getMinimumHeight()": {"Returns": [["int", "the minimum height the view will try to be, in pixels"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setMinimumHeight_E@"], "Permissions": [], "Description": "Returns the minimum height of the view.", "history": "Added in API level 16", "FullName": "public int getMinimumHeight ()"}, "getRightFadingEdgeStrength()": {"Returns": [["float", "the intensity of the right fade as a float between 0.0f and 1.0f"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the strength, or intensity, of the right faded edge. The strength is a value between 0.0 (no fade) and 1.0 (full fade). The default implementation returns 0.0 or 1.0 but no value in between. Subclasses should override this method to provide a smoother fade transition when scrolling occurs.", "history": "Added in API level 1", "FullName": "protected float getRightFadingEdgeStrength ()"}, "findViewWithTag(java.lang.Object)": {"Returns": [["T", "The View that has the given tag in the hierarchy or null"]], "Parameters": [["@B_java#lang#Object_E@", "Object: The tag to search for, using \"tag.equals(getTag())\"."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Look for a child view with the given tag. If this view has the given tag, return this view.", "history": "Added in API level 1", "FullName": "public final T findViewWithTag (Object tag)"}, "getSystemGestureExclusionRects()": {"Returns": [["@B_java#util#List_E@", "the list set by @B_android#view#View#setSystemGestureExclusionRects_E@ This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the list of areas within this view's post-layout coordinate space where the system should not intercept touch or other pointing device gestures. Do not modify the returned list.", "history": "Added in API level 29", "FullName": "public List<Rect> getSystemGestureExclusionRects ()"}, "jumpDrawablesToCurrentState()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call @B_android#graphics#drawable#Drawable#jumpToCurrentState_E@ on all Drawable objects associated with this view. Also calls @B_android#animation#StateListAnimator#jumpToCurrentState_E@ if there is a StateListAnimator attached to this view. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 11", "FullName": "public void jumpDrawablesToCurrentState ()"}, "getWindowSystemUiVisibility()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current system UI visibility that is currently set for the entire window. This is the combination of the @B_android#view#View#setSystemUiVisibility_E@ values supplied by all of the views in the window.", "history": "Added in API level 16", "FullName": "public int getWindowSystemUiVisibility ()"}, "isPaddingOffsetRequired()": {"Returns": [["boolean", "True if padding offset must be applied, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getLeftPaddingOffset_E@", "@B_android#view#View#getRightPaddingOffset_E@", "@B_android#view#View#getTopPaddingOffset_E@", "@B_android#view#View#getBottomPaddingOffset_E@"], "Permissions": [], "Description": "If the View draws content inside its padding and enables fading edges, it needs to support padding offsets. Padding offsets are added to the fading edges to extend the length of the fade so that it covers pixels drawn inside the padding. Subclasses of this class should override this method if they need to draw content inside the padding.", "history": "Added in API level 2", "FullName": "protected boolean isPaddingOffsetRequired ()"}, "startDrag(android.content.ClipData,android.view.View.DragShadowBuilder,java.lang.Object,int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#content#ClipData_E@", "ClipData no parameter comment"], ["@B_android#view#View#DragShadowBuilder_E@", "View.DragShadowBuilder no parameter comment"], ["@B_java#lang#Object_E@", "Object no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#view#View#startDragAndDrop_E@ for newer platform versions.", "history": "Added in API level 11 Deprecated in API level 24", "FullName": "public final boolean startDrag (ClipData data, View.DragShadowBuilder shadowBuilder, Object myLocalState, int flags)"}, "onTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle touch screen motion events. If this method is used to detect click actions, it is recommended that the actions be performed by implementing and calling @B_android#view#View#performClick_E@. This will ensure consistent system behavior, including: obeying click sound preferences dispatching OnClickListener calls handling @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_CLICK_E@ when accessibility features are enabled", "history": "Added in API level 1", "FullName": "public boolean onTouchEvent (MotionEvent event)"}, "requestFocus(int,android.graphics.Rect)": {"Returns": [["boolean", "Whether this view or one of its descendants actually took focus."]], "Parameters": [["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT"], ["@B_android#graphics#Rect_E@", "Rect: The rectangle (in this View's coordinate system) to give a finer grained hint about where focus is coming from. May be null if there is no hint."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this to try to give focus to a specific view or to one of its descendants and give it hints about the direction and a specific rectangle that the focus is coming from. The rectangle can help give larger views a finer grained hint about where focus is coming from, and therefore, where to show selection, or forward focus change internally. A view will not actually take focus if it is not focusable (@B_android#view#View#isFocusable_E@ returns false), or if it is focusable and it is not focusable in touch mode (@B_android#view#View#isFocusableInTouchMode_E@) while the device is in touch mode. A View will not take focus if it is not visible. A View will not take focus if one of its parents has @B_android#view#ViewGroup#getDescendantFocusability_E@ equal to @B_android#view#ViewGroup#FOCUS_BLOCK_DESCENDANTS_E@. See also @B_android#view#View#focusSearch_E@, which is what you call to say that you have focus, and you want your parent to look for the next one. You may wish to override this method if your custom @B_android#view#View_E@ has an internal @B_android#view#View_E@ that it wishes to forward the request to.", "history": "Added in API level 1", "FullName": "public boolean requestFocus (int direction, Rect previouslyFocusedRect)"}, "showContextMenu(float,float)": {"Returns": [["boolean", "true if the context menu was shown, false otherwise"]], "Parameters": [["float", "float: the X coordinate in pixels relative to the view to which the menu should be anchored, or @B_java#lang#Float#NaN_E@ to disable anchoring"], ["float", "float: the Y coordinate in pixels relative to the view to which the menu should be anchored, or @B_java#lang#Float#NaN_E@ to disable anchoring"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Shows the context menu for this view anchored to the specified view-relative coordinate.", "history": "Added in API level 24", "FullName": "public boolean showContextMenu (float x, float y)"}, "getFocusedRect(android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: The rectangle to fill in, in this view's coordinates."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "When a view has focus and the user navigates away from it, the next view is searched for starting from the rectangle filled in by this method. By default, the rectangle is the @B_android#view#View#getDrawingRect_E@) of the view. However, if your view maintains some idea of internal selection, such as a cursor, or a selected row or column, you should override this method and fill in a more specific rectangle.", "history": "Added in API level 1", "FullName": "public void getFocusedRect (Rect r)"}, "getPivotY()": {"Returns": [["float", "The y location of the pivot point."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getRotation_E@", "@B_android#view#View#getScaleX_E@", "@B_android#view#View#getScaleY_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "The y location of the point around which the view is @B_android#view#View#setRotation_E@ and @B_android#view#View#setScaleY_E@.", "history": "Added in API level 11", "FullName": "public float getPivotY ()"}, "isTextDirectionResolved()": {"Returns": [["boolean", "true if text direction is resolved."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 19", "FullName": "public boolean isTextDirectionResolved ()"}, "onInitializeAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo)": {"Returns": [], "Parameters": [["@B_android#view#accessibility#AccessibilityNodeInfo_E@", "AccessibilityNodeInfo: The instance to initialize."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Initializes an @B_android#view#accessibility#AccessibilityNodeInfo_E@ with information about this view. The base implementation sets: @B_android#view#accessibility#AccessibilityNodeInfo#setParent_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setBoundsInParent_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setBoundsInScreen_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setPackageName_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setClassName_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setContentDescription_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setEnabled_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setClickable_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setFocusable_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setFocused_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setLongClickable_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setSelected_E@, @B_android#view#accessibility#AccessibilityNodeInfo#setContextClickable_E@ Subclasses should override this method, call the super implementation, and set additional attributes. If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#onInitializeAccessibilityNodeInfo_E@ is responsible for handling this call. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 14", "FullName": "public void onInitializeAccessibilityNodeInfo (AccessibilityNodeInfo info)"}, "getDrawableState()": {"Returns": [["int[]", "The current drawable state"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#graphics#drawable#Drawable#setState_E@", "@B_android#view#View#drawableStateChanged_E@", "@B_android#view#View#onCreateDrawableState_E@"], "Permissions": [], "Description": "Return an array of resource IDs of the drawable states representing the current state of the view.", "history": "Added in API level 1", "FullName": "public final int[] getDrawableState ()"}, "getPaddingEnd()": {"Returns": [["int", "the end padding in pixels"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the end padding of this view depending on its resolved layout direction. If there are inset and enabled scrollbars, this value may include the space required to display the scrollbars as well.", "history": "Added in API level 17", "FullName": "public int getPaddingEnd ()"}, "invalidateOutline()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setOutlineProvider_E@"], "Permissions": [], "Description": "Called to rebuild this View's Outline from its @B_android#view#ViewOutlineProvider_E@", "history": "Added in API level 21", "FullName": "public void invalidateOutline ()"}, "getScrollY()": {"Returns": [["int", "The top edge of the displayed part of your view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the scrolled top position of this view. This is the top edge of the displayed part of your view. You do not need to draw any pixels above it, since those are outside of the frame of your view on screen.", "history": "Added in API level 1", "FullName": "public final int getScrollY ()"}, "dispatchSetPressed(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: The new pressed state"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setPressed_E@"], "Permissions": [], "Description": "Dispatch setPressed to all of this View's children.", "history": "Added in API level 1", "FullName": "protected void dispatchSetPressed (boolean pressed)"}, "buildDrawingCache()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#buildDrawingCache_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Calling this method is equivalent to calling buildDrawingCache(false).", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public void buildDrawingCache ()"}, "dispatchDragEvent(android.view.DragEvent)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#view#DragEvent_E@", "DragEvent no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Detects if this View is enabled and has a drag event listener. If both are true, then it calls the drag event listener with the @B_android#view#DragEvent_E@ it received. If the drag event listener returns true, then dispatchDragEvent() returns true. For all other cases, the method calls the @B_android#view#View#onDragEvent_E@ drag event handler method and returns its result. This ensures that a drag event is always consumed, even if the View does not have a drag event listener. However, if the View has a listener and the listener returns true, then onDragEvent() is not called.", "history": "Added in API level 11", "FullName": "public boolean dispatchDragEvent (DragEvent event)"}, "setContextClickable(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to make the view react to a context click, false otherwise"]], "Throws": [], "SeeAlso": ["@B_android#view#View#isContextClickable_E@"], "Permissions": [], "Description": "Enables or disables context clicking for this view. This event can launch the listener.", "history": "Added in API level 23", "FullName": "public void setContextClickable (boolean contextClickable)"}, "getOutlineProvider()": {"Returns": [["@B_android#view#ViewOutlineProvider_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setOutlineProvider_E@"], "Permissions": [], "Description": "Returns the current @B_android#view#ViewOutlineProvider_E@ of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping.", "history": "Added in API level 21", "FullName": "public ViewOutlineProvider getOutlineProvider ()"}, "fitsSystemWindows()": {"Returns": [["", "true if this view will adjust its content bounds for system screen decorations."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check for the FITS_SYSTEM_WINDOWS flag. If this method returns true, this view will account for system screen decorations such as the status bar and inset its content. This allows the view to be positioned in absolute screen coordinates and remain visible to the user.", "history": "Since: API Level 14", "FullName": "public boolean fitsSystemWindows ()"}, "getForegroundGravity()": {"Returns": [["int", "foreground gravity."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setForegroundGravity_E@"], "Permissions": [], "Description": "Describes how the foreground is positioned.", "history": "Added in API level 23", "FullName": "public int getForegroundGravity ()"}, "View(android.content.Context,android.util.AttributeSet,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The Context the view is running in, through which it can access the current theme, resources, etc."], ["@B_android#util#AttributeSet_E@", "AttributeSet: The attributes of the XML tag that is inflating the view. This value may be null."], ["int", "int: An attribute in the current theme that contains a reference to a style resource that supplies default values for the view. Can be 0 to not look for defaults."]], "Throws": [], "SeeAlso": ["@B_android#view#View#View_E@"], "Permissions": [], "Description": "Perform inflation from XML and apply a class-specific base style from a theme attribute. This constructor of View allows subclasses to use their own base style when they are inflating. For example, a Button class's constructor would call this version of the super class constructor and supply R.attr.buttonStyle for", "history": "Added in API level 1", "FullName": "public View (Context context, AttributeSet attrs, int defStyleAttr)"}, "getBottomFadingEdgeStrength()": {"Returns": [["float", "the intensity of the bottom fade as a float between 0.0f and 1.0f"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the strength, or intensity, of the bottom faded edge. The strength is a value between 0.0 (no fade) and 1.0 (full fade). The default implementation returns 0.0 or 1.0 but no value in between. Subclasses should override this method to provide a smoother fade transition when scrolling occurs.", "history": "Added in API level 1", "FullName": "protected float getBottomFadingEdgeStrength ()"}, "setPivotY(float)": {"Returns": [], "Parameters": [["float", "float: The y location of the pivot point."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getRotation_E@", "@B_android#view#View#getScaleX_E@", "@B_android#view#View#getScaleY_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "Sets the y location of the point around which the view is @B_android#view#View#setRotation_E@ and @B_android#view#View#setScaleY_E@. By default, the pivot point is centered on the object. Setting this property disables this behavior and causes the view to use only the explicitly set pivotX and pivotY values.", "history": "Added in API level 11", "FullName": "public void setPivotY (float pivotY)"}, "getRotationX()": {"Returns": [["float", "The degrees of X rotation."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@", "@B_android#view#View#setRotationX_E@"], "Permissions": [], "Description": "The degrees that the view is rotated around the horizontal axis through the pivot point.", "history": "Added in API level 11", "FullName": "public float getRotationX ()"}, "getTextAlignment()": {"Returns": [["int", "the resolved text alignment. Returns one of: @B_android#view#View#TEXT_ALIGNMENT_GRAVITY_E@, @B_android#view#View#TEXT_ALIGNMENT_CENTER_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_START_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_END_E@, @B_android#view#View#TEXT_ALIGNMENT_VIEW_START_E@, @B_android#view#View#TEXT_ALIGNMENT_VIEW_END_E@ Value is @B_android#view#View#TEXT_ALIGNMENT_INHERIT_E@, @B_android#view#View#TEXT_ALIGNMENT_GRAVITY_E@, @B_android#view#View#TEXT_ALIGNMENT_CENTER_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_START_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_END_E@, @B_android#view#View#TEXT_ALIGNMENT_VIEW_START_E@, or @B_android#view#View#TEXT_ALIGNMENT_VIEW_END_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the resolved text alignment.", "history": "Added in API level 17", "FullName": "public int getTextAlignment ()"}, "scrollTo(int,int)": {"Returns": [], "Parameters": [["int", "int: the x position to scroll to"], ["int", "int: the y position to scroll to"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated.", "history": "Added in API level 1", "FullName": "public void scrollTo (int x, int y)"}, "getSourceLayoutResId()": {"Returns": [["int", "The layout resource id if this view was inflated from XML, otherwise @B_android#content#res#Resources#ID_NULL_E@."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "A @B_android#view#View_E@ can be inflated from an XML layout. For such Views this method returns the resource ID of the source layout.", "history": "Added in API level 29", "FullName": "public int getSourceLayoutResId ()"}, "isSaveEnabled()": {"Returns": [["boolean", "Returns true if the view state saving is enabled, else false."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setSaveEnabled_E@"], "Permissions": [], "Description": "Indicates whether this view will save its state (that is, whether its @B_android#view#View#onSaveInstanceState_E@ method will be called).", "history": "Added in API level 1", "FullName": "public boolean isSaveEnabled ()"}, "getWindowAttachCount()": {"Returns": [["int", "The number of times this view has been attached to a window"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "protected int getWindowAttachCount ()"}, "isEnabled()": {"Returns": [["boolean", "True if this view is enabled, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the enabled status for this view. The interpretation of the enabled state varies by subclass.", "history": "Added in API level 1", "FullName": "public boolean isEnabled ()"}, "getWindowVisibleDisplayFrame(android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: Filled in with the visible display frame. If the view is not attached to a window, this is simply the raw display size."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve the overall visible display size in which the window this view is attached to has been positioned in. This takes into account screen decorations above the window, for both cases where the window itself is being position inside of them or the window is being placed under then and covered insets are used for the window to position its content inside. In effect, this tells you the available area where content can be placed and remain visible to users. This function requires an IPC back to the window manager to retrieve the requested information, so should not be used in performance critical code like drawing.", "history": "Added in API level 3", "FullName": "public void getWindowVisibleDisplayFrame (Rect outRect)"}, "getAccessibilityLiveRegion()": {"Returns": [["int", "The live region mode for the view."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setAccessibilityLiveRegion_E@"], "Permissions": [], "Description": "Gets the live region mode for this View.", "history": "Added in API level 19", "FullName": "public int getAccessibilityLiveRegion ()"}, "getScrollIndicators()": {"Returns": [["int", "a bitmask representing the enabled scroll indicators Value is either 0 or a combination of @B_android#view#View#SCROLL_INDICATOR_TOP_E@, @B_android#view#View#SCROLL_INDICATOR_BOTTOM_E@, @B_android#view#View#SCROLL_INDICATOR_LEFT_E@, @B_android#view#View#SCROLL_INDICATOR_RIGHT_E@, @B_android#view#View#SCROLL_INDICATOR_START_E@, and @B_android#view#View#SCROLL_INDICATOR_END_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a bitmask representing the enabled scroll indicators. For example, if the top and left scroll indicators are enabled and all other indicators are disabled, the return value will be View.SCROLL_INDICATOR_TOP | View.SCROLL_INDICATOR_LEFT. To check whether the bottom scroll indicator is enabled, use the value of (getScrollIndicators() & View.SCROLL_INDICATOR_BOTTOM) != 0.", "history": "Added in API level 23", "FullName": "public int getScrollIndicators ()"}, "onScrollChanged(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: Current horizontal scroll origin."], ["int", "int: Current vertical scroll origin."], ["int", "int: Previous horizontal scroll origin."], ["int", "int: Previous vertical scroll origin."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called in response to an internal scroll in this view (i.e., the view scrolled its own contents). This is typically as a result of @B_android#view#View#scrollBy_E@ or @B_android#view#View#scrollTo_E@ having been called.", "history": "Added in API level 1", "FullName": "protected void onScrollChanged (int l, int t, int oldl, int oldt)"}, "onInitializeAccessibilityEvent(android.view.accessibility.AccessibilityEvent)": {"Returns": [], "Parameters": [["@B_android#view#accessibility#AccessibilityEvent_E@", "AccessibilityEvent: The event to initialize."]], "Throws": [], "SeeAlso": ["@B_android#view#View#sendAccessibilityEvent_E@", "@B_android#view#View#dispatchPopulateAccessibilityEvent_E@"], "Permissions": [], "Description": "Initializes an @B_android#view#accessibility#AccessibilityEvent_E@ with information about this View which is the event source. In other words, the source of an accessibility event is the view whose state change triggered firing the event. Example: Setting the password property of an event in addition to properties set by the super implementation: If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#onInitializeAccessibilityEvent_E@ is responsible for handling this call. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 14", "FullName": "public void onInitializeAccessibilityEvent (AccessibilityEvent event)"}, "isPaddingRelative()": {"Returns": [["boolean", "true if the padding is relative or false if it is not."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return if the padding has been set through relative values @B_android#view#View#setPaddingRelative_E@ or through", "history": "Added in API level 17", "FullName": "public boolean isPaddingRelative ()"}, "getViewTreeObserver()": {"Returns": [["@B_android#view#ViewTreeObserver_E@", "The ViewTreeObserver for this view's hierarchy."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the ViewTreeObserver for this view's hierarchy. The view tree observer can be used to get notifications when global events, like layout, happen. The returned ViewTreeObserver observer is not guaranteed to remain valid for the lifetime of this View. If the caller of this method keeps a long-lived reference to ViewTreeObserver, it should always check for the return value of @B_android#view#ViewTreeObserver#isAlive_E@.", "history": "Added in API level 1", "FullName": "public ViewTreeObserver getViewTreeObserver ()"}, "dispatchApplyWindowInsets(android.view.WindowInsets)": {"Returns": [["@B_android#view#WindowInsets_E@", "The provided insets minus the insets that were consumed"]], "Parameters": [["@B_android#view#WindowInsets_E@", "WindowInsets: Insets to apply"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request to apply the given window insets to this view or another view in its subtree. This method should be called by clients wishing to apply insets corresponding to areas obscured by window decorations or overlays. This can include the status and navigation bars, action bars, input methods and more. New inset categories may be added in the future. The method returns the insets provided minus any that were applied by this view or its children. Clients wishing to provide custom behavior should override the @B_android#view#View#onApplyWindowInsets_E@ method or alternatively provide a @B_android#view#View#OnApplyWindowInsetsListener_E@ via the @B_android#view#View#setOnApplyWindowInsetsListener_E@ method. This method replaces the older @B_android#view#View#fitSystemWindows_E@ method.", "history": "Added in API level 20", "FullName": "public WindowInsets dispatchApplyWindowInsets (WindowInsets insets)"}, "setRevealOnFocusHint(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to request reveal on focus in ancestors, false otherwise"]], "Throws": [], "SeeAlso": ["@B_android#view#View#getRevealOnFocusHint_E@"], "Permissions": [], "Description": "Sets this view's preference for reveal behavior when it gains focus. When set to true, this is a signal to ancestor views in the hierarchy that this view would prefer to be brought fully into view when it gains focus. For example, a text field that a user is meant to type into. Other views such as scrolling containers may prefer to opt-out of this behavior. The default value for views is true, though subclasses may change this based on their preferred behavior.", "history": "Added in API level 25", "FullName": "public final void setRevealOnFocusHint (boolean revealOnFocus)"}, "getPaddingStart()": {"Returns": [["int", "the start padding in pixels"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the start padding of this view depending on its resolved layout direction. If there are inset and enabled scrollbars, this value may include the space required to display the scrollbars as well.", "history": "Added in API level 17", "FullName": "public int getPaddingStart ()"}, "getHandler()": {"Returns": [["@B_android#os#Handler_E@", "A handler associated with the thread running the View. This handler can be used to pump events in the UI events queue."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public Handler getHandler ()"}, "performLongClick()": {"Returns": [["boolean", "true if one of the above receivers consumed the event, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Calls this view's OnLongClickListener, if it is defined. Invokes the context menu if the OnLongClickListener did not consume the event.", "history": "Added in API level 1", "FullName": "public boolean performLongClick ()"}, "setAnimation(android.view.animation.Animation)": {"Returns": [], "Parameters": [["@B_android#view#animation#Animation_E@", "Animation: The next animation, or null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the next animation to play for this view. If you want the animation to play immediately, use @B_android#view#View#startAnimation_E@ instead. This method provides allows fine-grained control over the start time and invalidation, but you must make sure that 1) the animation has a start time set, and 2) the view's parent (which controls animations on its children) will be invalidated when the animation is supposed to start.", "history": "Added in API level 1", "FullName": "public void setAnimation (Animation animation)"}, "willNotDraw()": {"Returns": [["boolean", "true if this view has nothing to draw, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether or not this View draws on its own.", "history": "Added in API level 1", "FullName": "public boolean willNotDraw ()"}, "removeOnAttachStateChangeListener(android.view.View.OnAttachStateChangeListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnAttachStateChangeListener_E@", "View.OnAttachStateChangeListener: Listener to remove"]], "Throws": [], "SeeAlso": ["@B_android#view#View#addOnAttachStateChangeListener_E@"], "Permissions": [], "Description": "Remove a listener for attach state changes. The listener will receive no further notification of window attach/detach events.", "history": "Added in API level 12", "FullName": "public void removeOnAttachStateChangeListener (View.OnAttachStateChangeListener listener)"}, "setAccessibilityLiveRegion(int)": {"Returns": [], "Parameters": [["int", "int: The live region mode for this view, one of: ACCESSIBILITY_LIVE_REGION_NONE ACCESSIBILITY_LIVE_REGION_POLITE ACCESSIBILITY_LIVE_REGION_ASSERTIVE"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the live region mode for this view. This indicates to accessibility services whether they should automatically notify the user about changes to the view's content description or text, or to the content descriptions or text of the view's children (where applicable). For example, in a login screen with a TextView that displays an \"incorrect password\" notification, that view should be marked as a live region with mode @B_android#view#View#ACCESSIBILITY_LIVE_REGION_POLITE_E@. To disable change notifications for this view, use @B_android#view#View#ACCESSIBILITY_LIVE_REGION_NONE_E@. This is the default live region mode for most views. To indicate that the user should be notified of changes, use @B_android#view#View#ACCESSIBILITY_LIVE_REGION_POLITE_E@. If the view's changes should interrupt ongoing speech and notify the user immediately, use @B_android#view#View#ACCESSIBILITY_LIVE_REGION_ASSERTIVE_E@.", "history": "Added in API level 19", "FullName": "public void setAccessibilityLiveRegion (int mode)"}, "onSaveInstanceState()": {"Returns": [["@B_android#os#Parcelable_E@", "Returns a Parcelable object containing the view's current dynamic state, or null if there is nothing interesting to save."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#onRestoreInstanceState_E@", "@B_android#view#View#saveHierarchyState_E@", "@B_android#view#View#dispatchSaveInstanceState_E@", "@B_android#view#View#setSaveEnabled_E@"], "Permissions": [], "Description": "Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected Parcelable onSaveInstanceState ()"}, "addExtraDataToAccessibilityNodeInfo(android.view.accessibility.AccessibilityNodeInfo,java.lang.String,android.os.Bundle)": {"Returns": [], "Parameters": [["@B_android#view#accessibility#AccessibilityNodeInfo_E@", "AccessibilityNodeInfo: The info to which to add the extra data. Never null. This value must never be null."], ["@B_java#lang#String_E@", "String: A key specifying the type of extra data to add to the info. The extra data should be added to the @B_android#os#Bundle_E@ returned by the info's @B_android#view#accessibility#AccessibilityNodeInfo#getExtras_E@ method. Never null. This value must never be null."], ["@B_android#os#Bundle_E@", "Bundle: A @B_android#os#Bundle_E@ holding any arguments relevant for this request. May be null if the service provided no arguments. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#accessibility#AccessibilityNodeInfo#setAvailableExtraData_E@"], "Permissions": [], "Description": "Adds extra data to an @B_android#view#accessibility#AccessibilityNodeInfo_E@ based on an explicit request for the additional data. This method only needs overloading if the node is marked as having extra data available.", "history": "Added in API level 26", "FullName": "public void addExtraDataToAccessibilityNodeInfo (AccessibilityNodeInfo info, String extraDataKey, Bundle arguments)"}, "getScrollBarSize()": {"Returns": [["int", "the scrollbar size"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the scrollbar size.", "history": "Added in API level 16", "FullName": "public int getScrollBarSize ()"}, "setLeft(int)": {"Returns": [], "Parameters": [["int", "int: The left of this view, in pixels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the left position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.", "history": "Added in API level 11", "FullName": "public final void setLeft (int left)"}, "performLongClick(float,float)": {"Returns": [["boolean", "true if one of the above receivers consumed the event, false otherwise"]], "Parameters": [["float", "float: x coordinate of the anchoring touch event, or @B_java#lang#Float#NaN_E@ to disable anchoring"], ["float", "float: y coordinate of the anchoring touch event, or @B_java#lang#Float#NaN_E@ to disable anchoring"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Calls this view's OnLongClickListener, if it is defined. Invokes the context menu if the OnLongClickListener did not consume the event, anchoring it to an (x,y) coordinate.", "history": "Added in API level 24", "FullName": "public boolean performLongClick (float x, float y)"}, "isNestedScrollingEnabled()": {"Returns": [["boolean", "true if nested scrolling is enabled"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setNestedScrollingEnabled_E@"], "Permissions": [], "Description": "Returns true if nested scrolling is enabled for this view. If nested scrolling is enabled and this View class implementation supports it, this view will act as a nested scrolling child view when applicable, forwarding data about the scroll operation in progress to a compatible and cooperating nested scrolling parent.", "history": "Added in API level 21", "FullName": "public boolean isNestedScrollingEnabled ()"}, "showContextMenu(float, float)": {"Returns": [["boolean", "true if the context menu was shown, false otherwise"]], "Parameters": [["float", "float: the X coordinate in pixels relative to the view to which the menu should be anchored, or @B_java#lang#Float#NaN_E@ to disable anchoring"], ["float", "float: the Y coordinate in pixels relative to the view to which the menu should be anchored, or @B_java#lang#Float#NaN_E@ to disable anchoring"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Shows the context menu for this view anchored to the specified view-relative coordinate.", "history": "added in API level 24", "FullName": "public boolean showContextMenu (float x, float y)"}, "getSystemUiVisibility()": {"Returns": [["int", "Bitwise-or of flags @B_android#view#View#SYSTEM_UI_FLAG_LOW_PROFILE_E@, @B_android#view#View#SYSTEM_UI_FLAG_HIDE_NAVIGATION_E@, @B_android#view#View#SYSTEM_UI_FLAG_FULLSCREEN_E@, @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_STABLE_E@, @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION_E@, @B_android#view#View#SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN_E@, @B_android#view#View#SYSTEM_UI_FLAG_IMMERSIVE_E@, and @B_android#view#View#SYSTEM_UI_FLAG_IMMERSIVE_STICKY_E@."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the last @B_android#view#View#setSystemUiVisibility_E@ that this view has requested.", "history": "Added in API level 11", "FullName": "public int getSystemUiVisibility ()"}, "getForegroundTintBlendMode()": {"Returns": [["@B_android#graphics#BlendMode_E@", "the blending mode used to apply the tint to the foreground drawable This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setForegroundTintBlendMode_E@"], "Permissions": [], "Description": "Return the blending mode used to apply the tint to the foreground drawable, if specified.", "history": "Added in API level 29", "FullName": "public BlendMode getForegroundTintBlendMode ()"}, "isLayoutRequested()": {"Returns": [["boolean", "true if the layout will be forced during next layout pass"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether or not this view's layout will be requested during the next hierarchy layout pass.", "history": "Added in API level 1", "FullName": "public boolean isLayoutRequested ()"}, "setScrollIndicators(int, int)": {"Returns": [], "Parameters": [["int", "int: the indicator direction, or the logical OR of multiple indicator directions. One or more of: SCROLL_INDICATOR_TOP SCROLL_INDICATOR_BOTTOM SCROLL_INDICATOR_LEFT SCROLL_INDICATOR_RIGHT SCROLL_INDICATOR_START SCROLL_INDICATOR_END Value is either 0 or combination of SCROLL_INDICATOR_TOP, SCROLL_INDICATOR_BOTTOM, SCROLL_INDICATOR_LEFT, SCROLL_INDICATOR_RIGHT, SCROLL_INDICATOR_START or SCROLL_INDICATOR_END."], ["int", "int no parameter comment Value is either 0 or combination of SCROLL_INDICATOR_TOP, SCROLL_INDICATOR_BOTTOM, SCROLL_INDICATOR_LEFT, SCROLL_INDICATOR_RIGHT, SCROLL_INDICATOR_START or SCROLL_INDICATOR_END."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setScrollIndicators_E@", "@B_android#view#View#getScrollIndicators_E@"], "Permissions": [], "Description": "Sets the state of the scroll indicators specified by the mask. To change all scroll indicators at once, see @B_android#view#View#setScrollIndicators_E@. When a scroll indicator is enabled, it will be displayed if the view can scroll in the direction of the indicator. Multiple indicator types may be enabled or disabled by passing the logical OR of the desired types. If multiple types are specified, they will all be set to the same enabled state. For example, to enable the top scroll indicatorExample: {@code setScrollIndicators", "history": "added in API level 23", "FullName": "public void setScrollIndicators (int indicators, int mask)"}, "setTransitionName(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The name of the View to uniquely identify it for Transitions."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the name of the View to be used to identify Views in Transitions. Names should be unique in the View hierarchy.", "history": "Added in API level 21", "FullName": "public final void setTransitionName (String transitionName)"}, "setScrollbarFadingEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: whether to enable fading"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Define whether scrollbars will fade when the view is not scrolling.", "history": "Added in API level 5", "FullName": "public void setScrollbarFadingEnabled (boolean fadeScrollbars)"}, "onFinishTemporaryDetach()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called after @B_android#view#View#onStartTemporaryDetach_E@ when the container is done changing the view.", "history": "Added in API level 3", "FullName": "public void onFinishTemporaryDetach ()"}, "getContext()": {"Returns": [["@B_android#content#Context_E@", "The view's Context."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the context the view is running in, through which it can access the current theme, resources, etc.", "history": "Added in API level 1", "FullName": "public final Context getContext ()"}, "setOnFocusChangeListener(android.view.View.OnFocusChangeListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnFocusChangeListener_E@", "View.OnFocusChangeListener: The callback that will run."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when focus of this view changed.", "history": "Added in API level 1", "FullName": "public void setOnFocusChangeListener (View.OnFocusChangeListener l)"}, "dispatchFinishTemporaryDetach()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch @B_android#view#View#onFinishTemporaryDetach_E@ to this View and its direct children if this is a container View. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 24", "FullName": "public void dispatchFinishTemporaryDetach ()"}, "setRotationY(float)": {"Returns": [], "Parameters": [["float", "float: The degrees of Y rotation."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getRotationY_E@", "@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@", "@B_android#view#View#setRotation_E@", "@B_android#view#View#setRotationX_E@", "@B_android#view#View#setCameraDistance_E@"], "Permissions": [], "Description": "Sets the degrees that the view is rotated around the vertical axis through the pivot point. Increasing values result in counter-clockwise rotation from the viewpoint of looking down the y axis. When rotating large views, it is recommended to adjust the camera distance accordingly. Refer to @B_android#view#View#setCameraDistance_E@ for more information.", "history": "Added in API level 11", "FullName": "public void setRotationY (float rotationY)"}, "isFocusedByDefault()": {"Returns": [["boolean", "true if this view is the default-focus view, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#restoreDefaultFocus_E@"], "Permissions": [], "Description": "Returns whether this View should receive focus when the focus is restored for the view hierarchy containing this view. Focus gets restored for a view hierarchy when the root of the hierarchy gets added to a window or serves as a target of cluster navigation.", "history": "Added in API level 26", "FullName": "public final boolean isFocusedByDefault ()"}, "setOnLongClickListener(android.view.View.OnLongClickListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnLongClickListener_E@", "View.OnLongClickListener: The callback that will run This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setLongClickable_E@"], "Permissions": [], "Description": "Register a callback to be invoked when this view is clicked and held. If this view is not long clickable, it becomes long clickable.", "history": "Added in API level 1", "FullName": "public void setOnLongClickListener (View.OnLongClickListener l)"}, "setNextClusterForwardId(int)": {"Returns": [], "Parameters": [["int", "int: The next cluster ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the id of the view to use as the root of the next keyboard navigation cluster.", "history": "Added in API level 26", "FullName": "public void setNextClusterForwardId (int nextClusterForwardId)"}, "setTag(java.lang.Object)": {"Returns": [], "Parameters": [["@B_java#lang#Object_E@", "Object: an Object to tag the view with"]], "Throws": [], "SeeAlso": ["@B_android#view#View#getTag_E@", "@B_android#view#View#setTag_E@"], "Permissions": [], "Description": "Sets the tag associated with this view. A tag can be used to mark a view in its hierarchy and does not have to be unique within the hierarchy. Tags can also be used to store data within a view without resorting to another data structure.", "history": "Added in API level 1", "FullName": "public void setTag (Object tag)"}, "hasFocus()": {"Returns": [["boolean", "True if this view has or contains focus, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has focus itself, or is the ancestor of the view that has focus.", "history": "Added in API level 1", "FullName": "public boolean hasFocus ()"}, "getId()": {"Returns": [["int", "a positive integer used to identify the view or @B_android#view#View#NO_ID_E@ if the view has no ID"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setId_E@", "@B_android#view#View#findViewById_E@"], "Permissions": [], "Description": "Returns this view's identifier.", "history": "Added in API level 1", "FullName": "public int getId ()"}, "getTooltipText()": {"Returns": [["@B_java#lang#CharSequence_E@", "the tooltip text This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setTooltipText_E@"], "Permissions": [], "Description": "Returns the view's tooltip text. @B_android#view#View#setTooltipText_E@ to modify the tooltip text.", "history": "Added in API level 26", "FullName": "public CharSequence getTooltipText ()"}, "isFocusable()": {"Returns": [["boolean", "True if this view can take focus, or false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether this View is currently able to take focus.", "history": "Added in API level 1", "FullName": "public final boolean isFocusable ()"}, "onResolvePointerIcon(android.view.MotionEvent,int)": {"Returns": [["@B_android#view#PointerIcon_E@", "no returns description in source"]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The MotionEvent from a mouse"], ["int", "int: The index of the pointer for which to retrieve the @B_android#view#PointerIcon_E@. This will be between 0 and @B_android#view#MotionEvent#getPointerCount_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#PointerIcon_E@"], "Permissions": [], "Description": "Returns the pointer icon for the motion event, or null if it doesn't specify the icon. The default implementation does not care the location or event types, but some subclasses may use it (such as WebViews).", "history": "Added in API level 24", "FullName": "public PointerIcon onResolvePointerIcon (MotionEvent event, int pointerIndex)"}, "setNextFocusLeftId(int)": {"Returns": [], "Parameters": [["int", "int: The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the id of the view to use when the next focus is @B_android#view#View#FOCUS_LEFT_E@.", "history": "Added in API level 1", "FullName": "public void setNextFocusLeftId (int nextFocusLeftId)"}, "dispatchKeyShortcutEvent(android.view.KeyEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatches a key shortcut event.", "history": "Added in API level 1", "FullName": "public boolean dispatchKeyShortcutEvent (KeyEvent event)"}, "showContextMenu()": {"Returns": [["boolean", "true if the context menu was shown, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#showContextMenu_E@"], "Permissions": [], "Description": "Shows the context menu for this view.", "history": "Added in API level 1", "FullName": "public boolean showContextMenu ()"}, "setEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if this view is enabled, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the enabled state of this view. The interpretation of the enabled state varies by subclass.", "history": "Added in API level 1", "FullName": "public void setEnabled (boolean enabled)"}, "onAttachedToWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#onDetachedFromWindow_E@"], "Permissions": [], "Description": "This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before @B_android#view#View#onDraw_E@, however it may be called any time before the first onDraw -- including before or after @B_android#view#View#onMeasure_E@. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onAttachedToWindow ()"}, "createContextMenu(android.view.ContextMenu)": {"Returns": [], "Parameters": [["@B_android#view#ContextMenu_E@", "ContextMenu: The context menu to populate"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Show the context menu for this view. It is not safe to hold on to the menu after returning from this method. You should normally not overload this method. Overload @B_android#view#View#onCreateContextMenu_E@ or define an @B_android#view#View#OnCreateContextMenuListener_E@ to add items to the context menu.", "history": "Added in API level 1", "FullName": "public void createContextMenu (ContextMenu menu)"}, "setScrollBarFadeDuration(int)": {"Returns": [], "Parameters": [["int", "int: - the scrollbar fade duration, in milliseconds"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Define the scrollbar fade duration.", "history": "Added in API level 16", "FullName": "public void setScrollBarFadeDuration (int scrollBarFadeDuration)"}, "getRotation()": {"Returns": [["float", "The degrees of rotation."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setRotation_E@", "@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "The degrees that the view is rotated around the pivot point.", "history": "Added in API level 11", "FullName": "public float getRotation ()"}, "setElevation(float)": {"Returns": [], "Parameters": [["float", "float no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the base elevation of this view, in pixels.", "history": "Added in API level 21", "FullName": "public void setElevation (float elevation)"}, "onKeyShortcut(int,android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called on the focused view when a key shortcut event is not handled. Override this method to implement local key shortcuts for the View. Key shortcuts can also be implemented by setting the @B_android#view#MenuItem#setShortcut_E@ property of menu items.", "history": "Added in API level 1", "FullName": "public boolean onKeyShortcut (int keyCode, KeyEvent event)"}, "setClipBounds(android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: The rectangular area, in the local coordinates of this view, to which future drawing operations will be clipped."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets a rectangular area on this view to which the view will be clipped when it is drawn. Setting the value to null will remove the clip bounds and the view will draw normally, using its full bounds.", "history": "Added in API level 18", "FullName": "public void setClipBounds (Rect clipBounds)"}, "drawableStateChanged()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#graphics#drawable#Drawable#setState_E@"], "Permissions": [], "Description": "This function is called whenever the state of the view changes in such a way that it impacts the state of drawables being shown. If the View has a StateListAnimator, it will also be called to run necessary state change animations. Be sure to call through to the superclass when overriding this function. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void drawableStateChanged ()"}, "setOutlineAmbientShadowColor(int)": {"Returns": [], "Parameters": [["int", "int: The color this View will cast for its elevation shadow."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the color of the ambient shadow that is drawn when the view has a positive Z or elevation value. By default the shadow color is black. Generally, this color will be opaque so the intensity of the shadow is consistent between different views with different colors. The opacity of the final ambient shadow is a function of the shadow caster height, the alpha channel of the outlineAmbientShadowColor (typically opaque), and the @B_android#R#attr#ambientShadowAlpha_E@ theme attribute.", "history": "Added in API level 28", "FullName": "public void setOutlineAmbientShadowColor (int color)"}, "getAlpha()": {"Returns": [["float", "The opacity of the view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The opacity of the view. This is a value from 0 to 1, where 0 means the view is completely transparent and 1 means the view is completely opaque. By default this is 1.0f.", "history": "Added in API level 11", "FullName": "public float getAlpha ()"}, "getPaddingTop()": {"Returns": [["int", "the top padding in pixels"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the top padding of this view.", "history": "Added in API level 1", "FullName": "public int getPaddingTop ()"}, "dispatchCapturedPointerEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Pass a captured pointer event down to the focused view.", "history": "Added in API level 26", "FullName": "public boolean dispatchCapturedPointerEvent (MotionEvent event)"}, "dispatchProvideStructure(android.view.ViewStructure)": {"Returns": [], "Parameters": [["@B_android#view#ViewStructure_E@", "ViewStructure no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch creation of @B_android#view#ViewStructure_E@ down the hierarchy. The default implementation calls @B_android#view#View#onProvideStructure_E@ and @B_android#view#View#onProvideVirtualStructure_E@.", "history": "Added in API level 23", "FullName": "public void dispatchProvideStructure (ViewStructure structure)"}, "View(android.content.Context,android.util.AttributeSet,int,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The Context the view is running in, through which it can access the current theme, resources, etc."], ["@B_android#util#AttributeSet_E@", "AttributeSet: The attributes of the XML tag that is inflating the view. This value may be null."], ["int", "int: An attribute in the current theme that contains a reference to a style resource that supplies default values for the view. Can be 0 to not look for defaults."], ["int", "int: A resource identifier of a style resource that supplies default values for the view, used only if defStyleAttr is 0 or can not be found in the theme. Can be 0 to not look for defaults."]], "Throws": [], "SeeAlso": ["@B_android#view#View#View_E@"], "Permissions": [], "Description": "Perform inflation from XML and apply a class-specific base style from a theme attribute or style resource. This constructor of View allows subclasses to use their own base style when they are inflating. When determining the final value of a particular attribute, there are four inputs that come into play: Each of these inputs is considered in-order, with the first listed taking precedence over the following ones. In other words, if in the AttributeSet you have supplied <Button * textColor=\"#ff000000\"> , then the button's text will always be black, regardless of what is specified in any of the styles.", "history": "Added in API level 21", "FullName": "public View (Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)"}, "isTemporarilyDetached()": {"Returns": [["boolean", "true when the View is in the state between @B_android#view#View#onStartTemporaryDetach_E@ and @B_android#view#View#onFinishTemporaryDetach_E@."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tells whether the @B_android#view#View_E@ is in the state between @B_android#view#View#onStartTemporaryDetach_E@ and @B_android#view#View#onFinishTemporaryDetach_E@. This method always returns true when called directly or indirectly from @B_android#view#View#onStartTemporaryDetach_E@. The return value when called directly or indirectly from @B_android#view#View#onFinishTemporaryDetach_E@, however, depends on the OS version. true on @B_android#os#Build#VERSION_CODES#N_E@ false on @B_android#os#Build#VERSION_CODES#N_MR1_E@} and later", "history": "Added in API level 24", "FullName": "public final boolean isTemporarilyDetached ()"}, "postInvalidateDelayed(long, int, int, int, int)": {"Returns": [], "Parameters": [["long", "long: the duration in milliseconds to delay the invalidation by"], ["int", "int: The left coordinate of the rectangle to invalidate."], ["int", "int: The top coordinate of the rectangle to invalidate."], ["int", "int: The right coordinate of the rectangle to invalidate."], ["int", "int: The bottom coordinate of the rectangle to invalidate."]], "Throws": [], "SeeAlso": ["@B_android#view#View#invalidate_E@", "@B_android#view#View#postInvalidate_E@"], "Permissions": [], "Description": "Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop. Waits for the specified amount of time. This method can be invoked from outside of the UI thread only when this View is attached to a window.", "history": "added in API level 1", "FullName": "public void postInvalidateDelayed (long delayMilliseconds, int left, int top, int right, int bottom)"}, "dispatchStartTemporaryDetach()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch @B_android#view#View#onStartTemporaryDetach_E@ to this View and its direct children if this is a container View. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 24", "FullName": "public void dispatchStartTemporaryDetach ()"}, "addKeyboardNavigationClusters(java.util.Collection<android.view.View>,int)": {"Returns": [], "Parameters": [["@B_java#util#Collection_E@", "Collection: Keyboard navigation cluster roots found so far This value must never be null."], ["int", "int: Direction to look"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds any keyboard navigation cluster roots that are descendants of this view (possibly including this view if it is a cluster root itself) to views.", "history": "Added in API level 26", "FullName": "public void addKeyboardNavigationClusters (Collection<View> views, int direction)"}, "isHardwareAccelerated()": {"Returns": [["boolean", "True if the view is attached to a window and the window is hardware accelerated; false in any other case."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether this view is attached to a hardware accelerated window or not. Even if this method returns true, it does not mean that every call to @B_android#view#View#draw_E@ will be made with an hardware accelerated @B_android#graphics#Canvas_E@. For instance, if this view is drawn onto an offscreen @B_android#graphics#Bitmap_E@ and its window is hardware accelerated, @B_android#graphics#Canvas#isHardwareAccelerated_E@ will likely return false, and this method will return true.", "history": "Added in API level 11", "FullName": "public boolean isHardwareAccelerated ()"}, "dispatchTrackballEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Pass a trackball motion event down to the focused view.", "history": "Added in API level 1", "FullName": "public boolean dispatchTrackballEvent (MotionEvent event)"}, "dispatchDrawableHotspotChanged(float,float)": {"Returns": [], "Parameters": [["float", "float: hotspot x coordinate"], ["float", "float: hotspot y coordinate"]], "Throws": [], "SeeAlso": ["@B_android#view#View#drawableHotspotChanged_E@"], "Permissions": [], "Description": "Dispatches drawableHotspotChanged to all of this View's children.", "history": "Added in API level 22", "FullName": "public void dispatchDrawableHotspotChanged (float x, float y)"}, "setScrollY(int)": {"Returns": [], "Parameters": [["int", "int: the y position to scroll to"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the vertical scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated.", "history": "Added in API level 14", "FullName": "public void setScrollY (int value)"}, "setImportantForAutofill(int)": {"Returns": [], "Parameters": [["int", "int: @B_android#view#View#IMPORTANT_FOR_AUTOFILL_AUTO_E@, @B_android#view#View#IMPORTANT_FOR_AUTOFILL_YES_E@, @B_android#view#View#IMPORTANT_FOR_AUTOFILL_NO_E@, @B_android#view#View#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS_E@, or @B_android#view#View#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS_E@. Value is @B_android#view#View#IMPORTANT_FOR_AUTOFILL_AUTO_E@, @B_android#view#View#IMPORTANT_FOR_AUTOFILL_YES_E@, @B_android#view#View#IMPORTANT_FOR_AUTOFILL_NO_E@, @B_android#view#View#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS_E@, or @B_android#view#View#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the mode for determining whether this view is considered important for autofill. The platform determines the importance for autofill automatically but you can use this method to customize the behavior. For example: @B_android#view#View#IMPORTANT_FOR_AUTOFILL_NO_E@ or @B_android#view#View#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS_E@ does not guarantee the view (and its children) will be always be considered not important; for example, when the user explicitly makes an autofill request, all views are considered important. See @B_android#view#View#isImportantForAutofill_E@ for more details about how the View's importance for autofill is used.", "history": "Added in API level 26", "FullName": "public void setImportantForAutofill (int mode)"}, "postOnAnimationDelayed(java.lang.Runnable, long)": {"Returns": [], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: The Runnable that will be executed."], ["long", "long: The delay (in milliseconds) until the Runnable will be executed."]], "Throws": [], "SeeAlso": ["@B_android#view#View#postOnAnimation_E@", "@B_android#view#View#removeCallbacks_E@"], "Permissions": [], "Description": "Causes the Runnable to execute on the next animation time step, after the specified amount of time elapses. The runnable will be run on the user interface thread.", "history": "added in API level 16", "FullName": "public void postOnAnimationDelayed (Runnable action, long delayMillis)"}, "transformMatrixToLocal(android.graphics.Matrix)": {"Returns": [], "Parameters": [["@B_android#graphics#Matrix_E@", "Matrix: input matrix to modify This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Modifies the input matrix such that it maps on-screen coordinates to view-local coordinates.", "history": "Added in API level 29", "FullName": "public void transformMatrixToLocal (Matrix matrix)"}, "onDrawForeground(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: canvas to draw into"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Draw any foreground content for this view. Foreground content may consist of scroll bars, a @B_android#view#View#setForeground_E@ drawable or other view-specific decorations. The foreground is drawn on top of the primary view content.", "history": "Added in API level 23", "FullName": "public void onDrawForeground (Canvas canvas)"}, "requestLayout()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this when something has changed which has invalidated the layout of this view. This will schedule a layout pass of the view tree. This should not be called while the view hierarchy is currently in a layout pass (@B_android#view#View#isInLayout_E@. If layout is happening, the request may be honored at the end of the current layout pass (and then layout will run again) or after the current frame is drawn and the next layout occurs. Subclasses which override this method should call the superclass method to handle possible request-during-layout errors correctly. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "public void requestLayout ()"}, "setVerticalFadingEdgeEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the vertical edges should be faded when the view is scrolled vertically"]], "Throws": [], "SeeAlso": ["@B_android#view#View#isVerticalFadingEdgeEnabled_E@"], "Permissions": [], "Description": "Define whether the vertical edges should be faded when this view is scrolled vertically.", "history": "Added in API level 1", "FullName": "public void setVerticalFadingEdgeEnabled (boolean verticalFadingEdgeEnabled)"}, "resetPivot()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Clears any pivot previously set by a call to @B_android#view#View#setPivotX_E@ or @B_android#view#View#setPivotY_E@. After calling this @B_android#view#View#isPivotSet_E@ will be false and the pivot used for rotation will return to default of being centered on the view.", "history": "Added in API level 28", "FullName": "public void resetPivot ()"}, "getBackgroundTintList()": {"Returns": [["@B_android#content#res#ColorStateList_E@", "the tint applied to the background drawable This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setBackgroundTintList_E@"], "Permissions": [], "Description": "Return the tint applied to the background drawable, if specified.", "history": "Added in API level 21", "FullName": "public ColorStateList getBackgroundTintList ()"}, "setRight(int)": {"Returns": [], "Parameters": [["int", "int: The right of this view, in pixels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the right position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.", "history": "Added in API level 11", "FullName": "public final void setRight (int right)"}, "onDragEvent(android.view.DragEvent)": {"Returns": [["boolean", "true if the method was successful, otherwise false. The method should return true in response to an action type of DragEvent.ACTION_DRAG_STARTED to receive drag events for the current operation. The method should also return true in response to an action type of DragEvent.ACTION_DROP if it consumed the drop, or false if it didn't. For all other events, the return value is ignored."]], "Parameters": [["@B_android#view#DragEvent_E@", "DragEvent: The @B_android#view#DragEvent_E@ sent by the system. The @B_android#view#DragEvent#getAction_E@ method returns an action type constant defined in DragEvent, indicating the type of drag event represented by this object."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handles drag events sent by the system following a call to @B_android#view#View#startDragAndDrop_E@. When the system calls this method, it passes a @B_android#view#DragEvent_E@ object. A call to @B_android#view#DragEvent#getAction_E@ returns one of the action type constants defined in DragEvent. The method uses these to determine what is happening in the drag and drop operation.", "history": "Added in API level 11", "FullName": "public boolean onDragEvent (DragEvent event)"}, "getMeasuredWidthAndState()": {"Returns": [["int", "The measured width of this view as a bit mask."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the full width measurement information for this view as computed by the most recent call to @B_android#view#View#measure_E@. This result is a bit mask as defined by @B_android#view#View#MEASURED_SIZE_MASK_E@ and @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@. This should be used during measurement and layout calculations only. Use @B_android#view#View#getWidth_E@ to see how wide a view is after layout.", "history": "Added in API level 11", "FullName": "public final int getMeasuredWidthAndState ()"}, "isDirty()": {"Returns": [["boolean", "The dirty state of this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "True if this view has changed since the last time being drawn.", "history": "Added in API level 11", "FullName": "public boolean isDirty ()"}, "requestRectangleOnScreen(android.graphics.Rect)": {"Returns": [["boolean", "Whether any parent scrolled."]], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: The rectangle in the View's content coordinate space"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough. A View should call this if it maintains some notion of which part of its content is interesting. For example, a text editing view should call this when its cursor moves. The Rectangle passed into this method should be in the View's content coordinate space. It should not be affected by which part of the View is currently visible or its scroll position.", "history": "Added in API level 1", "FullName": "public boolean requestRectangleOnScreen (Rect rectangle)"}, "isSoundEffectsEnabled()": {"Returns": [["boolean", "whether this view should have sound effects enabled for events such as clicking and touching."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setSoundEffectsEnabled_E@", "@B_android#view#View#playSoundEffect_E@"], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public boolean isSoundEffectsEnabled ()"}, "getVisibility()": {"Returns": [["int", "One of @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the visibility status for this view.", "history": "Added in API level 1", "FullName": "public int getVisibility ()"}, "setSaveEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Set to false to disable state saving, or true (the default) to allow it."]], "Throws": [], "SeeAlso": ["@B_android#view#View#isSaveEnabled_E@", "@B_android#view#View#setId_E@", "@B_android#view#View#onSaveInstanceState_E@"], "Permissions": [], "Description": "Controls whether the saving of this view's state is enabled (that is, whether its @B_android#view#View#onSaveInstanceState_E@ method will be called). Note that even if freezing is enabled, the view still must have an id assigned to it (via @B_android#view#View#setId_E@) for its state to be saved. This flag can only disable the saving of this view; any child views may still have their state saved.", "history": "Added in API level 1", "FullName": "public void setSaveEnabled (boolean enabled)"}, "startActionMode(android.view.ActionMode.Callback,int)": {"Returns": [["@B_android#view#ActionMode_E@", "The new action mode if it is started, null otherwise"]], "Parameters": [["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: Callback that will control the lifecycle of the action mode"], ["int", "int: One of @B_android#view#ActionMode#TYPE_PRIMARY_E@ or @B_android#view#ActionMode#TYPE_FLOATING_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#ActionMode_E@"], "Permissions": [], "Description": "Start an action mode with the given type.", "history": "Added in API level 23", "FullName": "public ActionMode startActionMode (ActionMode.Callback callback, int type)"}, "getTransitionAlpha()": {"Returns": [["float", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This property is intended only for use by the Fade transition, which animates it to produce a visual translucency that does not side-effect (or get affected by) the real alpha property. This value is composited with the other alpha value (and the AlphaAnimation value, when that is present) to produce a final visual translucency result, which is what is passed into the DisplayList.", "history": "Added in API level 29", "FullName": "public float getTransitionAlpha ()"}, "onHoverChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: The current hover state, as returned by @B_android#view#View#isHovered_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#View#isHovered_E@", "@B_android#view#View#setHovered_E@"], "Permissions": [], "Description": "Implement this method to handle hover state changes. This method is called whenever the hover state changes as a result of a call to @B_android#view#View#setHovered_E@.", "history": "Added in API level 14", "FullName": "public void onHoverChanged (boolean hovered)"}, "dispatchWindowSystemUiVisiblityChanged(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch callbacks to @B_android#view#View#onWindowSystemUiVisibilityChanged_E@ down the view hierarchy.", "history": "Added in API level 16", "FullName": "public void dispatchWindowSystemUiVisiblityChanged (int visible)"}, "setDefaultFocusHighlightEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to set this view to use a default focus highlight, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets whether this View should use a default focus highlight when it gets focused but doesn't have @B_android#R#attr#state_focused_E@ defined in its background.", "history": "Added in API level 26", "FullName": "public void setDefaultFocusHighlightEnabled (boolean defaultFocusHighlightEnabled)"}, "getNextFocusRightId()": {"Returns": [["int", "The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the id of the view to use when the next focus is @B_android#view#View#FOCUS_RIGHT_E@.", "history": "Added in API level 1", "FullName": "public int getNextFocusRightId ()"}, "canScrollVertically(int)": {"Returns": [["boolean", "true if this view can be scrolled in the specified direction, false otherwise."]], "Parameters": [["int", "int: Negative to check scrolling up, positive to check scrolling down."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if this view can be scrolled vertically in a certain direction.", "history": "Added in API level 14", "FullName": "public boolean canScrollVertically (int direction)"}, "setAutofillHints(java.lang.String...)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: The autofill hints to set. If the array is emtpy, null is set. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the hints that help an @B_android#service#autofill#AutofillService_E@ determine how to autofill the view with the user's data. Typically, there is only one way to autofill a view, but there could be more than one. For example, if the application accepts either an username or email address to identify an user. These hints are not validated by the Android System, but passed \"as is\" to the service. Hence, they can have any value, but it's recommended to use the AUTOFILL_HINT_ constants such as: @B_android#view#View#AUTOFILL_HINT_USERNAME_E@, @B_android#view#View#AUTOFILL_HINT_PASSWORD_E@, @B_android#view#View#AUTOFILL_HINT_EMAIL_ADDRESS_E@, @B_android#view#View#AUTOFILL_HINT_NAME_E@, @B_android#view#View#AUTOFILL_HINT_PHONE_E@, @B_android#view#View#AUTOFILL_HINT_POSTAL_ADDRESS_E@, @B_android#view#View#AUTOFILL_HINT_POSTAL_CODE_E@, @B_android#view#View#AUTOFILL_HINT_CREDIT_CARD_NUMBER_E@, @B_android#view#View#AUTOFILL_HINT_CREDIT_CARD_SECURITY_CODE_E@, @B_android#view#View#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DATE_E@, @B_android#view#View#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_DAY_E@, @B_android#view#View#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_MONTH_E@ or @B_android#view#View#AUTOFILL_HINT_CREDIT_CARD_EXPIRATION_YEAR_E@.", "history": "Added in API level 26", "FullName": "public void setAutofillHints (String... autofillHints)"}, "setOnSystemUiVisibilityChangeListener(android.view.View.OnSystemUiVisibilityChangeListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnSystemUiVisibilityChangeListener_E@", "View.OnSystemUiVisibilityChangeListener: The @B_android#view#View#OnSystemUiVisibilityChangeListener_E@ to receive callbacks."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a listener to receive callbacks when the visibility of the system bar changes.", "history": "Added in API level 11", "FullName": "public void setOnSystemUiVisibilityChangeListener (View.OnSystemUiVisibilityChangeListener l)"}, "onProvideAutofillVirtualStructure(android.view.ViewStructure,int)": {"Returns": [], "Parameters": [["@B_android#view#ViewStructure_E@", "ViewStructure: fill in with virtual children data for autofill purposes."], ["int", "int: optional flags."]], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Populates a @B_android#view#ViewStructure_E@ containing virtual children to fullfil an autofill request. This method should be used when the view manages a virtual structure under this view. For example, a view that draws input fields using @B_android#view#View#draw_E@. When implementing this method, subclasses must follow the rules below: Add virtual children by calling the @B_android#view#ViewStructure#newChild_E@ or @B_android#view#ViewStructure#asyncNewChild_E@ methods, where the id is an unique id identifying the children in the virtual structure. The children hierarchy can have multiple levels if necessary, but ideally it should exclude intermediate levels that are irrelevant for autofill; that would improve the autofill performance. Also implement @B_android#view#View#autofill_E@ to autofill the virtual children. Set the autofill properties of the child structure as defined by @B_android#view#View#onProvideAutofillStructure_E@, using @B_android#view#ViewStructure#setAutofillId_E@ to set its autofill id. Call @B_android#view#autofill#AutofillManager#notifyViewEntered_E@ and/or @B_android#view#autofill#AutofillManager#notifyViewExited_E@ when the focused virtual child changed. Override @B_android#view#View#isVisibleToUserForAutofill_E@ to allow the platform to query whether a given virtual view is visible to the user in order to support triggering save when all views of interest go away. Call @B_android#view#autofill#AutofillManager#notifyValueChanged_E@ when the value of a virtual child changed. Call @B_android#view#autofill#AutofillManager#notifyViewVisibilityChanged_E@ when the visibility of a virtual child changed. Call @B_android#view#autofill#AutofillManager#notifyViewClicked_E@ when a virtual child is clicked. Call @B_android#view#autofill#AutofillManager#commit_E@ when the autofill context of the view structure changed and the current context should be committed (for example, when the user tapped a SUBMIT button in an HTML page). Call @B_android#view#autofill#AutofillManager#cancel_E@ when the autofill context of the view structure changed and the current context should be canceled (for example, when the user tapped a CANCEL button in an HTML page). Provide ways for users to manually request autofill by calling @B_android#view#autofill#AutofillManager#requestAutofill_E@. The left and top values set in @B_android#view#ViewStructure#setDimens_E@ must be relative to the next @B_android#view#View#isImportantForAutofill_E@ predecessor view included in the structure. Views with virtual children support the Autofill Framework mainly by: Providing the metadata defining what the virtual children mean and how they can be autofilled. Implementing the methods that autofill the virtual children. This method is responsible for the former; @B_android#view#View#autofill_E@ is responsible for the latter.", "history": "Added in API level 26", "FullName": "public void onProvideAutofillVirtualStructure (ViewStructure structure, int flags)"}, "getDefaultSize(int, int)": {"Returns": [["int", "The size this view should be."]], "Parameters": [["int", "int: Default size for this view"], ["int", "int: Constraints imposed by the parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Utility to return a default size. Uses the supplied size if the MeasureSpec imposed no constraints. Will get larger if allowed by the MeasureSpec.", "history": "added in API level 1", "FullName": "public static int getDefaultSize (int size, int measureSpec)"}, "setPadding(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: the left padding in pixels"], ["int", "int: the top padding in pixels"], ["int", "int: the right padding in pixels"], ["int", "int: the bottom padding in pixels"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the padding. The view may add on the space required to display the scrollbars, depending on the style and visibility of the scrollbars. So the values returned from @B_android#view#View#getPaddingLeft_E@, @B_android#view#View#getPaddingTop_E@, @B_android#view#View#getPaddingRight_E@ and @B_android#view#View#getPaddingBottom_E@ may be different from the values set in this call.", "history": "added in API level 1", "FullName": "public void setPadding (int left, int top, int right, int bottom)"}, "getAutofillType()": {"Returns": [["int", "either @B_android#view#View#AUTOFILL_TYPE_NONE_E@, @B_android#view#View#AUTOFILL_TYPE_TEXT_E@, @B_android#view#View#AUTOFILL_TYPE_LIST_E@, @B_android#view#View#AUTOFILL_TYPE_DATE_E@, or @B_android#view#View#AUTOFILL_TYPE_TOGGLE_E@. Value is @B_android#view#View#AUTOFILL_TYPE_NONE_E@, @B_android#view#View#AUTOFILL_TYPE_TEXT_E@, @B_android#view#View#AUTOFILL_TYPE_TOGGLE_E@, @B_android#view#View#AUTOFILL_TYPE_LIST_E@, or @B_android#view#View#AUTOFILL_TYPE_DATE_E@"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#onProvideAutofillStructure_E@", "@B_android#view#View#autofill_E@"], "Permissions": [], "Description": "Describes the autofill type of this view, so an @B_android#service#autofill#AutofillService_E@ can create the proper @B_android#view#autofill#AutofillValue_E@ when autofilling the view. By default returns @B_android#view#View#AUTOFILL_TYPE_NONE_E@, but views should override it to properly support the Autofill Framework.", "history": "Added in API level 26", "FullName": "public int getAutofillType ()"}, "setImportantForAccessibility(int)": {"Returns": [], "Parameters": [["int", "int: How to determine whether this view is important for accessibility."]], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Sets how to determine whether this view is important for accessibility which is if it fires accessibility events and if it is reported to accessibility services that query the screen.", "history": "Added in API level 16", "FullName": "public void setImportantForAccessibility (int mode)"}, "requestFitSystemWindows()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use @B_android#view#View#requestApplyInsets_E@ for newer platform versions. Ask that a new dispatch of @B_android#view#View#fitSystemWindows_E@ be performed.", "history": "Added in API level 16 Deprecated in API level 20", "FullName": "public void requestFitSystemWindows ()"}, "getPaddingRight()": {"Returns": [["int", "the right padding in pixels"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the right padding of this view. If there are inset and enabled scrollbars, this value may include the space required to display the scrollbars as well.", "history": "Added in API level 1", "FullName": "public int getPaddingRight ()"}, "getVerticalScrollbarTrackDrawable()": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@", "@B_android#view#View#isVerticalScrollBarEnabled_E@", "@B_android#view#View#setVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Returns the currently configured Drawable for the track of the vertical scroll bar if it exists, null otherwise.", "history": "Added in API level 29", "FullName": "public Drawable getVerticalScrollbarTrackDrawable ()"}, "getBackground()": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "The drawable used as the background for this view, if any."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setBackground_E@"], "Permissions": [], "Description": "Gets the background drawable", "history": "Added in API level 1", "FullName": "public Drawable getBackground ()"}, "onCreateContextMenu(android.view.ContextMenu)": {"Returns": [], "Parameters": [["@B_android#view#ContextMenu_E@", "ContextMenu: the context menu to populate"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Views should implement this if the view itself is going to add items to the context menu.", "history": "Added in API level 1", "FullName": "protected void onCreateContextMenu (ContextMenu menu)"}, "measure(int, int)": {"Returns": [], "Parameters": [["int", "int: Horizontal space requirements as imposed by the parent"], ["int", "int: Vertical space requirements as imposed by the parent"]], "Throws": [], "SeeAlso": ["@B_android#view#View#onMeasure_E@"], "Permissions": [], "Description": "This is called to find out how big a view should be. The parent supplies constraint information in the width and height parameters. The actual measurement work of a view is performed in @B_android#view#View#onMeasure_E@, called by this method. Therefore, only @B_android#view#View#onMeasure_E@ can and must be overridden by subclasses.", "history": "added in API level 1", "FullName": "public final void measure (int widthMeasureSpec, int heightMeasureSpec)"}, "updateDragShadow(android.view.View.DragShadowBuilder)": {"Returns": [], "Parameters": [["@B_android#view#View#DragShadowBuilder_E@", "View.DragShadowBuilder: A @B_android#view#View#DragShadowBuilder_E@ object for building the new drag shadow."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Updates the drag shadow for the ongoing drag and drop operation.", "history": "Added in API level 24", "FullName": "public final void updateDragShadow (View.DragShadowBuilder shadowBuilder)"}, "getDefaultSize(int,int)": {"Returns": [["int", "The size this view should be."]], "Parameters": [["int", "int: Default size for this view"], ["int", "int: Constraints imposed by the parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Utility to return a default size. Uses the supplied size if the MeasureSpec imposed no constraints. Will get larger if allowed by the MeasureSpec.", "history": "Added in API level 1", "FullName": "public static int getDefaultSize (int size, int measureSpec)"}, "refreshDrawableState()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#drawableStateChanged_E@", "@B_android#view#View#getDrawableState_E@"], "Permissions": [], "Description": "Call this to force a view to update its drawable state. This will cause drawableStateChanged to be called on this view. Views that are interested in the new state should call getDrawableState.", "history": "Added in API level 1", "FullName": "public void refreshDrawableState ()"}, "isContextClickable()": {"Returns": [["boolean", "true if the view is context clickable, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setContextClickable_E@"], "Permissions": [], "Description": "Indicates whether this view reacts to context clicks or not.", "history": "Added in API level 23", "FullName": "public boolean isContextClickable ()"}, "setScaleY(float)": {"Returns": [], "Parameters": [["float", "float: The scaling factor."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "Sets the amount that the view is scaled in Y around the pivot point, as a proportion of the view's unscaled width. A value of 1 means that no scaling is applied.", "history": "Added in API level 11", "FullName": "public void setScaleY (float scaleY)"}, "isPressed()": {"Returns": [["boolean", "true if the view is currently pressed, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setPressed_E@", "@B_android#view#View#isClickable_E@", "@B_android#view#View#setClickable_E@"], "Permissions": [], "Description": "Indicates whether the view is currently in pressed state. Unless @B_android#view#View#setPressed_E@ is explicitly called, only clickable views can enter the pressed state.", "history": "Added in API level 1", "FullName": "public boolean isPressed ()"}, "canResolveTextDirection()": {"Returns": [["boolean", "true if text direction resolution can be done otherwise return false."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if text direction resolution can be done.", "history": "Added in API level 19", "FullName": "public boolean canResolveTextDirection ()"}, "setScreenReaderFocusable(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether the view should be treated as a unit by screen reader accessibility tools."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets whether this View should be a focusable element for screen readers and include non-focusable Views from its subtree when providing feedback. Note: this is similar to using", "history": "Added in API level 28", "FullName": "public void setScreenReaderFocusable (boolean screenReaderFocusable)"}, "postInvalidateDelayed(long)": {"Returns": [], "Parameters": [["long", "long: the duration in milliseconds to delay the invalidation by"]], "Throws": [], "SeeAlso": ["@B_android#view#View#invalidate_E@", "@B_android#view#View#postInvalidate_E@"], "Permissions": [], "Description": "Cause an invalidate to happen on a subsequent cycle through the event loop. Waits for the specified amount of time. This method can be invoked from outside of the UI thread only when this View is attached to a window.", "history": "Added in API level 1", "FullName": "public void postInvalidateDelayed (long delayMilliseconds)"}, "hasWindowFocus()": {"Returns": [["boolean", "True if this view is in a window that currently has window focus."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view is in a window that currently has window focus. Note that this is not the same as the view itself having focus.", "history": "Added in API level 1", "FullName": "public boolean hasWindowFocus ()"}, "setOnKeyListener(android.view.View.OnKeyListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnKeyListener_E@", "View.OnKeyListener: the key listener to attach to this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when a hardware key is pressed in this view. Key presses in software input methods will generally not trigger the methods of this listener.", "history": "Added in API level 1", "FullName": "public void setOnKeyListener (View.OnKeyListener l)"}, "setHorizontalFadingEdgeEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the horizontal edges should be faded when the view is scrolled horizontally"]], "Throws": [], "SeeAlso": ["@B_android#view#View#isHorizontalFadingEdgeEnabled_E@"], "Permissions": [], "Description": "Define whether the horizontal edges should be faded when this view is scrolled horizontally.", "history": "Added in API level 1", "FullName": "public void setHorizontalFadingEdgeEnabled (boolean horizontalFadingEdgeEnabled)"}, "onConfigurationChanged(android.content.res.Configuration)": {"Returns": [], "Parameters": [["@B_android#content#res#Configuration_E@", "Configuration: The new resource configuration."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the current configuration of the resources being used by the application have changed. You can use this to decide when to reload resources that can changed based on orientation and other configuration characteristics. You only need to use this if you are not relying on the normal @B_android#app#Activity_E@ mechanism of recreating the activity instance upon a configuration change.", "history": "Added in API level 8", "FullName": "protected void onConfigurationChanged (Configuration newConfig)"}, "setTransitionVisibility(int)": {"Returns": [], "Parameters": [["int", "int: One of @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setVisibility_E@"], "Permissions": [], "Description": "Changes the visibility of this View without triggering any other changes. This should only be used by animation frameworks, such as @B_android#transition#Transition_E@, where visibility changes should not adjust focus or trigger a new layout. Application developers should use @B_android#view#View#setVisibility_E@ instead to ensure that the hierarchy is correctly updated. Only call this method when a temporary visibility must be applied during an animation and the original visibility value is guaranteed to be reset after the animation completes. Use @B_android#view#View#setVisibility_E@ in all other cases.", "history": "Added in API level 29", "FullName": "public void setTransitionVisibility (int visibility)"}, "setAccessibilityPaneTitle(java.lang.CharSequence)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The pane's title. Setting to null indicates that this View is not a pane. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Visually distinct portion of a window with window-like semantics are considered panes for accessibility purposes. One example is the content view of a fragment that is replaced. In order for accessibility services to understand a pane's window-like behavior, panes should have descriptive titles. Views with pane titles produce @B_android#view#accessibility#AccessibilityEvent_E@s when they appear, disappear, or change title.", "history": "Added in API level 28", "FullName": "public void setAccessibilityPaneTitle (CharSequence accessibilityPaneTitle)"}, "setForeground(android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: the Drawable to be drawn on top of the children"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Supply a Drawable that is to be rendered on top of all of the content in the view.", "history": "Added in API level 23", "FullName": "public void setForeground (Drawable foreground)"}, "setContentDescription(java.lang.CharSequence)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The content description."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getContentDescription_E@"], "Permissions": [], "Description": "Sets the @B_android#view#View_E@'s content description. A content description briefly describes the view and is primarily used for accessibility support to determine how a view should be presented to the user. In the case of a view with no textual representation, such as @B_android#widget#ImageButton_E@, a useful content description explains what the view does. For example, an image button with a phone icon that is used to place a call may use \"Call\" as its content description. An image of a floppy disk that is used to save a file may use \"Save\".", "history": "Added in API level 4", "FullName": "public void setContentDescription (CharSequence contentDescription)"}, "getRevealOnFocusHint()": {"Returns": [["boolean", "true if this view would prefer to become fully visible when it gains focus, false if it would prefer not to disrupt scroll positioning"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setRevealOnFocusHint_E@"], "Permissions": [], "Description": "Returns this view's preference for reveal behavior when it gains focus. When this method returns true for a child view requesting focus, ancestor views responding to a focus change in @B_android#view#ViewParent#requestChildFocus_E@ should make a best effort to make the newly focused child fully visible to the user. When it returns false, ancestor views should preferably not disrupt scroll positioning or other properties affecting visibility to the user as part of the focus change.", "history": "Added in API level 25", "FullName": "public final boolean getRevealOnFocusHint ()"}, "dispatchTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Pass the touch screen motion event down to the target view, or this view if it is the target.", "history": "Added in API level 1", "FullName": "public boolean dispatchTouchEvent (MotionEvent event)"}, "mergeDrawableStates(int[],int[])": {"Returns": [["int[]", "As a convenience, the baseState array you originally passed into the function is returned."]], "Parameters": [["int[]", "int: The base state values returned by @B_android#view#View#onCreateDrawableState_E@, which will be modified to also hold your own additional state values."], ["int[]", "int: The additional state values you would like added to baseState; this array is not modified."]], "Throws": [], "SeeAlso": ["@B_android#view#View#onCreateDrawableState_E@"], "Permissions": [], "Description": "Merge your own state values in @B_android#view#View#onCreateDrawableState_E@.", "history": "Added in API level 1", "FullName": "protected static int[] mergeDrawableStates (int[] baseState, int[] additionalState)"}, "getAttributeSourceResourceMap()": {"Returns": [["@B_java#util#Map_E@", "mapping of attribute resource ID to source resource ID where the attribute value was set. This value will never be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the mapping of attribute resource ID to source resource ID where the attribute value was set. Source resource ID can either be a layout resource ID, if the value was set in XML within the View tag, or a style resource ID, if the attribute was set in a style. The source resource value will be one of the resource IDs from @B_android#view#View#getAttributeSourceResourceMap_E@.", "history": "Added in API level 29", "FullName": "public Map<Integer, Integer> getAttributeSourceResourceMap ()"}, "getDisplay()": {"Returns": [["@B_android#view#Display_E@", "The logical display, or null if the view is not currently attached to a window."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the logical display to which the view's window has been attached.", "history": "Added in API level 17", "FullName": "public Display getDisplay ()"}, "onKeyMultiple(int,int,android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: A key code that represents the button pressed, from @B_android#view#KeyEvent_E@."], ["int", "int: The number of times the action was made."], ["@B_android#view#KeyEvent_E@", "KeyEvent: The KeyEvent object that defines the button action."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyMultiple_E@: always returns false (doesn't handle the event). Key presses in software keyboards will generally NOT trigger this listener, although some may elect to do so in some situations. Do not rely on this to catch software key presses.", "history": "Added in API level 1", "FullName": "public boolean onKeyMultiple (int keyCode, int repeatCount, KeyEvent event)"}, "getBackgroundTintMode()": {"Returns": [["@B_android#graphics#PorterDuff#Mode_E@", "the blending mode used to apply the tint to the background drawable This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setBackgroundTintBlendMode_E@"], "Permissions": [], "Description": "Return the blending mode used to apply the tint to the background drawable, if specified.", "history": "Added in API level 21", "FullName": "public PorterDuff.Mode getBackgroundTintMode ()"}, "computeHorizontalScrollRange()": {"Returns": [["int", "the total horizontal range represented by the horizontal scrollbar"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#computeHorizontalScrollExtent_E@", "@B_android#view#View#computeHorizontalScrollOffset_E@"], "Permissions": [], "Description": "Compute the horizontal range that the horizontal scrollbar represents. The range is expressed in arbitrary units that must be the same as the units used by @B_android#view#View#computeHorizontalScrollExtent_E@ and @B_android#view#View#computeHorizontalScrollOffset_E@. The default range is the drawing width of this view.", "history": "Added in API level 1", "FullName": "protected int computeHorizontalScrollRange ()"}, "isInLayout()": {"Returns": [["boolean", "whether the view hierarchy is currently undergoing a layout pass"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether the view hierarchy is currently undergoing a layout pass. This information is useful to avoid situations such as calling @B_android#view#View#requestLayout_E@ during a layout pass.", "history": "Added in API level 18", "FullName": "public boolean isInLayout ()"}, "addOnLayoutChangeListener(android.view.View.OnLayoutChangeListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnLayoutChangeListener_E@", "View.OnLayoutChangeListener: The listener that will be called when layout bounds change."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add a listener that will be called when the bounds of the view change due to layout processing.", "history": "Added in API level 11", "FullName": "public void addOnLayoutChangeListener (View.OnLayoutChangeListener listener)"}, "setAlpha(float)": {"Returns": [], "Parameters": [["float", "float: The opacity of the view. Value is between 0.0 and 1.0 inclusive"]], "Throws": [], "SeeAlso": ["@B_android#view#View#hasOverlappingRendering_E@", "@B_android#view#View#setLayerType_E@"], "Permissions": [], "Description": "Sets the opacity of the view to a value from 0 to 1, where 0 means the view is completely transparent and 1 means the view is completely opaque. For a view with a frequently changing alpha, such as during a fading animation, it is strongly recommended for performance reasons to either override @B_android#view#View#hasOverlappingRendering_E@ to return false if appropriate, or setting a @B_android#view#View#setLayerType_E@ on the view for the duration of the animation. On versions @B_android#os#Build#VERSION_CODES#M_E@ and below, the default path for rendering an unlayered View with alpha could add multiple milliseconds of rendering cost, even for simple or small views. Starting with @B_android#os#Build#VERSION_CODES#M_E@, @B_android#view#View#LAYER_TYPE_HARDWARE_E@ is automatically applied to the view at the rendering level. If this view overrides @B_android#view#View#onSetAlpha_E@ to return true, then this view is responsible for applying the opacity itself. On versions @B_android#os#Build#VERSION_CODES#LOLLIPOP_MR1_E@ and below, note that if the view is backed by a @B_android#view#View#setLayerType_E@ and is associated with a @B_android#view#View#setLayerPaint_E@, setting an alpha value less than 1.0 will supersede the alpha of the layer paint. Starting with @B_android#os#Build#VERSION_CODES#M_E@, setting a translucent alpha value will clip a View to its bounds, unless the View returns false from @B_android#view#View#hasOverlappingRendering_E@.", "history": "Added in API level 11", "FullName": "public void setAlpha (float alpha)"}, "isHorizontalFadingEdgeEnabled()": {"Returns": [["boolean", "true if the horizontal edges should are faded on scroll, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setHorizontalFadingEdgeEnabled_E@"], "Permissions": [], "Description": "Indicate whether the horizontal edges are faded when the view is scrolled horizontally.", "history": "Added in API level 1", "FullName": "public boolean isHorizontalFadingEdgeEnabled ()"}, "autofill(android.util.SparseArray<android.view.autofill.AutofillValue>)": {"Returns": [], "Parameters": [["@B_android#util#SparseArray_E@", "SparseArray: map of values to be autofilled, keyed by virtual child id. This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Automatically fills the content of the virtual children within this view. Views with virtual children support the Autofill Framework mainly by: Providing the metadata defining what the virtual children mean and how they can be autofilled. Implementing the methods that autofill the virtual children. @B_android#view#View#onProvideAutofillVirtualStructure_E@ is responsible for the former, this method is responsible for the latter - see @B_android#view#View#autofill_E@ and @B_android#view#View#onProvideAutofillVirtualStructure_E@ for more info about autofill. If a child value is updated asynchronously, the next call to @B_android#view#autofill#AutofillManager#notifyValueChanged_E@ must happen ?android:attr/autofilledHighlight should be drawn over it until the data changes.", "history": "Added in API level 26", "FullName": "public void autofill (SparseArray<AutofillValue> values)"}, "invalidate()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Invalidate the whole view. If the view is visible, @B_android#view#View#onDraw_E@ will be called at some point in the future. This must be called from a UI thread. To call from a non-UI thread, call @B_android#view#View#postInvalidate_E@.", "history": "Added in API level 1", "FullName": "public void invalidate ()"}, "setPivotX(float)": {"Returns": [], "Parameters": [["float", "float: The x location of the pivot point."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getRotation_E@", "@B_android#view#View#getScaleX_E@", "@B_android#view#View#getScaleY_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "Sets the x location of the point around which the view is @B_android#view#View#setRotation_E@ and @B_android#view#View#setScaleX_E@. By default, the pivot point is centered on the object. Setting this property disables this behavior and causes the view to use only the explicitly set pivotX and pivotY values.", "history": "Added in API level 11", "FullName": "public void setPivotX (float pivotX)"}, "transformMatrixToGlobal(android.graphics.Matrix)": {"Returns": [], "Parameters": [["@B_android#graphics#Matrix_E@", "Matrix: input matrix to modify This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Modifies the input matrix such that it maps view-local coordinates to on-screen coordinates.", "history": "Added in API level 29", "FullName": "public void transformMatrixToGlobal (Matrix matrix)"}, "getParentForAccessibility()": {"Returns": [["@B_android#view#ViewParent_E@", "The parent for accessibility purposes."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the parent for accessibility purposes. Note that the parent for accessibility is not necessary the immediate parent. It is the first predecessor that is important for accessibility.", "history": "Added in API level 16", "FullName": "public ViewParent getParentForAccessibility ()"}, "dispatchSetSelected(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: The new selected state"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setSelected_E@"], "Permissions": [], "Description": "Dispatch setSelected to all of this View's children.", "history": "Added in API level 1", "FullName": "protected void dispatchSetSelected (boolean selected)"}, "generateViewId()": {"Returns": [["int", "a generated ID value"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Generate a value suitable for use in @B_android#view#View#setId_E@. This value will not collide with ID values generated at build time by aapt for R.id.", "history": "Added in API level 17", "FullName": "public static int generateViewId ()"}, "getLayoutParams()": {"Returns": [["@B_android#view#ViewGroup#LayoutParams_E@", "The LayoutParams associated with this view, or null if no parameters have been set yet"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the LayoutParams associated with this view. All views should have layout parameters. These supply parameters to the @B_android#view#View#setLayoutParams_E@ was not invoked successfully. When a View is attached to a parent ViewGroup, this method must not return null.", "history": "Added in API level 1", "FullName": "public ViewGroup.LayoutParams getLayoutParams ()"}, "getForeground()": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "a Drawable or null if no foreground was set"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#onDrawForeground_E@"], "Permissions": [], "Description": "Returns the drawable used as the foreground of this View. The foreground drawable, if non-null, is always drawn on top of the view's content.", "history": "Added in API level 23", "FullName": "public Drawable getForeground ()"}, "getImportantForAutofill()": {"Returns": [["int", "@B_android#view#View#IMPORTANT_FOR_AUTOFILL_AUTO_E@ by default, or value passed to @B_android#view#View#setImportantForAutofill_E@. Value is @B_android#view#View#IMPORTANT_FOR_AUTOFILL_AUTO_E@, @B_android#view#View#IMPORTANT_FOR_AUTOFILL_YES_E@, @B_android#view#View#IMPORTANT_FOR_AUTOFILL_NO_E@, @B_android#view#View#IMPORTANT_FOR_AUTOFILL_YES_EXCLUDE_DESCENDANTS_E@, or @B_android#view#View#IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the mode for determining whether this view is important for autofill. See @B_android#view#View#setImportantForAutofill_E@ and @B_android#view#View#isImportantForAutofill_E@ for more info about this mode.", "history": "Added in API level 26", "FullName": "public int getImportantForAutofill ()"}, "canScrollHorizontally(int)": {"Returns": [["boolean", "true if this view can be scrolled in the specified direction, false otherwise."]], "Parameters": [["int", "int: Negative to check scrolling left, positive to check scrolling right."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Check if this view can be scrolled horizontally in a certain direction.", "history": "Added in API level 14", "FullName": "public boolean canScrollHorizontally (int direction)"}, "cancelDragAndDrop()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Cancels an ongoing drag and drop operation. A @B_android#view#DragEvent_E@ object with @B_android#view#DragEvent#getAction_E@ value of @B_android#view#DragEvent#ACTION_DRAG_ENDED_E@ and @B_android#view#DragEvent#getResult_E@ value of false will be sent to every View that received @B_android#view#DragEvent#ACTION_DRAG_STARTED_E@ even if they are not currently visible. This method can be called on any View in the same window as the View on which @B_android#view#View#startDragAndDrop_E@ was called.", "history": "Added in API level 24", "FullName": "public final void cancelDragAndDrop ()"}, "buildDrawingCache(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": ["@B_android#view#View#getDrawingCache_E@", "@B_android#view#View#destroyDrawingCache_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Forces the drawing cache to be built if the drawing cache is invalid. If you call @B_android#view#View#buildDrawingCache_E@ manually without calling @B_android#view#View#setDrawingCacheEnabled_E@, you should cleanup the cache by calling @B_android#view#View#destroyDrawingCache_E@ afterwards. Note about auto scaling in compatibility mode: When auto scaling is not enabled, this method will create a bitmap of the same size as this view. Because this bitmap will be drawn scaled by the parent ViewGroup, the result on screen might show scaling artifacts. To avoid such artifacts, you should call this method by setting the auto scaling to true. Doing so, however, will generate a bitmap of a different size than the view. This implies that your application must be able to handle this size. You should avoid calling this method when hardware acceleration is enabled. If you do not need the drawing cache bitmap, calling this method will increase memory usage and cause the view to be rendered in software once, thus negatively impacting performance.", "history": "Added in API level 4 Deprecated in API level 28", "FullName": "public void buildDrawingCache (boolean autoScale)"}, "offsetLeftAndRight(int)": {"Returns": [], "Parameters": [["int", "int: the number of pixels to offset the view by"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Offset this view's horizontal location by the specified amount of pixels.", "history": "Added in API level 1", "FullName": "public void offsetLeftAndRight (int offset)"}, "onCapturedPointerEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The captured pointer event."]], "Throws": [], "SeeAlso": ["@B_android#view#View#requestPointerCapture_E@"], "Permissions": [], "Description": "Implement this method to handle captured pointer events", "history": "Added in API level 26", "FullName": "public boolean onCapturedPointerEvent (MotionEvent event)"}, "addOnUnhandledKeyEventListener(android.view.View.OnUnhandledKeyEventListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnUnhandledKeyEventListener_E@", "View.OnUnhandledKeyEventListener: a receiver of unhandled @B_android#view#KeyEvent_E@s."]], "Throws": [], "SeeAlso": ["@B_android#view#View#removeOnUnhandledKeyEventListener_E@"], "Permissions": [], "Description": "Adds a listener which will receive unhandled @B_android#view#KeyEvent_E@s. This must be called on the UI thread.", "history": "Added in API level 28", "FullName": "public void addOnUnhandledKeyEventListener (View.OnUnhandledKeyEventListener listener)"}, "animate()": {"Returns": [["@B_android#view#ViewPropertyAnimator_E@", "ViewPropertyAnimator The ViewPropertyAnimator associated with this View."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method returns a ViewPropertyAnimator object, which can be used to animate specific properties on this View.", "history": "Added in API level 12", "FullName": "public ViewPropertyAnimator animate ()"}, "getNextFocusUpId()": {"Returns": [["int", "The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the id of the view to use when the next focus is @B_android#view#View#FOCUS_UP_E@.", "history": "Added in API level 1", "FullName": "public int getNextFocusUpId ()"}, "onMeasure(int, int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getMeasuredWidth_E@", "@B_android#view#View#getMeasuredHeight_E@", "@B_android#view#View#setMeasuredDimension_E@", "@B_android#view#View#getSuggestedMinimumHeight_E@", "@B_android#view#View#getSuggestedMinimumWidth_E@", "@B_android#view#View#MeasureSpec#getMode_E@", "@B_android#view#View#MeasureSpec#getSize_E@"], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "added in API level 1", "FullName": "protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "setBackgroundResource(int)": {"Returns": [], "Parameters": [["int", "int: The identifier of the resource."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the background to a given resource. The resource should refer to a Drawable object or 0 to remove the background.", "history": "Added in API level 1", "FullName": "public void setBackgroundResource (int resid)"}, "onLayout(boolean,int,int,int,int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "Added in API level 1", "FullName": "protected void onLayout (boolean changed, int left, int top, int right, int bottom)"}, "setStateListAnimator(android.animation.StateListAnimator)": {"Returns": [], "Parameters": [["@B_android#animation#StateListAnimator_E@", "StateListAnimator: The StateListAnimator to update the view"]], "Throws": [], "SeeAlso": ["@B_android#animation#StateListAnimator_E@"], "Permissions": [], "Description": "Attaches the provided StateListAnimator to this View. Any previously attached StateListAnimator will be detached.", "history": "Added in API level 21", "FullName": "public void setStateListAnimator (StateListAnimator stateListAnimator)"}, "getLeftPaddingOffset()": {"Returns": [["int", "The left padding offset in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#isPaddingOffsetRequired_E@"], "Permissions": [], "Description": "Amount by which to extend the left fading region. Called only when @B_android#view#View#isPaddingOffsetRequired_E@ returns true.", "history": "Added in API level 2", "FullName": "protected int getLeftPaddingOffset ()"}, "onVisibilityChanged(android.view.View, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view whose visibility changed. May be this or an ancestor view.This value must never be null."], ["int", "int: The new visibility, one of @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@ or @B_android#view#View#GONE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the visibility of the view or an ancestor of the view has changed.", "history": "added in API level 8", "FullName": "protected void onVisibilityChanged (View changedView, int visibility)"}, "performContextClick(float, float)": {"Returns": [["boolean", "True if there was an assigned OnContextClickListener that consumed the event, false otherwise."]], "Parameters": [["float", "float: the x coordinate of the context click"], ["float", "float: the y coordinate of the context click"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this view's OnContextClickListener, if it is defined.", "history": "added in API level 24", "FullName": "public boolean performContextClick (float x, float y)"}, "computeVerticalScrollOffset()": {"Returns": [["int", "the vertical offset of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#computeVerticalScrollRange_E@", "@B_android#view#View#computeVerticalScrollExtent_E@"], "Permissions": [], "Description": "Compute the vertical offset of the vertical scrollbar's thumb within the horizontal range. This value is used to compute the position of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#view#View#computeVerticalScrollRange_E@ and @B_android#view#View#computeVerticalScrollExtent_E@. The default offset is the scroll offset of this view.", "history": "Added in API level 1", "FullName": "protected int computeVerticalScrollOffset ()"}, "isPivotSet()": {"Returns": [["boolean", "True if a pivot has been set, false if the default pivot is being used"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether or not a pivot has been set by a call to @B_android#view#View#setPivotX_E@ or @B_android#view#View#setPivotY_E@. If no pivot has been set then the pivot will be the center of the view.", "history": "Added in API level 28", "FullName": "public boolean isPivotSet ()"}, "getPointerIcon()": {"Returns": [["@B_android#view#PointerIcon_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the pointer icon for the current view.", "history": "Added in API level 24", "FullName": "public PointerIcon getPointerIcon ()"}, "addFocusables(java.util.ArrayList<android.view.View>,int)": {"Returns": [], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: Focusable views found so far"], ["int", "int: The direction of the focus Value is @B_android#view#View#FOCUS_BACKWARD_E@, @B_android#view#View#FOCUS_FORWARD_E@, @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_RIGHT_E@, or @B_android#view#View#FOCUS_DOWN_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views. If we are in touch mode, only add views that are also focusable in touch mode.", "history": "Added in API level 1", "FullName": "public void addFocusables (ArrayList<View> views, int direction)"}, "getPaddingLeft()": {"Returns": [["int", "the left padding in pixels"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the left padding of this view. If there are inset and enabled scrollbars, this value may include the space required to display the scrollbars as well.", "history": "Added in API level 1", "FullName": "public int getPaddingLeft ()"}, "performHapticFeedback(int,int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int", "int: One of the constants defined in @B_android#view#HapticFeedbackConstants_E@"], ["int", "int: Additional flags as per @B_android#view#HapticFeedbackConstants_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "BZZZTT!!1! Like @B_android#view#View#performHapticFeedback_E@, with additional options.", "history": "Added in API level 3", "FullName": "public boolean performHapticFeedback (int feedbackConstant, int flags)"}, "setTop(int)": {"Returns": [], "Parameters": [["int", "int: The top of this view, in pixels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the top position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.", "history": "Added in API level 11", "FullName": "public final void setTop (int top)"}, "getSuggestedMinimumHeight()": {"Returns": [["int", "The suggested minimum height of the view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the suggested minimum height that the view should use. This returns the maximum of the view's minimum height and the background's minimum height (@B_android#graphics#drawable#Drawable#getMinimumHeight_E@). When being used in @B_android#view#View#onMeasure_E@, the caller should still ensure the returned height is within the requirements of the parent.", "history": "Added in API level 1", "FullName": "protected int getSuggestedMinimumHeight ()"}, "getOverScrollMode()": {"Returns": [["int", "This view's over-scroll mode."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the over-scroll mode for this view. The result will be one of @B_android#view#View#OVER_SCROLL_ALWAYS_E@, @B_android#view#View#OVER_SCROLL_IF_CONTENT_SCROLLS_E@ (allow over-scrolling only if the view content is larger than the container), or @B_android#view#View#OVER_SCROLL_NEVER_E@.", "history": "Added in API level 9", "FullName": "public int getOverScrollMode ()"}, "getKeyDispatcherState()": {"Returns": [["@B_android#view#KeyEvent#DispatcherState_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the global @B_android#view#KeyEvent#DispatcherState_E@ for this view's window. Returns null if the view is not currently attached to the window. Normally you will not need to use this directly, but just use the standard high-level event callbacks like @B_android#view#View#onKeyDown_E@.", "history": "Added in API level 5", "FullName": "public KeyEvent.DispatcherState getKeyDispatcherState ()"}, "getContentDescription()": {"Returns": [["@B_java#lang#CharSequence_E@", "the content description"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setContentDescription_E@"], "Permissions": [], "Description": "Returns the @B_android#view#View_E@'s content description. @B_android#view#View#setContentDescription_E@ to modify the content description.", "history": "Added in API level 4", "FullName": "public CharSequence getContentDescription ()"}, "setPaddingRelative(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: the start padding in pixels"], ["int", "int: the top padding in pixels"], ["int", "int: the end padding in pixels"], ["int", "int: the bottom padding in pixels"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the relative padding. The view may add on the space required to display the scrollbars, depending on the style and visibility of the scrollbars. So the values returned from @B_android#view#View#getPaddingStart_E@, @B_android#view#View#getPaddingTop_E@, @B_android#view#View#getPaddingEnd_E@ and @B_android#view#View#getPaddingBottom_E@ may be different from the values set in this call.", "history": "added in API level 17", "FullName": "public void setPaddingRelative (int start, int top, int end, int bottom)"}, "performContextClick(float,float)": {"Returns": [["boolean", "True if there was an assigned OnContextClickListener that consumed the event, false otherwise."]], "Parameters": [["float", "float: the x coordinate of the context click"], ["float", "float: the y coordinate of the context click"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this view's OnContextClickListener, if it is defined.", "history": "Added in API level 24", "FullName": "public boolean performContextClick (float x, float y)"}, "setMeasuredDimension(int,int)": {"Returns": [], "Parameters": [["int", "int: The measured width of this view. May be a complex bit mask as defined by @B_android#view#View#MEASURED_SIZE_MASK_E@ and @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@."], ["int", "int: The measured height of this view. May be a complex bit mask as defined by @B_android#view#View#MEASURED_SIZE_MASK_E@ and @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method must be called by @B_android#view#View#onMeasure_E@ to store the measured width and measured height. Failing to do so will trigger an exception at measurement time.", "history": "Added in API level 1", "FullName": "protected final void setMeasuredDimension (int measuredWidth, int measuredHeight)"}, "findFocus()": {"Returns": [["@B_android#view#View_E@", "The view that currently has focus, or null if no focused view can be found."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the view in the hierarchy rooted at this view that currently has focus.", "history": "Added in API level 1", "FullName": "public View findFocus ()"}, "stopNestedScroll()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#startNestedScroll_E@"], "Permissions": [], "Description": "Stop a nested scroll in progress. Calling this method when a nested scroll is not currently in progress is harmless.", "history": "Added in API level 21", "FullName": "public void stopNestedScroll ()"}, "getZ()": {"Returns": [["float", "The visual z position of this view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The visual z position of this view, in pixels. This is equivalent to the @B_android#view#View#setTranslationZ_E@ property plus the current @B_android#view#View#getElevation_E@ property.", "history": "Added in API level 21", "FullName": "public float getZ ()"}, "awakenScrollBars(int,boolean)": {"Returns": [["boolean", "true if the animation is played, false otherwise"]], "Parameters": [["int", "int: the delay, in milliseconds, after which the animation should start; when the delay is 0, the animation starts immediately"], ["boolean", "boolean: Whether this method should call invalidate"]], "Throws": [], "SeeAlso": ["@B_android#view#View#scrollBy_E@", "@B_android#view#View#scrollTo_E@", "@B_android#view#View#isHorizontalScrollBarEnabled_E@", "@B_android#view#View#isVerticalScrollBarEnabled_E@", "@B_android#view#View#setHorizontalScrollBarEnabled_E@", "@B_android#view#View#setVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Trigger the scrollbars to draw. When invoked this method starts an animation to fade the scrollbars out after a fixed delay. If a subclass provides animated scrolling, the start delay should equal the duration of the scrolling animation. The animation starts only if at least one of the scrollbars is enabled, as specified by @B_android#view#View#isHorizontalScrollBarEnabled_E@ and @B_android#view#View#isVerticalScrollBarEnabled_E@. When the animation is started, this method returns true, and false otherwise. If the animation is started, this method calls @B_android#view#View#invalidate_E@ if the invalidate parameter is set to true; in that case the caller should not call @B_android#view#View#invalidate_E@. This method should be invoked every time a subclass directly updates the scroll parameters.", "history": "Added in API level 5", "FullName": "protected boolean awakenScrollBars (int startDelay, boolean invalidate)"}, "setScaleX(float)": {"Returns": [], "Parameters": [["float", "float: The scaling factor."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "Sets the amount that the view is scaled in x around the pivot point, as a proportion of the view's unscaled width. A value of 1 means that no scaling is applied.", "history": "Added in API level 11", "FullName": "public void setScaleX (float scaleX)"}, "setForegroundTintList(android.content.res.ColorStateList)": {"Returns": [], "Parameters": [["@B_android#content#res#ColorStateList_E@", "ColorStateList: the tint to apply, may be null to clear tint This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getForegroundTintList_E@", "@B_android#graphics#drawable#Drawable#setTintList_E@"], "Permissions": [], "Description": "Applies a tint to the foreground drawable. Does not modify the current tint mode, which is @B_android#graphics#PorterDuff#Mode#SRC_IN_E@ by default. Subsequent calls to @B_android#view#View#setForeground_E@ will automatically mutate the drawable and apply the specified tint and tint mode using @B_android#graphics#drawable#Drawable#setTintList_E@.", "history": "Added in API level 23", "FullName": "public void setForegroundTintList (ColorStateList tint)"}, "onKeyLongPress(int, android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyLongPress_E@: always returns false (doesn't handle the event). Key presses in software keyboards will generally NOT trigger this listener, although some may elect to do so in some situations. Do not rely on this to catch software key presses.", "history": "added in API level 5", "FullName": "public boolean onKeyLongPress (int keyCode, KeyEvent event)"}, "isSelected()": {"Returns": [["boolean", "true if the view is selected, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates the selection state of this view.", "history": "Added in API level 1", "FullName": "public boolean isSelected ()"}, "startNestedScroll(int)": {"Returns": [["boolean", "true if a cooperative parent was found and nested scrolling has been enabled for the current gesture."]], "Parameters": [["int", "int: Flags consisting of a combination of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@ and/or @B_android#view#View#SCROLL_AXIS_VERTICAL_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#View#stopNestedScroll_E@", "@B_android#view#View#dispatchNestedPreScroll_E@", "@B_android#view#View#dispatchNestedScroll_E@"], "Permissions": [], "Description": "Begin a nestable scroll operation along the given axes. A view starting a nested scroll promises to abide by the following contract: The view will call startNestedScroll upon initiating a scroll operation. In the case of a touch scroll this corresponds to the initial @B_android#view#MotionEvent#ACTION_DOWN_E@. In the case of touch scrolling the nested scroll will be terminated automatically in the same manner as @B_android#view#ViewParent#requestDisallowInterceptTouchEvent_E@. In the event of programmatic scrolling the caller must explicitly call @B_android#view#View#stopNestedScroll_E@ to indicate the end of the nested scroll. If startNestedScroll returns true, a cooperative parent was found. If it returns false the caller may ignore the rest of this contract until the next scroll. Calling startNestedScroll while a nested scroll is already in progress will return true. At each incremental step of the scroll the caller should invoke @B_android#view#View#dispatchNestedPreScroll_E@ once it has calculated the requested scrolling delta. If it returns true the nested scrolling parent at least partially consumed the scroll and the caller should adjust the amount it scrolls by. After applying the remainder of the scroll delta the caller should invoke @B_android#view#View#dispatchNestedScroll_E@, passing both the delta consumed and the delta unconsumed. A nested scrolling parent may treat these values differently. See @B_android#view#ViewParent#onNestedScroll_E@.", "history": "Added in API level 21", "FullName": "public boolean startNestedScroll (int axes)"}, "setAccessibilityTraversalBefore(int)": {"Returns": [], "Parameters": [["int", "int: The id of a view this one precedes in accessibility traversal."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setImportantForAccessibility_E@"], "Permissions": [], "Description": "Sets the id of a view before which this one is visited in accessibility traversal. A screen-reader must visit the content of this view before the content of the one it precedes. For example, if view B is set to be before view A, then a screen-reader will traverse the entire content of B before traversing the entire content of A, regardles of what traversal strategy it is using. Views that do not have specified before/after relationships are traversed in order determined by the screen-reader. Setting that this view is before a view that is not important for accessibility or if this view is not important for accessibility will have no effect as the screen-reader is not aware of unimportant views.", "history": "Added in API level 22", "FullName": "public void setAccessibilityTraversalBefore (int beforeId)"}, "onApplyWindowInsets(android.view.WindowInsets)": {"Returns": [["@B_android#view#WindowInsets_E@", "The supplied insets with any applied insets consumed"]], "Parameters": [["@B_android#view#WindowInsets_E@", "WindowInsets: Insets to apply"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the view should apply @B_android#view#WindowInsets_E@ according to its internal policy. This method should be overridden by views that wish to apply a policy different from or in addition to the default behavior. Clients that wish to force a view subtree to apply insets should call @B_android#view#View#dispatchApplyWindowInsets_E@. Clients may supply an @B_android#view#View#OnApplyWindowInsetsListener_E@ to a view. If one is set it will be called during dispatch instead of this method. The listener may optionally call this method from its own implementation if it wishes to apply the view's default insets policy in addition to its own. Implementations of this method should either return the insets parameter unchanged or a new @B_android#view#WindowInsets_E@ cloned from the supplied insets with any insets consumed that this view applied itself. This allows new inset types added in future platform versions to pass through existing implementations unchanged without being erroneously consumed. By default if a view's @B_android#view#View#setFitsSystemWindows_E@ property is set then the view will consume the system window insets and apply them as padding for the view.", "history": "Added in API level 20", "FullName": "public WindowInsets onApplyWindowInsets (WindowInsets insets)"}, "computeHorizontalScrollExtent()": {"Returns": [["int", "the horizontal extent of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#computeHorizontalScrollRange_E@", "@B_android#view#View#computeHorizontalScrollOffset_E@"], "Permissions": [], "Description": "Compute the horizontal extent of the horizontal scrollbar's thumb within the horizontal range. This value is used to compute the length of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#view#View#computeHorizontalScrollRange_E@ and @B_android#view#View#computeHorizontalScrollOffset_E@. The default extent is the drawing width of this view.", "history": "Added in API level 1", "FullName": "protected int computeHorizontalScrollExtent ()"}, "scheduleDrawable(android.graphics.drawable.Drawable,java.lang.Runnable,long)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: the recipient of the action This value must never be null."], ["@B_java#lang#Runnable_E@", "Runnable: the action to run on the drawable This value must never be null."], ["long", "long: the time at which the action must occur. Uses the @B_android#os#SystemClock#uptimeMillis_E@ timebase."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Schedules an action on a drawable to occur at a specified time.", "history": "Added in API level 1", "FullName": "public void scheduleDrawable (Drawable who, Runnable what, long when)"}, "setNextFocusRightId(int)": {"Returns": [], "Parameters": [["int", "int: The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the id of the view to use when the next focus is @B_android#view#View#FOCUS_RIGHT_E@.", "history": "Added in API level 1", "FullName": "public void setNextFocusRightId (int nextFocusRightId)"}, "dispatchNestedPreFling(float, float)": {"Returns": [["boolean", "true if a nested scrolling parent consumed the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent before it is processed by this view. Nested pre-fling events are to nested fling events what touch intercept is to touch and what nested pre-scroll is to nested scroll. dispatchNestedPreFling offsets an opportunity for the parent view in a nested fling to fully consume the fling before the child view consumes it. If this method returns true, a nested parent view consumed the fling and this view should not scroll as a result. For a better user experience, only one view in a nested scrolling chain should consume the fling at a time. If a parent view consumed the fling this method will return false. Custom view implementations should account for this in two ways: If a custom view is paged and needs to settle to a fixed page-point, do not call dispatchNestedPreFling; consume the fling and settle to a valid position regardless. If a nested parent does consume the fling, this view should not scroll at all, even to settle back to a valid idle position. Views should also not offer fling velocities to nested parent views along an axis where scrolling is not currently supported; a @B_android#widget#ScrollView_E@ should not offer a horizontal fling velocity to its parents since scrolling along that axis is not permitted and carrying velocity along that motion does not make sense.", "history": "added in API level 21", "FullName": "public boolean dispatchNestedPreFling (float velocityX, float velocityY)"}, "startActionMode(android.view.ActionMode.Callback)": {"Returns": [["@B_android#view#ActionMode_E@", "The new action mode if it is started, null otherwise"]], "Parameters": [["@B_android#view#ActionMode#Callback_E@", "ActionMode.Callback: Callback that will control the lifecycle of the action mode"]], "Throws": [], "SeeAlso": ["@B_android#view#ActionMode_E@", "@B_android#view#View#startActionMode_E@"], "Permissions": [], "Description": "Start an action mode with the default type @B_android#view#ActionMode#TYPE_PRIMARY_E@.", "history": "Added in API level 11", "FullName": "public ActionMode startActionMode (ActionMode.Callback callback)"}, "setLeftTopRightBottom(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setLeft_E@"], "Permissions": [], "Description": "Assign a size and position to this view. This method is meant to be used in animations only as it applies this position and size for the view only temporary and it can be changed back at any time by the layout.", "history": "Added in API level 29", "FullName": "public final void setLeftTopRightBottom (int left, int top, int right, int bottom)"}, "setScrollBarStyle(int)": {"Returns": [], "Parameters": [["int", "int: the style of the scrollbars. Should be one of SCROLLBARS_INSIDE_OVERLAY, SCROLLBARS_INSIDE_INSET, SCROLLBARS_OUTSIDE_OVERLAY or SCROLLBARS_OUTSIDE_INSET. Value is @B_android#view#View#SCROLLBARS_INSIDE_OVERLAY_E@, @B_android#view#View#SCROLLBARS_INSIDE_INSET_E@, @B_android#view#View#SCROLLBARS_OUTSIDE_OVERLAY_E@, or @B_android#view#View#SCROLLBARS_OUTSIDE_INSET_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Specify the style of the scrollbars. The scrollbars can be overlaid or inset. When inset, they add to the padding of the view. And the scrollbars can be drawn inside the padding area or on the edge of the view. For example, if a view has a background drawable and you want to draw the scrollbars inside the padding specified by the drawable, you can use SCROLLBARS_INSIDE_OVERLAY or SCROLLBARS_INSIDE_INSET. If you want them to appear at the edge of the view, ignoring the padding, then you can use SCROLLBARS_OUTSIDE_OVERLAY or SCROLLBARS_OUTSIDE_INSET.", "history": "Added in API level 1", "FullName": "public void setScrollBarStyle (int style)"}, "requestFocusFromTouch()": {"Returns": [["boolean", "Whether this view or one of its descendants actually took focus."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#isInTouchMode_E@"], "Permissions": [], "Description": "Call this to try to give focus to a specific view or to one of its descendants. This is a special variant of @B_android#view#View#requestFocus_E@ that will allow views that are not focusable in touch mode to request focus when they are touched.", "history": "Added in API level 1", "FullName": "public final boolean requestFocusFromTouch ()"}, "dispatchDrawableHotspotChanged(float, float)": {"Returns": [], "Parameters": [["float", "float: hotspot x coordinate"], ["float", "float: hotspot y coordinate"]], "Throws": [], "SeeAlso": ["@B_android#view#View#drawableHotspotChanged_E@"], "Permissions": [], "Description": "Dispatches drawableHotspotChanged to all of this View's children.", "history": "added in API level 22", "FullName": "public void dispatchDrawableHotspotChanged (float x, float y)"}, "setHasTransientState(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if this view has transient state"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set whether this view is currently tracking transient state that the framework should attempt to preserve when possible. This flag is reference counted, so every call to setHasTransientState(true) should be paired with a later call to setHasTransientState(false). A view with transient state cannot be trivially rebound from an external data source, such as an adapter binding item views in a list. This may be because the view is performing an animation, tracking user selection of content, or similar.", "history": "Added in API level 16", "FullName": "public void setHasTransientState (boolean hasTransientState)"}, "getBottom()": {"Returns": [["int", "The bottom of this view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Bottom position of this view relative to its parent.", "history": "Added in API level 1", "FullName": "public final int getBottom ()"}, "requestFocus(int)": {"Returns": [["boolean", "Whether this view or one of its descendants actually took focus."]], "Parameters": [["int", "int: One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this to try to give focus to a specific view or to one of its descendants and give it a hint about what direction focus is heading. A view will not actually take focus if it is not focusable (@B_android#view#View#isFocusable_E@ returns false), or if it is focusable and it is not focusable in touch mode (@B_android#view#View#isFocusableInTouchMode_E@) while the device is in touch mode. See also @B_android#view#View#focusSearch_E@, which is what you call to say that you have focus, and you want your parent to look for the next one. This is equivalent to calling @B_android#view#View#requestFocus_E@ with null set for the previously focused rectangle.", "history": "Added in API level 1", "FullName": "public final boolean requestFocus (int direction)"}, "isHorizontalScrollBarEnabled()": {"Returns": [["boolean", "true if the horizontal scrollbar should be painted, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setHorizontalScrollBarEnabled_E@"], "Permissions": [], "Description": "Indicate whether the horizontal scrollbar should be drawn or not. The scrollbar is not drawn by default.", "history": "Added in API level 1", "FullName": "public boolean isHorizontalScrollBarEnabled ()"}, "setBottom(int)": {"Returns": [], "Parameters": [["int", "int: The bottom of this view, in pixels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the bottom position of this view relative to its parent. This method is meant to be called by the layout system and should not generally be called otherwise, because the property may be changed at any time by the layout.", "history": "Added in API level 11", "FullName": "public final void setBottom (int bottom)"}, "setNextFocusDownId(int)": {"Returns": [], "Parameters": [["int", "int: The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the id of the view to use when the next focus is @B_android#view#View#FOCUS_DOWN_E@.", "history": "Added in API level 1", "FullName": "public void setNextFocusDownId (int nextFocusDownId)"}, "setSoundEffectsEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: whether sound effects are enabled for this view."]], "Throws": [], "SeeAlso": ["@B_android#view#View#isSoundEffectsEnabled_E@", "@B_android#view#View#playSoundEffect_E@"], "Permissions": [], "Description": "Set whether this view should have sound effects enabled for events such as clicking and touching. You may wish to disable sound effects for a view if you already play sounds, for instance, a dial key that plays dtmf tones.", "history": "Added in API level 1", "FullName": "public void setSoundEffectsEnabled (boolean soundEffectsEnabled)"}, "requestUnbufferedDispatch(android.view.MotionEvent)": {"Returns": [], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request unbuffered dispatch of the given stream of MotionEvents to this View. Until this View receives a corresponding @B_android#view#MotionEvent#ACTION_UP_E@, ask that the input system not batch @B_android#view#MotionEvent_E@s but instead deliver them as soon as they're available. This method should only be called for touch events. This api is not intended for most applications. Buffered dispatch provides many of benefits, and just requesting unbuffered dispatch on most MotionEvent streams will not improve your input latency. Side effects include: increased latency, jittery scrolls and inability to take advantage of system resampling. Talk to your input professional to see if @B_android#view#View#requestUnbufferedDispatch_E@ is right for you.", "history": "Added in API level 21", "FullName": "public final void requestUnbufferedDispatch (MotionEvent event)"}, "getClipBounds()": {"Returns": [["@B_android#graphics#Rect_E@", "A copy of the current clip bounds if clip bounds are set, otherwise null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a copy of the current @B_android#view#View#setClipBounds_E@.", "history": "Added in API level 18", "FullName": "public Rect getClipBounds ()"}, "getY()": {"Returns": [["float", "The visual y position of this view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The visual y position of this view, in pixels. This is equivalent to the @B_android#view#View#setTranslationY_E@ property plus the current @B_android#view#View#getTop_E@ property.", "history": "Added in API level 11", "FullName": "public float getY ()"}, "setMeasuredDimension(int, int)": {"Returns": [], "Parameters": [["int", "int: The measured width of this view. May be a complex bit mask as defined by @B_android#view#View#MEASURED_SIZE_MASK_E@ and @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@."], ["int", "int: The measured height of this view. May be a complex bit mask as defined by @B_android#view#View#MEASURED_SIZE_MASK_E@ and @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method must be called by @B_android#view#View#onMeasure_E@ to store the measured width and measured height. Failing to do so will trigger an exception at measurement time.", "history": "added in API level 1", "FullName": "protected final void setMeasuredDimension (int measuredWidth, int measuredHeight)"}, "setTouchDelegate(android.view.TouchDelegate)": {"Returns": [], "Parameters": [["@B_android#view#TouchDelegate_E@", "TouchDelegate no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the TouchDelegate for this View.", "history": "Added in API level 1", "FullName": "public void setTouchDelegate (TouchDelegate delegate)"}, "getLocalVisibleRect(android.graphics.Rect)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#graphics#Rect_E@", "Rect no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public final boolean getLocalVisibleRect (Rect r)"}, "onKeyDown(int,android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: a key code that represents the button pressed, from @B_android#view#KeyEvent_E@"], ["@B_android#view#KeyEvent_E@", "KeyEvent: the KeyEvent object that defines the button action"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyDown_E@: perform press of the view when @B_android#view#KeyEvent#KEYCODE_DPAD_CENTER_E@ or @B_android#view#KeyEvent#KEYCODE_ENTER_E@ is released, if the view is enabled and clickable. Key presses in software keyboards will generally NOT trigger this listener, although some may elect to do so in some situations. Do not rely on this to catch software key presses.", "history": "Added in API level 1", "FullName": "public boolean onKeyDown (int keyCode, KeyEvent event)"}, "setScrollContainer(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Change whether this view is one of the set of scrollable containers in its window. This will be used to determine whether the window can resize or must pan when a soft input area is open -- scrollable containers allow the window to use resize mode since the container will appropriately shrink.", "history": "Added in API level 3", "FullName": "public void setScrollContainer (boolean isScrollContainer)"}, "getDefaultFocusHighlightEnabled()": {"Returns": [["boolean", "True if this View should use a default focus highlight."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "/** Returns whether this View should use a default focus highlight when it gets focused but doesn't have @B_android#R#attr#state_focused_E@ defined in its background.", "history": "Added in API level 26", "FullName": "public final boolean getDefaultFocusHighlightEnabled ()"}, "setOnCreateContextMenuListener(android.view.View.OnCreateContextMenuListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnCreateContextMenuListener_E@", "View.OnCreateContextMenuListener: The callback that will run"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Register a callback to be invoked when the context menu for this view is being built. If this view is not long clickable, it becomes long clickable.", "history": "Added in API level 1", "FullName": "public void setOnCreateContextMenuListener (View.OnCreateContextMenuListener l)"}, "onFocusChanged(boolean,int,android.graphics.Rect)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the View has focus; false otherwise."], ["int", "int: The direction focus has moved when requestFocus() is called to give this view focus. Values are @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_DOWN_E@, @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_RIGHT_E@, @B_android#view#View#FOCUS_FORWARD_E@, or @B_android#view#View#FOCUS_BACKWARD_E@. It may not always apply, in which case use the default. Value is @B_android#view#View#FOCUS_BACKWARD_E@, @B_android#view#View#FOCUS_FORWARD_E@, @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_RIGHT_E@, or @B_android#view#View#FOCUS_DOWN_E@"], ["@B_android#graphics#Rect_E@", "Rect: The rectangle, in this view's coordinate system, of the previously focused view. If applicable, this will be passed in as finer grained information about where the focus is coming from (in addition to direction). Will be null otherwise. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the view system when the focus state of this view changes. When the focus change event is caused by directional navigation, direction and previouslyFocusedRect provide insight into where the focus is coming from. When overriding, be sure to call up through to the super class so that the standard focus handling will occur. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onFocusChanged (boolean gainFocus, int direction, Rect previouslyFocusedRect)"}, "View(android.content.Context,android.util.AttributeSet)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The Context the view is running in, through which it can access the current theme, resources, etc."], ["@B_android#util#AttributeSet_E@", "AttributeSet: The attributes of the XML tag that is inflating the view. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#View_E@"], "Permissions": [], "Description": "Constructor that is called when inflating a view from XML. This is called when a view is being constructed from an XML file, supplying attributes that were specified in the XML file. This version uses a default style of 0, so the only attribute values applied are those in the Context's Theme and the given AttributeSet. The method onFinishInflate() will be called after all children have been added.", "history": "Added in API level 1", "FullName": "public View (Context context, AttributeSet attrs)"}, "getClipToOutline()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setOutlineProvider_E@", "@B_android#view#View#setClipToOutline_E@"], "Permissions": [], "Description": "Returns whether the Outline should be used to clip the contents of the View. Note that this flag will only be respected if the View's Outline returns true from @B_android#graphics#Outline#canClip_E@.", "history": "Added in API level 21", "FullName": "public final boolean getClipToOutline ()"}, "forceLayout()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Forces this view to be laid out during the next layout pass. This method does not call requestLayout() or forceLayout() on the parent.", "history": "Added in API level 1", "FullName": "public void forceLayout ()"}, "addFocusables(java.util.ArrayList<android.view.View>,int,int)": {"Returns": [], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: Focusable views found so far or null if all we are interested is the number of focusables."], ["int", "int: The direction of the focus. Value is @B_android#view#View#FOCUS_BACKWARD_E@, @B_android#view#View#FOCUS_FORWARD_E@, @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_RIGHT_E@, or @B_android#view#View#FOCUS_DOWN_E@"], ["int", "int: The type of focusables to be added. Value is either 0 or a combination of @B_android#view#View#FOCUSABLES_ALL_E@, and @B_android#view#View#FOCUSABLES_TOUCH_MODE_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Adds any focusable views that are descendants of this view (possibly including this view if it is focusable itself) to views. This method adds all focusable views regardless if we are in touch mode or only views focusable in touch mode if we are in touch mode or only views that can take accessibility focus if accessibility is enabled depending on the focusable mode parameter.", "history": "Added in API level 4", "FullName": "public void addFocusables (ArrayList<View> views, int direction, int focusableMode)"}, "onAnimationEnd()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setAnimation_E@", "@B_android#view#View#getAnimation_E@"], "Permissions": [], "Description": "Invoked by a parent ViewGroup to notify the end of the animation currently associated with this view. If you override this method, always call super.onAnimationEnd(); If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onAnimationEnd ()"}, "getVerticalScrollbarWidth()": {"Returns": [["int", "The width in pixels of the vertical scrollbar or 0 if there is no vertical scrollbar."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the width of the vertical scrollbar.", "history": "Added in API level 1", "FullName": "public int getVerticalScrollbarWidth ()"}, "overScrollBy(int,int,int,int,int,int,int,int,boolean)": {"Returns": [["boolean", "true if scrolling was clamped to an over-scroll boundary along either axis, false otherwise."]], "Parameters": [["int", "int: Change in X in pixels"], ["int", "int: Change in Y in pixels"], ["int", "int: Current X scroll value in pixels before applying deltaX"], ["int", "int: Current Y scroll value in pixels before applying deltaY"], ["int", "int: Maximum content scroll range along the X axis"], ["int", "int: Maximum content scroll range along the Y axis"], ["int", "int: Number of pixels to overscroll by in either direction along the X axis."], ["int", "int: Number of pixels to overscroll by in either direction along the Y axis."], ["boolean", "boolean: true if this scroll operation is the result of a touch event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Scroll the view with standard behavior for scrolling beyond the normal content boundaries. Views that call this method should override @B_android#view#View#onOverScrolled_E@ to respond to the results of an over-scroll operation. Views can use this method to handle any touch or fling-based scrolling.", "history": "Added in API level 9", "FullName": "protected boolean overScrollBy (int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent)"}, "getAnimation()": {"Returns": [["@B_android#view#animation#Animation_E@", "The animation that is currently playing or scheduled to play for this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the animation currently associated with this view.", "history": "Added in API level 1", "FullName": "public Animation getAnimation ()"}, "setSelected(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the view must be selected, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Changes the selection state of this view. A view can be selected or not. Note that selection is not the same as focus. Views are typically selected in the context of an AdapterView like ListView or GridView; the selected view is the view that is highlighted.", "history": "Added in API level 1", "FullName": "public void setSelected (boolean selected)"}, "getForegroundTintList()": {"Returns": [["@B_android#content#res#ColorStateList_E@", "the tint applied to the foreground drawable This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setForegroundTintList_E@"], "Permissions": [], "Description": "Return the tint applied to the foreground drawable, if specified.", "history": "Added in API level 23", "FullName": "public ColorStateList getForegroundTintList ()"}, "getHorizontalScrollbarTrackDrawable()": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@", "@B_android#view#View#isHorizontalScrollBarEnabled_E@", "@B_android#view#View#setHorizontalScrollBarEnabled_E@"], "Permissions": [], "Description": "Returns the currently configured Drawable for the track of the horizontal scroll bar if it exists, null otherwise.", "history": "Added in API level 29", "FullName": "public Drawable getHorizontalScrollbarTrackDrawable ()"}, "dispatchNestedScroll(int, int, int, int, int[])": {"Returns": [["boolean", "true if the event was dispatched, false if it could not be dispatched."]], "Parameters": [["int", "int: Horizontal distance in pixels consumed by this view during this scroll step"], ["int", "int: Vertical distance in pixels consumed by this view during this scroll step"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking."]], "Throws": [], "SeeAlso": ["@B_android#view#View#dispatchNestedPreScroll_E@"], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress. Implementations of views that support nested scrolling should call this to report info about a scroll in progress to the current nested scrolling parent. If a nested scroll is not currently in progress or nested scrolling is not @B_android#view#View#isNestedScrollingEnabled_E@ for this view this method does nothing. Compatible View implementations should also call @B_android#view#View#dispatchNestedPreScroll_E@ before consuming a component of the scroll event themselves.", "history": "added in API level 21", "FullName": "public boolean dispatchNestedScroll (int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)"}, "playSoundEffect(int)": {"Returns": [], "Parameters": [["int", "int: One of the constants defined in @B_android#view#SoundEffectConstants_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Play a sound effect for this view. The framework will play sound effects for some built in actions, such as clicking, but you may wish to play these effects in your widget, for instance, for internal navigation. The sound effect will only be played if sound effects are enabled by the user, and @B_android#view#View#isSoundEffectsEnabled_E@ is true.", "history": "Added in API level 1", "FullName": "public void playSoundEffect (int soundConstant)"}, "setFitsSystemWindows(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: If true, then the default implementation of @B_android#view#View#fitSystemWindows_E@ will be executed."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getFitsSystemWindows_E@", "@B_android#view#View#fitSystemWindows_E@", "@B_android#view#View#setSystemUiVisibility_E@"], "Permissions": [], "Description": "Sets whether or not this view should account for system screen decorations such as the status bar and inset its content; that is, controlling whether the default implementation of @B_android#view#View#fitSystemWindows_E@ will be executed. See that method for more details. Note that if you are providing your own implementation of @B_android#view#View#fitSystemWindows_E@, then there is no need to set this flag to true -- your implementation will be overriding the default implementation that checks this flag.", "history": "Added in API level 14", "FullName": "public void setFitsSystemWindows (boolean fitSystemWindows)"}, "dispatchKeyEvent(android.view.KeyEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a key event to the next view on the focus path. This path runs from the top of the view tree down to the currently focused view. If this view has focus, it will dispatch to itself. Otherwise it will dispatch the next node down the focus path. This method also fires any key listeners.", "history": "Added in API level 1", "FullName": "public boolean dispatchKeyEvent (KeyEvent event)"}, "getHorizontalScrollbarHeight()": {"Returns": [["int", "The height in pixels of the horizontal scrollbar or 0 if there is no horizontal scrollbar."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the height of the horizontal scrollbar.", "history": "Added in API level 1", "FullName": "protected int getHorizontalScrollbarHeight ()"}, "getTop()": {"Returns": [["int", "The top of this view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Top position of this view relative to its parent.", "history": "Added in API level 1", "FullName": "public final int getTop ()"}, "onPointerCaptureChange(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the view now has pointerCapture, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the window has just acquired or lost pointer capture. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 26", "FullName": "public void onPointerCaptureChange (boolean hasCapture)"}, "isForceDarkAllowed()": {"Returns": [["boolean", "true if force dark is allowed (default), false if it is disabled"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "See @B_android#view#View#setForceDarkAllowed_E@", "history": "Added in API level 29", "FullName": "public boolean isForceDarkAllowed ()"}, "dispatchUnhandledMove(android.view.View, int)": {"Returns": [["boolean", "True if the this view consumed this unhandled move."]], "Parameters": [["@B_android#view#View_E@", "View: The currently focused view."], ["int", "int: The direction focus wants to move. One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT.Value is FOCUS_LEFT, FOCUS_UP, FOCUS_RIGHT or FOCUS_DOWN."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is the last chance for the focused view and its ancestors to respond to an arrow key. This is called when the focused view did not consume the key internally, nor could the view system find a new view in the requested direction to give focus to.", "history": "added in API level 1", "FullName": "public boolean dispatchUnhandledMove (View focused, int direction)"}, "cancelPendingInputEvents()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Cancel any deferred high-level input events that were previously posted to the event queue. Many views post high-level events such as click handlers to the event queue to run deferred in order to preserve a desired user experience - clearing visible pressed states before executing, etc. This method will abort any events of this nature that are currently in flight. Custom views that generate their own high-level deferred input events should override @B_android#view#View#onCancelPendingInputEvents_E@ and remove those pending events from the queue. This will also cancel pending input events for any child views. Note that this may not be sufficient as a debouncing strategy for clicks in all cases. This will not impact newer events posted after this call that may occur as a result of lower-level input events still waiting in the queue. If you are trying to prevent double-submitted events for the duration of some sort of asynchronous transaction you should also take other steps to protect against unexpected double inputs e.g. calling @B_android#view#View#setEnabled_E@ and re-enabling the view when the transaction completes, tracking already submitted transaction IDs, etc.", "history": "Added in API level 19", "FullName": "public final void cancelPendingInputEvents ()"}, "onOverScrolled(int, int, boolean, boolean)": {"Returns": [], "Parameters": [["int", "int: New X scroll value in pixels"], ["int", "int: New Y scroll value in pixels"], ["boolean", "boolean: True if scrollX was clamped to an over-scroll boundary"], ["boolean", "boolean: True if scrollY was clamped to an over-scroll boundary"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by @B_android#view#View#overScrollBy_E@ to respond to the results of an over-scroll operation.", "history": "added in API level 9", "FullName": "protected void onOverScrolled (int scrollX, int scrollY, boolean clampedX, boolean clampedY)"}, "View(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context: The Context the view is running in, through which it can access the current theme, resources, etc."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Simple constructor to use when creating a view from code.", "history": "Added in API level 1", "FullName": "public View (Context context)"}, "mergeDrawableStates(int[], int[])": {"Returns": [["int[]", "As a convenience, the baseState array you originally passed into the function is returned."]], "Parameters": [["int[]", "int: The base state values returned by @B_android#view#View#onCreateDrawableState_E@, which will be modified to also hold your own additional state values."], ["int[]", "int: The additional state values you would like added to baseState; this array is not modified."]], "Throws": [], "SeeAlso": ["@B_android#view#View#onCreateDrawableState_E@"], "Permissions": [], "Description": "Merge your own state values in @B_android#view#View#onCreateDrawableState_E@.", "history": "added in API level 1", "FullName": "protected static int[] mergeDrawableStates (int[] baseState, int[] additionalState)"}, "setDrawingCacheQuality(int)": {"Returns": [], "Parameters": [["int", "int: One of @B_android#view#View#DRAWING_CACHE_QUALITY_AUTO_E@, @B_android#view#View#DRAWING_CACHE_QUALITY_LOW_E@, or @B_android#view#View#DRAWING_CACHE_QUALITY_HIGH_E@ Value is @B_android#view#View#DRAWING_CACHE_QUALITY_LOW_E@, @B_android#view#View#DRAWING_CACHE_QUALITY_HIGH_E@, or @B_android#view#View#DRAWING_CACHE_QUALITY_AUTO_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View#getDrawingCacheQuality_E@", "@B_android#view#View#setDrawingCacheEnabled_E@", "@B_android#view#View#isDrawingCacheEnabled_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Set the drawing cache quality of this view. This value is used only when the drawing cache is enabled", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public void setDrawingCacheQuality (int quality)"}, "getTextDirection()": {"Returns": [["int", "the resolved text direction. Returns one of: @B_android#view#View#TEXT_DIRECTION_FIRST_STRONG_E@, @B_android#view#View#TEXT_DIRECTION_ANY_RTL_E@, @B_android#view#View#TEXT_DIRECTION_LTR_E@, @B_android#view#View#TEXT_DIRECTION_RTL_E@, @B_android#view#View#TEXT_DIRECTION_LOCALE_E@, @B_android#view#View#TEXT_DIRECTION_FIRST_STRONG_LTR_E@, @B_android#view#View#TEXT_DIRECTION_FIRST_STRONG_RTL_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the resolved text direction.", "history": "Added in API level 17", "FullName": "public int getTextDirection ()"}, "setOnContextClickListener(android.view.View.OnContextClickListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnContextClickListener_E@", "View.OnContextClickListener: The callback that will run This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setContextClickable_E@"], "Permissions": [], "Description": "Register a callback to be invoked when this view is context clicked. If the view is not context clickable, it becomes context clickable.", "history": "Added in API level 23", "FullName": "public void setOnContextClickListener (View.OnContextClickListener l)"}, "getNextFocusForwardId()": {"Returns": [["int", "The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the id of the view to use when the next focus is @B_android#view#View#FOCUS_FORWARD_E@.", "history": "Added in API level 11", "FullName": "public int getNextFocusForwardId ()"}, "getHitRect(android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: The hit rectangle of the view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hit rectangle in parent's coordinates", "history": "Added in API level 1", "FullName": "public void getHitRect (Rect outRect)"}, "getResources()": {"Returns": [["@B_android#content#res#Resources_E@", "Resources object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the resources associated with this view.", "history": "Added in API level 1", "FullName": "public Resources getResources ()"}, "verifyDrawable(android.graphics.drawable.Drawable)": {"Returns": [["boolean", "boolean If true than the Drawable is being displayed in the view; else false and it is not allowed to animate."]], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: The Drawable to verify. Return true if it is one you are displaying, else return the result of calling through to the super class. This value must never be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#unscheduleDrawable_E@", "@B_android#view#View#drawableStateChanged_E@"], "Permissions": [], "Description": "If your view subclass is displaying its own Drawable objects, it should override this function and return true for any Drawable it is displaying. This allows animations for those drawables to be scheduled. Be sure to call through to the super class when overriding this function. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected boolean verifyDrawable (Drawable who)"}, "isHapticFeedbackEnabled()": {"Returns": [["boolean", "whether this view should have haptic feedback enabled for events long presses."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setHapticFeedbackEnabled_E@", "@B_android#view#View#performHapticFeedback_E@"], "Permissions": [], "Description": "", "history": "Added in API level 3", "FullName": "public boolean isHapticFeedbackEnabled ()"}, "requestRectangleOnScreen(android.graphics.Rect,boolean)": {"Returns": [["boolean", "Whether any parent scrolled."]], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: The rectangle in the View's content coordinate space"], ["boolean", "boolean: True to forbid animated scrolling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Request that a rectangle of this view be visible on the screen, scrolling if necessary just enough. A View should call this if it maintains some notion of which part of its content is interesting. For example, a text editing view should call this when its cursor moves. The Rectangle passed into this method should be in the View's content coordinate space. It should not be affected by which part of the View is currently visible or its scroll position. When immediate is set to true, scrolling will not be animated.", "history": "Added in API level 1", "FullName": "public boolean requestRectangleOnScreen (Rect rectangle, boolean immediate)"}, "setOnCapturedPointerListener(android.view.View.OnCapturedPointerListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnCapturedPointerListener_E@", "View.OnCapturedPointerListener: The @B_android#view#View#OnCapturedPointerListener_E@ to receive callbacks."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set a listener to receive callbacks when the pointer capture state of a view changes.", "history": "Added in API level 26", "FullName": "public void setOnCapturedPointerListener (View.OnCapturedPointerListener l)"}, "setAccessibilityDelegate(android.view.View.AccessibilityDelegate)": {"Returns": [], "Parameters": [["@B_android#view#View#AccessibilityDelegate_E@", "View.AccessibilityDelegate: the object to which accessibility method calls should be delegated This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#AccessibilityDelegate_E@"], "Permissions": [], "Description": "Sets a delegate for implementing accessibility support via composition (as opposed to inheritance). For more details, see @B_android#view#View#AccessibilityDelegate_E@. @B_android#os#Build#VERSION_CODES#M_E@, delegate methods on views in the android.widget.* package are called @B_android#view#View#AccessibilityDelegate#onInitializeAccessibilityNodeInfo_E@, as any changes will be overwritten by the host class. Starting in @B_android#os#Build#VERSION_CODES#M_E@, delegate methods are called", "history": "Added in API level 14", "FullName": "public void setAccessibilityDelegate (View.AccessibilityDelegate delegate)"}, "setHorizontalScrollbarTrackDrawable(android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@", "@B_android#view#View#isHorizontalScrollBarEnabled_E@", "@B_android#view#View#setHorizontalScrollBarEnabled_E@"], "Permissions": [], "Description": "Defines the horizontal track drawable", "history": "Added in API level 29", "FullName": "public void setHorizontalScrollbarTrackDrawable (Drawable drawable)"}, "getKeepScreenOn()": {"Returns": [["boolean", "Returns true if @B_android#view#View#KEEP_SCREEN_ON_E@ is set."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setKeepScreenOn_E@"], "Permissions": [], "Description": "Returns whether the screen should remain on, corresponding to the current value of @B_android#view#View#KEEP_SCREEN_ON_E@.", "history": "Added in API level 1", "FullName": "public boolean getKeepScreenOn ()"}, "addOnAttachStateChangeListener(android.view.View.OnAttachStateChangeListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnAttachStateChangeListener_E@", "View.OnAttachStateChangeListener: Listener to attach"]], "Throws": [], "SeeAlso": ["@B_android#view#View#removeOnAttachStateChangeListener_E@"], "Permissions": [], "Description": "Add a listener for attach state changes. This listener will be called whenever this view is attached or detached from a window. Remove the listener using @B_android#view#View#removeOnAttachStateChangeListener_E@.", "history": "Added in API level 12", "FullName": "public void addOnAttachStateChangeListener (View.OnAttachStateChangeListener listener)"}, "getDrawingRect(android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: The (scrolled) drawing bounds of the view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the visible drawing bounds of your view. Fills in the output rectangle with the values from getScrollX(), getScrollY(), getWidth(), and getHeight(). These bounds do not account for any transformation properties currently set on the view, such as @B_android#view#View#setScaleX_E@ or @B_android#view#View#setRotation_E@.", "history": "Added in API level 1", "FullName": "public void getDrawingRect (Rect outRect)"}, "dispatchNestedPreFling(float,float)": {"Returns": [["boolean", "true if a nested scrolling parent consumed the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent before it is processed by this view. Nested pre-fling events are to nested fling events what touch intercept is to touch and what nested pre-scroll is to nested scroll. dispatchNestedPreFling offsets an opportunity for the parent view in a nested fling to fully consume the fling before the child view consumes it. If this method returns true, a nested parent view consumed the fling and this view should not scroll as a result. For a better user experience, only one view in a nested scrolling chain should consume the fling at a time. If a parent view consumed the fling this method will return false. Custom view implementations should account for this in two ways: If a custom view is paged and needs to settle to a fixed page-point, do not call dispatchNestedPreFling; consume the fling and settle to a valid position regardless. If a nested parent does consume the fling, this view should not scroll at all, even to settle back to a valid idle position. Views should also not offer fling velocities to nested parent views along an axis where scrolling is not currently supported; a @B_android#widget#ScrollView_E@ should not offer a horizontal fling velocity to its parents since scrolling along that axis is not permitted and carrying velocity along that motion does not make sense.", "history": "Added in API level 21", "FullName": "public boolean dispatchNestedPreFling (float velocityX, float velocityY)"}, "postInvalidate(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: The left coordinate of the rectangle to invalidate."], ["int", "int: The top coordinate of the rectangle to invalidate."], ["int", "int: The right coordinate of the rectangle to invalidate."], ["int", "int: The bottom coordinate of the rectangle to invalidate."]], "Throws": [], "SeeAlso": ["@B_android#view#View#invalidate_E@", "@B_android#view#View#postInvalidateDelayed_E@"], "Permissions": [], "Description": "Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop. Use this to invalidate the View from a non-UI thread. This method can be invoked from outside of the UI thread only when this View is attached to a window.", "history": "Added in API level 1", "FullName": "public void postInvalidate (int left, int top, int right, int bottom)"}, "onFinishInflate()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Finalize inflating a view from XML. This is called as the last phase of inflation, after all child views have been added. Even if the subclass overrides onFinishInflate, they should always be sure to call the super method, so that we get called. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onFinishInflate ()"}, "unscheduleDrawable(android.graphics.drawable.Drawable)": {"Returns": [], "Parameters": [["@B_android#graphics#drawable#Drawable_E@", "Drawable: The Drawable to unschedule."]], "Throws": [], "SeeAlso": ["@B_android#view#View#drawableStateChanged_E@"], "Permissions": [], "Description": "Unschedule any events associated with the given Drawable. This can be used when selecting a new Drawable into a view, so that the previous one is completely unscheduled.", "history": "Added in API level 1", "FullName": "public void unscheduleDrawable (Drawable who)"}, "dispatchNestedPreScroll(int, int, int[], int[])": {"Returns": [["boolean", "true if the parent consumed some or all of the scroll delta"]], "Parameters": [["int", "int: Horizontal scroll distance in pixels"], ["int", "int: Vertical scroll distance in pixels"], ["int[]", "int: Output. If not null, consumed[0] will contain the consumed component of dx and consumed[1] the consumed dy."], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking."]], "Throws": [], "SeeAlso": ["@B_android#view#View#dispatchNestedScroll_E@"], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress before this view consumes any portion of it. Nested pre-scroll events are to nested scroll events what touch intercept is to touch. dispatchNestedPreScroll offers an opportunity for the parent view in a nested scrolling operation to consume some or all of the scroll operation before the child view consumes it.", "history": "added in API level 21", "FullName": "public boolean dispatchNestedPreScroll (int dx, int dy, int[] consumed, int[] offsetInWindow)"}, "setFilterTouchesWhenObscured(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if touch filtering should be enabled."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getFilterTouchesWhenObscured_E@"], "Permissions": [], "Description": "Sets whether the framework should discard touches when the view's window is obscured by another visible window. Refer to the @B_android#view#View_E@ security documentation for more details.", "history": "Added in API level 9", "FullName": "public void setFilterTouchesWhenObscured (boolean enabled)"}, "awakenScrollBars(int, boolean)": {"Returns": [["boolean", "true if the animation is played, false otherwise"]], "Parameters": [["int", "int: the delay, in milliseconds, after which the animation should start; when the delay is 0, the animation starts immediately"], ["boolean", "boolean: Whether this method should call invalidate"]], "Throws": [], "SeeAlso": ["@B_android#view#View#scrollBy_E@", "@B_android#view#View#scrollTo_E@", "@B_android#view#View#isHorizontalScrollBarEnabled_E@", "@B_android#view#View#isVerticalScrollBarEnabled_E@", "@B_android#view#View#setHorizontalScrollBarEnabled_E@", "@B_android#view#View#setVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Trigger the scrollbars to draw. When invoked this method starts an animation to fade the scrollbars out after a fixed delay. If a subclass provides animated scrolling, the start delay should equal the duration of the scrolling animation. The animation starts only if at least one of the scrollbars is enabled, as specified by @B_android#view#View#isHorizontalScrollBarEnabled_E@ and @B_android#view#View#isVerticalScrollBarEnabled_E@. When the animation is started, this method returns true, and false otherwise. If the animation is started, this method calls @B_android#view#View#invalidate_E@ if the invalidate parameter is set to true; in that case the caller should not call @B_android#view#View#invalidate_E@. This method should be invoked every time a subclass directly updates the scroll parameters.", "history": "added in API level 5", "FullName": "protected boolean awakenScrollBars (int startDelay, boolean invalidate)"}, "getSuggestedMinimumWidth()": {"Returns": [["int", "The suggested minimum width of the view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the suggested minimum width that the view should use. This returns the maximum of the view's minimum width and the background's minimum width (@B_android#graphics#drawable#Drawable#getMinimumWidth_E@). When being used in @B_android#view#View#onMeasure_E@, the caller should still ensure the returned width is within the requirements of the parent.", "history": "Added in API level 1", "FullName": "protected int getSuggestedMinimumWidth ()"}, "findViewsWithText(java.util.ArrayList<android.view.View>,java.lang.CharSequence,int)": {"Returns": [], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: The output list of matching Views."], ["@B_java#lang#CharSequence_E@", "CharSequence: The text to match against."], ["int", "int: Value is either 0 or a combination of @B_android#view#View#FIND_VIEWS_WITH_TEXT_E@, and @B_android#view#View#FIND_VIEWS_WITH_CONTENT_DESCRIPTION_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View_E@", "@B_android#view#View#setContentDescription_E@"], "Permissions": [], "Description": "Finds the Views that contain given text. The containment is case insensitive. The search is performed by either the text that the View renders or the content description that describes the view for accessibility purposes and the view does not render or both. Clients can specify how the search is to be performed via passing the @B_android#view#View#FIND_VIEWS_WITH_TEXT_E@ and @B_android#view#View#FIND_VIEWS_WITH_CONTENT_DESCRIPTION_E@ flags.", "history": "Added in API level 14", "FullName": "public void findViewsWithText (ArrayList<View> outViews, CharSequence searched, int flags)"}, "hasPointerCapture()": {"Returns": [["boolean", "true if the view has pointer capture."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#requestPointerCapture_E@", "@B_android#view#View#hasPointerCapture_E@"], "Permissions": [], "Description": "Checks pointer capture status.", "history": "Added in API level 26", "FullName": "public boolean hasPointerCapture ()"}, "resolveSizeAndState(int,int,int)": {"Returns": [["int", "Size information bit mask as defined by @B_android#view#View#MEASURED_SIZE_MASK_E@ and @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@."]], "Parameters": [["int", "int: How big the view wants to be."], ["int", "int: Constraints imposed by the parent."], ["int", "int: Size information bit mask for the view's children."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Utility to reconcile a desired size and state, with constraints imposed by a MeasureSpec. Will take the desired size, unless a different size is imposed by the constraints. The returned value is a compound integer, with the resolved size in the @B_android#view#View#MEASURED_SIZE_MASK_E@ bits and optionally the bit @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@ set if the resulting size is smaller than the size the view wants to be.", "history": "Added in API level 11", "FullName": "public static int resolveSizeAndState (int size, int measureSpec, int childMeasuredState)"}, "dispatchPopulateAccessibilityEvent(android.view.accessibility.AccessibilityEvent)": {"Returns": [["boolean", "True if the event population was completed."]], "Parameters": [["@B_android#view#accessibility#AccessibilityEvent_E@", "AccessibilityEvent: The event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatches an @B_android#view#accessibility#AccessibilityEvent_E@ to the @B_android#view#View_E@ first and then to its children for adding their text content to the event. Note that the event text is populated in a separate dispatch path since we add to the event not only the text of the source but also the text of all its descendants. A typical implementation will call @B_android#view#View#onPopulateAccessibilityEvent_E@ on the this view and then call the @B_android#view#View#dispatchPopulateAccessibilityEvent_E@ on each child. Override this method if custom population of the event text content is required. If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#dispatchPopulateAccessibilityEvent_E@ is responsible for handling this call. Note: Accessibility events of certain types are not dispatched for populating the event text via this method. For details refer to @B_android#view#accessibility#AccessibilityEvent_E@.", "history": "Added in API level 4", "FullName": "public boolean dispatchPopulateAccessibilityEvent (AccessibilityEvent event)"}, "dispatchVisibilityChanged(android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view whose visibility changed. Could be 'this' or an ancestor view. This value must never be null."], ["int", "int: The new visibility of changedView: @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@ or @B_android#view#View#GONE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a view visibility change down the view hierarchy. ViewGroups should override to route to their children.", "history": "Added in API level 8", "FullName": "protected void dispatchVisibilityChanged (View changedView, int visibility)"}, "getWindowToken()": {"Returns": [["@B_android#os#IBinder_E@", "Return the window's token for use in @B_android#view#WindowManager#LayoutParams#token_E@."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Retrieve a unique token identifying the window this view is attached to.", "history": "Added in API level 1", "FullName": "public IBinder getWindowToken ()"}, "getAnimationMatrix()": {"Returns": [["@B_android#graphics#Matrix_E@", "the Matrix, null indicates there is no transformation"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setAnimationMatrix_E@"], "Permissions": [], "Description": "Return the current transformation matrix of the view. This is used in animation frameworks, such as @B_android#transition#Transition_E@. Returns null when there is no transformation provided by @B_android#view#View#setAnimationMatrix_E@. Application developers should use transformation methods like @B_android#view#View#setRotation_E@, @B_android#view#View#setScaleX_E@, @B_android#view#View#setScaleX_E@, @B_android#view#View#setTranslationX_E@} and @B_android#view#View#setTranslationY_E@ (float)}} instead.", "history": "Added in API level 29", "FullName": "public Matrix getAnimationMatrix ()"}, "dispatchSetActivated(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: The new activated state"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setActivated_E@"], "Permissions": [], "Description": "Dispatch setActivated to all of this View's children.", "history": "Added in API level 11", "FullName": "protected void dispatchSetActivated (boolean activated)"}, "combineMeasuredStates(int,int)": {"Returns": [["int", "Returns a new integer reflecting the combination of the two states."]], "Parameters": [["int", "int: The current state as returned from a view or the result of combining multiple views."], ["int", "int: The new view state to combine."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Merge two states as returned by @B_android#view#View#getMeasuredState_E@.", "history": "Added in API level 11", "FullName": "public static int combineMeasuredStates (int curState, int newState)"}, "computeScroll()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary. This will typically be done if the child is animating a scroll using a @B_android#widget#Scroller_E@ object.", "history": "Added in API level 1", "FullName": "public void computeScroll ()"}, "onDrawScrollBars(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: the canvas on which to draw the scrollbars"]], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@"], "Permissions": [], "Description": "Request the drawing of the horizontal and the vertical scrollbar. The scrollbars are painted only if they have been awakened first.", "history": "Added in API level 7", "FullName": "protected final void onDrawScrollBars (Canvas canvas)"}, "setOnScrollChangeListener(android.view.View.OnScrollChangeListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnScrollChangeListener_E@", "View.OnScrollChangeListener: The listener to notify when the scroll X or Y position changes."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getScrollX_E@", "@B_android#view#View#getScrollY_E@"], "Permissions": [], "Description": "Register a callback to be invoked when the scroll X or Y positions of this view change. @B_android#widget#ListView_E@ allows clients to register an @B_android#widget#AbsListView#setOnScrollListener_E@ to listen for changes in list scroll position.", "history": "Added in API level 23", "FullName": "public void setOnScrollChangeListener (View.OnScrollChangeListener l)"}, "onCancelPendingInputEvents()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called as the result of a call to @B_android#view#View#cancelPendingInputEvents_E@ on this view or a parent view. This method is responsible for removing any pending high-level input events that were posted to the event queue to run later. Custom view classes that post their own deferred high-level events via @B_android#view#View#post_E@, @B_android#view#View#postDelayed_E@ or @B_android#os#Handler_E@ should override this method, call super.onCancelPendingInputEvents() and remove those callbacks as appropriate.", "history": "Added in API level 19", "FullName": "public void onCancelPendingInputEvents ()"}, "isActivated()": {"Returns": [["boolean", "true if the view is activated, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates the activation state of this view.", "history": "Added in API level 11", "FullName": "public boolean isActivated ()"}, "removeCallbacks(java.lang.Runnable)": {"Returns": [["boolean", "true if this view could ask the Handler to remove the Runnable, false otherwise. When the returned value is true, the Runnable may or may not have been actually removed from the message queue (for instance, if the Runnable was not in the queue already.)"]], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: The Runnable to remove from the message handling queue"]], "Throws": [], "SeeAlso": ["@B_android#view#View#post_E@", "@B_android#view#View#postDelayed_E@", "@B_android#view#View#postOnAnimation_E@", "@B_android#view#View#postOnAnimationDelayed_E@"], "Permissions": [], "Description": "Removes the specified Runnable from the message queue.", "history": "Added in API level 1", "FullName": "public boolean removeCallbacks (Runnable action)"}, "requireViewById(int)": {"Returns": [["T", "a view with given ID This value will never be null."]], "Parameters": [["int", "int: the ID to search for"]], "Throws": [], "SeeAlso": ["@B_android#view#View#findViewById_E@"], "Permissions": [], "Description": "Finds the first descendant view with the given ID, the view itself if the ID matches @B_android#view#View#getId_E@, or throws an IllegalArgumentException if the ID is invalid or there is no matching view in the hierarchy.", "history": "Added in API level 28", "FullName": "public final T requireViewById (int id)"}, "setBackgroundTintMode(android.graphics.PorterDuff.Mode)": {"Returns": [], "Parameters": [["@B_android#graphics#PorterDuff#Mode_E@", "PorterDuff.Mode: the blending mode used to apply the tint, may be null to clear tint This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getBackgroundTintMode_E@", "@B_android#graphics#drawable#Drawable#setTintMode_E@"], "Permissions": [], "Description": "Specifies the blending mode used to apply the tint specified by @B_android#view#View#setBackgroundTintList_E@} to the background drawable. The default mode is @B_android#graphics#PorterDuff#Mode#SRC_IN_E@.", "history": "Added in API level 21", "FullName": "public void setBackgroundTintMode (PorterDuff.Mode tintMode)"}, "onProvideVirtualStructure(android.view.ViewStructure)": {"Returns": [], "Parameters": [["@B_android#view#ViewStructure_E@", "ViewStructure no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when assist structure is being retrieved from a view as part of @B_android#app#Activity#onProvideAssistData_E@ to generate additional virtual structure under this view. The defaullt implementation uses @B_android#view#View#getAccessibilityNodeProvider_E@ to try to generate this from the view's virtual accessibility nodes, if any. You can override this for a more optimal implementation providing this data.", "history": "Added in API level 23", "FullName": "public void onProvideVirtualStructure (ViewStructure structure)"}, "setNestedScrollingEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to enable nested scrolling, false to disable"]], "Throws": [], "SeeAlso": ["@B_android#view#View#isNestedScrollingEnabled_E@"], "Permissions": [], "Description": "Enable or disable nested scrolling for this view. If this property is set to true the view will be permitted to initiate nested scrolling operations with a compatible parent view in the current hierarchy. If this view does not implement nested scrolling this will have no effect. Disabling nested scrolling while a nested scroll is in progress has the effect of @B_android#view#View#stopNestedScroll_E@ the nested scroll.", "history": "Added in API level 21", "FullName": "public void setNestedScrollingEnabled (boolean enabled)"}, "setSaveFromParentEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Set to false to disable state saving, or true (the default) to allow it."]], "Throws": [], "SeeAlso": ["@B_android#view#View#isSaveFromParentEnabled_E@", "@B_android#view#View#setId_E@", "@B_android#view#View#onSaveInstanceState_E@"], "Permissions": [], "Description": "Controls whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent. The default is true; if false, these views will not be saved unless @B_android#view#View#saveHierarchyState_E@ is called directly on this view.", "history": "Added in API level 11", "FullName": "public void setSaveFromParentEnabled (boolean enabled)"}, "setScrollBarDefaultDelayBeforeFade(int)": {"Returns": [], "Parameters": [["int", "int: - the delay before scrollbars fade"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Define the delay before scrollbars fade.", "history": "Added in API level 16", "FullName": "public void setScrollBarDefaultDelayBeforeFade (int scrollBarDefaultDelayBeforeFade)"}, "setOnClickListener(android.view.View.OnClickListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnClickListener_E@", "View.OnClickListener: The callback that will run This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setClickable_E@"], "Permissions": [], "Description": "Register a callback to be invoked when this view is clicked. If this view is not clickable, it becomes clickable.", "history": "Added in API level 1", "FullName": "public void setOnClickListener (View.OnClickListener l)"}, "setTranslationZ(float)": {"Returns": [], "Parameters": [["float", "float no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the depth location of this view relative to its @B_android#view#View#getElevation_E@.", "history": "Added in API level 21", "FullName": "public void setTranslationZ (float translationZ)"}, "getDrawingCacheBackgroundColor()": {"Returns": [["int", "The background color to used for the drawing cache's bitmap"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setDrawingCacheBackgroundColor_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public int getDrawingCacheBackgroundColor ()"}, "announceForAccessibility(java.lang.CharSequence)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: The announcement text."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Convenience method for sending a @B_android#view#accessibility#AccessibilityEvent#TYPE_ANNOUNCEMENT_E@ @B_android#view#accessibility#AccessibilityEvent_E@ to suggest that an accessibility service announce the specified text to its users. Note: The event generated with this API carries no semantic meaning, and is appropriate only in exceptional situations. Apps can generally achieve correct behavior for accessibility by accurately supplying the semantics of their UI. They should not need to specify what exactly is announced to users.", "history": "Added in API level 16", "FullName": "public void announceForAccessibility (CharSequence text)"}, "getRight()": {"Returns": [["int", "The right edge of this view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Right position of this view relative to its parent.", "history": "Added in API level 1", "FullName": "public final int getRight ()"}, "setForceDarkAllowed(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: Whether or not to allow force dark."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets whether or not to allow force dark to apply to this view. Setting this to false will disable the auto-dark feature on everything this view draws, including any descendants. Setting this to true will allow this view to be automatically made dark, however a value of 'true' will not override any 'false' value in its parent chain nor will it prevent any 'false' in any of its children. The default behavior of force dark is also influenced by the Theme's @B_android#R#styleable#Theme_isLightTheme_E@ attribute. If a theme is isLightTheme=\"false\", then force dark is globally disabled for that theme.", "history": "Added in API level 29", "FullName": "public void setForceDarkAllowed (boolean allow)"}, "setTranslationY(float)": {"Returns": [], "Parameters": [["float", "float: The vertical position of this view relative to its top position, in pixels."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the vertical location of this view relative to its @B_android#view#View#getTop_E@ position. This effectively positions the object post-layout, in addition to wherever the object's layout placed it.", "history": "Added in API level 11", "FullName": "public void setTranslationY (float translationY)"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of the object. In general, the toString method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:", "history": "Added in API level 1", "FullName": "public String toString ()"}, "drawableHotspotChanged(float,float)": {"Returns": [], "Parameters": [["float", "float: hotspot x coordinate"], ["float", "float: hotspot y coordinate"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This function is called whenever the view hotspot changes and needs to be propagated to drawables or child views managed by the view. Dispatching to child views is handled by @B_android#view#View#dispatchDrawableHotspotChanged_E@. Be sure to call through to the superclass when overriding this function. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 21", "FullName": "public void drawableHotspotChanged (float x, float y)"}, "isShown()": {"Returns": [["boolean", "True if this view and all of its ancestors are @B_android#view#View#VISIBLE_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the visibility of this view and all of its ancestors", "history": "Added in API level 1", "FullName": "public boolean isShown ()"}, "setCameraDistance(float)": {"Returns": [], "Parameters": [["float", "float: The distance in \"depth pixels\", if negative the opposite value is used"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setRotationX_E@", "@B_android#view#View#setRotationY_E@"], "Permissions": [], "Description": "Sets the distance along the Z axis (orthogonal to the X/Y plane on which views are drawn) from the camera to this view. The camera's distance affects 3D transformations, for instance rotations around the X and Y axis. If the rotationX or rotationY properties are changed and this view is large (more than half the size of the screen), it is recommended to always use a camera distance that's greater than the height (X axis rotation) or the width (Y axis rotation) of this view. The distance of the camera from the view plane can have an affect on the perspective distortion of the view when it is rotated around the x or y axis. For example, a large distance will result in a large viewing angle, and there will not be much perspective distortion of the view as it rotates. A short distance may cause much more perspective distortion upon rotation, and can also result in some drawing artifacts if the rotated view ends up partially behind the camera (which is why the recommendation is to use a distance at least as far as the size of the view, if the view is to be rotated.) The distance is expressed in \"depth pixels.\" The default distance depends on the screen density. For instance, on a medium density display, the default distance is 1280. On a high density display, the default distance is 1920. If you want to specify a distance that leads to visually consistent results across various densities, use the following formula: The density scale factor of a high density display is 1.5, and 1920 = 1280 * 1.5.", "history": "Added in API level 12", "FullName": "public void setCameraDistance (float distance)"}, "setTag(int, java.lang.Object)": {"Returns": [], "Parameters": [["int", "int: The key identifying the tag"], ["@B_java#lang#Object_E@", "Object: An Object to tag the view with"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "If they specified key is not valid"]], "SeeAlso": ["@B_android#view#View#setTag_E@", "@B_android#view#View#getTag_E@"], "Permissions": [], "Description": "Sets a tag associated with this view and a key. A tag can be used to mark a view in its hierarchy and does not have to be unique within the hierarchy. Tags can also be used to store data within a view without resorting to another data structure. The specified key should be an id declared in the resources of the application to ensure it is unique (see the @B_java#lang#IllegalArgumentException_E@ to be thrown.", "history": "added in API level 4", "FullName": "public void setTag (int key, Object tag)"}, "keyboardNavigationClusterSearch(android.view.View,int)": {"Returns": [["@B_android#view#View_E@", "The nearest keyboard navigation cluster in the specified direction, or null if none can be found"]], "Parameters": [["@B_android#view#View_E@", "View: The starting point of the search. Null means the current cluster is not found yet"], ["int", "int: Direction to look Value is @B_android#view#View#FOCUS_BACKWARD_E@, @B_android#view#View#FOCUS_FORWARD_E@, @B_android#view#View#FOCUS_LEFT_E@, @B_android#view#View#FOCUS_UP_E@, @B_android#view#View#FOCUS_RIGHT_E@, or @B_android#view#View#FOCUS_DOWN_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Find the nearest keyboard navigation cluster in the specified direction. This does not actually give focus to that cluster.", "history": "Added in API level 26", "FullName": "public View keyboardNavigationClusterSearch (View currentCluster, int direction)"}, "resolveSizeAndState(int, int, int)": {"Returns": [["int", "Size information bit mask as defined by @B_android#view#View#MEASURED_SIZE_MASK_E@ and @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@."]], "Parameters": [["int", "int: How big the view wants to be."], ["int", "int: Constraints imposed by the parent."], ["int", "int: Size information bit mask for the view's children."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Utility to reconcile a desired size and state, with constraints imposed by a MeasureSpec. Will take the desired size, unless a different size is imposed by the constraints. The returned value is a compound integer, with the resolved size in the @B_android#view#View#MEASURED_SIZE_MASK_E@ bits and optionally the bit @B_android#view#View#MEASURED_STATE_TOO_SMALL_E@ set if the resulting size is smaller than the size the view wants to be.", "history": "added in API level 11", "FullName": "public static int resolveSizeAndState (int size, int measureSpec, int childMeasuredState)"}, "setAnimationMatrix(android.graphics.Matrix)": {"Returns": [], "Parameters": [["@B_android#graphics#Matrix_E@", "Matrix: The matrix, null indicates that the matrix should be cleared. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getAnimationMatrix_E@"], "Permissions": [], "Description": "Changes the transformation matrix on the view. This is used in animation frameworks, such as @B_android#transition#Transition_E@. When the animation finishes, the matrix should be cleared by calling this method with null as the matrix parameter. Application developers should use transformation methods like @B_android#view#View#setRotation_E@, @B_android#view#View#setScaleX_E@, @B_android#view#View#setScaleX_E@, @B_android#view#View#setTranslationX_E@} and @B_android#view#View#setTranslationY_E@ (float)}} instead.", "history": "Added in API level 29", "FullName": "public void setAnimationMatrix (Matrix matrix)"}, "getTopFadingEdgeStrength()": {"Returns": [["float", "the intensity of the top fade as a float between 0.0f and 1.0f"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the strength, or intensity, of the top faded edge. The strength is a value between 0.0 (no fade) and 1.0 (full fade). The default implementation returns 0.0 or 1.0 but no value in between. Subclasses should override this method to provide a smoother fade transition when scrolling occurs.", "history": "Added in API level 1", "FullName": "protected float getTopFadingEdgeStrength ()"}, "getPaddingBottom()": {"Returns": [["int", "the bottom padding in pixels"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the bottom padding of this view. If there are inset and enabled scrollbars, this value may include the space required to display the scrollbars as well.", "history": "Added in API level 1", "FullName": "public int getPaddingBottom ()"}, "setFocusedByDefault(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to set this view as the default-focus view, false otherwise."]], "Throws": [], "SeeAlso": ["@B_android#view#View#restoreDefaultFocus_E@"], "Permissions": [], "Description": "Sets whether this View should receive focus when the focus is restored for the view hierarchy containing this view. Focus gets restored for a view hierarchy when the root of the hierarchy gets added to a window or serves as a target of cluster navigation.", "history": "Added in API level 26", "FullName": "public void setFocusedByDefault (boolean isFocusedByDefault)"}, "onKeyPreIme(int,android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handle a key event before it is processed by any input method associated with the view hierarchy. This can be used to intercept key events in special situations before the IME consumes them; a typical example would be handling the BACK key to update the application's UI instead of allowing the IME to see it and close itself.", "history": "Added in API level 3", "FullName": "public boolean onKeyPreIme (int keyCode, KeyEvent event)"}, "getFitsSystemWindows()": {"Returns": [["boolean", "true if the default implementation of @B_android#view#View#fitSystemWindows_E@ will be executed."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setFitsSystemWindows_E@", "@B_android#view#View#fitSystemWindows_E@", "@B_android#view#View#setSystemUiVisibility_E@"], "Permissions": [], "Description": "Check for state of @B_android#view#View#setFitsSystemWindows_E@. If this method returns true, the default implementation of @B_android#view#View#fitSystemWindows_E@ will be executed.", "history": "Added in API level 16", "FullName": "public boolean getFitsSystemWindows ()"}, "onGenericMotionEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The generic motion event being processed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle generic motion events. Generic motion events describe joystick movements, mouse hovers, track pad touches, scroll wheel movements and other input events. The @B_android#view#MotionEvent#getSource_E@ of the motion event specifies the class of input that was received. Implementations of this method must examine the bits in the source before processing the event. The following code example shows how this is done. Generic motion events with source class @B_android#view#InputDevice#SOURCE_CLASS_POINTER_E@ are delivered to the view under the pointer. All other generic motion events are delivered to the focused view.", "history": "Added in API level 12", "FullName": "public boolean onGenericMotionEvent (MotionEvent event)"}, "getTag()": {"Returns": [["@B_java#lang#Object_E@", "the Object stored in this view as a tag, or null if not set"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setTag_E@", "@B_android#view#View#getTag_E@"], "Permissions": [], "Description": "Returns this view's tag.", "history": "Added in API level 1", "FullName": "public Object getTag ()"}, "setClipToOutline(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setOutlineProvider_E@", "@B_android#view#View#getClipToOutline_E@"], "Permissions": [], "Description": "Sets whether the View's Outline should be used to clip the contents of the View. Only a single non-rectangular clip can be applied on a View at any time. Circular clips from a @B_android#view#ViewAnimationUtils#createCircularReveal_E@ animation take priority over Outline clipping, and child Outline clipping takes priority over Outline clipping done by a parent. Note that this flag will only be respected if the View's Outline returns true from @B_android#graphics#Outline#canClip_E@.", "history": "Added in API level 21", "FullName": "public void setClipToOutline (boolean clipToOutline)"}, "restoreHierarchyState(android.util.SparseArray<android.os.Parcelable>)": {"Returns": [], "Parameters": [["@B_android#util#SparseArray_E@", "SparseArray: The SparseArray which holds previously frozen states."]], "Throws": [], "SeeAlso": ["@B_android#view#View#saveHierarchyState_E@", "@B_android#view#View#dispatchRestoreInstanceState_E@", "@B_android#view#View#onRestoreInstanceState_E@"], "Permissions": [], "Description": "Restore this view hierarchy's frozen state from the given container.", "history": "Added in API level 1", "FullName": "public void restoreHierarchyState (SparseArray<Parcelable> container)"}, "startAnimation(android.view.animation.Animation)": {"Returns": [], "Parameters": [["@B_android#view#animation#Animation_E@", "Animation: the animation to start now"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Start the specified animation now.", "history": "Added in API level 1", "FullName": "public void startAnimation (Animation animation)"}, "getLeftFadingEdgeStrength()": {"Returns": [["float", "the intensity of the left fade as a float between 0.0f and 1.0f"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the strength, or intensity, of the left faded edge. The strength is a value between 0.0 (no fade) and 1.0 (full fade). The default implementation returns 0.0 or 1.0 but no value in between. Subclasses should override this method to provide a smoother fade transition when scrolling occurs.", "history": "Added in API level 1", "FullName": "protected float getLeftFadingEdgeStrength ()"}, "setOnApplyWindowInsetsListener(android.view.View.OnApplyWindowInsetsListener)": {"Returns": [], "Parameters": [["@B_android#view#View#OnApplyWindowInsetsListener_E@", "View.OnApplyWindowInsetsListener: Listener to set"]], "Throws": [], "SeeAlso": ["@B_android#view#View#onApplyWindowInsets_E@"], "Permissions": [], "Description": "Set an @B_android#view#View#OnApplyWindowInsetsListener_E@ to take over the policy for applying window insets to this view. The listener's @B_android#view#View#OnApplyWindowInsetsListener#onApplyWindowInsets_E@ method will be called instead of the view's @B_android#view#View#onApplyWindowInsets_E@ method.", "history": "Added in API level 20", "FullName": "public void setOnApplyWindowInsetsListener (View.OnApplyWindowInsetsListener listener)"}, "getLabelFor()": {"Returns": [["int", "The labeled view id."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the id of a view for which this view serves as a label for accessibility purposes.", "history": "Added in API level 17", "FullName": "public int getLabelFor ()"}, "getAccessibilityTraversalBefore()": {"Returns": [["int", "The id of a view this one precedes in accessibility traversal if specified, otherwise @B_android#view#View#NO_ID_E@."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setAccessibilityTraversalBefore_E@"], "Permissions": [], "Description": "Gets the id of a view before which this one is visited in accessibility traversal.", "history": "Added in API level 22", "FullName": "public int getAccessibilityTraversalBefore ()"}, "performHapticFeedback(int, int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int", "int: One of the constants defined in @B_android#view#HapticFeedbackConstants_E@"], ["int", "int: Additional flags as per @B_android#view#HapticFeedbackConstants_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "BZZZTT!!1! Like @B_android#view#View#performHapticFeedback_E@, with additional options.", "history": "added in API level 3", "FullName": "public boolean performHapticFeedback (int feedbackConstant, int flags)"}, "getHorizontalFadingEdgeLength()": {"Returns": [["int", "The size in pixels of the horizontal faded edge or 0 if horizontal faded edges are not enabled for this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the size of the horizontal faded edges used to indicate that more content in this view is visible.", "history": "Added in API level 1", "FullName": "public int getHorizontalFadingEdgeLength ()"}, "getVerticalScrollbarThumbDrawable()": {"Returns": [["@B_android#graphics#drawable#Drawable_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#awakenScrollBars_E@", "@B_android#view#View#isVerticalScrollBarEnabled_E@", "@B_android#view#View#setVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Returns the currently configured Drawable for the thumb of the vertical scroll bar if it exists, null otherwise.", "history": "Added in API level 29", "FullName": "public Drawable getVerticalScrollbarThumbDrawable ()"}, "dispatchSaveInstanceState(android.util.SparseArray<android.os.Parcelable>)": {"Returns": [], "Parameters": [["@B_android#util#SparseArray_E@", "SparseArray: The SparseArray in which to save the view's state."]], "Throws": [], "SeeAlso": ["@B_android#view#View#dispatchRestoreInstanceState_E@", "@B_android#view#View#saveHierarchyState_E@", "@B_android#view#View#onSaveInstanceState_E@"], "Permissions": [], "Description": "Called by @B_android#view#View#saveHierarchyState_E@ to store the state for this view and its children. May be overridden to modify how freezing happens to a view's children; for example, some views may want to not store state for their children.", "history": "Added in API level 1", "FullName": "protected void dispatchSaveInstanceState (SparseArray<Parcelable> container)"}, "getDrawingTime()": {"Returns": [["long", "the drawing start time in milliseconds"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the time at which the drawing of the view hierarchy started.", "history": "Added in API level 1", "FullName": "public long getDrawingTime ()"}, "onMeasure(int,int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getMeasuredWidth_E@", "@B_android#view#View#getMeasuredHeight_E@", "@B_android#view#View#setMeasuredDimension_E@", "@B_android#view#View#getSuggestedMinimumHeight_E@", "@B_android#view#View#getSuggestedMinimumWidth_E@", "@B_android#view#View#MeasureSpec#getMode_E@", "@B_android#view#View#MeasureSpec#getSize_E@"], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "Added in API level 1", "FullName": "protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "getRightPaddingOffset()": {"Returns": [["int", "The right padding offset in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#isPaddingOffsetRequired_E@"], "Permissions": [], "Description": "Amount by which to extend the right fading region. Called only when @B_android#view#View#isPaddingOffsetRequired_E@ returns true.", "history": "Added in API level 2", "FullName": "protected int getRightPaddingOffset ()"}, "setRotation(float)": {"Returns": [], "Parameters": [["float", "float: The degrees of rotation."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getRotation_E@", "@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@", "@B_android#view#View#setRotationX_E@", "@B_android#view#View#setRotationY_E@"], "Permissions": [], "Description": "Sets the degrees that the view is rotated around the pivot point. Increasing values result in clockwise rotation.", "history": "Added in API level 11", "FullName": "public void setRotation (float rotation)"}, "onDisplayHint(int)": {"Returns": [], "Parameters": [["int", "int: A hint about whether or not this view is displayed: @B_android#view#View#VISIBLE_E@ or @B_android#view#View#INVISIBLE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gives this view a hint about whether is displayed or not. For instance, when a View moves out of the screen, it might receives a display hint indicating the view is not displayed. Applications should not rely on this hint as there is no guarantee that they will receive one.", "history": "Added in API level 8", "FullName": "protected void onDisplayHint (int hint)"}, "getFilterTouchesWhenObscured()": {"Returns": [["boolean", "True if touch filtering is enabled."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setFilterTouchesWhenObscured_E@"], "Permissions": [], "Description": "Gets whether the framework should discard touches when the view's window is obscured by another visible window. Refer to the @B_android#view#View_E@ security documentation for more details.", "history": "Added in API level 9", "FullName": "public boolean getFilterTouchesWhenObscured ()"}, "isDrawingCacheEnabled()": {"Returns": [["boolean", "true if the drawing cache is enabled"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setDrawingCacheEnabled_E@", "@B_android#view#View#getDrawingCache_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Indicates whether the drawing cache is enabled for this view.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public boolean isDrawingCacheEnabled ()"}, "getLocationInSurface(int[])": {"Returns": [], "Parameters": [["int[]", "int: an array of two integers in which to hold the coordinates This value must never be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compute the view's coordinate within the surface. Computes the coordinates of this view in its surface. The argument must be an array of two integers. After the method returns, the array contains the x and y location in that order.", "history": "Added in API level 29", "FullName": "public void getLocationInSurface (int[] location)"}, "setBackgroundColor(int)": {"Returns": [], "Parameters": [["int", "int: the color of the background"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the background color for this view.", "history": "Added in API level 1", "FullName": "public void setBackgroundColor (int color)"}, "addTouchables(java.util.ArrayList<android.view.View>)": {"Returns": [], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: Touchable views found so far"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add any touchable views that are descendants of this view (possibly including this view if it is touchable itself) to views.", "history": "Added in API level 1", "FullName": "public void addTouchables (ArrayList<View> views)"}, "performLongClick(float, float)": {"Returns": [["boolean", "true if one of the above receivers consumed the event, false otherwise"]], "Parameters": [["float", "float: x coordinate of the anchoring touch event, or @B_java#lang#Float#NaN_E@ to disable anchoring"], ["float", "float: y coordinate of the anchoring touch event, or @B_java#lang#Float#NaN_E@ to disable anchoring"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Calls this view's OnLongClickListener, if it is defined. Invokes the context menu if the OnLongClickListener did not consume the event, anchoring it to an (x,y) coordinate.", "history": "added in API level 24", "FullName": "public boolean performLongClick (float x, float y)"}, "resolveSize(int, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Version of @B_android#view#View#resolveSizeAndState_E@ returning only the @B_android#view#View#MEASURED_SIZE_MASK_E@ bits of the result.", "history": "added in API level 1", "FullName": "public static int resolveSize (int size, int measureSpec)"}, "releasePointerCapture()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#requestPointerCapture_E@", "@B_android#view#View#hasPointerCapture_E@"], "Permissions": [], "Description": "Releases the pointer capture. If the window does not have pointer capture, this call will do nothing.", "history": "Added in API level 26", "FullName": "public void releasePointerCapture ()"}, "setNextFocusForwardId(int)": {"Returns": [], "Parameters": [["int", "int: The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the id of the view to use when the next focus is @B_android#view#View#FOCUS_FORWARD_E@.", "history": "Added in API level 11", "FullName": "public void setNextFocusForwardId (int nextFocusForwardId)"}, "onSizeChanged(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: Current width of this view."], ["int", "int: Current height of this view."], ["int", "int: Old width of this view."], ["int", "int: Old height of this view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0.", "history": "Added in API level 1", "FullName": "protected void onSizeChanged (int w, int h, int oldw, int oldh)"}, "cancelLongPress()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Cancels a pending long press. Your subclass can use this if you want the context menu to come up if the user presses and holds at the same place, but you don't want it to come up if they press and then move around enough to cause scrolling.", "history": "Added in API level 1", "FullName": "public void cancelLongPress ()"}, "hasOverlappingRendering()": {"Returns": [["boolean", "true if the content in this view might overlap, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether this View has content which overlaps. This function, intended to be overridden by specific View types, is an optimization when alpha is set on a view. If rendering overlaps in a view with alpha < 1, that view is drawn to an offscreen buffer and then composited into place, which can be expensive. If the view has no overlapping rendering, the view can draw each primitive with the appropriate alpha value directly. An example of overlapping rendering is a TextView with a background image, such as a Button. An example of non-overlapping rendering is a TextView with no background, or an ImageView with only the foreground image. The default implementation returns true; subclasses should override if they have cases which can be optimized. @B_android#view#View#forceHasOverlappingRendering_E@ has been called on this view.", "history": "Added in API level 16", "FullName": "public boolean hasOverlappingRendering ()"}, "performHapticFeedback(int)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["int", "int: One of the constants defined in @B_android#view#HapticFeedbackConstants_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "BZZZTT!!1! Provide haptic feedback to the user for this view. The framework will provide haptic feedback for some built in actions, such as long presses, but you may wish to provide feedback for your own widget. The feedback will only be performed if @B_android#view#View#isHapticFeedbackEnabled_E@ is true.", "history": "Added in API level 3", "FullName": "public boolean performHapticFeedback (int feedbackConstant)"}, "dispatchNestedPrePerformAccessibilityAction(int,android.os.Bundle)": {"Returns": [["boolean", "true if the action was consumed by a parent"]], "Parameters": [["int", "int: Accessibility action to delegate"], ["@B_android#os#Bundle_E@", "Bundle: Optional action arguments"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Report an accessibility action to this view's parents for delegated processing. Implementations of @B_android#view#View#performAccessibilityAction_E@ may internally call this method to delegate an accessibility action to a supporting parent. If the parent returns true from its @B_android#view#ViewParent#onNestedPrePerformAccessibilityAction_E@ method this method will return true to signify that the action was consumed. This method is useful for implementing nested scrolling child views. If @B_android#view#View#isNestedScrollingEnabled_E@ returns true and the action is a scrolling action a custom view implementation may invoke this method to allow a parent to consume the scroll first. If this method returns true the custom view should skip its own scrolling behavior.", "history": "Added in API level 22", "FullName": "public boolean dispatchNestedPrePerformAccessibilityAction (int action, Bundle arguments)"}, "onRtlPropertiesChanged(int)": {"Returns": [], "Parameters": [["int", "int: the direction of the layout Value is @B_android#view#View#LAYOUT_DIRECTION_LTR_E@, or @B_android#view#View#LAYOUT_DIRECTION_RTL_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View_E@"], "Permissions": [], "Description": "Called when any RTL property (layout direction or text direction or text alignment) has been changed. Subclasses need to override this method to take care of cached information that depends on the resolved layout direction, or to inform child views that inherit their layout direction. The default implementation does nothing.", "history": "Added in API level 17", "FullName": "public void onRtlPropertiesChanged (int layoutDirection)"}, "sendAccessibilityEventUnchecked(android.view.accessibility.AccessibilityEvent)": {"Returns": [], "Parameters": [["@B_android#view#accessibility#AccessibilityEvent_E@", "AccessibilityEvent: The event to send."]], "Throws": [], "SeeAlso": ["@B_android#view#View#sendAccessibilityEvent_E@"], "Permissions": [], "Description": "This method behaves exactly as @B_android#view#View#sendAccessibilityEvent_E@ but takes as an argument an empty @B_android#view#accessibility#AccessibilityEvent_E@ and does not perform a check whether accessibility is enabled. If an @B_android#view#View#AccessibilityDelegate_E@ has been specified via calling @B_android#view#View#setAccessibilityDelegate_E@ its @B_android#view#View#AccessibilityDelegate#sendAccessibilityEventUnchecked_E@ is responsible for handling this call.", "history": "Added in API level 4", "FullName": "public void sendAccessibilityEventUnchecked (AccessibilityEvent event)"}, "invalidate(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: the left position of the dirty region"], ["int", "int: the top position of the dirty region"], ["int", "int: the right position of the dirty region"], ["int", "int: the bottom position of the dirty region"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The switch to hardware accelerated rendering in API 14 reduced the importance of the dirty rectangle. In API 21 the given rectangle is ignored entirely in favor of an internally-calculated area instead. Because of this, clients are encouraged to just call @B_android#view#View#invalidate_E@. Mark the area defined by the rect (l,t,r,b) as needing to be drawn. The coordinates of the dirty rect are relative to the view. If the view is visible, @B_android#view#View#onDraw_E@ will be called at some point in the future. This must be called from a UI thread. To call from a non-UI thread, call @B_android#view#View#postInvalidate_E@.", "history": "added in API level 1", "FullName": "public void invalidate (int l, int t, int r, int b)"}, "addChildrenForAccessibility(java.util.ArrayList<android.view.View>)": {"Returns": [], "Parameters": [["@B_java#util#ArrayList_E@", "ArrayList: The output list that will receive children for accessibility."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds the children of this View relevant for accessibility to the given list as output. Since some Views are not important for accessibility the added child views are not necessarily direct children of this view, rather they are the first level of descendants important for accessibility.", "history": "Added in API level 16", "FullName": "public void addChildrenForAccessibility (ArrayList<View> outChildren)"}, "offsetTopAndBottom(int)": {"Returns": [], "Parameters": [["int", "int: the number of pixels to offset the view by"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Offset this view's vertical location by the specified number of pixels.", "history": "Added in API level 1", "FullName": "public void offsetTopAndBottom (int offset)"}, "getTranslationY()": {"Returns": [["float", "The vertical position of this view relative to its top position, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The vertical location of this view relative to its @B_android#view#View#getTop_E@ position. This position is post-layout, in addition to wherever the object's layout placed it.", "history": "Added in API level 11", "FullName": "public float getTranslationY ()"}, "dispatchVisibilityChanged(android.view.View, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view whose visibility changed. Could be 'this' or an ancestor view.This value must never be null."], ["int", "int: The new visibility of changedView: @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@ or @B_android#view#View#GONE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a view visibility change down the view hierarchy. ViewGroups should override to route to their children.", "history": "added in API level 8", "FullName": "protected void dispatchVisibilityChanged (View changedView, int visibility)"}, "destroyDrawingCache()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setDrawingCacheEnabled_E@", "@B_android#view#View#buildDrawingCache_E@", "@B_android#view#View#getDrawingCache_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Frees the resources used by the drawing cache. If you call @B_android#view#View#buildDrawingCache_E@ manually without calling @B_android#view#View#setDrawingCacheEnabled_E@, you should cleanup the cache with this method afterwards.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public void destroyDrawingCache ()"}, "awakenScrollBars(int)": {"Returns": [["boolean", "true if the animation is played, false otherwise"]], "Parameters": [["int", "int: the delay, in milliseconds, after which the animation should start; when the delay is 0, the animation starts immediately"]], "Throws": [], "SeeAlso": ["@B_android#view#View#scrollBy_E@", "@B_android#view#View#scrollTo_E@", "@B_android#view#View#isHorizontalScrollBarEnabled_E@", "@B_android#view#View#isVerticalScrollBarEnabled_E@", "@B_android#view#View#setHorizontalScrollBarEnabled_E@", "@B_android#view#View#setVerticalScrollBarEnabled_E@"], "Permissions": [], "Description": "Trigger the scrollbars to draw. When invoked this method starts an animation to fade the scrollbars out after a fixed delay. If a subclass provides animated scrolling, the start delay should equal the duration of the scrolling animation. The animation starts only if at least one of the scrollbars is enabled, as specified by @B_android#view#View#isHorizontalScrollBarEnabled_E@ and @B_android#view#View#isVerticalScrollBarEnabled_E@. When the animation is started, this method returns true, and false otherwise. If the animation is started, this method calls @B_android#view#View#invalidate_E@; in that case the caller should not call @B_android#view#View#invalidate_E@. This method should be invoked every time a subclass directly updates the scroll parameters.", "history": "Added in API level 5", "FullName": "protected boolean awakenScrollBars (int startDelay)"}, "onKeyLongPress(int,android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: The value in event.getKeyCode()."], ["@B_android#view#KeyEvent_E@", "KeyEvent: Description of the key event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyLongPress_E@: always returns false (doesn't handle the event). Key presses in software keyboards will generally NOT trigger this listener, although some may elect to do so in some situations. Do not rely on this to catch software key presses.", "history": "Added in API level 5", "FullName": "public boolean onKeyLongPress (int keyCode, KeyEvent event)"}, "getPivotX()": {"Returns": [["float", "The x location of the pivot point."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getRotation_E@", "@B_android#view#View#getScaleX_E@", "@B_android#view#View#getScaleY_E@", "@B_android#view#View#getPivotY_E@"], "Permissions": [], "Description": "The x location of the point around which the view is @B_android#view#View#setRotation_E@ and @B_android#view#View#setScaleX_E@.", "history": "Added in API level 11", "FullName": "public float getPivotX ()"}, "setFocusable(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: If true, this view can receive the focus."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setFocusableInTouchMode_E@", "@B_android#view#View#setFocusable_E@"], "Permissions": [], "Description": "Set whether this view can receive the focus. Setting this to false will also ensure that this view is not focusable in touch mode.", "history": "Added in API level 1", "FullName": "public void setFocusable (boolean focusable)"}, "isScrollContainer()": {"Returns": [["boolean", "whether this view is one of the set of scrollable containers in its window"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether this view is one of the set of scrollable containers in its window.", "history": "Added in API level 16", "FullName": "public boolean isScrollContainer ()"}, "invalidate(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: the left position of the dirty region"], ["int", "int: the top position of the dirty region"], ["int", "int: the right position of the dirty region"], ["int", "int: the bottom position of the dirty region"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The switch to hardware accelerated rendering in API 14 reduced the importance of the dirty rectangle. In API 21 the given rectangle is ignored entirely in favor of an internally-calculated area instead. Because of this, clients are encouraged to just call @B_android#view#View#invalidate_E@. Mark the area defined by the rect (l,t,r,b) as needing to be drawn. The coordinates of the dirty rect are relative to the view. If the view is visible, @B_android#view#View#onDraw_E@ will be called at some point in the future. This must be called from a UI thread. To call from a non-UI thread, call @B_android#view#View#postInvalidate_E@.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public void invalidate (int l, int t, int r, int b)"}, "requestPointerCapture()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#releasePointerCapture_E@", "@B_android#view#View#hasPointerCapture_E@"], "Permissions": [], "Description": "Requests pointer capture mode. When the window has pointer capture, the mouse pointer icon will disappear and will not change its position. Further mouse will be dispatched with the source @B_android#view#InputDevice#SOURCE_MOUSE_RELATIVE_E@, and relative position changes will be available through @B_android#view#MotionEvent#getX_E@ and @B_android#view#MotionEvent#getY_E@. Non-mouse events (touchscreens, or stylus) will not be affected. If the window already has pointer capture, this call does nothing. The capture may be released through @B_android#view#View#releasePointerCapture_E@, or will be lost automatically when the window loses focus.", "history": "Added in API level 26", "FullName": "public void requestPointerCapture ()"}, "dispatchNestedScroll(int,int,int,int,int[])": {"Returns": [["boolean", "true if the event was dispatched, false if it could not be dispatched."]], "Parameters": [["int", "int: Horizontal distance in pixels consumed by this view during this scroll step"], ["int", "int: Vertical distance in pixels consumed by this view during this scroll step"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking. This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#dispatchNestedPreScroll_E@"], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress. Implementations of views that support nested scrolling should call this to report info about a scroll in progress to the current nested scrolling parent. If a nested scroll is not currently in progress or nested scrolling is not @B_android#view#View#isNestedScrollingEnabled_E@ for this view this method does nothing. Compatible View implementations should also call @B_android#view#View#dispatchNestedPreScroll_E@ before consuming a component of the scroll event themselves.", "history": "Added in API level 21", "FullName": "public boolean dispatchNestedScroll (int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)"}, "getScrollBarDefaultDelayBeforeFade()": {"Returns": [["int", "the delay before scrollbars fade"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the delay before scrollbars fade.", "history": "Added in API level 16", "FullName": "public int getScrollBarDefaultDelayBeforeFade ()"}, "onDraw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: the canvas on which the background will be drawn"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this to do your drawing.", "history": "Added in API level 1", "FullName": "protected void onDraw (Canvas canvas)"}, "setAccessibilityHeading(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the view is a heading, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set if view is a heading for a section of content for accessibility purposes.", "history": "Added in API level 28", "FullName": "public void setAccessibilityHeading (boolean isHeading)"}, "computeSystemWindowInsets(android.view.WindowInsets,android.graphics.Rect)": {"Returns": [["@B_android#view#WindowInsets_E@", "Insets that should be passed along to views under this one"]], "Parameters": [["@B_android#view#WindowInsets_E@", "WindowInsets: Insets currently being processed by this View, likely received as a parameter to @B_android#view#View#onApplyWindowInsets_E@."], ["@B_android#graphics#Rect_E@", "Rect: A Rect that will receive the insets that should be consumed by this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compute insets that should be consumed by this view and the ones that should propagate to those under it.", "history": "Added in API level 21", "FullName": "public WindowInsets computeSystemWindowInsets (WindowInsets in, Rect outLocalInsets)"}, "onWindowSystemUiVisibilityChanged(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Override to find out when the window's requested system UI visibility has changed, that is the value returned by @B_android#view#View#getWindowSystemUiVisibility_E@. This is different from the callbacks received through @B_android#view#View#setOnSystemUiVisibilityChangeListener_E@ in that this is only telling you about the local request of the window, not the actual values applied by the system.", "history": "Added in API level 16", "FullName": "public void onWindowSystemUiVisibilityChanged (int visible)"}, "getTranslationZ()": {"Returns": [["float", "The depth of this view relative to its elevation."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The depth location of this view relative to its @B_android#view#View#getElevation_E@.", "history": "Added in API level 21", "FullName": "public float getTranslationZ ()"}, "measure(int,int)": {"Returns": [], "Parameters": [["int", "int: Horizontal space requirements as imposed by the parent"], ["int", "int: Vertical space requirements as imposed by the parent"]], "Throws": [], "SeeAlso": ["@B_android#view#View#onMeasure_E@"], "Permissions": [], "Description": "This is called to find out how big a view should be. The parent supplies constraint information in the width and height parameters. The actual measurement work of a view is performed in @B_android#view#View#onMeasure_E@, called by this method. Therefore, only @B_android#view#View#onMeasure_E@ can and must be overridden by subclasses.", "history": "Added in API level 1", "FullName": "public final void measure (int widthMeasureSpec, int heightMeasureSpec)"}, "getFocusable()": {"Returns": [["int", "One of @B_android#view#View#NOT_FOCUSABLE_E@, @B_android#view#View#FOCUSABLE_E@, or @B_android#view#View#FOCUSABLE_AUTO_E@. Value is @B_android#view#View#NOT_FOCUSABLE_E@, @B_android#view#View#FOCUSABLE_E@, or @B_android#view#View#FOCUSABLE_AUTO_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the focusable setting for this view.", "history": "Added in API level 26", "FullName": "public int getFocusable ()"}, "setScrollIndicators(int)": {"Returns": [], "Parameters": [["int", "int: a bitmask of indicators that should be enabled, or 0 to disable all indicators Value is either 0 or a combination of @B_android#view#View#SCROLL_INDICATOR_TOP_E@, @B_android#view#View#SCROLL_INDICATOR_BOTTOM_E@, @B_android#view#View#SCROLL_INDICATOR_LEFT_E@, @B_android#view#View#SCROLL_INDICATOR_RIGHT_E@, @B_android#view#View#SCROLL_INDICATOR_START_E@, and @B_android#view#View#SCROLL_INDICATOR_END_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setScrollIndicators_E@", "@B_android#view#View#getScrollIndicators_E@"], "Permissions": [], "Description": "Sets the state of all scroll indicators. See @B_android#view#View#setScrollIndicators_E@ for usage information.", "history": "Added in API level 23", "FullName": "public void setScrollIndicators (int indicators)"}, "setBackgroundTintList(android.content.res.ColorStateList)": {"Returns": [], "Parameters": [["@B_android#content#res#ColorStateList_E@", "ColorStateList: the tint to apply, may be null to clear tint This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getBackgroundTintList_E@", "@B_android#graphics#drawable#Drawable#setTintList_E@"], "Permissions": [], "Description": "Applies a tint to the background drawable. Does not modify the current tint mode, which is @B_android#graphics#BlendMode#SRC_IN_E@ by default. Subsequent calls to @B_android#view#View#setBackground_E@ will automatically mutate the drawable and apply the specified tint and tint mode using @B_android#graphics#drawable#Drawable#setTintList_E@.", "history": "Added in API level 21", "FullName": "public void setBackgroundTintList (ColorStateList tint)"}, "setMinimumHeight(int)": {"Returns": [], "Parameters": [["int", "int: The minimum height the view will try to be, in pixels"]], "Throws": [], "SeeAlso": ["@B_android#view#View#getMinimumHeight_E@"], "Permissions": [], "Description": "Sets the minimum height of the view. It is not guaranteed the view will be able to achieve this minimum height (for example, if its parent layout constrains it with less available height).", "history": "Added in API level 1", "FullName": "public void setMinimumHeight (int minHeight)"}, "getAttributeResolutionStack(int)": {"Returns": [["int[]", "ordered list of resource ID that are considered when resolving attribute values for this @B_android#view#View_E@. This value will never be null."]], "Parameters": [["int", "int: Attribute resource ID for which the resolution stack should be returned."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the ordered list of resource ID that are considered when resolving attribute values for this @B_android#view#View_E@. The list will include layout resource ID if the View is inflated from XML. It will also include a set of explicit styles if specified in XML using style=\"...\". Finally, it will include the default styles resolved from the theme.", "history": "Added in API level 29", "FullName": "public int[] getAttributeResolutionStack (int attribute)"}, "getBottomPaddingOffset()": {"Returns": [["int", "The bottom padding offset in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#isPaddingOffsetRequired_E@"], "Permissions": [], "Description": "Amount by which to extend the bottom fading region. Called only when @B_android#view#View#isPaddingOffsetRequired_E@ returns true.", "history": "Added in API level 2", "FullName": "protected int getBottomPaddingOffset ()"}, "isLongClickable()": {"Returns": [["boolean", "true if the view is long clickable, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setLongClickable_E@"], "Permissions": [], "Description": "Indicates whether this view reacts to long click events or not.", "history": "Added in API level 1", "FullName": "public boolean isLongClickable ()"}, "getElevation()": {"Returns": [["float", "The base depth position of the view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The base elevation of this view relative to its parent, in pixels.", "history": "Added in API level 21", "FullName": "public float getElevation ()"}, "setBackgroundTintBlendMode(android.graphics.BlendMode)": {"Returns": [], "Parameters": [["@B_android#graphics#BlendMode_E@", "BlendMode: the blending mode used to apply the tint, may be null to clear tint This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getBackgroundTintMode_E@", "@B_android#graphics#drawable#Drawable#setTintBlendMode_E@"], "Permissions": [], "Description": "Specifies the blending mode used to apply the tint specified by @B_android#view#View#setBackgroundTintList_E@} to the background drawable. The default mode is @B_android#graphics#BlendMode#SRC_IN_E@.", "history": "Added in API level 29", "FullName": "public void setBackgroundTintBlendMode (BlendMode blendMode)"}, "dispatchGenericFocusedEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a generic motion event to the currently focused view. Do not call this method directly. Call @B_android#view#View#dispatchGenericMotionEvent_E@ instead.", "history": "Added in API level 14", "FullName": "protected boolean dispatchGenericFocusedEvent (MotionEvent event)"}, "computeVerticalScrollExtent()": {"Returns": [["int", "the vertical extent of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#computeVerticalScrollRange_E@", "@B_android#view#View#computeVerticalScrollOffset_E@"], "Permissions": [], "Description": "Compute the vertical extent of the vertical scrollbar's thumb within the vertical range. This value is used to compute the length of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#view#View#computeVerticalScrollRange_E@ and @B_android#view#View#computeVerticalScrollOffset_E@. The default extent is the drawing height of this view.", "history": "Added in API level 1", "FullName": "protected int computeVerticalScrollExtent ()"}, "getTag(int)": {"Returns": [["@B_java#lang#Object_E@", "the Object stored in this view as a tag, or null if not set"]], "Parameters": [["int", "int: The key identifying the tag"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setTag_E@", "@B_android#view#View#getTag_E@"], "Permissions": [], "Description": "Returns the tag associated with this view and the specified key.", "history": "Added in API level 4", "FullName": "public Object getTag (int key)"}, "setTooltipText(java.lang.CharSequence)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the tooltip text, or null if no tooltip is required This value may be null."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getTooltipText_E@"], "Permissions": [], "Description": "Sets the tooltip text which will be displayed in a small popup next to the view. The tooltip will be displayed: On long click, unless it is handled otherwise (by OnLongClickListener or a context menu). On hover, after a brief delay since the pointer has stopped moving", "history": "Added in API level 26", "FullName": "public void setTooltipText (CharSequence tooltipText)"}, "isInTouchMode()": {"Returns": [["boolean", "Whether the device is in touch mode."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns whether the device is currently in touch mode. Touch mode is entered once the user begins interacting with the device by touch, and affects various things like whether focus is always visible to the user.", "history": "Added in API level 1", "FullName": "public boolean isInTouchMode ()"}, "dispatchGenericPointerEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled by the view, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a generic motion event to the view under the first pointer. Do not call this method directly. Call @B_android#view#View#dispatchGenericMotionEvent_E@ instead.", "history": "Added in API level 14", "FullName": "protected boolean dispatchGenericPointerEvent (MotionEvent event)"}, "isOpaque()": {"Returns": [["boolean", "True if this View is guaranteed to be fully opaque, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether this View is opaque. An opaque View guarantees that it will draw all the pixels overlapping its bounds using a fully opaque color. Subclasses of View should override this method whenever possible to indicate whether an instance is opaque. Opaque Views are treated in a special way by the View hierarchy, possibly allowing it to perform optimizations during invalidate/draw passes.", "history": "Added in API level 7", "FullName": "public boolean isOpaque ()"}, "onStartTemporaryDetach()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when a container is going to temporarily detach a child, with @B_android#view#ViewGroup#detachViewFromParent_E@. It will either be followed by @B_android#view#View#onFinishTemporaryDetach_E@ or @B_android#view#View#onDetachedFromWindow_E@ when the container is done.", "history": "Added in API level 3", "FullName": "public void onStartTemporaryDetach ()"}, "isLayoutDirectionResolved()": {"Returns": [["boolean", "true if layout direction has been resolved."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 19", "FullName": "public boolean isLayoutDirectionResolved ()"}, "isFocusableInTouchMode()": {"Returns": [["boolean", "Whether the view is focusable in touch mode."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "When a view is focusable, it may not want to take focus when in touch mode. For example, a button would like focus when the user is navigating via a D-pad so that the user can click on it, but once the user starts touching the screen, the button shouldn't take focus", "history": "Added in API level 1", "FullName": "public final boolean isFocusableInTouchMode ()"}, "getVerticalFadingEdgeLength()": {"Returns": [["int", "The size in pixels of the vertical faded edge or 0 if vertical faded edges are not enabled for this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the size of the vertical faded edges used to indicate that more content in this view is visible.", "history": "Added in API level 1", "FullName": "public int getVerticalFadingEdgeLength ()"}, "dispatchPointerCaptureChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": ["@B_android#view#View#onPointerCaptureChange_E@"], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public void dispatchPointerCaptureChanged (boolean hasCapture)"}, "getTransitionName()": {"Returns": [["@B_java#lang#String_E@", "The name used of the View to be used to identify Views in Transitions or null if no name has been given."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the name of the View to be used to identify Views in Transitions. Names should be unique in the View hierarchy. This returns null if the View has not been given a name.", "history": "Added in API level 21", "FullName": "public String getTransitionName ()"}, "setVisibility(int)": {"Returns": [], "Parameters": [["int", "int: One of @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the visibility state of this view.", "history": "Added in API level 1", "FullName": "public void setVisibility (int visibility)"}, "onAnimationStart()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setAnimation_E@", "@B_android#view#View#getAnimation_E@"], "Permissions": [], "Description": "Invoked by a parent ViewGroup to notify the start of the animation currently associated with this view. If you override this method, always call super.onAnimationStart(); If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onAnimationStart ()"}, "getAccessibilityTraversalAfter()": {"Returns": [["int", "The id of a view this one succeedes in accessibility traversal if specified, otherwise @B_android#view#View#NO_ID_E@."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setAccessibilityTraversalAfter_E@"], "Permissions": [], "Description": "Gets the id of a view after which this one is visited in accessibility traversal.", "history": "Added in API level 22", "FullName": "public int getAccessibilityTraversalAfter ()"}, "dispatchSystemUiVisibilityChanged(int)": {"Returns": [], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch callbacks to @B_android#view#View#setOnSystemUiVisibilityChangeListener_E@ down the view hierarchy.", "history": "Added in API level 11", "FullName": "public void dispatchSystemUiVisibilityChanged (int visibility)"}, "setTransitionAlpha(float)": {"Returns": [], "Parameters": [["float", "float no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This property is intended only for use by the Fade transition, which animates it to produce a visual translucency that does not side-effect (or get affected by) the real alpha property. This value is composited with the other alpha value (and the AlphaAnimation value, when that is present) to produce a final visual translucency result, which is what is passed into the DisplayList.", "history": "Added in API level 29", "FullName": "public void setTransitionAlpha (float alpha)"}, "onOverScrolled(int,int,boolean,boolean)": {"Returns": [], "Parameters": [["int", "int: New X scroll value in pixels"], ["int", "int: New Y scroll value in pixels"], ["boolean", "boolean: True if scrollX was clamped to an over-scroll boundary"], ["boolean", "boolean: True if scrollY was clamped to an over-scroll boundary"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by @B_android#view#View#overScrollBy_E@ to respond to the results of an over-scroll operation.", "history": "Added in API level 9", "FullName": "protected void onOverScrolled (int scrollX, int scrollY, boolean clampedX, boolean clampedY)"}, "setScrollX(int)": {"Returns": [], "Parameters": [["int", "int: the x position to scroll to"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the horizontal scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated.", "history": "Added in API level 14", "FullName": "public void setScrollX (int value)"}, "setWillNotCacheDrawing(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if this view does not cache its drawing, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. When a View's drawing cache is enabled, drawing is redirected to an offscreen bitmap. Some views, like an ImageView, must be able to bypass this mechanism if they already draw a single bitmap, to avoid unnecessary usage of the memory.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public void setWillNotCacheDrawing (boolean willNotCacheDrawing)"}, "getNextClusterForwardId()": {"Returns": [["int", "The next keyboard navigation cluster ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the id of the root of the next keyboard navigation cluster.", "history": "Added in API level 26", "FullName": "public int getNextClusterForwardId ()"}, "scrollBy(int,int)": {"Returns": [], "Parameters": [["int", "int: the amount of pixels to scroll by horizontally"], ["int", "int: the amount of pixels to scroll by vertically"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Move the scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated.", "history": "Added in API level 1", "FullName": "public void scrollBy (int x, int y)"}, "postInvalidateOnAnimation(int,int,int,int)": {"Returns": [], "Parameters": [["int", "int: The left coordinate of the rectangle to invalidate."], ["int", "int: The top coordinate of the rectangle to invalidate."], ["int", "int: The right coordinate of the rectangle to invalidate."], ["int", "int: The bottom coordinate of the rectangle to invalidate."]], "Throws": [], "SeeAlso": ["@B_android#view#View#invalidate_E@"], "Permissions": [], "Description": "Cause an invalidate of the specified area to happen on the next animation time step, typically the next display frame. This method can be invoked from outside of the UI thread only when this View is attached to a window.", "history": "Added in API level 16", "FullName": "public void postInvalidateOnAnimation (int left, int top, int right, int bottom)"}, "clearAnimation()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Cancels any animations for this view.", "history": "Added in API level 1", "FullName": "public void clearAnimation ()"}, "onWindowFocusChanged(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the window containing this view now has focus, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the window containing this view gains or loses focus. Note that this is separate from view focus: to receive key events, both your view and its window must have focus. If a window is displayed on top of yours that takes input focus, then your own window will lose focus but the view focus will remain unchanged.", "history": "Added in API level 1", "FullName": "public void onWindowFocusChanged (boolean hasWindowFocus)"}, "getWidth()": {"Returns": [["int", "The width of your view, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the width of your view.", "history": "Added in API level 1", "FullName": "public final int getWidth ()"}, "isSaveFromParentEnabled()": {"Returns": [["boolean", "Returns true if the view state saving from parent is enabled, else false."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setSaveFromParentEnabled_E@"], "Permissions": [], "Description": "Indicates whether the entire hierarchy under this view will save its state when a state saving traversal occurs from its parent. The default is true; if false, these views will not be saved unless @B_android#view#View#saveHierarchyState_E@ is called directly on this view.", "history": "Added in API level 11", "FullName": "public boolean isSaveFromParentEnabled ()"}, "getGlobalVisibleRect(android.graphics.Rect)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#graphics#Rect_E@", "Rect no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public final boolean getGlobalVisibleRect (Rect r)"}, "isScrollbarFadingEnabled()": {"Returns": [["boolean", "true if scrollbar fading is enabled"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if scrollbars will fade when this view is not scrolling", "history": "Added in API level 5", "FullName": "public boolean isScrollbarFadingEnabled ()"}, "getAutofillHints()": {"Returns": [["@B_java#lang#String_E@", "The hints set via the attribute or @B_android#view#View#setAutofillHints_E@, or null if no hints were set."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the hints that help an @B_android#service#autofill#AutofillService_E@ determine how to autofill the view with the user's data. See @B_android#view#View#setAutofillHints_E@ for more info about these hints.", "history": "Added in API level 26", "FullName": "public String[] getAutofillHints ()"}, "setNextFocusUpId(int)": {"Returns": [], "Parameters": [["int", "int: The next focus ID, or @B_android#view#View#NO_ID_E@ if the framework should decide automatically."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the id of the view to use when the next focus is @B_android#view#View#FOCUS_UP_E@.", "history": "Added in API level 1", "FullName": "public void setNextFocusUpId (int nextFocusUpId)"}, "post(java.lang.Runnable)": {"Returns": [["boolean", "Returns true if the Runnable was successfully placed in to the message queue. Returns false on failure, usually because the looper processing the message queue is exiting."]], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: The Runnable that will be executed."]], "Throws": [], "SeeAlso": ["@B_android#view#View#postDelayed_E@", "@B_android#view#View#removeCallbacks_E@"], "Permissions": [], "Description": "Causes the Runnable to be added to the message queue. The runnable will be run on the user interface thread.", "history": "Added in API level 1", "FullName": "public boolean post (Runnable action)"}, "setTextDirection(int)": {"Returns": [], "Parameters": [["int", "int: the direction to set. Should be one of: @B_android#view#View#TEXT_DIRECTION_INHERIT_E@, @B_android#view#View#TEXT_DIRECTION_FIRST_STRONG_E@, @B_android#view#View#TEXT_DIRECTION_ANY_RTL_E@, @B_android#view#View#TEXT_DIRECTION_LTR_E@, @B_android#view#View#TEXT_DIRECTION_RTL_E@, @B_android#view#View#TEXT_DIRECTION_LOCALE_E@ @B_android#view#View#TEXT_DIRECTION_FIRST_STRONG_LTR_E@, @B_android#view#View#TEXT_DIRECTION_FIRST_STRONG_RTL_E@, Resolution will be done if the value is set to TEXT_DIRECTION_INHERIT. The resolution proceeds up the parent chain of the view to get the value. If there is no parent, then it will return the default @B_android#view#View#TEXT_DIRECTION_FIRST_STRONG_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the text direction.", "history": "Added in API level 17", "FullName": "public void setTextDirection (int textDirection)"}, "setHorizontalScrollBarEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the horizontal scrollbar should be painted"]], "Throws": [], "SeeAlso": ["@B_android#view#View#isHorizontalScrollBarEnabled_E@"], "Permissions": [], "Description": "Define whether the horizontal scrollbar should be drawn or not. The scrollbar is not drawn by default.", "history": "Added in API level 1", "FullName": "public void setHorizontalScrollBarEnabled (boolean horizontalScrollBarEnabled)"}, "setTextAlignment(int)": {"Returns": [], "Parameters": [["int", "int: The text alignment to set. Should be one of @B_android#view#View#TEXT_ALIGNMENT_INHERIT_E@, @B_android#view#View#TEXT_ALIGNMENT_GRAVITY_E@, @B_android#view#View#TEXT_ALIGNMENT_CENTER_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_START_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_END_E@, @B_android#view#View#TEXT_ALIGNMENT_VIEW_START_E@, @B_android#view#View#TEXT_ALIGNMENT_VIEW_END_E@ Resolution will be done if the value is set to TEXT_ALIGNMENT_INHERIT. The resolution proceeds up the parent chain of the view to get the value. If there is no parent, then it will return the default @B_android#view#View#TEXT_ALIGNMENT_GRAVITY_E@. Value is @B_android#view#View#TEXT_ALIGNMENT_INHERIT_E@, @B_android#view#View#TEXT_ALIGNMENT_GRAVITY_E@, @B_android#view#View#TEXT_ALIGNMENT_CENTER_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_START_E@, @B_android#view#View#TEXT_ALIGNMENT_TEXT_END_E@, @B_android#view#View#TEXT_ALIGNMENT_VIEW_START_E@, or @B_android#view#View#TEXT_ALIGNMENT_VIEW_END_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the text alignment.", "history": "Added in API level 17", "FullName": "public void setTextAlignment (int textAlignment)"}, "invalidate(android.graphics.Rect)": {"Returns": [], "Parameters": [["@B_android#graphics#Rect_E@", "Rect: the rectangle representing the bounds of the dirty region"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The switch to hardware accelerated rendering in API 14 reduced the importance of the dirty rectangle. In API 21 the given rectangle is ignored entirely in favor of an internally-calculated area instead. Because of this, clients are encouraged to just call @B_android#view#View#invalidate_E@. Mark the area defined by dirty as needing to be drawn. If the view is visible, @B_android#view#View#onDraw_E@ will be called at some point in the future. This must be called from a UI thread. To call from a non-UI thread, call @B_android#view#View#postInvalidate_E@. dirty.", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public void invalidate (Rect dirty)"}, "isImportantForAccessibility()": {"Returns": [["boolean", "Whether the view is exposed for accessibility."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setImportantForAccessibility_E@", "@B_android#view#View#getImportantForAccessibility_E@"], "Permissions": [], "Description": "Computes whether this view should be exposed for accessibility. In general, views that are interactive or provide information are exposed while views that serve only as containers are hidden. If an ancestor of this view has importance @B_android#view#View#IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS_E@, this method returns false. Otherwise, the value is computed according to the view's @B_android#view#View#getImportantForAccessibility_E@ value:", "history": "Added in API level 21", "FullName": "public boolean isImportantForAccessibility ()"}, "setRotationX(float)": {"Returns": [], "Parameters": [["float", "float: The degrees of X rotation."]], "Throws": [], "SeeAlso": ["@B_android#view#View#getRotationX_E@", "@B_android#view#View#getPivotX_E@", "@B_android#view#View#getPivotY_E@", "@B_android#view#View#setRotation_E@", "@B_android#view#View#setRotationY_E@", "@B_android#view#View#setCameraDistance_E@"], "Permissions": [], "Description": "Sets the degrees that the view is rotated around the horizontal axis through the pivot point. Increasing values result in clockwise rotation from the viewpoint of looking down the x axis. When rotating large views, it is recommended to adjust the camera distance accordingly. Refer to @B_android#view#View#setCameraDistance_E@ for more information.", "history": "Added in API level 11", "FullName": "public void setRotationX (float rotationX)"}, "getParent()": {"Returns": [["@B_android#view#ViewParent_E@", "Parent of this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the parent of this view. Note that the parent is a ViewParent and not necessarily a View.", "history": "Added in API level 1", "FullName": "public final ViewParent getParent ()"}, "setOverScrollMode(int)": {"Returns": [], "Parameters": [["int", "int: The new over-scroll mode for this view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the over-scroll mode for this view. Valid over-scroll modes are @B_android#view#View#OVER_SCROLL_ALWAYS_E@, @B_android#view#View#OVER_SCROLL_IF_CONTENT_SCROLLS_E@ (allow over-scrolling only if the view content is larger than the container), or @B_android#view#View#OVER_SCROLL_NEVER_E@. Setting the over-scroll mode of a view will have an effect only if the view is capable of scrolling.", "history": "Added in API level 9", "FullName": "public void setOverScrollMode (int overScrollMode)"}, "getDrawingCache()": {"Returns": [["@B_android#graphics#Bitmap_E@", "A non-scaled bitmap representing this view or null if cache is disabled."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#getDrawingCache_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Calling this method is equivalent to calling getDrawingCache(false).", "history": "Added in API level 1 Deprecated in API level 28", "FullName": "public Bitmap getDrawingCache ()"}, "getMeasuredWidth()": {"Returns": [["int", "The raw measured width of this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#view#View#getMeasuredWidthAndState_E@, but only returns the raw width component (that is the result is masked by @B_android#view#View#MEASURED_SIZE_MASK_E@).", "history": "Added in API level 1", "FullName": "public final int getMeasuredWidth ()"}, "getContentCaptureSession()": {"Returns": [["@B_android#view#contentcapture#ContentCaptureSession_E@", "session explicitly set by @B_android#view#View#setContentCaptureSession_E@, inherited by ancestors, default session or null if content capture is disabled for this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the session used to notify content capture events.", "history": "Added in API level 29", "FullName": "public final ContentCaptureSession getContentCaptureSession ()"}, "computeHorizontalScrollOffset()": {"Returns": [["int", "the horizontal offset of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#computeHorizontalScrollRange_E@", "@B_android#view#View#computeHorizontalScrollExtent_E@"], "Permissions": [], "Description": "Compute the horizontal offset of the horizontal scrollbar's thumb within the horizontal range. This value is used to compute the position of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#view#View#computeHorizontalScrollRange_E@ and @B_android#view#View#computeHorizontalScrollExtent_E@. The default offset is the scroll offset of this view.", "history": "Added in API level 1", "FullName": "protected int computeHorizontalScrollOffset ()"}, "getBaseline()": {"Returns": [["int", "the offset of the baseline within the widget's bounds or -1 if baseline alignment is not supported"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the offset of the widget's text baseline from the widget's top boundary. If this widget does not support baseline alignment, this method returns -1.", "history": "Added in API level 1", "FullName": "public int getBaseline ()"}, "getHasOverlappingRendering()": {"Returns": [["boolean", "The value for overlapping rendering being used internally."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the value for overlapping rendering that is used internally. This is either the value passed into @B_android#view#View#forceHasOverlappingRendering_E@, if called, or the return value of @B_android#view#View#hasOverlappingRendering_E@, otherwise.", "history": "Added in API level 24", "FullName": "public final boolean getHasOverlappingRendering ()"}, "setActivated(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the view must be activated, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Changes the activated state of this view. A view can be activated or not. Note that activation is not the same as selection. Selection is a transient property, representing the view (hierarchy) the user is currently interacting with. Activation is a longer-term state that the user can move views in and out of. For example, in a list view with single or multiple selection enabled, the views in the current selection set are activated. (Um, yeah, we are deeply sorry about the terminology here.) The activated state is propagated down to children of the view it is set on.", "history": "Added in API level 11", "FullName": "public void setActivated (boolean activated)"}, "getDrawingCache(boolean)": {"Returns": [["@B_android#graphics#Bitmap_E@", "A bitmap representing this view or null if cache is disabled."]], "Parameters": [["boolean", "boolean: Indicates whether the generated bitmap should be scaled based on the current density of the screen when the application is in compatibility mode."]], "Throws": [], "SeeAlso": ["@B_android#view#View#setDrawingCacheEnabled_E@", "@B_android#view#View#isDrawingCacheEnabled_E@", "@B_android#view#View#buildDrawingCache_E@", "@B_android#view#View#destroyDrawingCache_E@"], "Permissions": [], "Description": "The view drawing cache was largely made obsolete with the introduction of hardware-accelerated rendering in API 11. With hardware-acceleration, intermediate cache layers are largely unnecessary and can easily result in a net loss in performance due to the cost of creating and updating the layer. In the rare cases where caching layers are useful, such as for alpha animations, @B_android#view#View#setLayerType_E@ handles this with hardware rendering. For software-rendered snapshots of a small part of the View hierarchy or individual Views it is recommended to create a @B_android#graphics#Canvas_E@ from either a @B_android#graphics#Bitmap_E@ or @B_android#graphics#Picture_E@ and call @B_android#view#View#draw_E@ on the View. However these software-rendered usages are discouraged and have compatibility issues with hardware-only rendering features such as @B_android#graphics#Bitmap#Config#HARDWARE_E@ bitmaps, real-time shadows, and outline clipping. For screenshots of the UI for feedback reports or unit testing the @B_android#view#PixelCopy_E@ API is recommended. Returns the bitmap in which this view drawing is cached. The returned bitmap is null when caching is disabled. If caching is enabled and the cache is not ready, this method will create it. Calling @B_android#view#View#draw_E@ will not draw from the cache when the cache is enabled. To benefit from the cache, you must request the drawing cache by calling this method and draw it on screen if the returned bitmap is not null. Note about auto scaling in compatibility mode: When auto scaling is not enabled, this method will create a bitmap of the same size as this view. Because this bitmap will be drawn scaled by the parent ViewGroup, the result on screen might show scaling artifacts. To avoid such artifacts, you should call this method by setting the auto scaling to true. Doing so, however, will generate a bitmap of a different size than the view. This implies that your application must be able to handle this size.", "history": "Added in API level 4 Deprecated in API level 28", "FullName": "public Bitmap getDrawingCache (boolean autoScale)"}, "setScrollIndicators(int,int)": {"Returns": [], "Parameters": [["int", "int: the indicator direction, or the logical OR of multiple indicator directions. One or more of: SCROLL_INDICATOR_TOP SCROLL_INDICATOR_BOTTOM SCROLL_INDICATOR_LEFT SCROLL_INDICATOR_RIGHT SCROLL_INDICATOR_START SCROLL_INDICATOR_END"], ["int", "int: Value is either 0 or a combination of @B_android#view#View#SCROLL_INDICATOR_TOP_E@, @B_android#view#View#SCROLL_INDICATOR_BOTTOM_E@, @B_android#view#View#SCROLL_INDICATOR_LEFT_E@, @B_android#view#View#SCROLL_INDICATOR_RIGHT_E@, @B_android#view#View#SCROLL_INDICATOR_START_E@, and @B_android#view#View#SCROLL_INDICATOR_END_E@"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setScrollIndicators_E@", "@B_android#view#View#getScrollIndicators_E@"], "Permissions": [], "Description": "Sets the state of the scroll indicators specified by the mask. To change all scroll indicators at once, see @B_android#view#View#setScrollIndicators_E@. When a scroll indicator is enabled, it will be displayed if the view can scroll in the direction of the indicator. Multiple indicator types may be enabled or disabled by passing the logical OR of the desired types. If multiple types are specified, they will all be set to the same enabled state. For example, to enable the top scroll indicatorExample: {@code setScrollIndicators", "history": "Added in API level 23", "FullName": "public void setScrollIndicators (int indicators, int mask)"}, "isFocused()": {"Returns": [["boolean", "True if this view has focus, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has focus", "history": "Added in API level 1", "FullName": "public boolean isFocused ()"}, "onSetAlpha(int)": {"Returns": [["boolean", "true if the view can draw with the specified alpha."]], "Parameters": [["int", "int: The alpha (0..255) to apply to the view's drawing"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Invoked if there is a Transform that involves alpha. Subclass that can draw themselves with the specified alpha should return true, and then respect that alpha when their onDraw() is called. If this returns false then the view may be redirected to draw into an offscreen buffer to fulfill the request, which will look fine, but may be slower than if the subclass handles it internally. The default implementation returns false.", "history": "Added in API level 1", "FullName": "protected boolean onSetAlpha (int alpha)"}, "getAccessibilityDelegate()": {"Returns": [["@B_android#view#View#AccessibilityDelegate_E@", "The delegate, or null if none set."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the delegate for implementing accessibility support via composition. For more details see @B_android#view#View#AccessibilityDelegate_E@.", "history": "Added in API level 29", "FullName": "public View.AccessibilityDelegate getAccessibilityDelegate ()"}, "restoreDefaultFocus()": {"Returns": [["boolean", "Whether this view or one of its descendants actually took focus"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gives focus to the default-focus view in the view hierarchy that has this view as a root. If the default-focus view cannot be found, falls back to calling @B_android#view#View#requestFocus_E@.", "history": "Added in API level 26", "FullName": "public boolean restoreDefaultFocus ()"}, "setLongClickable(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to make the view long clickable, false otherwise"]], "Throws": [], "SeeAlso": ["@B_android#view#View#isLongClickable_E@"], "Permissions": [], "Description": "Enables or disables long click events for this view. When a view is long clickable it reacts to the user holding down the button for a longer duration than a tap. This event can either launch the listener or a context menu.", "history": "Added in API level 1", "FullName": "public void setLongClickable (boolean longClickable)"}, "autofill(android.view.autofill.AutofillValue)": {"Returns": [], "Parameters": [["@B_android#view#autofill#AutofillValue_E@", "AutofillValue: value to be autofilled."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Automatically fills the content of this view with the value. Views support the Autofill Framework mainly by: Providing the metadata defining what the view means and how it can be autofilled. Implementing the methods that autofill the view. @B_android#view#View#onProvideAutofillStructure_E@ is responsible for the former, this method is responsible for latter. This method does nothing by default, but when overridden it typically: For example, a text-field view could implement the method this way: If the value is updated asynchronously, the next call to @B_android#view#autofill#AutofillManager#notifyValueChanged_E@ must happen @B_android#view#View#getAutofillValue_E@ must be equal to the value passed to it, otherwise the view will not be highlighted as autofilled.", "history": "Added in API level 26", "FullName": "public void autofill (AutofillValue value)"}, "getMeasuredState()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return only the state bits of @B_android#view#View#getMeasuredWidthAndState_E@ and @B_android#view#View#getMeasuredHeightAndState_E@, combined into one integer. The width component is in the regular bits @B_android#view#View#MEASURED_STATE_MASK_E@ and the height component is at the shifted bits @B_android#view#View#MEASURED_HEIGHT_STATE_SHIFT_E@>>@B_android#view#View#MEASURED_STATE_MASK_E@.", "history": "Added in API level 11", "FullName": "public final int getMeasuredState ()"}, "onVisibilityChanged(android.view.View,int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The view whose visibility changed. May be this or an ancestor view. This value must never be null."], ["int", "int: The new visibility, one of @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@ or @B_android#view#View#GONE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the visibility of the view or an ancestor of the view has changed.", "history": "Added in API level 8", "FullName": "protected void onVisibilityChanged (View changedView, int visibility)"}, "onKeyUp(int, android.view.KeyEvent)": {"Returns": [["boolean", "If you handled the event, return true. If you want to allow the event to be handled by the next receiver, return false."]], "Parameters": [["int", "int: A key code that represents the button pressed, from @B_android#view#KeyEvent_E@."], ["@B_android#view#KeyEvent_E@", "KeyEvent: The KeyEvent object that defines the button action."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Default implementation of @B_android#view#KeyEvent#Callback#onKeyUp_E@: perform clicking of the view when @B_android#view#KeyEvent#KEYCODE_DPAD_CENTER_E@, @B_android#view#KeyEvent#KEYCODE_ENTER_E@ or @B_android#view#KeyEvent#KEYCODE_SPACE_E@ is released. Key presses in software keyboards will generally NOT trigger this listener, although some may elect to do so in some situations. Do not rely on this to catch software key presses.", "history": "added in API level 1", "FullName": "public boolean onKeyUp (int keyCode, KeyEvent event)"}, "createAccessibilityNodeInfo()": {"Returns": [["@B_android#view#accessibility#AccessibilityNodeInfo_E@", "A populated @B_android#view#accessibility#AccessibilityNodeInfo_E@."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#accessibility#AccessibilityNodeInfo_E@"], "Permissions": [], "Description": "Returns an @B_android#view#accessibility#AccessibilityNodeInfo_E@ representing this view from the point of view of an @B_android#accessibilityservice#AccessibilityService_E@. This method is responsible for obtaining an accessibility node info from a pool of reusable instances and calling @B_android#view#View#onInitializeAccessibilityNodeInfo_E@ on this view to initialize the former. Note: The client is responsible for recycling the obtained instance by calling @B_android#view#accessibility#AccessibilityNodeInfo#recycle_E@ to minimize object creation.", "history": "Added in API level 14", "FullName": "public AccessibilityNodeInfo createAccessibilityNodeInfo ()"}, "hasFocusable()": {"Returns": [["boolean", "true if the view is focusable or if the view contains a focusable view, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#ViewGroup_E@", "@B_android#view#ViewGroup#getTouchscreenBlocksFocus_E@", "@B_android#view#View#hasExplicitFocusable_E@"], "Permissions": [], "Description": "Returns true if this view is focusable or if it contains a reachable View for which @B_android#view#View#hasFocusable_E@ returns true. A \"reachable hasFocusable()\" is a view whose parents do not block descendants focus. Only @B_android#view#View#VISIBLE_E@ views are considered focusable. As of @B_android#os#Build#VERSION_CODES#O_E@ views that are determined to be focusable through @B_android#view#View#FOCUSABLE_AUTO_E@ will also cause this method to return true. Apps that declare a @B_android#content#pm#ApplicationInfo#targetSdkVersion_E@ of earlier than @B_android#os#Build#VERSION_CODES#O_E@ will continue to see this method return false for views not explicitly marked as focusable. Use @B_android#view#View#hasExplicitFocusable_E@ if you require the pre-@B_android#os#Build#VERSION_CODES#O_E@ behavior.", "history": "Added in API level 1", "FullName": "public boolean hasFocusable ()"}, "postInvalidateOnAnimation(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: The left coordinate of the rectangle to invalidate."], ["int", "int: The top coordinate of the rectangle to invalidate."], ["int", "int: The right coordinate of the rectangle to invalidate."], ["int", "int: The bottom coordinate of the rectangle to invalidate."]], "Throws": [], "SeeAlso": ["@B_android#view#View#invalidate_E@"], "Permissions": [], "Description": "Cause an invalidate of the specified area to happen on the next animation time step, typically the next display frame. This method can be invoked from outside of the UI thread only when this View is attached to a window.", "history": "added in API level 16", "FullName": "public void postInvalidateOnAnimation (int left, int top, int right, int bottom)"}, "onScreenStateChanged(int)": {"Returns": [], "Parameters": [["int", "int: The new state of the screen. Can be either @B_android#view#View#SCREEN_STATE_ON_E@ or @B_android#view#View#SCREEN_STATE_OFF_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is called whenever the state of the screen this view is attached to changes. A state change will usually occurs when the screen turns on or off (whether it happens automatically or the user does it manually.)", "history": "Added in API level 16", "FullName": "public void onScreenStateChanged (int screenState)"}, "getExplicitStyle()": {"Returns": [["int", "The resource ID for the style specified using style=\"...\" in the @B_android#util#AttributeSet_E@'s backing XML element or @B_android#content#res#Resources#ID_NULL_E@ otherwise if not specified or otherwise not applicable."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the resource ID for the style specified using style=\"...\" in the @B_android#util#AttributeSet_E@'s backing XML element or @B_android#content#res#Resources#ID_NULL_E@ otherwise if not specified or otherwise not applicable. Each @B_android#view#View_E@ can have an explicit style specified in the layout file. This style is used first during the @B_android#view#View_E@ attribute resolution, then if an attribute is not defined there the resource system looks at default style and theme as fallbacks.", "history": "Added in API level 29", "FullName": "public int getExplicitStyle ()"}, "scrollTo(int, int)": {"Returns": [], "Parameters": [["int", "int: the x position to scroll to"], ["int", "int: the y position to scroll to"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated.", "history": "added in API level 1", "FullName": "public void scrollTo (int x, int y)"}, "setOutlineProvider(android.view.ViewOutlineProvider)": {"Returns": [], "Parameters": [["@B_android#view#ViewOutlineProvider_E@", "ViewOutlineProvider no parameter comment"]], "Throws": [], "SeeAlso": ["@B_android#view#View#setClipToOutline_E@", "@B_android#view#View#getClipToOutline_E@", "@B_android#view#View#getOutlineProvider_E@"], "Permissions": [], "Description": "Sets the @B_android#view#ViewOutlineProvider_E@ of the view, which generates the Outline that defines the shape of the shadow it casts, and enables outline clipping. The default ViewOutlineProvider, @B_android#view#ViewOutlineProvider#BACKGROUND_E@, queries the Outline from the View's background drawable, via @B_android#graphics#drawable#Drawable#getOutline_E@. Changing the outline provider with this method allows this behavior to be overridden. If the ViewOutlineProvider is null, if querying it for an outline returns false, or if the produced Outline is @B_android#graphics#Outline#isEmpty_E@, shadows will not be cast. Only outlines that return true from @B_android#graphics#Outline#canClip_E@ may be used for clipping.", "history": "Added in API level 21", "FullName": "public void setOutlineProvider (ViewOutlineProvider provider)"}, "isTextAlignmentResolved()": {"Returns": [["boolean", "true if text alignment is resolved."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 19", "FullName": "public boolean isTextAlignmentResolved ()"}, "postDelayed(java.lang.Runnable, long)": {"Returns": [["boolean", "true if the Runnable was successfully placed in to the message queue. Returns false on failure, usually because the looper processing the message queue is exiting. Note that a result of true does not mean the Runnable will be processed -- if the looper is quit before the delivery time of the message occurs then the message will be dropped."]], "Parameters": [["@B_java#lang#Runnable_E@", "Runnable: The Runnable that will be executed."], ["long", "long: The delay (in milliseconds) until the Runnable will be executed."]], "Throws": [], "SeeAlso": ["@B_android#view#View#post_E@", "@B_android#view#View#removeCallbacks_E@"], "Permissions": [], "Description": "Causes the Runnable to be added to the message queue, to be run after the specified amount of time elapses. The runnable will be run on the user interface thread.", "history": "added in API level 1", "FullName": "public boolean postDelayed (Runnable action, long delayMillis)"}, "hasNestedScrollingParent()": {"Returns": [["boolean", "whether this view has a nested scrolling parent"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has a nested scrolling parent. The presence of a nested scrolling parent indicates that this view has initiated a nested scroll and it was accepted by an ancestor view further up the view hierarchy.", "history": "Added in API level 21", "FullName": "public boolean hasNestedScrollingParent ()"}, "postInvalidate(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: The left coordinate of the rectangle to invalidate."], ["int", "int: The top coordinate of the rectangle to invalidate."], ["int", "int: The right coordinate of the rectangle to invalidate."], ["int", "int: The bottom coordinate of the rectangle to invalidate."]], "Throws": [], "SeeAlso": ["@B_android#view#View#invalidate_E@", "@B_android#view#View#postInvalidateDelayed_E@"], "Permissions": [], "Description": "Cause an invalidate of the specified area to happen on a subsequent cycle through the event loop. Use this to invalidate the View from a non-UI thread. This method can be invoked from outside of the UI thread only when this View is attached to a window.", "history": "added in API level 1", "FullName": "public void postInvalidate (int left, int top, int right, int bottom)"}, "isVerticalFadingEdgeEnabled()": {"Returns": [["boolean", "true if the vertical edges should are faded on scroll, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#view#View#setVerticalFadingEdgeEnabled_E@"], "Permissions": [], "Description": "Indicate whether the vertical edges are faded when the view is scrolled horizontally.", "history": "Added in API level 1", "FullName": "public boolean isVerticalFadingEdgeEnabled ()"}, "getTranslationX()": {"Returns": [["float", "The horizontal position of this view relative to its left position, in pixels."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The horizontal location of this view relative to its @B_android#view#View#getLeft_E@ position. This position is post-layout, in addition to wherever the object's layout placed it.", "history": "Added in API level 11", "FullName": "public float getTranslationX ()"}, "dispatchDisplayHint(int)": {"Returns": [], "Parameters": [["int", "int: A hint about whether or not this view is displayed: @B_android#view#View#VISIBLE_E@ or @B_android#view#View#INVISIBLE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a hint about whether this view is displayed. For instance, when a View moves out of the screen, it might receives a display hint indicating the view is not displayed. Applications should not rely on this hint as there is no guarantee that they will receive one.", "history": "Added in API level 8", "FullName": "public void dispatchDisplayHint (int hint)"}, "combineMeasuredStates(int, int)": {"Returns": [["int", "Returns a new integer reflecting the combination of the two states."]], "Parameters": [["int", "int: The current state as returned from a view or the result of combining multiple views."], ["int", "int: The new view state to combine."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Merge two states as returned by @B_android#view#View#getMeasuredState_E@.", "history": "added in API level 11", "FullName": "public static int combineMeasuredStates (int curState, int newState)"}, "getAccessibilityPaneTitle()": {"Returns": [["@B_java#lang#CharSequence_E@", "The current pane title. . This value may be null."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Get the title of the pane for purposes of accessibility.", "history": "Added in API level 28", "FullName": "public CharSequence getAccessibilityPaneTitle ()"}}, "Inheritance": [], "ClassName": "android.view.View", "ClassDesc": "This class represents the basic building block for user interface components. A View occupies a rectangular area on the screen and is responsible for drawing and event handling. View is the base class for widgets, which are used to create interactive UI components (buttons, text fields, etc.). The @B_android#view#ViewGroup_E@ subclass is the base class for layouts, which are invisible containers that hold other Views (or other ViewGroups) and define their layout properties. All of the views in a window are arranged in a single tree. You can add views either from code or by specifying a tree of views in one or more XML layout files. There are many specialized subclasses of views that act as controls or are capable of displaying text, images, or other content. Once you have created a tree of views, there are typically a few types of common operations you may wish to perform: @B_android#widget#TextView_E@. The available properties and the methods that set them will vary among the different subclasses of views. Note that properties that are known at build time can be set in the XML layout files. @B_android#view#View#requestFocus_E@. @B_android#view#View#setOnFocusChangeListener_E@. Other view subclasses offer more specialized listeners. For example, a Button exposes a listener to notify clients when the button is clicked. @B_android#view#View#setVisibility_E@. Note: The Android framework is responsible for measuring, laying out and drawing views. You should not call methods that perform these actions on views yourself unless you are actually implementing a @B_android#view#ViewGroup_E@. To implement a custom view, you will usually begin by providing overrides for some of the standard methods that the framework calls on all views. You do not need to override all of these methods. In fact, you can start by just overriding @B_android#view#View#onDraw_E@. Define a Button in the layout file and assign it a unique ID. From the onCreate method of an Activity, find the Button View IDs need not be unique throughout the tree, but it is good practice to ensure that they are at least unique within the part of the tree you are searching. The geometry of a view is that of a rectangle. A view has a location, expressed as a pair of left and top coordinates, and two dimensions, expressed as a width and a height. The unit for location and dimensions is the pixel. It is possible to retrieve the location of a view by invoking the methods @B_android#view#View#getLeft_E@ and @B_android#view#View#getTop_E@. The former returns the left, or X, coordinate of the rectangle representing the view. The latter returns the top, or Y, coordinate of the rectangle representing the view. These methods both return the location of the view relative to its parent. For instance, when getLeft() returns 20, that means the view is located 20 pixels to the right of the left edge of its direct parent. In addition, several convenience methods are offered to avoid unnecessary computations, namely @B_android#view#View#getRight_E@ and @B_android#view#View#getBottom_E@. These methods return the coordinates of the right and bottom edges of the rectangle representing the view. For instance, calling @B_android#view#View#getRight_E@ is similar to the following computation: getLeft() + getWidth() (see The size of a view is expressed with a width and a height. A view actually possess two pairs of width and height values. The first pair is known as measured width and measured height. These dimensions define how big a view wants to be within its parent (see @B_android#view#View#getMeasuredWidth_E@ and @B_android#view#View#getMeasuredHeight_E@. The second pair is simply known as width and height, or sometimes drawing width and drawing height. These dimensions define the actual size of the view on screen, at drawing time and after layout. These values may, but do not have to, be different from the measured width and height. The width and height can be obtained by calling @B_android#view#View#getWidth_E@ and @B_android#view#View#getHeight_E@. To measure its dimensions, a view takes into account its padding. The padding is expressed in pixels for the left, top, right and bottom parts of the view. Padding can be used to offset the content of the view by a specific amount of pixels. For instance, a left padding of 2 will push the view's content by 2 pixels to the right of the left edge. Padding can be set using the @B_android#view#View#setPadding_E@ or @B_android#view#View#setPaddingRelative_E@ method and queried by calling @B_android#view#View#getPaddingLeft_E@, @B_android#view#View#getPaddingTop_E@, @B_android#view#View#getPaddingRight_E@, @B_android#view#View#getPaddingBottom_E@, @B_android#view#View#getPaddingStart_E@, @B_android#view#View#getPaddingEnd_E@. Even though a view can define a padding, it does not provide any support for margins. However, view groups provide such a support. Refer to @B_android#view#ViewGroup_E@ and @B_android#view#ViewGroup#MarginLayoutParams_E@ for further information. Layout is a two pass process: a measure pass and a layout pass. The measuring pass is implemented in @B_android#view#View#measure_E@ and is a top-down traversal of the view tree. Each view pushes dimension specifications down the tree during the recursion. At the end of the measure pass, every view has stored its measurements. The second pass happens in @B_android#view#View#layout_E@ and is also top-down. During this pass each parent is responsible for positioning all of its children using the sizes computed in the measure pass. When a view's measure() method returns, its @B_android#view#View#getMeasuredWidth_E@ and @B_android#view#View#getMeasuredHeight_E@ values must be set, along with those for all of that view's descendants. A view's measured width and measured height values must respect the constraints imposed by the view's parents. This guarantees that at the end of the measure pass, all parents accept all of their children's measurements. A parent view may call measure() more than once on its children. For example, the parent may measure each child once with unspecified dimensions to find out how big they want to be, then call measure() on them again with actual numbers if the sum of all the children's unconstrained sizes is too big or too small. The measure pass uses two classes to communicate dimensions. The @B_android#view#View#MeasureSpec_E@ class is used by views to tell their parents how they want to be measured and positioned. The base LayoutParams class just describes how big the view wants to be for both width and height. For each dimension, it can specify one of: an exact number MATCH_PARENT, which means the view wants to be as big as its parent (minus padding) WRAP_CONTENT, which means that the view wants to be just big enough to enclose its content (plus padding). There are subclasses of LayoutParams for different subclasses of ViewGroup. For example, AbsoluteLayout has its own subclass of LayoutParams which adds an X and Y value. MeasureSpecs are used to push requirements down the tree from parent to child. A MeasureSpec can be in one of three modes: UNSPECIFIED: This is used by a parent to determine the desired dimension of a child view. For example, a LinearLayout may call measure() on its child with the height set to UNSPECIFIED and a width of EXACTLY 240 to find out how tall the child view wants to be given a width of 240 pixels. EXACTLY: This is used by the parent to impose an exact size on the child. The child must use this size, and guarantee that all of its descendants will fit within this size. AT_MOST: This is used by the parent to impose a maximum size on the child. The child must guarantee that it and all of its descendants will fit within this size. To initiate a layout, call @B_android#view#View#requestLayout_E@. This method is typically called by a view on itself when it believes that it can no longer fit within its current bounds. Drawing is handled by walking the tree and recording the drawing commands of any View that needs to update. After this, the drawing commands of the entire tree are issued to screen, clipped to the newly damaged area. The tree is largely recorded and drawn in order, with parents drawn before (i.e., behind) their children, with siblings drawn in the order they appear in the tree. If you set a background drawable for a View, then the View will draw it before calling back to its onDraw() method. The child drawing order can be overridden with @B_android#view#ViewGroup#setChildrenDrawingOrderEnabled_E@ in a ViewGroup, and with @B_android#view#View#setZ_E@ custom Z values} set on Views. To force a view to draw, call @B_android#view#View#invalidate_E@. The basic cycle of a view is as follows: Note: The entire view tree is single threaded. You must always be on the UI thread when calling any method on any view. If you are doing work on other threads and want to update the state of a view from that thread, you should use a @B_android#os#Handler_E@. The framework will handle routine focus movement in response to user input. This includes changing the focus as views are removed or hidden, or as new views become available. Views indicate their willingness to take focus through the @B_android#view#View#isFocusable_E@ method. To change whether a view can take focus, call @B_android#view#View#setFocusable_E@. When in touch mode (see notes below) views indicate whether they still would like focus via @B_android#view#View#isFocusableInTouchMode_E@ and can change this via @B_android#view#View#setFocusableInTouchMode_E@. Focus movement is based on an algorithm which finds the nearest neighbor in a given direction. In rare cases, the default algorithm may not match the intended behavior of the developer. In these situations, you can provide explicit overrides by using these XML attributes in the layout file: To get a particular view to take focus, call @B_android#view#View#requestFocus_E@. When a user is navigating a user interface via directional keys such as a D-pad, it is necessary to give focus to actionable items such as buttons so the user can see what will take input. If the device has touch capabilities, however, and the user begins interacting with the interface by touching it, it is no longer necessary to always highlight, or give focus to, a particular view. This motivates a mode for interaction named 'touch mode'. For a touch capable device, once the user touches the screen, the device will enter touch mode. From this point onward, only views for which @B_android#view#View#isFocusableInTouchMode_E@ is true will be focusable, such as text editing widgets. Other views that are touchable, like buttons, will not take focus when touched; they will only fire the on click listeners. Any time a user hits a directional key, such as a D-pad direction, the view device will exit touch mode, and find a view to take focus, so that the user may resume interacting with the user interface without touching the screen again. The touch mode state is maintained across @B_android#app#Activity_E@s. Call @B_android#view#View#isInTouchMode_E@ to see whether the device is currently in touch mode. The framework provides basic support for views that wish to internally scroll their content. This includes keeping track of the X and Y scroll offset as well as mechanisms for drawing scrollbars. See @B_android#view#View#scrollBy_E@, @B_android#view#View#scrollTo_E@, and @B_android#view#View#awakenScrollBars_E@ for more details. Unlike IDs, tags are not used to identify views. Tags are essentially an extra piece of information that can be associated with a view. They are most often used as a convenience to store data related to views in the views themselves rather than by putting them in a separate structure. Tags may be specified with character sequence values in layout XML as either a single tag using the @B_android#R#styleable#View_tag_E@ attribute or multiple tags using the <tag> child element: Tags may also be specified with arbitrary objects from code using @B_android#view#View#setTag_E@ or @B_android#view#View#setTag_E@. By default, Views are created using the theme of the Context object supplied to their constructor; however, a different theme may be specified by using the @B_android#R#styleable#View_theme_E@ attribute in layout XML or by passing a @B_android#view#ContextThemeWrapper_E@ to the constructor from code. When the @B_android#R#styleable#View_theme_E@ attribute is used in XML, the specified theme is applied on top of the inflation context's theme (see @B_android#view#LayoutInflater_E@) and used for the view itself as well as any child elements. In the following example, both views will be created using the Material dark color scheme; however, because an overlay theme is used which only defines a subset of attributes, the value of @B_android#R#styleable#Theme_colorAccent_E@ defined on the inflation context's theme (e.g. the Activity theme) will be preserved. The View class exposes an @B_android#view#View#ALPHA_E@ property, as well as several transform-related properties, such as @B_android#view#View#TRANSLATION_X_E@ and @B_android#view#View#TRANSLATION_Y_E@. These properties are available both in the @B_android#util#Property_E@ form as well as in similarly-named setter/getter methods (such as @B_android#view#View#setAlpha_E@ for @B_android#view#View#ALPHA_E@). These properties can be used to set persistent state associated with these rendering-related properties on the view. The properties and methods can also be used in conjunction with @B_android#animation#Animator_E@-based animations, described more in the Starting with Android 3.0, the preferred way of animating views is to use the @B_android#animation#package-summary_E@ package APIs. These @B_android#animation#Animator_E@-based classes change actual properties of the View object, such as @B_android#view#View#setAlpha_E@ and @B_android#view#View#setTranslationX_E@. This behavior is contrasted to that of the pre-3.0 @B_android#view#animation#Animation_E@-based classes, which instead animate only how the view is drawn on the display. In particular, the @B_android#view#ViewPropertyAnimator_E@ class makes animating these View properties particularly easy and efficient. Alternatively, you can use the pre-3.0 animation classes to animate how Views are rendered. You can attach an @B_android#view#animation#Animation_E@ object to a view using @B_android#view#View#setAnimation_E@ or @B_android#view#View#startAnimation_E@. The animation can alter the scale, rotation, translation and alpha of a view over time. If the animation is attached to a view that has children, the animation will affect the entire subtree rooted by that node. When an animation is started, the framework will take care of redrawing the appropriate views until the animation completes. Sometimes it is essential that an application be able to verify that an action is being performed with the full knowledge and consent of the user, such as granting a permission request, making a purchase or clicking on an advertisement. Unfortunately, a malicious application could try to spoof the user into performing these actions, unaware, by concealing the intended purpose of the view. As a remedy, the framework offers a touch filtering mechanism that can be used to improve the security of views that provide access to sensitive functionality. To enable touch filtering, call @B_android#view#View#setFilterTouchesWhenObscured_E@ or set the android:filterTouchesWhenObscured layout attribute to true. When enabled, the framework will discard touches that are received whenever the view's window is obscured by another visible window. As a result, the view will not receive touches whenever a toast, dialog or other window appears above the view's window. For more fine-grained control over security, consider overriding the @B_android#view#View#onFilterTouchEventForSecurity_E@ method to implement your own security policy. See also @B_android#view#MotionEvent#FLAG_WINDOW_IS_OBSCURED_E@."}