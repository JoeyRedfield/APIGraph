{"Functions": {"getPlaybackParams()": {"Returns": [["@B_android#media#PlaybackParams_E@", "the playback rate being used. This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal sync engine or the audio track has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Gets the playback rate using @B_android#media#PlaybackParams_E@.", "history": "Added in API level 23", "FullName": "public PlaybackParams getPlaybackParams ()"}, "setOnErrorListener(android.media.MediaSync.OnErrorListener,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaSync#OnErrorListener_E@", "MediaSync.OnErrorListener: The callback that will run. Use null to stop receiving callbacks. This value may be null."], ["@B_android#os#Handler_E@", "Handler: The Handler that will run the callback. Use null to use MediaSync's internal handler if it exists. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets an asynchronous callback for error events. This method can be called multiple times to update a previously set listener. If the handler is changed, undelivered notifications scheduled for the old handler may be dropped.", "history": "Added in API level 23", "FullName": "public void setOnErrorListener (MediaSync.OnErrorListener listener, Handler handler)"}, "setSurface(android.view.Surface)": {"Returns": [], "Parameters": [["@B_android#view#Surface_E@", "Surface: Specify a surface on which to render the video data. This value may be null."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the surface has been released, is invalid, or can not be connected."], ["@B_java#lang#IllegalStateException_E@", "if setting the surface is not supported, e.g. not in the Initialized state, or another surface has already been set."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the output surface for MediaSync. Currently, this is only supported in the Initialized state.", "history": "Added in API level 23", "FullName": "public void setSurface (Surface surface)"}, "queueAudio(java.nio.ByteBuffer,int,long)": {"Returns": [], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the buffer that holds the data to play. This buffer will be returned to the client via registered callback. This value must never be null."], ["int", "int: an integer used to identify audioData. It will be returned to the client along with audioData. This helps applications to keep track of audioData, e.g., it can be used to store the output buffer index used by the audio codec."], ["long", "long: the presentation timestamp in microseconds for the first frame in the buffer."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if audio track is not set or internal configureation has not been done correctly."]], "SeeAlso": [], "Permissions": [], "Description": "Queues the audio data asynchronously for playback (AudioTrack must be in streaming mode). If the audio track was flushed as a result of @B_android#media#MediaSync#flush_E@, it will be restarted.", "history": "Added in API level 23", "FullName": "public void queueAudio (ByteBuffer audioData, int bufferId, long presentationTimeUs)"}, "setAudioTrack(android.media.AudioTrack)": {"Returns": [], "Parameters": [["@B_android#media#AudioTrack_E@", "AudioTrack: Specify an AudioTrack through which to render the audio data. This value may be null."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the audioTrack has been released, or is invalid."], ["@B_java#lang#IllegalStateException_E@", "if setting the audio track is not supported, e.g. not in the Initialized state, or another audio track has already been set."]], "SeeAlso": [], "Permissions": [], "Description": "Sets the audio track for MediaSync. Currently, this is only supported in the Initialized state.", "history": "Added in API level 23", "FullName": "public void setAudioTrack (AudioTrack audioTrack)"}, "finalize()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by the garbage collector on an object when garbage collection determines that there are no more references to the object. A subclass overrides the finalize method to dispose of system resources or to perform other cleanup. The general contract of finalize is that it is invoked if and when the Java\u2122 virtual machine has determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, except as a result of an action taken by the finalization of some other object or class which is ready to be finalized. The finalize method may take any action, including making this object available again to other threads; the usual purpose of finalize, however, is to perform cleanup actions before the object is irrevocably discarded. For example, the finalize method for an object that represents an input/output connection might perform explicit I/O transactions to break the connection before the object is permanently discarded. The finalize method of class Object performs no special action; it simply returns normally. Subclasses of Object may override this definition. The Java programming language does not guarantee which thread will invoke the finalize method for any given object. It is guaranteed, however, that the thread that invokes finalize will not be holding any user-visible synchronization locks when finalize is invoked. If an uncaught exception is thrown by the finalize method, the exception is ignored and finalization of that object terminates. After the finalize method has been invoked for an object, no further action is taken until the Java virtual machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded. The finalize method is never invoked more than once by a Java virtual machine for any given object. Any exception thrown by the finalize method causes the finalization of this object to be halted, but is otherwise ignored.", "history": "Added in API level 23", "FullName": "protected void finalize ()"}, "queueAudio(java.nio.ByteBuffer, int, long)": {"Returns": [], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: the buffer that holds the data to play. This buffer will be returned to the client via registered callback.This value must never be null."], ["int", "int: an integer used to identify audioData. It will be returned to the client along with audioData. This helps applications to keep track of audioData, e.g., it can be used to store the output buffer index used by the audio codec."], ["long", "long: the presentation timestamp in microseconds for the first frame in the buffer."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if audio track is not set or internal configureation has not been done correctly."]], "SeeAlso": [], "Permissions": [], "Description": "Queues the audio data asynchronously for playback (AudioTrack must be in streaming mode). If the audio track was flushed as a result of @B_android#media#MediaSync#flush_E@, it will be restarted.", "history": "added in API level 23", "FullName": "public void queueAudio (ByteBuffer audioData, int bufferId, long presentationTimeUs)"}, "setCallback(android.media.MediaSync.Callback,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#media#MediaSync#Callback_E@", "MediaSync.Callback: The callback that will run. Use null to stop receiving callbacks. This value may be null."], ["@B_android#os#Handler_E@", "Handler: The Handler that will run the callback. Use null to use MediaSync's internal handler if it exists. This value may be null."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets an asynchronous callback for actionable MediaSync events. This method can be called multiple times to update a previously set callback. If the handler is changed, undelivered notifications scheduled for the old handler may be dropped.", "history": "Added in API level 23", "FullName": "public void setCallback (MediaSync.Callback cb, Handler handler)"}, "getTimestamp()": {"Returns": [["@B_android#media#MediaTimestamp_E@", "a MediaTimestamp object if a timestamp is available, or null if no timestamp is available, e.g. because the media player has not been initialized."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_android#media#MediaTimestamp_E@"], "Permissions": [], "Description": "Get current playback position. The MediaTimestamp represents how the media time correlates to the system time in a linear fashion using an anchor and a clock rate. During regular playback, the media time moves fairly constantly (though the anchor frame may be rebased to a current system time, the linear correlation stays steady). Therefore, this method does not need to be called often. To help users get current playback position, this method always anchors the timestamp to the current @B_java#lang#System#nanoTime_E@, so @B_android#media#MediaTimestamp#getAnchorMediaTimeUs_E@ can be used as current playback position.", "history": "Added in API level 23", "FullName": "public MediaTimestamp getTimestamp ()"}, "release()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Make sure you call this when you're done to free up any opened component instance instead of relying on the garbage collector to do this for you at some point in the future.", "history": "Added in API level 23", "FullName": "public void release ()"}, "createInputSurface()": {"Returns": [["@B_android#view#Surface_E@", "This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if not set, or another input surface has already been created."]], "SeeAlso": [], "Permissions": [], "Description": "Requests a Surface to use as the input. This may only be called after @B_android#media#MediaSync#setSurface_E@. The application is responsible for calling release() on the Surface when done.", "history": "Added in API level 23", "FullName": "public Surface createInputSurface ()"}, "flush()": {"Returns": [], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Flushes all buffers from the sync object. All pending unprocessed audio and video buffers are discarded. If an audio track was configured, it is flushed and stopped. If a video output surface was configured, the last frame queued to it is left on the frame. Queue a blank video frame to clear the surface, No callbacks are received for the flushed buffers.", "history": "Added in API level 23", "FullName": "public void flush ()"}, "getSyncParams()": {"Returns": [["@B_android#media#SyncParams_E@", "the A/V sync params This value will never be null."]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Gets the A/V sync mode.", "history": "Added in API level 23", "FullName": "public SyncParams getSyncParams ()"}, "setSyncParams(android.media.SyncParams)": {"Returns": [], "Parameters": [["@B_android#media#SyncParams_E@", "SyncParams: the A/V sync params to apply This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal player engine has not been initialized."], ["@B_java#lang#IllegalArgumentException_E@", "if params are not supported."]], "SeeAlso": [], "Permissions": [], "Description": "Sets A/V sync mode.", "history": "Added in API level 23", "FullName": "public void setSyncParams (SyncParams params)"}, "setPlaybackParams(android.media.PlaybackParams)": {"Returns": [], "Parameters": [["@B_android#media#PlaybackParams_E@", "PlaybackParams: the playback params to use. @B_android#media#PlaybackParams#getSpeed_E@ is the ratio between desired playback rate and normal one. 1.0 means normal playback speed. 0.0 means pause. Value larger than 1.0 means faster playback, while value between 0.0 and 1.0 for slower playback. Note: the normal rate does not change as a result of this call. To restore the original rate at any time, use speed of 1.0. This value must never be null."]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if the internal sync engine or the audio track has not been initialized."], ["@B_java#lang#IllegalArgumentException_E@", "if the params are not supported."]], "SeeAlso": [], "Permissions": [], "Description": "Sets playback rate using @B_android#media#PlaybackParams_E@. When using MediaSync with @B_android#media#AudioTrack_E@, set playback params using this call instead of calling it directly on the track, so that the sync is aware of the params change. This call also works if there is no audio track.", "history": "Added in API level 23", "FullName": "public void setPlaybackParams (PlaybackParams params)"}, "MediaSync()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Class constructor. On creation, MediaSync is paused, i.e., playback rate is 0.0f.", "history": "Added in API level 23", "FullName": "public MediaSync ()"}}, "Inheritance": [], "ClassName": "android.media.MediaSync", "ClassDesc": "MediaSync class can be used to synchronously play audio and video streams. It can be used to play audio-only or video-only stream, too. MediaSync is generally used like this: For video, the client needs to call @B_android#media#MediaSync#createInputSurface_E@ to obtain a surface on which it will render video frames. For audio, the client needs to set up audio track correctly, e.g., using @B_android#media#AudioTrack#MODE_STREAM_E@. The audio buffers are sent to MediaSync directly via @B_android#media#MediaSync#queueAudio_E@, and are returned to the client via @B_android#media#MediaSync#Callback#onAudioBufferConsumed_E@ asynchronously. The client should not modify an audio buffer till it's returned. The client can optionally pre-fill audio/video buffers by setting playback rate to 0.0, and then feed audio/video buffers to corresponding components. This can reduce possible initial underrun."}