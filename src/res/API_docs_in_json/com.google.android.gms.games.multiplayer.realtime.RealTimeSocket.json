{"Functions": {"getParcelFileDescriptor()": {"Returns": [["", "An instance of @B_android#os#ParcelFileDescriptor_E@ or null if the underlying socket is closed."]], "Parameters": [], "Throws": [["IOException", "in case of error."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the underlying file descriptor for direct read/write access. Calling close() on the returned ParcelFileDescriptor will close the socket.", "history": "", "FullName": "public abstract ParcelFileDescriptor getParcelFileDescriptor ()"}, "getOutputStream()": {"Returns": [["", "An instance of @B_java#io#OutputStream_E@."]], "Parameters": [], "Throws": [["IOException", "on error."]], "SeeAlso": [], "Permissions": [], "Description": "Instance of @B_java#io#OutputStream_E@ to write data to. Calling @B_java#io#OutputStream#close_E@ on the OutputStream will close the socket. Note: The maximum (unfragmented) packet size supported through this API is @B_com#google#android#gms#games#multiplayer#Multiplayer#MAX_UNRELIABLE_MESSAGE_LEN_E@ bytes (excluding internal protocol headers). Make sure that the byte[] data passed to @B_java#io#OutputStream#write_E@ honors this limit - otherwise the packet will be dropped and an error message will be sent to the log. Do not call flush() on the OutputStream instance that you obtained from this routine. To send each message as a single datagram, implement your own message parsing logic to distinguish message boundaries. This allows partial messages and a non-integral number of messages to be delivered using RealTimeSocket.", "history": "", "FullName": "public abstract OutputStream getOutputStream ()"}, "getInputStream()": {"Returns": [["", "An instance of @B_java#io#InputStream_E@."]], "Parameters": [], "Throws": [["IOException", "on error."]], "SeeAlso": [], "Permissions": [], "Description": "Use this to read data from this socket. Calling close() on the InputStream will close the socket.", "history": "", "FullName": "public abstract InputStream getInputStream ()"}, "isClosed()": {"Returns": [["", "True if the socket is closed."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Use this to check if the socket is closed.", "history": "", "FullName": "public abstract boolean isClosed ()"}, "close()": {"Returns": [], "Parameters": [], "Throws": [["IOException", "on error."]], "SeeAlso": [], "Permissions": [], "Description": "Closes this real-time socket connection with the participant.", "history": "", "FullName": "public abstract void close ()"}}, "Inheritance": [], "ClassName": "com.google.android.gms.games.multiplayer.realtime.RealTimeSocket", "ClassDesc": "Deprecated in favor of @B_com#google#android#gms#games#multiplayer#realtime#RealTimeMultiplayer#sendUnreliableMessage_E@ Provides a Socket-like interface for a real-time data connection to a participant in a real-time room. Use @B_com#google#android#gms#games#multiplayer#realtime#RealTimeMultiplayer#getSocketForParticipant_E@ to get an instance. Use @B_com#google#android#gms#games#multiplayer#realtime#RealTimeSocket#getParcelFileDescriptor_E@ to get a file descriptor for read/write, or use @B_com#google#android#gms#games#multiplayer#realtime#RealTimeSocket#getInputStream_E@ / @B_com#google#android#gms#games#multiplayer#realtime#RealTimeSocket#getOutputStream_E@ to get access to an instance of @B_java#io#InputStream_E@ or @B_java#io#OutputStream_E@ respectively. Calling close() on any of (i) the returned @B_android#os#ParcelFileDescriptor_E@ or, (ii) the @B_java#io#InputStream_E@ or @B_java#io#OutputStream_E@ instances will close the socket. The Socket-like interface provided is currently modeled on connection-based byte streams, rather than preserving packet semantics. That is, multiple writes may be coalesced or individual writes divided. Clients should avoid calling @B_java#io#OutputStream#write_E@ with more than @B_com#google#android#gms#games#multiplayer#Multiplayer#MAX_UNRELIABLE_MESSAGE_LEN_E@ bytes at a time."}