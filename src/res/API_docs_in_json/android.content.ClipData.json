{"Functions": {"getItemCount()": {"Returns": [["int", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the number of items in the clip data.", "history": "Added in API level 11", "FullName": "public int getItemCount ()"}, "writeToParcel(android.os.Parcel, int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "added in API level 11", "FullName": "public void writeToParcel (Parcel dest, int flags)"}, "newHtmlText(java.lang.CharSequence,java.lang.CharSequence,java.lang.String)": {"Returns": [["@B_android#content#ClipData_E@", "Returns a new ClipData containing the specified data."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: User-visible label for the clip data."], ["@B_java#lang#CharSequence_E@", "CharSequence: The text of clip as plain text, for receivers that don't handle HTML. This is required."], ["@B_java#lang#String_E@", "String: The actual HTML text in the clip."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new ClipData holding data of the type @B_android#content#ClipDescription#MIMETYPE_TEXT_HTML_E@.", "history": "Added in API level 16", "FullName": "public static ClipData newHtmlText (CharSequence label, CharSequence text, String htmlText)"}, "newPlainText(java.lang.CharSequence,java.lang.CharSequence)": {"Returns": [["@B_android#content#ClipData_E@", "Returns a new ClipData containing the specified data."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: User-visible label for the clip data."], ["@B_java#lang#CharSequence_E@", "CharSequence: The actual text in the clip."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new ClipData holding data of the type @B_android#content#ClipDescription#MIMETYPE_TEXT_PLAIN_E@.", "history": "Added in API level 11", "FullName": "public static ClipData newPlainText (CharSequence label, CharSequence text)"}, "getDescription()": {"Returns": [["@B_android#content#ClipDescription_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the @B_android#content#ClipDescription_E@ associated with this data, describing what it contains.", "history": "Added in API level 11", "FullName": "public ClipDescription getDescription ()"}, "newRawUri(java.lang.CharSequence,android.net.Uri)": {"Returns": [["@B_android#content#ClipData_E@", "Returns a new ClipData containing the specified data."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: User-visible label for the clip data."], ["@B_android#net#Uri_E@", "Uri: The URI in the clip."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new ClipData holding an URI with MIME type @B_android#content#ClipDescription#MIMETYPE_TEXT_URILIST_E@. Unlike @B_android#content#ClipData#newUri_E@, nothing is inferred about the URI -- if it is a content: URI holding a bitmap, the reported type will still be uri-list. Use this with care!", "history": "Added in API level 11", "FullName": "public static ClipData newRawUri (CharSequence label, Uri uri)"}, "newRawUri(java.lang.CharSequence, android.net.Uri)": {"Returns": [["@B_android#content#ClipData_E@", "Returns a new ClipData containing the specified data."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: User-visible label for the clip data."], ["@B_android#net#Uri_E@", "Uri: The URI in the clip."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new ClipData holding an URI with MIME type @B_android#content#ClipDescription#MIMETYPE_TEXT_URILIST_E@. Unlike @B_android#content#ClipData#newUri_E@, nothing is inferred about the URI -- if it is a content: URI holding a bitmap, the reported type will still be uri-list. Use this with care!", "history": "added in API level 11", "FullName": "public static ClipData newRawUri (CharSequence label, Uri uri)"}, "newUri(android.content.ContentResolver,java.lang.CharSequence,android.net.Uri)": {"Returns": [["@B_android#content#ClipData_E@", "Returns a new ClipData containing the specified data."]], "Parameters": [["@B_android#content#ContentResolver_E@", "ContentResolver: ContentResolver used to get information about the URI."], ["@B_java#lang#CharSequence_E@", "CharSequence: User-visible label for the clip data."], ["@B_android#net#Uri_E@", "Uri: The URI in the clip."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new ClipData holding a URI. If the URI is a content: URI, this will query the content provider for the MIME type of its data and use that as the MIME type. Otherwise, it will use the MIME type @B_android#content#ClipDescription#MIMETYPE_TEXT_URILIST_E@.", "history": "Added in API level 11", "FullName": "public static ClipData newUri (ContentResolver resolver, CharSequence label, Uri uri)"}, "describeContents()": {"Returns": [["int", "a bitmask indicating the set of special object types marshaled by this Parcelable object instance. Value is either 0 or @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Describe the kinds of special objects contained in this Parcelable instance's marshaled representation. For example, if the object will include a file descriptor in the output of @B_android#os#Parcelable#writeToParcel_E@, the return value of this method must include the @B_android#os#Parcelable#CONTENTS_FILE_DESCRIPTOR_E@ bit.", "history": "Added in API level 11", "FullName": "public int describeContents ()"}, "toString()": {"Returns": [["@B_java#lang#String_E@", "a string representation of the object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a string representation of the object. In general, the toString method returns a string that \"textually represents\" this object. The result should be a concise but informative representation that is easy for a person to read. It is recommended that all subclasses override this method. The toString method for class Object returns a string consisting of the name of the class of which the object is an instance, the at-sign character `@', and the unsigned hexadecimal representation of the hash code of the object. In other words, this method returns a string equal to the value of:", "history": "Added in API level 11", "FullName": "public String toString ()"}, "ClipData(android.content.ClipData)": {"Returns": [], "Parameters": [["@B_android#content#ClipData_E@", "ClipData: The existing ClipData that is to be copied."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new clip that is a copy of another clip. This does a deep-copy of all items in the clip.", "history": "Added in API level 16", "FullName": "public ClipData (ClipData other)"}, "ClipData(android.content.ClipDescription,android.content.ClipData.Item)": {"Returns": [], "Parameters": [["@B_android#content#ClipDescription_E@", "ClipDescription: The ClipDescription describing the clip contents."], ["@B_android#content#ClipData#Item_E@", "ClipData.Item: The contents of the first item in the clip."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new clip.", "history": "Added in API level 11", "FullName": "public ClipData (ClipDescription description, ClipData.Item item)"}, "newIntent(java.lang.CharSequence,android.content.Intent)": {"Returns": [["@B_android#content#ClipData_E@", "Returns a new ClipData containing the specified data."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: User-visible label for the clip data."], ["@B_android#content#Intent_E@", "Intent: The actual Intent in the clip."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new ClipData holding an Intent with MIME type @B_android#content#ClipDescription#MIMETYPE_TEXT_INTENT_E@.", "history": "Added in API level 11", "FullName": "public static ClipData newIntent (CharSequence label, Intent intent)"}, "ClipData(java.lang.CharSequence,java.lang.String[],android.content.ClipData.Item)": {"Returns": [], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: Label to show to the user describing this clip."], ["@B_java#lang#String_E@", "String: An array of MIME types this data is available as."], ["@B_android#content#ClipData#Item_E@", "ClipData.Item: The contents of the first item in the clip."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a new clip.", "history": "Added in API level 11", "FullName": "public ClipData (CharSequence label, String[] mimeTypes, ClipData.Item item)"}, "getItemAt(int)": {"Returns": [["@B_android#content#ClipData#Item_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a single item inside of the clip data. The index can range from 0 to @B_android#content#ClipData#getItemCount_E@-1.", "history": "Added in API level 11", "FullName": "public ClipData.Item getItemAt (int index)"}, "addItem(android.content.ContentResolver,android.content.ClipData.Item)": {"Returns": [], "Parameters": [["@B_android#content#ContentResolver_E@", "ContentResolver: ContentResolver used to get information about the URI possibly contained in the item."], ["@B_android#content#ClipData#Item_E@", "ClipData.Item: Item to be added."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add a new Item to the overall ClipData container. Unlike @B_android#content#ClipData#addItem_E@, this method will update the list of available MIME types in the @B_android#content#ClipDescription_E@.", "history": "Added in API level 26", "FullName": "public void addItem (ContentResolver resolver, ClipData.Item item)"}, "writeToParcel(android.os.Parcel,int)": {"Returns": [], "Parameters": [["@B_android#os#Parcel_E@", "Parcel: The Parcel in which the object should be written."], ["int", "int: Additional flags about how the object should be written. May be 0 or @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@. Value is either 0 or a combination of @B_android#os#Parcelable#PARCELABLE_WRITE_RETURN_VALUE_E@, and android.os.Parcelable.PARCELABLE_ELIDE_DUPLICATES"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Flatten this object in to a Parcel.", "history": "Added in API level 11", "FullName": "public void writeToParcel (Parcel dest, int flags)"}, "addItem(android.content.ClipData.Item)": {"Returns": [], "Parameters": [["@B_android#content#ClipData#Item_E@", "ClipData.Item: Item to be added."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Add a new Item to the overall ClipData container. This method will not update the list of available MIME types in the @B_android#content#ClipDescription_E@. It should be used only when adding items which do not add new MIME types to this clip. If this is not the case, use @B_android#content#ClipData#addItem_E@ or call @B_android#content#ClipData#ClipData_E@ with a complete list of MIME types.", "history": "Added in API level 11", "FullName": "public void addItem (ClipData.Item item)"}}, "Inheritance": [], "ClassName": "android.content.ClipData", "ClassDesc": "Representation of a clipped data on the clipboard. ClipData is a complex type containing one or more Item instances, each of which can hold one or more representations of an item of data. For display to the user, it also has a label. A ClipData contains a @B_android#content#ClipDescription_E@, which describes important meta-data about the clip. In particular, its @B_android#content#ClipDescription#getMimeType_E@ must return correct MIME type(s) describing the data in the clip. For help in correctly constructing a clip with the correct MIME type, use @B_android#content#ClipData#newPlainText_E@, @B_android#content#ClipData#newUri_E@, and @B_android#content#ClipData#newIntent_E@. Each Item instance can be one of three main classes of data: a simple CharSequence of text, a single Intent object, or a Uri. See @B_android#content#ClipData#Item_E@ for more details. To implement a paste or drop of a ClipData object into an application, the application must correctly interpret the data for its use. If the @B_android#content#ClipData#Item_E@ it contains is simple text or an Intent, there is little to be done: text can only be interpreted as text, and an Intent will typically be used for creating shortcuts (such as placing icons on the home screen) or other actions. If all you want is the textual representation of the clipped data, you can use the convenience method @B_android#content#ClipData#Item#coerceToText_E@. In this case there is generally no need to worry about the MIME types reported by @B_android#content#ClipDescription#getMimeType_E@, since any clip item can always be converted to a string. More complicated exchanges will be done through URIs, in particular \"content:\" URIs. A content URI allows the recipient of a ClipData item to interact closely with the ContentProvider holding the data in order to negotiate the transfer of that data. The clip must also be filled in with the available MIME types; @B_android#content#ClipData#newUri_E@ will take care of correctly doing this. For example, here is the paste function of a simple NotePad application. When retrieving the data from the clipboard, it can do either two things: if the clipboard contains a URI reference to an existing note, it copies the entire structure of the note into a new note; otherwise, it simply coerces the clip into text and uses that as the new note's contents. In many cases an application can paste various types of streams of data. For example, an e-mail application may want to allow the user to paste an image or other binary data as an attachment. This is accomplished through the ContentResolver @B_android#content#ContentResolver#getStreamTypes_E@ and @B_android#content#ContentResolver#openTypedAssetFileDescriptor_E@ methods. These allow a client to discover the type(s) of data that a particular content URI can make available as a stream and retrieve the stream of data. For example, the implementation of @B_android#content#ClipData#Item#coerceToText_E@ itself uses this to try to retrieve a URI clip as a stream of text: To be the source of a clip, the application must construct a ClipData object that any recipient can interpret best for their context. If the clip is to contain a simple text, Intent, or URI, this is easy: an @B_android#content#ClipData#Item_E@ containing the appropriate data type can be constructed and used. More complicated data types require the implementation of support in a ContentProvider for describing and generating the data for the recipient. A common scenario is one where an application places on the clipboard the content: URI of an object that the user has copied, with the data at that URI consisting of a complicated structure that only other applications with direct knowledge of the structure can use. For applications that do not have intrinsic knowledge of the data structure, the content provider holding it can make the data available as an arbitrary number of types of data streams. This is done by implementing the ContentProvider @B_android#content#ContentProvider#getStreamTypes_E@ and @B_android#content#ContentProvider#openTypedAssetFile_E@ methods. Going back to our simple NotePad application, this is the implementation it may have to convert a single note URI (consisting of a title and the note text) into a stream of plain text data. The copy operation in our NotePad application is now just a simple matter of making a clip containing the URI of the note being copied: Note if a paste operation needs this clip as text (for example to paste into an editor), then @B_android#content#ClipData#Item#coerceToText_E@ will ask the content provider for the clip URI as text and successfully paste the entire note."}