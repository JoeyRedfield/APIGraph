{"Functions": {"countIn(java.lang.CharSequence,android.icu.text.UnicodeSetSpanner.CountMethod,android.icu.text.UnicodeSet.SpanCondition)": {"Returns": [["int", "the count. Zero if there are none."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the sequence to count characters in"], ["@B_android#icu#text#UnicodeSetSpanner#CountMethod_E@", "UnicodeSetSpanner.CountMethod: whether to treat an entire span as a match, or individual elements as matches"], ["@B_android#icu#text#UnicodeSet#SpanCondition_E@", "UnicodeSet.SpanCondition: the spanCondition to use. SIMPLE or CONTAINED means only count the elements in the span; NOT_CONTAINED is the reverse. WARNING: when a UnicodeSet contains strings, there may be unexpected behavior in edge cases."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the number of matching characters found in a character sequence. The code alternates spans; see the class doc for @B_android#icu#text#UnicodeSetSpanner_E@ for a note about boundary conditions.", "history": "Added in API level 24", "FullName": "public int countIn (CharSequence sequence, UnicodeSetSpanner.CountMethod countMethod, UnicodeSet.SpanCondition spanCondition)"}, "hashCode()": {"Returns": [["int", "a hash code value for this object."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a hash code value for the object. This method is supported for the benefit of hash tables such as those provided by @B_java#util#HashMap_E@. The general contract of hashCode is: Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application. If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result. It is not required that if two objects are unequal according to the @B_java#lang#Object#equals_E@ method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables. As much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java\u2122 programming language.)", "history": "Added in API level 24", "FullName": "public int hashCode ()"}, "deleteFrom(java.lang.CharSequence,android.icu.text.UnicodeSet.SpanCondition)": {"Returns": [["@B_java#lang#String_E@", "modified string."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: charsequence to replace matching spans in."], ["@B_android#icu#text#UnicodeSet#SpanCondition_E@", "UnicodeSet.SpanCondition: specify whether to modify the matching spans (CONTAINED or SIMPLE) or the non-matching (NOT_CONTAINED)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Delete all matching spans in sequence, according to the spanCondition. The code alternates spans; see the class doc for @B_android#icu#text#UnicodeSetSpanner_E@ for a note about boundary conditions.", "history": "Added in API level 24", "FullName": "public String deleteFrom (CharSequence sequence, UnicodeSet.SpanCondition spanCondition)"}, "replaceFrom(java.lang.CharSequence,java.lang.CharSequence,android.icu.text.UnicodeSetSpanner.CountMethod)": {"Returns": [["@B_java#lang#String_E@", "modified string."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: charsequence to replace matching spans in."], ["@B_java#lang#CharSequence_E@", "CharSequence: replacement sequence. To delete, use \"\""], ["@B_android#icu#text#UnicodeSetSpanner#CountMethod_E@", "UnicodeSetSpanner.CountMethod: whether to treat an entire span as a match, or individual elements as matches"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Replace all matching spans in sequence by replacement, according to the CountMethod, using SpanCondition.SIMPLE. The code alternates spans; see the class doc for @B_android#icu#text#UnicodeSetSpanner_E@ for a note about boundary conditions.", "history": "Added in API level 24", "FullName": "public String replaceFrom (CharSequence sequence, CharSequence replacement, UnicodeSetSpanner.CountMethod countMethod)"}, "replaceFrom(java.lang.CharSequence,java.lang.CharSequence,android.icu.text.UnicodeSetSpanner.CountMethod,android.icu.text.UnicodeSet.SpanCondition)": {"Returns": [["@B_java#lang#String_E@", "modified string."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: charsequence to replace matching spans in."], ["@B_java#lang#CharSequence_E@", "CharSequence: replacement sequence. To delete, use \"\""], ["@B_android#icu#text#UnicodeSetSpanner#CountMethod_E@", "UnicodeSetSpanner.CountMethod: whether to treat an entire span as a match, or individual elements as matches"], ["@B_android#icu#text#UnicodeSet#SpanCondition_E@", "UnicodeSet.SpanCondition: specify whether to modify the matching spans (CONTAINED or SIMPLE) or the non-matching (NOT_CONTAINED)"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition. The code alternates spans; see the class doc for @B_android#icu#text#UnicodeSetSpanner_E@ for a note about boundary conditions.", "history": "Added in API level 24", "FullName": "public String replaceFrom (CharSequence sequence, CharSequence replacement, UnicodeSetSpanner.CountMethod countMethod, UnicodeSet.SpanCondition spanCondition)"}, "UnicodeSetSpanner(android.icu.text.UnicodeSet)": {"Returns": [], "Parameters": [["@B_android#icu#text#UnicodeSet_E@", "UnicodeSet: the original UnicodeSet"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Create a spanner from a UnicodeSet. For speed and safety, the UnicodeSet should be frozen. However, this class can be used with a non-frozen version to avoid the cost of freezing.", "history": "Added in API level 24", "FullName": "public UnicodeSetSpanner (UnicodeSet source)"}, "trim(java.lang.CharSequence,android.icu.text.UnicodeSetSpanner.TrimOption)": {"Returns": [["@B_java#lang#CharSequence_E@", "a subsequence"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the sequence to trim"], ["@B_android#icu#text#UnicodeSetSpanner#TrimOption_E@", "UnicodeSetSpanner.TrimOption: LEADING, TRAILING, or BOTH"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a trimmed sequence (using CharSequence.subsequence()), that omits matching elements at the start or end of the string, using the trimOption and SpanCondition.SIMPLE. For example: \"catbab\".", "history": "Added in API level 24", "FullName": "public CharSequence trim (CharSequence sequence, UnicodeSetSpanner.TrimOption trimOption)"}, "countIn(java.lang.CharSequence)": {"Returns": [["int", "the count. Zero if there are none."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the sequence to count characters in"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the number of matching characters found in a character sequence, counting by CountMethod.MIN_ELEMENTS using SpanCondition.SIMPLE. The code alternates spans; see the class doc for @B_android#icu#text#UnicodeSetSpanner_E@ for a note about boundary conditions.", "history": "Added in API level 24", "FullName": "public int countIn (CharSequence sequence)"}, "getUnicodeSet()": {"Returns": [["@B_android#icu#text#UnicodeSet_E@", "the construction set."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the UnicodeSet used for processing. It is frozen iff the original was.", "history": "Added in API level 24", "FullName": "public UnicodeSet getUnicodeSet ()"}, "trim(java.lang.CharSequence)": {"Returns": [["@B_java#lang#CharSequence_E@", "a subsequence"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the sequence to trim"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a trimmed sequence (using CharSequence.subsequence()), that omits matching elements at the start and end of the string, using TrimOption.BOTH and SpanCondition.SIMPLE. For example: \"cat\".", "history": "Added in API level 24", "FullName": "public CharSequence trim (CharSequence sequence)"}, "equals(java.lang.Object)": {"Returns": [["boolean", "true if this object is the same as the obj argument; false otherwise."]], "Parameters": [["@B_java#lang#Object_E@", "Object: the reference object with which to compare."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether some other object is \"equal to\" this one. The equals method implements an equivalence relation on non-null object references: It is x, x.equals(x) should return true. It is x and y, x.equals(y) should return true if and only if y.equals(x) returns true. It is x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. It is x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified. For any non-null reference value x, x.equals(null) should return false. The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true). Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.", "history": "Added in API level 24", "FullName": "public boolean equals (Object other)"}, "deleteFrom(java.lang.CharSequence)": {"Returns": [["@B_java#lang#String_E@", "modified string."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: charsequence to replace matching spans in."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Delete all the matching spans in sequence, using SpanCondition.SIMPLE The code alternates spans; see the class doc for @B_android#icu#text#UnicodeSetSpanner_E@ for a note about boundary conditions.", "history": "Added in API level 24", "FullName": "public String deleteFrom (CharSequence sequence)"}, "replaceFrom(java.lang.CharSequence,java.lang.CharSequence)": {"Returns": [["@B_java#lang#String_E@", "modified string."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: charsequence to replace matching spans in."], ["@B_java#lang#CharSequence_E@", "CharSequence: replacement sequence. To delete, use \"\""]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Replace all matching spans in sequence by the replacement, counting by CountMethod.MIN_ELEMENTS using SpanCondition.SIMPLE. The code alternates spans; see the class doc for @B_android#icu#text#UnicodeSetSpanner_E@ for a note about boundary conditions.", "history": "Added in API level 24", "FullName": "public String replaceFrom (CharSequence sequence, CharSequence replacement)"}, "trim(java.lang.CharSequence,android.icu.text.UnicodeSetSpanner.TrimOption,android.icu.text.UnicodeSet.SpanCondition)": {"Returns": [["@B_java#lang#CharSequence_E@", "a subsequence"]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the sequence to trim"], ["@B_android#icu#text#UnicodeSetSpanner#TrimOption_E@", "UnicodeSetSpanner.TrimOption: LEADING, TRAILING, or BOTH"], ["@B_android#icu#text#UnicodeSet#SpanCondition_E@", "UnicodeSet.SpanCondition: SIMPLE, CONTAINED or NOT_CONTAINED"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a trimmed sequence (using CharSequence.subsequence()), that omits matching elements at the start or end of the string, depending on the trimOption and spanCondition. For example: \"catbab\".", "history": "Added in API level 24", "FullName": "public CharSequence trim (CharSequence sequence, UnicodeSetSpanner.TrimOption trimOption, UnicodeSet.SpanCondition spanCondition)"}, "countIn(java.lang.CharSequence,android.icu.text.UnicodeSetSpanner.CountMethod)": {"Returns": [["int", "the count. Zero if there are none."]], "Parameters": [["@B_java#lang#CharSequence_E@", "CharSequence: the sequence to count characters in"], ["@B_android#icu#text#UnicodeSetSpanner#CountMethod_E@", "UnicodeSetSpanner.CountMethod: whether to treat an entire span as a match, or individual elements as matches"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the number of matching characters found in a character sequence, using SpanCondition.SIMPLE. The code alternates spans; see the class doc for @B_android#icu#text#UnicodeSetSpanner_E@ for a note about boundary conditions.", "history": "Added in API level 24", "FullName": "public int countIn (CharSequence sequence, UnicodeSetSpanner.CountMethod countMethod)"}}, "Inheritance": [], "ClassName": "android.icu.text.UnicodeSetSpanner", "ClassDesc": "A helper class used to count, replace, and trim CharSequences based on UnicodeSet matches. An instance is immutable (and thus thread-safe) iff the source UnicodeSet is frozen. @B_android#icu#text#UnicodeSet#SpanCondition_E@ with its inverse. That is, the code spans, then spans for the inverse, then spans, and so on. For the inverse, the following mapping is used: @B_android#icu#text#UnicodeSet#SpanCondition#SIMPLE_E@ \u2192 @B_android#icu#text#UnicodeSet#SpanCondition#NOT_CONTAINED_E@ @B_android#icu#text#UnicodeSet#SpanCondition#CONTAINED_E@ \u2192 @B_android#icu#text#UnicodeSet#SpanCondition#NOT_CONTAINED_E@ @B_android#icu#text#UnicodeSet#SpanCondition#NOT_CONTAINED_E@ \u2192 @B_android#icu#text#UnicodeSet#SpanCondition#SIMPLE_E@ These are actually not complete inverses. However, the alternating works because there are no gaps. For example, with [a{ab}{bc}], you get the following behavior when scanning forward: So here is what happens when you alternate: The entire string is traversed."}