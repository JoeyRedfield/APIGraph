{"Functions": {"gatherTransparentRegion(android.graphics.Region)": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [["@B_android#graphics#Region_E@", "Region no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public boolean gatherTransparentRegion (Region region)"}, "SurfaceView(android.content.Context,android.util.AttributeSet,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["@B_android#util#AttributeSet_E@", "AttributeSet no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public SurfaceView (Context context, AttributeSet attrs, int defStyleAttr)"}, "setZOrderMediaOverlay(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Control whether the surface view's surface is placed on top of another regular surface view in the window (but still behind the window itself). This is typically used to place overlays on top of an underlying media surface view. Note that this must be set before the surface view's containing window is attached to the window manager. Calling this overrides any previous call to @B_android#view#SurfaceView#setZOrderOnTop_E@.", "history": "Added in API level 5", "FullName": "public void setZOrderMediaOverlay (boolean isMediaOverlay)"}, "onMeasure(int,int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "Added in API level 1", "FullName": "protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "setSecure(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the surface view is secure."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Control whether the surface view's content should be treated as secure, preventing it from appearing in screenshots or from being viewed on non-secure displays. Note that this must be set before the surface view's containing window is attached to the window manager. See @B_android#view#Display#FLAG_SECURE_E@ for details.", "history": "Added in API level 17", "FullName": "public void setSecure (boolean isSecure)"}, "SurfaceView(android.content.Context,android.util.AttributeSet,int,int)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["@B_android#util#AttributeSet_E@", "AttributeSet no parameter comment"], ["int", "int no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 21", "FullName": "public SurfaceView (Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes)"}, "onWindowVisibilityChanged(int)": {"Returns": [], "Parameters": [["int", "int: The new visibility of the window. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when the window containing has change its visibility (between @B_android#view#View#GONE_E@, @B_android#view#View#INVISIBLE_E@, and @B_android#view#View#VISIBLE_E@). Note that this tells you whether or not your window is being made visible to the window manager; this does not tell you whether or not your window is obscured by other windows on the screen, even if it is itself visible.", "history": "Added in API level 1", "FullName": "protected void onWindowVisibilityChanged (int visibility)"}, "draw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: The Canvas to which the View is rendered."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Manually render this view (and all of its children) to the given Canvas. The view must have already done a full layout before this function is called. When implementing a view, implement @B_android#view#View#onDraw_E@ instead of overriding this method. If you do need to override this method, call the superclass version. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "public void draw (Canvas canvas)"}, "onAttachedToWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before @B_android#view#View#onDraw_E@, however it may be called any time before the first onDraw -- including before or after @B_android#view#View#onMeasure_E@. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onAttachedToWindow ()"}, "setVisibility(int)": {"Returns": [], "Parameters": [["int", "int: One of @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@. Value is @B_android#view#View#VISIBLE_E@, @B_android#view#View#INVISIBLE_E@, or @B_android#view#View#GONE_E@"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the visibility state of this view.", "history": "Added in API level 1", "FullName": "public void setVisibility (int visibility)"}, "SurfaceView(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public SurfaceView (Context context)"}, "getSurfaceControl()": {"Returns": [["@B_android#view#SurfaceControl_E@", "The SurfaceControl for this SurfaceView."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return a SurfaceControl which can be used for parenting Surfaces to this SurfaceView.", "history": "Added in API level 29", "FullName": "public SurfaceControl getSurfaceControl ()"}, "setZOrderOnTop(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Control whether the surface view's surface is placed on top of its window. Normally it is placed behind the window, to allow it to (for the most part) appear to composite with the views in the hierarchy. By setting this, you cause it to be placed above the window. This means that none of the contents of the window this SurfaceView is in will be visible on top of its surface. Note that this must be set before the surface view's containing window is attached to the window manager. Calling this overrides any previous call to @B_android#view#SurfaceView#setZOrderMediaOverlay_E@.", "history": "Added in API level 5", "FullName": "public void setZOrderOnTop (boolean onTop)"}, "onMeasure(int, int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "added in API level 1", "FullName": "protected void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "SurfaceView(android.content.Context,android.util.AttributeSet)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"], ["@B_android#util#AttributeSet_E@", "AttributeSet no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 1", "FullName": "public SurfaceView (Context context, AttributeSet attrs)"}, "dispatchDraw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: the canvas on which to draw the view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by draw to draw the child views. This may be overridden by derived classes to gain control just before its children are drawn (but after its own view has been drawn).", "history": "Added in API level 1", "FullName": "protected void dispatchDraw (Canvas canvas)"}, "onDetachedFromWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is detached from a window. At this point it no longer has a surface for drawing. If you override this method you must call through to the superclass implementation.", "history": "Added in API level 1", "FullName": "protected void onDetachedFromWindow ()"}, "getHolder()": {"Returns": [["@B_android#view#SurfaceHolder_E@", "SurfaceHolder The holder of the surface."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the SurfaceHolder providing access and control over this SurfaceView's underlying surface.", "history": "Added in API level 1", "FullName": "public SurfaceHolder getHolder ()"}}, "Inheritance": ["@B_android#view#View_E@"], "ClassName": "android.view.SurfaceView", "ClassDesc": "Provides a dedicated drawing surface embedded inside of a view hierarchy. You can control the format of this surface and, if you like, its size; the SurfaceView takes care of placing the surface at the correct location on the screen The surface is Z ordered so that it is behind the window holding its SurfaceView; the SurfaceView punches a hole in its window to allow its surface to be displayed. The view hierarchy will take care of correctly compositing with the Surface any siblings of the SurfaceView that would normally appear on top of it. This can be used to place overlays such as buttons on top of the Surface, though note however that it can have an impact on performance since a full alpha-blended composite will be performed each time the Surface changes. The transparent region that makes the surface visible is based on the layout positions in the view hierarchy. If the post-layout transform properties are used to draw a sibling view on top of the SurfaceView, the view may not be properly composited with the surface. Access to the underlying surface is provided via the SurfaceHolder interface, which can be retrieved by calling @B_android#view#SurfaceView#getHolder_E@. The Surface will be created for you while the SurfaceView's window is visible; you should implement @B_android#view#SurfaceHolder#Callback#surfaceCreated_E@ and @B_android#view#SurfaceHolder#Callback#surfaceDestroyed_E@ to discover when the Surface is created and destroyed as the window is shown and hidden. One of the purposes of this class is to provide a surface in which a secondary thread can render into the screen. If you are going to use it this way, you need to be aware of some threading semantics: All SurfaceView and @B_android#view#SurfaceHolder#Callback_E@ methods will be called from the thread running the SurfaceView's window (typically the main thread of the application). They thus need to correctly synchronize with any state that is also touched by the drawing thread. You must ensure that the drawing thread only touches the underlying Surface while it is valid -- between @B_android#view#SurfaceHolder#Callback#surfaceCreated_E@ and @B_android#view#SurfaceHolder#Callback#surfaceDestroyed_E@. @B_android#os#Build#VERSION_CODES#N_E@, SurfaceView's window position is updated synchronously with other View rendering. This means that translating and scaling a SurfaceView on screen will not cause rendering artifacts. Such artifacts may occur on previous versions of the platform when its window is positioned asynchronously."}