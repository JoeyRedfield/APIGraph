{"Functions": {"closeInbound()": {"Returns": [], "Parameters": [], "Throws": [["@B_javax#net#ssl#SSLException_E@", "if this engine has not received the proper SSL/TLS close notification message from the peer."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#isInboundDone_E@", "@B_javax#net#ssl#SSLEngine#isOutboundDone_E@"], "Permissions": [], "Description": "Signals that no more inbound network data will be sent to this SSLEngine. If the application initiated the closing process by calling @B_javax#net#ssl#SSLEngine#closeOutbound_E@, under some circumstances it is not required that the initiator wait for the peer's corresponding close message. (See section 7.2.1 of the TLS specification ( But if the application did not initiate the closure process, or if the circumstances above do not apply, this method should be called whenever the end of the SSL/TLS data stream is reached. This ensures closure of the inbound side, and checks that the peer followed the SSL/TLS close procedure properly, thus detecting possible truncation attacks. This method is idempotent: if the inbound side has already been closed, this method does not do anything. @B_javax#net#ssl#SSLEngine#wrap_E@ should be called to flush any remaining handshake data.", "history": "Added in API level 1", "FullName": "public abstract void closeInbound ()"}, "getSupportedProtocols()": {"Returns": [["@B_java#lang#String_E@", "an array of protocols supported"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the names of the protocols which could be enabled for use with this SSLEngine.", "history": "Added in API level 1", "FullName": "public abstract String[] getSupportedProtocols ()"}, "getDelegatedTask()": {"Returns": [["@B_java#lang#Runnable_E@", "a delegated Runnable task, or null if none are available."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns a delegated Runnable task for this SSLEngine. SSLEngine operations may require the results of operations that block, or may take an extended period of time to complete. This method is used to obtain an outstanding @B_java#lang#Runnable_E@ operation (task). Each task must be assigned a thread (possibly the current) to perform the @B_java#lang#Runnable#run_E@ operation. Once the run method returns, the Runnable object is no longer needed and may be discarded. Delegated tasks run in the AccessControlContext in place when this object was created. A call to this method will return each outstanding task exactly once. Multiple delegated tasks can be run in parallel.", "history": "Added in API level 1", "FullName": "public abstract Runnable getDelegatedTask ()"}, "getSupportedCipherSuites()": {"Returns": [["@B_java#lang#String_E@", "an array of cipher suite names"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#getEnabledCipherSuites_E@", "@B_javax#net#ssl#SSLEngine#setEnabledCipherSuites_E@"], "Permissions": [], "Description": "Returns the names of the cipher suites which could be enabled for use on this engine. Normally, only a subset of these will actually be enabled by default, since this list may include cipher suites which do not meet quality of service requirements for those defaults. Such cipher suites might be useful in specialized applications. Applications should not blindly enable all supported cipher suites. The supported cipher suites can include signaling cipher suite values that can cause connection problems if enabled inappropriately. The proper way to use this method is to either check if a specific cipher suite is supported via Arrays.asList(getSupportedCipherSuites()).contains(...) or to filter a desired list of cipher suites to only the supported ones via desiredSuiteSet.retainAll(Arrays.asList(getSupportedCipherSuites())).", "history": "Added in API level 1", "FullName": "public abstract String[] getSupportedCipherSuites ()"}, "wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer containing outbound application data"], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer to hold outbound network data"]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#nio#ReadOnlyBufferException_E@", "if the dst buffer is read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either src or dst is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#wrap_E@"], "Permissions": [], "Description": "Attempts to encode a buffer of plaintext application data into SSL/TLS network data. An invocation of this method behaves in exactly the same manner as the invocation:", "history": "added in API level 1", "FullName": "public SSLEngineResult wrap (ByteBuffer src, ByteBuffer dst)"}, "wrap(java.nio.ByteBuffer[],java.nio.ByteBuffer)": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: an array of ByteBuffers containing the outbound application data"], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer to hold outbound network data"]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#nio#ReadOnlyBufferException_E@", "if the dst buffer is read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either srcs or dst is null, or if any element in srcs is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#wrap_E@"], "Permissions": [], "Description": "Attempts to encode plaintext bytes from a sequence of data buffers into SSL/TLS network data. An invocation of this method behaves in exactly the same manner as the invocation:", "history": "Added in API level 1", "FullName": "public SSLEngineResult wrap (ByteBuffer[] srcs, ByteBuffer dst)"}, "isInboundDone()": {"Returns": [["boolean", "true if the SSLEngine will not consume anymore network data (and by implication, will not produce any more application data.)"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#closeInbound_E@"], "Permissions": [], "Description": "Returns whether @B_javax#net#ssl#SSLEngine#unwrap_E@ will accept any more inbound data messages.", "history": "Added in API level 1", "FullName": "public abstract boolean isInboundDone ()"}, "setWantClientAuth(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: set to true if client authentication is requested, or false if no client authentication is desired."]], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#getWantClientAuth_E@", "@B_javax#net#ssl#SSLEngine#setNeedClientAuth_E@", "@B_javax#net#ssl#SSLEngine#getNeedClientAuth_E@", "@B_javax#net#ssl#SSLEngine#setUseClientMode_E@"], "Permissions": [], "Description": "Configures the engine to An engine's client authentication setting is one of the following: client authentication required client authentication requested no client authentication desired Unlike @B_javax#net#ssl#SSLEngine#setNeedClientAuth_E@, if this option is set and the client chooses not to provide authentication information about itself, Calling this method overrides any previous setting made by this method or @B_javax#net#ssl#SSLEngine#setNeedClientAuth_E@.", "history": "Added in API level 1", "FullName": "public abstract void setWantClientAuth (boolean want)"}, "getHandshakeApplicationProtocol()": {"Returns": [["@B_java#lang#String_E@", "null if it has not yet been determined if application protocols might be used for this handshake, an empty String if application protocols values will not be used, or a non-empty application protocol String if a value was successfully negotiated."]], "Parameters": [], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the application protocol value negotiated on a SSL/TLS handshake currently in progress. Like @B_javax#net#ssl#SSLEngine#getHandshakeSession_E@, a connection may be in the middle of a handshake. The application protocol may or may not yet be available.", "history": "Added in API level 29", "FullName": "public String getHandshakeApplicationProtocol ()"}, "beginHandshake()": {"Returns": [], "Parameters": [], "Throws": [["@B_javax#net#ssl#SSLException_E@", "if a problem was encountered while signaling the SSLEngine to begin a new handshake. See the class description for more information on engine closure."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_javax#net#ssl#SSLSession#invalidate_E@"], "Permissions": [], "Description": "Initiates handshaking (initial or renegotiation) on this SSLEngine. This method is not needed for the initial handshake, as the wrap() and unwrap() methods will implicitly call this method if handshaking has not already begun. Note that the peer may also request a session renegotiation with this SSLEngine by sending the appropriate session renegotiate handshake message. Unlike the @B_javax#net#ssl#SSLSocket#startHandshake_E@ method, this method does not block until handshaking is completed. To force a complete SSL/TLS session renegotiation, the current session should be invalidated prior to calling this method. Some protocols may not support multiple handshakes on an existing engine and may throw an SSLException.", "history": "Added in API level 1", "FullName": "public abstract void beginHandshake ()"}, "getSession()": {"Returns": [["@B_javax#net#ssl#SSLSession_E@", "the SSLSession for this SSLEngine"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLSession_E@"], "Permissions": [], "Description": "Returns the SSLSession in use in this SSLEngine. These can be long lived, and frequently correspond to an entire login session for some user. The session specifies a particular cipher suite which is being actively used by all connections in that session, as well as the identities of the session's client and server. Unlike @B_javax#net#ssl#SSLSocket#getSession_E@ this method does not block until handshaking is complete. Until the initial handshake has completed, this method returns a session object which reports an invalid cipher suite of \"SSL_NULL_WITH_NULL_NULL\".", "history": "Added in API level 1", "FullName": "public abstract SSLSession getSession ()"}, "closeOutbound()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#isOutboundDone_E@"], "Permissions": [], "Description": "Signals that no more outbound application data will be sent on this SSLEngine. This method is idempotent: if the outbound side has already been closed, this method does not do anything. @B_javax#net#ssl#SSLEngine#wrap_E@ should be called to flush any remaining handshake data.", "history": "Added in API level 1", "FullName": "public abstract void closeOutbound ()"}, "getEnabledCipherSuites()": {"Returns": [["@B_java#lang#String_E@", "an array of cipher suite names"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#getSupportedCipherSuites_E@", "@B_javax#net#ssl#SSLEngine#setEnabledCipherSuites_E@"], "Permissions": [], "Description": "Returns the names of the SSL cipher suites which are currently enabled for use on this engine. When an SSLEngine is first created, all enabled cipher suites support a minimum quality of service. Thus, in some environments this value might be empty. Even if a suite has been enabled, it might never be used. (For example, the peer does not support it, the requisite certificates/private keys for the suite are not available, or an anonymous suite is enabled but authentication is required.)", "history": "Added in API level 1", "FullName": "public abstract String[] getEnabledCipherSuites ()"}, "getEnableSessionCreation()": {"Returns": [["boolean", "true indicates that sessions may be created; this is the default. false indicates that an existing session must be resumed"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#setEnableSessionCreation_E@"], "Permissions": [], "Description": "Returns true if new SSL sessions may be established by this engine.", "history": "Added in API level 1", "FullName": "public abstract boolean getEnableSessionCreation ()"}, "getSSLParameters()": {"Returns": [["@B_javax#net#ssl#SSLParameters_E@", "the SSLParameters in effect for this SSLEngine."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the SSLParameters in effect for this SSLEngine. The ciphersuites and protocols of the returned SSLParameters are always non-null.", "history": "Added in API level 9", "FullName": "public SSLParameters getSSLParameters ()"}, "wrap(java.nio.ByteBuffer[], java.nio.ByteBuffer)": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: an array of ByteBuffers containing the outbound application data"], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer to hold outbound network data"]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#nio#ReadOnlyBufferException_E@", "if the dst buffer is read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either srcs or dst is null, or if any element in srcs is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#wrap_E@"], "Permissions": [], "Description": "Attempts to encode plaintext bytes from a sequence of data buffers into SSL/TLS network data. An invocation of this method behaves in exactly the same manner as the invocation:", "history": "added in API level 1", "FullName": "public SSLEngineResult wrap (ByteBuffer[] srcs, ByteBuffer dst)"}, "SSLEngine(java.lang.String, int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the name of the peer host"], ["int", "int: the port number of the peer"]], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLContext#createSSLEngine_E@", "@B_javax#net#ssl#SSLSessionContext_E@"], "Permissions": [], "Description": "Constructor for an SSLEngine. SSLEngine implementations may use the peerHost and peerPort parameters as hints for their internal session reuse strategy. Some cipher suites (such as Kerberos) require remote hostname information. Implementations of this class should use this constructor to use Kerberos. The parameters are not authenticated by the SSLEngine.", "history": "added in API level 1", "FullName": "protected SSLEngine (String peerHost, int peerPort)"}, "wrap(java.nio.ByteBuffer[],int,int,java.nio.ByteBuffer)": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: an array of ByteBuffers containing the outbound application data"], ["int", "int: The offset within the buffer array of the first buffer from which bytes are to be retrieved; it must be non-negative and no larger than srcs.length"], ["int", "int: The maximum number of buffers to be accessed; it must be non-negative and no larger than srcs.length - offset"], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer to hold outbound network data"]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#lang#IndexOutOfBoundsException_E@", "if the preconditions on the offset and length parameters do not hold."], ["@B_java#nio#ReadOnlyBufferException_E@", "if the dst buffer is read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either srcs or dst is null, or if any element in the srcs subsequence specified is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_java#nio#channels#GatheringByteChannel_E@", "@B_java#nio#channels#GatheringByteChannel#write_E@"], "Permissions": [], "Description": "Attempts to encode plaintext bytes from a subsequence of data buffers into SSL/TLS network data. This @B_java#nio#channels#GatheringByteChannel_E@ for more information on gathering, and @B_java#nio#channels#GatheringByteChannel#write_E@ for more information on the subsequence behavior. Depending on the state of the SSLEngine, this method may produce network data without consuming any application data (for example, it may generate handshake data.) The application is responsible for reliably transporting the network data to the peer, and for ensuring that data created by multiple calls to wrap() is transported in the same order in which it was generated. The application must properly synchronize multiple calls to this method. If this SSLEngine has not yet started its initial handshake, this method will automatically start the handshake. This method will attempt to produce SSL/TLS records, and will consume as much source data as possible, but will never consume more than the sum of the bytes remaining in each buffer. Each ByteBuffer's position is updated to reflect the amount of data consumed or produced. The limits remain the same. The underlying memory used by the srcs and dst ByteBuffers must not be the same. See the class description for more information on engine closure.", "history": "Added in API level 1", "FullName": "public abstract SSLEngineResult wrap (ByteBuffer[] srcs, int offset, int length, ByteBuffer dst)"}, "getNeedClientAuth()": {"Returns": [["boolean", "true if client authentication is required, or false if no client authentication is desired."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#setNeedClientAuth_E@", "@B_javax#net#ssl#SSLEngine#setWantClientAuth_E@", "@B_javax#net#ssl#SSLEngine#getWantClientAuth_E@", "@B_javax#net#ssl#SSLEngine#setUseClientMode_E@"], "Permissions": [], "Description": "Returns true if the engine will", "history": "Added in API level 1", "FullName": "public abstract boolean getNeedClientAuth ()"}, "unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[])": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer containing inbound network data."], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: an array of ByteBuffers to hold inbound application data."]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#nio#ReadOnlyBufferException_E@", "if any of the dst buffers are read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either src or dsts is null, or if any element in dsts is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#unwrap_E@"], "Permissions": [], "Description": "Attempts to decode SSL/TLS network data into a sequence of plaintext application data buffers. An invocation of this method behaves in exactly the same manner as the invocation:", "history": "added in API level 1", "FullName": "public SSLEngineResult unwrap (ByteBuffer src, ByteBuffer[] dsts)"}, "SSLEngine(java.lang.String,int)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: the name of the peer host"], ["int", "int: the port number of the peer"]], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLContext#createSSLEngine_E@", "@B_javax#net#ssl#SSLSessionContext_E@"], "Permissions": [], "Description": "Constructor for an SSLEngine. SSLEngine implementations may use the peerHost and peerPort parameters as hints for their internal session reuse strategy. Some cipher suites (such as Kerberos) require remote hostname information. Implementations of this class should use this constructor to use Kerberos. The parameters are not authenticated by the SSLEngine.", "history": "Added in API level 1", "FullName": "protected SSLEngine (String peerHost, int peerPort)"}, "getPeerPort()": {"Returns": [["int", "the port number of the peer, or -1 if nothing is available."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the port number of the peer. Note that the value is not authenticated, and should not be relied upon.", "history": "Added in API level 1", "FullName": "public int getPeerPort ()"}, "setEnableSessionCreation(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true indicates that sessions may be created; this is the default. false indicates that an existing session must be resumed"]], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#getEnableSessionCreation_E@"], "Permissions": [], "Description": "Controls whether new SSL sessions may be established by this engine. If session creations are not allowed, and there are no existing sessions to resume, there will be no successful handshaking.", "history": "Added in API level 1", "FullName": "public abstract void setEnableSessionCreation (boolean flag)"}, "isOutboundDone()": {"Returns": [["boolean", "true if the SSLEngine will not produce any more network data"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#closeOutbound_E@", "@B_javax#net#ssl#SSLEngine#closeInbound_E@"], "Permissions": [], "Description": "Returns whether @B_javax#net#ssl#SSLEngine#wrap_E@ will produce any more outbound data messages. Note that during the closure phase, a SSLEngine may generate handshake closure data that must be sent to the peer. wrap() must be called to generate this data. When this method returns true, no more outbound data will be created.", "history": "Added in API level 1", "FullName": "public abstract boolean isOutboundDone ()"}, "setEnabledProtocols(java.lang.String[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Names of all the protocols to enable."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when one or more of the protocols named by the parameter is not supported or when the protocols parameter is null."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#getEnabledProtocols_E@"], "Permissions": [], "Description": "Set the protocol versions enabled for use on this engine. The protocols must have been listed by getSupportedProtocols() as being supported. Following a successful call to this method, only protocols listed in the protocols parameter are enabled for use. Because of the way the protocol version is negotiated, connections will only be able to use a member of the lowest set of contiguous enabled protocol versions. For example, enabling TLSv1.2 and TLSv1 will result in connections only being able to use TLSv1.", "history": "Added in API level 1", "FullName": "public abstract void setEnabledProtocols (String[] protocols)"}, "getHandshakeStatus()": {"Returns": [["@B_javax#net#ssl#SSLEngineResult#HandshakeStatus_E@", "the current SSLEngineResult.HandshakeStatus."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current handshake status for this SSLEngine.", "history": "Added in API level 1", "FullName": "public abstract SSLEngineResult.HandshakeStatus getHandshakeStatus ()"}, "unwrap(java.nio.ByteBuffer,java.nio.ByteBuffer[])": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer containing inbound network data."], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: an array of ByteBuffers to hold inbound application data."]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#nio#ReadOnlyBufferException_E@", "if any of the dst buffers are read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either src or dsts is null, or if any element in dsts is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#unwrap_E@"], "Permissions": [], "Description": "Attempts to decode SSL/TLS network data into a sequence of plaintext application data buffers. An invocation of this method behaves in exactly the same manner as the invocation:", "history": "Added in API level 1", "FullName": "public SSLEngineResult unwrap (ByteBuffer src, ByteBuffer[] dsts)"}, "getApplicationProtocol()": {"Returns": [["@B_java#lang#String_E@", "null if it has not yet been determined if application protocols might be used for this connection, an empty String if application protocols values will not be used, or a non-empty application protocol String if a value was successfully negotiated."]], "Parameters": [], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": [], "Permissions": [], "Description": "Returns the most recent application protocol value negotiated for this connection. If supported by the underlying SSL/TLS implementation, application name negotiation mechanisms such as", "history": "Added in API level 29", "FullName": "public String getApplicationProtocol ()"}, "getHandshakeApplicationProtocolSelector()": {"Returns": [["@B_java#util#function#BiFunction_E@", "the callback function, or null if none has been set."]], "Parameters": [], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": [], "Permissions": [], "Description": "Retrieves the callback function that selects an application protocol value during a SSL/TLS handshake. See @B_javax#net#ssl#SSLEngine#setHandshakeApplicationProtocolSelector_E@ for the function's type parameters.", "history": "Added in API level 29", "FullName": "public BiFunction<SSLEngine, List<String>, String> getHandshakeApplicationProtocolSelector ()"}, "getEnabledProtocols()": {"Returns": [["@B_java#lang#String_E@", "an array of protocols"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#setEnabledProtocols_E@"], "Permissions": [], "Description": "Returns the names of the protocol versions which are currently enabled for use with this SSLEngine.", "history": "Added in API level 1", "FullName": "public abstract String[] getEnabledProtocols ()"}, "unwrap(java.nio.ByteBuffer,java.nio.ByteBuffer)": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer containing inbound network data."], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer to hold inbound application data."]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#nio#ReadOnlyBufferException_E@", "if the dst buffer is read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either src or dst is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#unwrap_E@"], "Permissions": [], "Description": "Attempts to decode SSL/TLS network data into a plaintext application data buffer. An invocation of this method behaves in exactly the same manner as the invocation:", "history": "Added in API level 1", "FullName": "public SSLEngineResult unwrap (ByteBuffer src, ByteBuffer dst)"}, "getPeerHost()": {"Returns": [["@B_java#lang#String_E@", "the host name of the peer, or null if nothing is available."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the host name of the peer. Note that the value is not authenticated, and should not be relied upon.", "history": "Added in API level 1", "FullName": "public String getPeerHost ()"}, "wrap(java.nio.ByteBuffer,java.nio.ByteBuffer)": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer containing outbound application data"], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer to hold outbound network data"]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#nio#ReadOnlyBufferException_E@", "if the dst buffer is read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either src or dst is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#wrap_E@"], "Permissions": [], "Description": "Attempts to encode a buffer of plaintext application data into SSL/TLS network data. An invocation of this method behaves in exactly the same manner as the invocation:", "history": "Added in API level 1", "FullName": "public SSLEngineResult wrap (ByteBuffer src, ByteBuffer dst)"}, "getWantClientAuth()": {"Returns": [["boolean", "true if client authentication is requested, or false if no client authentication is desired."]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#setNeedClientAuth_E@", "@B_javax#net#ssl#SSLEngine#getNeedClientAuth_E@", "@B_javax#net#ssl#SSLEngine#setWantClientAuth_E@", "@B_javax#net#ssl#SSLEngine#setUseClientMode_E@"], "Permissions": [], "Description": "Returns true if the engine will", "history": "Added in API level 1", "FullName": "public abstract boolean getWantClientAuth ()"}, "setUseClientMode(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true if the engine should start its handshaking in \"client\" mode"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if a mode change is attempted after the initial handshake has begun."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#getUseClientMode_E@"], "Permissions": [], "Description": "Configures the engine to use client (or server) mode when handshaking. This method must be called before any handshaking occurs. Once handshaking has begun, the mode can not be reset for the life of this engine. Servers normally authenticate themselves, and clients are not required to do so.", "history": "Added in API level 1", "FullName": "public abstract void setUseClientMode (boolean mode)"}, "setNeedClientAuth(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: set to true if client authentication is required, or false if no client authentication is desired."]], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#getNeedClientAuth_E@", "@B_javax#net#ssl#SSLEngine#setWantClientAuth_E@", "@B_javax#net#ssl#SSLEngine#getWantClientAuth_E@", "@B_javax#net#ssl#SSLEngine#setUseClientMode_E@"], "Permissions": [], "Description": "Configures the engine to An engine's client authentication setting is one of the following: client authentication required client authentication requested no client authentication desired Unlike @B_javax#net#ssl#SSLEngine#setWantClientAuth_E@, if this option is set and the client chooses not to provide authentication information about itself, Calling this method overrides any previous setting made by this method or @B_javax#net#ssl#SSLEngine#setWantClientAuth_E@.", "history": "Added in API level 1", "FullName": "public abstract void setNeedClientAuth (boolean need)"}, "SSLEngine()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLContext#createSSLEngine_E@", "@B_javax#net#ssl#SSLSessionContext_E@"], "Permissions": [], "Description": "Constructor for an SSLEngine providing no hints for an internal session reuse strategy.", "history": "Added in API level 1", "FullName": "protected SSLEngine ()"}, "setEnabledCipherSuites(java.lang.String[])": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: Names of all the cipher suites to enable"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when one or more of the ciphers named by the parameter is not supported, or when the parameter is null."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#getSupportedCipherSuites_E@", "@B_javax#net#ssl#SSLEngine#getEnabledCipherSuites_E@"], "Permissions": [], "Description": "Sets the cipher suites enabled for use on this engine. Each cipher suite in the suites parameter must have been listed by getSupportedCipherSuites(), or the method will fail. Following a successful call to this method, only suites listed in the suites parameter are enabled for use. See @B_javax#net#ssl#SSLEngine#getEnabledCipherSuites_E@ for more information on why a specific cipher suite may never be used on a engine.", "history": "Added in API level 1", "FullName": "public abstract void setEnabledCipherSuites (String[] suites)"}, "getUseClientMode()": {"Returns": [["boolean", "true if the engine should do handshaking in \"client\" mode"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#setUseClientMode_E@"], "Permissions": [], "Description": "Returns true if the engine is set to use client mode when handshaking.", "history": "Added in API level 1", "FullName": "public abstract boolean getUseClientMode ()"}, "setSSLParameters(javax.net.ssl.SSLParameters)": {"Returns": [], "Parameters": [["@B_javax#net#ssl#SSLParameters_E@", "SSLParameters: the parameters"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if the setEnabledCipherSuites() or the setEnabledProtocols() call fails"]], "SeeAlso": [], "Permissions": [], "Description": "Applies SSLParameters to this engine. This means: If params.getCipherSuites() is non-null, setEnabledCipherSuites() is called with that value. If params.getProtocols() is non-null, setEnabledProtocols() is called with that value. If params.getNeedClientAuth() or params.getWantClientAuth() return true, setNeedClientAuth(true) and setWantClientAuth(true) are called, respectively; otherwise setWantClientAuth(false) is called. If params.getServerNames() is non-null, the engine will configure its server names with that value. If params.getSNIMatchers() is non-null, the engine will configure its SNI matchers with that value.", "history": "Added in API level 9", "FullName": "public void setSSLParameters (SSLParameters params)"}, "getHandshakeSession()": {"Returns": [["@B_javax#net#ssl#SSLSession_E@", "null if this instance is not currently handshaking, or if the current handshake has not progressed far enough to create a basic SSLSession. Otherwise, this method returns the SSLSession currently being negotiated."]], "Parameters": [], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": ["@B_javax#net#ssl#SSLSocket_E@", "@B_javax#net#ssl#SSLSession_E@", "@B_javax#net#ssl#ExtendedSSLSession_E@", "@B_javax#net#ssl#X509ExtendedKeyManager_E@", "@B_javax#net#ssl#X509ExtendedTrustManager_E@"], "Permissions": [], "Description": "Returns the SSLSession being constructed during a SSL/TLS handshake. TLS protocols may negotiate parameters that are needed when using an instance of this class, but before the SSLSession has been completely initialized and made available via getSession. For example, the list of valid signature algorithms may restrict the type of certificates that can used during TrustManager decisions, or the maximum TLS fragment packet sizes can be resized to better support the network environment. This method provides early access to the SSLSession being constructed. Depending on how far the handshake has progressed, some data may not yet be available for use. For example, if a remote server will be sending a Certificate chain, but that chain has yet not been processed, the getPeerCertificates method of SSLSession will throw a SSLPeerUnverifiedException. Once that chain has been processed, getPeerCertificates will return the proper value.", "history": "Added in API level 24", "FullName": "public SSLSession getHandshakeSession ()"}, "unwrap(java.nio.ByteBuffer,java.nio.ByteBuffer[],int,int)": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer containing inbound network data."], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: an array of ByteBuffers to hold inbound application data."], ["int", "int: The offset within the buffer array of the first buffer from which bytes are to be transferred; it must be non-negative and no larger than dsts.length."], ["int", "int: The maximum number of buffers to be accessed; it must be non-negative and no larger than dsts.length - offset."]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#lang#IndexOutOfBoundsException_E@", "If the preconditions on the offset and length parameters do not hold."], ["@B_java#nio#ReadOnlyBufferException_E@", "if any of the dst buffers are read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either src or dsts is null, or if any element in the dsts subsequence specified is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_java#nio#channels#ScatteringByteChannel_E@", "@B_java#nio#channels#ScatteringByteChannel#read_E@"], "Permissions": [], "Description": "Attempts to decode SSL/TLS network data into a subsequence of plaintext application data buffers. This @B_java#nio#channels#ScatteringByteChannel_E@ for more information on scattering, and @B_java#nio#channels#ScatteringByteChannel#read_E@ for more information on the subsequence behavior. Depending on the state of the SSLEngine, this method may consume network data without producing any application data (for example, it may consume handshake data.) The application is responsible for reliably obtaining the network data from the peer, and for invoking unwrap() on the data in the order it was received. The application must properly synchronize multiple calls to this method. If this SSLEngine has not yet started its initial handshake, this method will automatically start the handshake. This method will attempt to consume one complete SSL/TLS network packet, but will never consume more than the sum of the bytes remaining in the buffers. Each ByteBuffer's position is updated to reflect the amount of data consumed or produced. The limits remain the same. The underlying memory used by the src and dsts ByteBuffers must not be the same. The inbound network buffer may be modified as a result of this call: therefore if the network data packet is required for some secondary purpose, the data should be duplicated before calling this method. Note: the network data will not be useful to a second SSLEngine, as each SSLEngine contains unique random state which influences the SSL/TLS messages. See the class description for more information on engine closure.", "history": "Added in API level 1", "FullName": "public abstract SSLEngineResult unwrap (ByteBuffer src, ByteBuffer[] dsts, int offset, int length)"}, "setHandshakeApplicationProtocolSelector(java.util.function.BiFunction<javax.net.ssl.SSLEngine,java.util.List<java.lang.String>,java.lang.String>)": {"Returns": [], "Parameters": [["@B_java#util#function#BiFunction_E@", "BiFunction: the callback function, or null to disable the callback functionality."]], "Throws": [["@B_java#lang#UnsupportedOperationException_E@", "if the underlying provider does not implement the operation."]], "SeeAlso": [], "Permissions": [], "Description": "Registers a callback function that selects an application protocol value for a SSL/TLS handshake. The function overrides any values supplied using @B_javax#net#ssl#SSLParameters#setApplicationProtocols_E@ and it supports the following type parameters:", "history": "Added in API level 29", "FullName": "public void setHandshakeApplicationProtocolSelector (BiFunction<SSLEngine, List<String>, String> selector)"}, "unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)": {"Returns": [["@B_javax#net#ssl#SSLEngineResult_E@", "an SSLEngineResult describing the result of this operation."]], "Parameters": [["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer containing inbound network data."], ["@B_java#nio#ByteBuffer_E@", "ByteBuffer: a ByteBuffer to hold inbound application data."]], "Throws": [["@B_javax#net#ssl#SSLException_E@", "A problem was encountered while processing the data that caused the SSLEngine to abort. See the class description for more information on engine closure."], ["@B_java#nio#ReadOnlyBufferException_E@", "if the dst buffer is read-only."], ["@B_java#lang#IllegalArgumentException_E@", "if either src or dst is null."], ["@B_java#lang#IllegalStateException_E@", "if the client/server mode has not yet been set."]], "SeeAlso": ["@B_javax#net#ssl#SSLEngine#unwrap_E@"], "Permissions": [], "Description": "Attempts to decode SSL/TLS network data into a plaintext application data buffer. An invocation of this method behaves in exactly the same manner as the invocation:", "history": "added in API level 1", "FullName": "public SSLEngineResult unwrap (ByteBuffer src, ByteBuffer dst)"}}, "Inheritance": [], "ClassName": "javax.net.ssl.SSLEngine", "ClassDesc": "A class which enables secure communications using protocols such as the Secure Sockets Layer (SSL) or The secure communications modes include: Integrity Protection. SSL/TLS protects against modification of messages by an active wiretapper. Authentication. In most modes, SSL/TLS provides peer authentication. Servers are usually authenticated, and clients may be authenticated as requested by servers. Confidentiality (Privacy Protection). In most modes, SSL/TLS encrypts data being sent between client and server. This protects the confidentiality of data, so that passive wiretappers won't see sensitive data such as financial information or personal information of many kinds. These kinds of protection are specified by a \"cipher suite\", which is a combination of cryptographic algorithms used by a given SSL connection. During the negotiation process, the two endpoints must agree on a cipher suite that is available in both environments. If there is no such suite in common, no SSL connection can be established, and no data can be exchanged. The cipher suite used is established by a negotiation process called \"handshaking\". The goal of this process is to create or rejoin a \"session\", which may protect many connections over time. After handshaking has completed, you can access session attributes by using the @B_javax#net#ssl#SSLEngine#getSession_E@ method. The SSLSocket class provides much of the same security functionality, but all of the inbound and outbound data is automatically transported using the underlying @B_java#net#Socket_E@, which by design uses a blocking model. While this is appropriate for many applications, this model does not provide the scalability required by large servers. The primary distinction of an SSLEngine is that it operates on inbound and outbound byte streams, independent of the transport mechanism. It is the responsibility of the SSLEngine user to arrange for reliable I/O transport to the peer. By separating the SSL/TLS abstraction from the I/O transport mechanism, the SSLEngine can be used for a wide variety of I/O types, such as @B_java#nio#channels#spi#AbstractSelectableChannel#configureBlocking_E@, @B_java#nio#channels#Selector_E@, @B_java#net#Socket_E@ and the traditional Input/OutputStreams, local @B_java#nio#ByteBuffer_E@ or byte arrays, At a high level, the SSLEngine appears thus: (In the context of an SSLEngine, the term \"handshake data\" is taken to mean any data exchanged to establish and control a secure connection. Handshake data includes the SSL/TLS messages \"alert\", \"change_cipher_spec,\" and \"handshake.\") There are five distinct phases to an SSLEngine. SSLEngine is created by calling @B_javax#net#ssl#SSLContext#createSSLEngine_E@ from an initialized SSLContext. Any configuration parameters should be set before making the first call to wrap(), unwrap(), or beginHandshake(). These methods all trigger the initial handshake. Data moves through the engine by calling @B_javax#net#ssl#SSLEngine#wrap_E@ or @B_javax#net#ssl#SSLEngine#unwrap_E@ on outbound or inbound data, respectively. Depending on the state of the SSLEngine, a wrap() call may consume application data from the source buffer and may produce network data in the destination buffer. The outbound data may contain application and/or handshake data. A call to unwrap() will examine the source buffer and may advance the handshake if the data is handshaking information, or may place application data in the destination buffer if the data is application. The state of the underlying SSL/TLS algorithm will determine when data is consumed and produced. Calls to wrap() and unwrap() return an SSLEngineResult which indicates the status of the operation, and (optionally) how to interact with the engine to make progress. The SSLEngine produces/consumes complete SSL/TLS packets only, and does not store application data internally between calls to wrap()/unwrap(). Thus input and output ByteBuffers must be sized appropriately to hold the maximum record that can be produced. Calls to @B_javax#net#ssl#SSLSession#getPacketBufferSize_E@ and @B_javax#net#ssl#SSLSession#getApplicationBufferSize_E@ should be used to determine the appropriate buffer sizes. The size of the outbound application data buffer generally does not matter. If buffer conditions do not allow for the proper consumption/production of data, the application must determine (via @B_javax#net#ssl#SSLEngineResult_E@) and correct the problem, and then try the call again. For example, unwrap() will return a @B_javax#net#ssl#SSLEngineResult#Status#BUFFER_OVERFLOW_E@ result if the engine determines that there is not enough destination buffer space available. Applications should call @B_javax#net#ssl#SSLSession#getApplicationBufferSize_E@ and compare that value with the space available in the destination buffer, enlarging the buffer if necessary. Similarly, if unwrap() were to return a @B_javax#net#ssl#SSLEngineResult#Status#BUFFER_UNDERFLOW_E@, the application should call @B_javax#net#ssl#SSLSession#getPacketBufferSize_E@ to ensure that the source buffer has enough room to hold a record (enlarging if necessary), and then obtain more inbound data. Unlike SSLSocket, all methods of SSLEngine are non-blocking. SSLEngine implementations may require the results of tasks that may take an extended period of time to complete, or may even block. For example, a TrustManager may need to connect to a remote certificate validation service, or a KeyManager might need to prompt a user to determine which certificate to use as part of client authentication. Additionally, creating cryptographic signatures and verifying them can be slow, seemingly blocking. For any operation which may potentially block, the SSLEngine will create a @B_java#lang#Runnable_E@ delegated task. When SSLEngineResult indicates that a delegated task result is needed, the application must call @B_javax#net#ssl#SSLEngine#getDelegatedTask_E@ to obtain an outstanding delegated task and call its @B_java#lang#Runnable#run_E@ method (possibly using a different thread depending on the compute strategy). The application should continue obtaining delegated tasks until no more exist, and try the original operation again. At the end of a communication session, applications should properly close the SSL/TLS link. The SSL/TLS protocols have closure handshake messages, and these messages should be communicated to the peer before releasing the SSLEngine and closing the underlying transport mechanism. A close can be initiated by one of: an SSLException, an inbound closure handshake message, or one of the close methods. In all cases, closure handshake messages are generated by the engine, and wrap() should be repeatedly called until the resulting SSLEngineResult's status returns \"CLOSED\", or @B_javax#net#ssl#SSLEngine#isOutboundDone_E@ returns true. All data obtained from the wrap() method should be sent to the peer. @B_javax#net#ssl#SSLEngine#closeOutbound_E@ is used to signal the engine that the application will not be sending any more data. A peer will signal its intent to close by sending its own closure handshake message. After this message has been received and processed by the local SSLEngine's unwrap() call, the application can detect the close by calling unwrap() and looking for a SSLEngineResult with status \"CLOSED\", or if @B_javax#net#ssl#SSLEngine#isInboundDone_E@ returns true. If for some reason the peer closes the communication link without sending the proper SSL/TLS closure message, the application can detect the end-of-stream and can signal the engine via @B_javax#net#ssl#SSLEngine#closeInbound_E@ that there will no more inbound messages to process. Some applications might choose to require orderly shutdown messages from a peer, in which case they can check that the closure was generated by a handshake message and not by an end-of-stream condition. There are two groups of cipher suites which you will need to know about when managing cipher suites: Supported cipher suites: all the suites which are supported by the SSL implementation. This list is reported using @B_javax#net#ssl#SSLEngine#getSupportedCipherSuites_E@. Enabled cipher suites, which may be fewer than the full set of supported suites. This group is set using the @B_javax#net#ssl#SSLEngine#setEnabledCipherSuites_E@ method, and queried using the @B_javax#net#ssl#SSLEngine#getEnabledCipherSuites_E@ method. Initially, a default set of cipher suites will be enabled on a new engine that represents the minimum suggested configuration. Implementation defaults require that only cipher suites which authenticate servers and provide confidentiality be enabled by default. Only if both sides explicitly agree to unauthenticated and/or non-private (unencrypted) communications will such a cipher suite be selected. Each SSL/TLS connection must have one client and one server, thus each endpoint must decide which role to assume. This choice determines who begins the handshaking process as well as which type of messages should be sent by each party. The method @B_javax#net#ssl#SSLEngine#setUseClientMode_E@ configures the mode. Once the initial handshaking has started, an SSLEngine can not switch between client and server modes, even when performing renegotiations. Applications might choose to process delegated tasks in different threads. When an SSLEngine is created, the current @B_java#security#AccessControlContext_E@ is saved. All future delegated tasks will be processed using this context: that is, all access control decisions will be made using the context captured at engine creation. SSLEngine instances obtained from the default @B_javax#net#ssl#SSLContext_E@ are configured as follows: NOTE: PSK cipher suites are enabled by default only if the SSLContext through which the engine was created has been initialized with a PSKKeyManager."}