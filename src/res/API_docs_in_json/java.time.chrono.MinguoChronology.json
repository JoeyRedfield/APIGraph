{"Functions": {"range(java.time.temporal.ChronoField)": {"Returns": [["@B_java#time#temporal#ValueRange_E@", "no returns description in source"]], "Parameters": [["@B_java#time#temporal#ChronoField_E@", "ChronoField no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public ValueRange range (ChronoField field)"}, "zonedDateTime(java.time.Instant, java.time.ZoneId)": {"Returns": [["@B_java#time#chrono#ChronoZonedDateTime_E@", "no returns description in source"]], "Parameters": [["@B_java#time#Instant_E@", "Instant no parameter comment"], ["@B_java#time#ZoneId_E@", "ZoneId no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 26", "FullName": "public ChronoZonedDateTime<MinguoDate> zonedDateTime (Instant instant, ZoneId zone)"}, "getCalendarType()": {"Returns": [["@B_java#lang#String_E@", "the calendar system type - 'roc'"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_java#time#chrono#MinguoChronology#getId_E@"], "Permissions": [], "Description": "Gets the calendar type of the underlying calendar system - 'roc'. The calendar type is an identifier defined by the Unicode Locale Data Markup Language (LDML) specification. It can be used to lookup the Chronology using @B_java#time#chrono#Chronology#of_E@. It can also be used as part of a locale, accessible via @B_java#util#Locale#getUnicodeLocaleType_E@ with the key 'ca'.", "history": "Added in API level 26", "FullName": "public String getCalendarType ()"}, "zonedDateTime(java.time.temporal.TemporalAccessor)": {"Returns": [["@B_java#time#chrono#ChronoZonedDateTime_E@", "no returns description in source"]], "Parameters": [["@B_java#time#temporal#TemporalAccessor_E@", "TemporalAccessor no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public ChronoZonedDateTime<MinguoDate> zonedDateTime (TemporalAccessor temporal)"}, "dateNow(java.time.Clock)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "no returns description in source"]], "Parameters": [["@B_java#time#Clock_E@", "Clock no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public MinguoDate dateNow (Clock clock)"}, "date(int, int, int)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the Minguo local date, not null"]], "Parameters": [["int", "int: the proleptic-year"], ["int", "int: the month-of-year"], ["int", "int: the day-of-month"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Minguo calendar system from the proleptic-year, month-of-year and day-of-month fields.", "history": "added in API level 26", "FullName": "public MinguoDate date (int prolepticYear, int month, int dayOfMonth)"}, "zonedDateTime(java.time.Instant,java.time.ZoneId)": {"Returns": [["@B_java#time#chrono#ChronoZonedDateTime_E@", "no returns description in source"]], "Parameters": [["@B_java#time#Instant_E@", "Instant no parameter comment"], ["@B_java#time#ZoneId_E@", "ZoneId no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public ChronoZonedDateTime<MinguoDate> zonedDateTime (Instant instant, ZoneId zone)"}, "dateYearDay(int, int)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the Minguo local date, not null"]], "Parameters": [["int", "int: the proleptic-year"], ["int", "int: the day-of-year"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Minguo calendar system from the proleptic-year and day-of-year fields.", "history": "added in API level 26", "FullName": "public MinguoDate dateYearDay (int prolepticYear, int dayOfYear)"}, "dateEpochDay(long)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the Minguo local date, not null"]], "Parameters": [["long", "long: the epoch day"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in the Minguo calendar system from the epoch-day.", "history": "Added in API level 26", "FullName": "public MinguoDate dateEpochDay (long epochDay)"}, "prolepticYear(java.time.chrono.Era, int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 26", "FullName": "public int prolepticYear (Era era, int yearOfEra)"}, "dateNow()": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public MinguoDate dateNow ()"}, "resolveDate(java.util.Map<java.time.temporal.TemporalField,java.lang.Long>,java.time.format.ResolverStyle)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the resolved date, null if insufficient information to create a date"]], "Parameters": [["@B_java#util#Map_E@", "Map: the map of fields to values, which can be updated, not null"], ["@B_java#time#format#ResolverStyle_E@", "ResolverStyle: the requested type of resolve, not null"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Resolves parsed ChronoField values into a date during parsing. Most TemporalField implementations are resolved using the resolve method on the field. By contrast, the ChronoField class defines fields that only have meaning relative to the chronology. As such, ChronoField date fields are resolved here in the context of a specific chronology. ChronoField instances are resolved by this method, which may be overridden in subclasses. EPOCH_DAY - If present, this is converted to a date and all other date fields are then cross-checked against the date. PROLEPTIC_MONTH - If present, then it is split into the YEAR and MONTH_OF_YEAR. If the mode is strict or smart then the field is validated. YEAR_OF_ERA and ERA - If both are present, then they are combined to form a YEAR. In lenient mode, the YEAR_OF_ERA range is not validated, in smart and strict mode it is. The ERA is validated for range in all three modes. If only the YEAR_OF_ERA is present, and the mode is smart or lenient, then the last available era is assumed. In strict mode, no era is assumed and the YEAR_OF_ERA is left untouched. If only the ERA is present, then it is left untouched. YEAR, MONTH_OF_YEAR and DAY_OF_MONTH - If all three are present, then they are combined to form a date. In all three modes, the YEAR is validated. If the mode is smart or strict, then the month and day are validated. If the mode is lenient, then the date is combined in a manner equivalent to creating a date on the first day of the first month in the requested year, then adding the difference in months, then the difference in days. If the mode is smart, and the day-of-month is greater than the maximum for the year-month, then the day-of-month is adjusted to the last day-of-month. If the mode is strict, then the three fields must form a valid date. YEAR and DAY_OF_YEAR - If both are present, then they are combined to form a date. In all three modes, the YEAR is validated. If the mode is lenient, then the date is combined in a manner equivalent to creating a date on the first day of the requested year, then adding the difference in days. If the mode is smart or strict, then the two fields must form a valid date. YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and ALIGNED_DAY_OF_WEEK_IN_MONTH - If all four are present, then they are combined to form a date. In all three modes, the YEAR is validated. If the mode is lenient, then the date is combined in a manner equivalent to creating a date on the first day of the first month in the requested year, then adding the difference in months, then the difference in weeks, then in days. If the mode is smart or strict, then the all four fields are validated to their outer ranges. The date is then combined in a manner equivalent to creating a date on the first day of the requested year and month, then adding the amount in weeks and days to reach their values. If the mode is strict, the date is additionally validated to check that the day and week adjustment did not change the month. YEAR, MONTH_OF_YEAR, ALIGNED_WEEK_OF_MONTH and DAY_OF_WEEK - If all four are present, then they are combined to form a date. The approach is the same as described above for years, months and weeks in ALIGNED_DAY_OF_WEEK_IN_MONTH. The day-of-week is adjusted as the next or same matching day-of-week once the years, months and weeks have been handled. YEAR, ALIGNED_WEEK_OF_YEAR and ALIGNED_DAY_OF_WEEK_IN_YEAR - If all three are present, then they are combined to form a date. In all three modes, the YEAR is validated. If the mode is lenient, then the date is combined in a manner equivalent to creating a date on the first day of the requested year, then adding the difference in weeks, then in days. If the mode is smart or strict, then the all three fields are validated to their outer ranges. The date is then combined in a manner equivalent to creating a date on the first day of the requested year, then adding the amount in weeks and days to reach their values. If the mode is strict, the date is additionally validated to check that the day and week adjustment did not change the year. YEAR, ALIGNED_WEEK_OF_YEAR and DAY_OF_WEEK - If all three are present, then they are combined to form a date. The approach is the same as described above for years and weeks in ALIGNED_DAY_OF_WEEK_IN_YEAR. The day-of-week is adjusted as the next or same matching day-of-week once the years and weeks have been handled. The default implementation is suitable for most calendar systems. If @B_java#time#temporal#ChronoField#YEAR_OF_ERA_E@ is found without an @B_java#time#temporal#ChronoField#ERA_E@ then the last era in @B_java#time#chrono#Chronology#eras_E@ is used. The implementation assumes a 7 day week, that the first day-of-month has the value 1, that first day-of-year has the value 1, and that the first of the month and year always exists.", "history": "Added in API level 26", "FullName": "public MinguoDate resolveDate (Map<TemporalField, Long> fieldValues, ResolverStyle resolverStyle)"}, "getId()": {"Returns": [["@B_java#lang#String_E@", "the chronology ID - 'Minguo'"]], "Parameters": [], "Throws": [], "SeeAlso": ["@B_java#time#chrono#MinguoChronology#getCalendarType_E@"], "Permissions": [], "Description": "Gets the ID of the chronology - 'Minguo'. The ID uniquely identifies the Chronology. It can be used to lookup the Chronology using @B_java#time#chrono#Chronology#of_E@.", "history": "Added in API level 26", "FullName": "public String getId ()"}, "dateNow(java.time.ZoneId)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "no returns description in source"]], "Parameters": [["@B_java#time#ZoneId_E@", "ZoneId no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public MinguoDate dateNow (ZoneId zone)"}, "prolepticYear(java.time.chrono.Era,int)": {"Returns": [["int", "no returns description in source"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era no parameter comment"], ["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public int prolepticYear (Era era, int yearOfEra)"}, "isLeapYear(long)": {"Returns": [["boolean", "true if the year is a leap year"]], "Parameters": [["long", "long: the proleptic-year to check, not validated for range"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Checks if the specified year is a leap year. Minguo leap years occur exactly in line with ISO leap years. This method does not validate the year passed in, and only has a well-defined result for years in the supported range.", "history": "Added in API level 26", "FullName": "public boolean isLeapYear (long prolepticYear)"}, "date(java.time.chrono.Era, int, int, int)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the Minguo local date, not null"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era: the Minguo era, not null"], ["int", "int: the year-of-era"], ["int", "int: the month-of-year"], ["int", "int: the day-of-month"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"], ["@B_java#lang#ClassCastException_E@", "if the era is not a MinguoEra"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Minguo calendar system from the era, year-of-era, month-of-year and day-of-month fields.", "history": "added in API level 26", "FullName": "public MinguoDate date (Era era, int yearOfEra, int month, int dayOfMonth)"}, "date(java.time.chrono.Era,int,int,int)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the Minguo local date, not null"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era: the Minguo era, not null"], ["int", "int: the year-of-era"], ["int", "int: the month-of-year"], ["int", "int: the day-of-month"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"], ["@B_java#lang#ClassCastException_E@", "if the era is not a MinguoEra"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Minguo calendar system from the era, year-of-era, month-of-year and day-of-month fields.", "history": "Added in API level 26", "FullName": "public MinguoDate date (Era era, int yearOfEra, int month, int dayOfMonth)"}, "eras()": {"Returns": [["@B_java#util#List_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public List<Era> eras ()"}, "dateYearDay(java.time.chrono.Era,int,int)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the Minguo local date, not null"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era: the Minguo era, not null"], ["int", "int: the year-of-era"], ["int", "int: the day-of-year"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"], ["@B_java#lang#ClassCastException_E@", "if the era is not a MinguoEra"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Minguo calendar system from the era, year-of-era and day-of-year fields.", "history": "Added in API level 26", "FullName": "public MinguoDate dateYearDay (Era era, int yearOfEra, int dayOfYear)"}, "dateYearDay(int,int)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the Minguo local date, not null"]], "Parameters": [["int", "int: the proleptic-year"], ["int", "int: the day-of-year"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Minguo calendar system from the proleptic-year and day-of-year fields.", "history": "Added in API level 26", "FullName": "public MinguoDate dateYearDay (int prolepticYear, int dayOfYear)"}, "date(java.time.temporal.TemporalAccessor)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "no returns description in source"]], "Parameters": [["@B_java#time#temporal#TemporalAccessor_E@", "TemporalAccessor no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public MinguoDate date (TemporalAccessor temporal)"}, "dateYearDay(java.time.chrono.Era, int, int)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the Minguo local date, not null"]], "Parameters": [["@B_java#time#chrono#Era_E@", "Era: the Minguo era, not null"], ["int", "int: the year-of-era"], ["int", "int: the day-of-year"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"], ["@B_java#lang#ClassCastException_E@", "if the era is not a MinguoEra"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Minguo calendar system from the era, year-of-era and day-of-year fields.", "history": "added in API level 26", "FullName": "public MinguoDate dateYearDay (Era era, int yearOfEra, int dayOfYear)"}, "date(int,int,int)": {"Returns": [["@B_java#time#chrono#MinguoDate_E@", "the Minguo local date, not null"]], "Parameters": [["int", "int: the proleptic-year"], ["int", "int: the month-of-year"], ["int", "int: the day-of-month"]], "Throws": [["@B_java#time#DateTimeException_E@", "if unable to create the date"]], "SeeAlso": [], "Permissions": [], "Description": "Obtains a local date in Minguo calendar system from the proleptic-year, month-of-year and day-of-month fields.", "history": "Added in API level 26", "FullName": "public MinguoDate date (int prolepticYear, int month, int dayOfMonth)"}, "eraOf(int)": {"Returns": [["@B_java#time#chrono#MinguoEra_E@", "no returns description in source"]], "Parameters": [["int", "int no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public MinguoEra eraOf (int eraValue)"}, "localDateTime(java.time.temporal.TemporalAccessor)": {"Returns": [["@B_java#time#chrono#ChronoLocalDateTime_E@", "no returns description in source"]], "Parameters": [["@B_java#time#temporal#TemporalAccessor_E@", "TemporalAccessor no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "Added in API level 26", "FullName": "public ChronoLocalDateTime<MinguoDate> localDateTime (TemporalAccessor temporal)"}}, "Inheritance": ["@B_java#time#chrono#AbstractChronology_E@"], "ClassName": "java.time.chrono.MinguoChronology", "ClassDesc": "The Minguo calendar system. This chronology defines the rules of the Minguo calendar system. This calendar system is primarily used in the Republic of China, often known as Taiwan. Dates are aligned such that 0001-01-01 (Minguo) is 1912-01-01 (ISO). The fields are defined as follows: era - There are two eras, the current 'Republic' (ERA_ROC) and the previous era (ERA_BEFORE_ROC). year-of-era - The year-of-era for the current era increases uniformly from the epoch at year one. For the previous era the year increases from one as time goes backwards. The value for the current era is equal to the ISO proleptic-year minus 1911. proleptic-year - The proleptic year is the same as the year-of-era for the current era. For the previous era, years have zero, then negative values. The value is equal to the ISO proleptic-year minus 1911. month-of-year - The Minguo month-of-year exactly matches ISO. day-of-month - The Minguo day-of-month exactly matches ISO. day-of-year - The Minguo day-of-year exactly matches ISO. leap-year - The Minguo leap-year pattern exactly matches ISO, such that the two calendars are never out of step."}