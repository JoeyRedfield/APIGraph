{"Functions": {"KeyAgreementSpi()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in API level 1", "FullName": "public KeyAgreementSpi ()"}, "engineGenerateSecret(byte[],int)": {"Returns": [["int", "the number of bytes placed into sharedSecret"]], "Parameters": [["byte[]", "byte: the buffer for the shared secret"], ["int", "int: the offset in sharedSecret where the shared secret will be stored"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been completed yet"], ["@B_javax#crypto#ShortBufferException_E@", "if the given output buffer is too small to hold the secret"]], "SeeAlso": [], "Permissions": [], "Description": "Generates the shared secret, and places it into the buffer sharedSecret, beginning at offset inclusive. If the sharedSecret buffer is too small to hold the result, a ShortBufferException is thrown. In this case, this call should be repeated with a larger output buffer. This method resets this KeyAgreementSpi object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the engineInit methods, the same private information and algorithm parameters will be used for subsequent key agreements.", "history": "Added in API level 1", "FullName": "protected abstract int engineGenerateSecret (byte[] sharedSecret, int offset)"}, "engineGenerateSecret(byte[], int)": {"Returns": [["int", "the number of bytes placed into sharedSecret"]], "Parameters": [["byte[]", "byte: the buffer for the shared secret"], ["int", "int: the offset in sharedSecret where the shared secret will be stored"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been completed yet"], ["@B_javax#crypto#ShortBufferException_E@", "if the given output buffer is too small to hold the secret"]], "SeeAlso": [], "Permissions": [], "Description": "Generates the shared secret, and places it into the buffer sharedSecret, beginning at offset inclusive. If the sharedSecret buffer is too small to hold the result, a ShortBufferException is thrown. In this case, this call should be repeated with a larger output buffer. This method resets this KeyAgreementSpi object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the engineInit methods, the same private information and algorithm parameters will be used for subsequent key agreements.", "history": "added in API level 1", "FullName": "protected abstract int engineGenerateSecret (byte[] sharedSecret, int offset)"}, "engineGenerateSecret(java.lang.String)": {"Returns": [["@B_javax#crypto#SecretKey_E@", "the shared secret key"]], "Parameters": [["@B_java#lang#String_E@", "String: the requested secret key algorithm"]], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been completed yet"], ["@B_java#security#NoSuchAlgorithmException_E@", "if the requested secret key algorithm is not available"], ["@B_java#security#InvalidKeyException_E@", "if the shared secret key material cannot be used to generate a secret key of the requested algorithm type (e.g., the key material is too short)"]], "SeeAlso": [], "Permissions": [], "Description": "Creates the shared secret and returns it as a secret key object of the requested algorithm type. This method resets this KeyAgreementSpi object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the engineInit methods, the same private information and algorithm parameters will be used for subsequent key agreements.", "history": "Added in API level 1", "FullName": "protected abstract SecretKey engineGenerateSecret (String algorithm)"}, "engineInit(java.security.Key,java.security.spec.AlgorithmParameterSpec,java.security.SecureRandom)": {"Returns": [], "Parameters": [["@B_java#security#Key_E@", "Key: the party's private information. For example, in the case of the Diffie-Hellman key agreement, this would be the party's own Diffie-Hellman private key."], ["@B_java#security#spec#AlgorithmParameterSpec_E@", "AlgorithmParameterSpec: the key agreement parameters"], ["@B_java#security#SecureRandom_E@", "SecureRandom: the source of randomness"]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this key agreement, e.g., is of the wrong type or has an incompatible algorithm type."], ["@B_java#security#InvalidAlgorithmParameterException_E@", "if the given parameters are inappropriate for this key agreement."]], "SeeAlso": [], "Permissions": [], "Description": "Initializes this key agreement with the given key, set of algorithm parameters, and source of randomness.", "history": "Added in API level 1", "FullName": "protected abstract void engineInit (Key key, AlgorithmParameterSpec params, SecureRandom random)"}, "engineInit(java.security.Key,java.security.SecureRandom)": {"Returns": [], "Parameters": [["@B_java#security#Key_E@", "Key: the party's private information. For example, in the case of the Diffie-Hellman key agreement, this would be the party's own Diffie-Hellman private key."], ["@B_java#security#SecureRandom_E@", "SecureRandom: the source of randomness"]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this key agreement, e.g., is of the wrong type or has an incompatible algorithm type."]], "SeeAlso": [], "Permissions": [], "Description": "Initializes this key agreement with the given key and source of randomness. The given key is required to contain all the algorithm parameters required for this key agreement. If the key agreement algorithm requires random bytes, it gets them from the given source of randomness, random. However, if the underlying algorithm implementation does not require any random bytes, random is ignored.", "history": "Added in API level 1", "FullName": "protected abstract void engineInit (Key key, SecureRandom random)"}, "engineDoPhase(java.security.Key,boolean)": {"Returns": [["@B_java#security#Key_E@", "the (intermediate) key resulting from this phase, or null if this phase does not yield a key"]], "Parameters": [["@B_java#security#Key_E@", "Key: the key for this phase. For example, in the case of Diffie-Hellman between 2 parties, this would be the other party's Diffie-Hellman public key."], ["boolean", "boolean: flag which indicates whether or not this is the last phase of this key agreement."]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this phase."], ["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Executes the next phase of this key agreement with the given key that was received from one of the other parties involved in this key agreement.", "history": "Added in API level 1", "FullName": "protected abstract Key engineDoPhase (Key key, boolean lastPhase)"}, "engineGenerateSecret()": {"Returns": [["byte[]", "the new buffer with the shared secret"]], "Parameters": [], "Throws": [["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been completed yet"]], "SeeAlso": [], "Permissions": [], "Description": "Generates the shared secret and returns it in a new buffer. This method resets this KeyAgreementSpi object, so that it can be reused for further key agreements. Unless this key agreement is reinitialized with one of the engineInit methods, the same private information and algorithm parameters will be used for subsequent key agreements.", "history": "Added in API level 1", "FullName": "protected abstract byte[] engineGenerateSecret ()"}, "engineDoPhase(java.security.Key, boolean)": {"Returns": [["@B_java#security#Key_E@", "the (intermediate) key resulting from this phase, or null if this phase does not yield a key"]], "Parameters": [["@B_java#security#Key_E@", "Key: the key for this phase. For example, in the case of Diffie-Hellman between 2 parties, this would be the other party's Diffie-Hellman public key."], ["boolean", "boolean: flag which indicates whether or not this is the last phase of this key agreement."]], "Throws": [["@B_java#security#InvalidKeyException_E@", "if the given key is inappropriate for this phase."], ["@B_java#lang#IllegalStateException_E@", "if this key agreement has not been initialized."]], "SeeAlso": [], "Permissions": [], "Description": "Executes the next phase of this key agreement with the given key that was received from one of the other parties involved in this key agreement.", "history": "added in API level 1", "FullName": "protected abstract Key engineDoPhase (Key key, boolean lastPhase)"}}, "Inheritance": [], "ClassName": "javax.crypto.KeyAgreementSpi", "ClassDesc": "This class defines the KeyAgreement class. All the abstract methods in this class must be implemented by each cryptographic service provider who wishes to supply the implementation of a particular key agreement algorithm. The keys involved in establishing a shared secret are created by one of the key generators (KeyPairGenerator or KeyGenerator), a KeyFactory, or as a result from an intermediate phase of the key agreement protocol (@B_javax#crypto#KeyAgreementSpi#engineDoPhase_E@). For each of the correspondents in the key exchange, engineDoPhase needs to be called. For example, if the key exchange is with one other party, engineDoPhase needs to be called once, with the lastPhase flag set to true. If the key exchange is with two other parties, engineDoPhase needs to be called twice, the first time setting the lastPhase flag to false, and the second time setting it to true. There may be any number of parties involved in a key exchange."}