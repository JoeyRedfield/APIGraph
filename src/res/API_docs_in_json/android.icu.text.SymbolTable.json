{"Functions": {"lookup(java.lang.String)": {"Returns": [["char[]", "a char array containing the name's value, or null if there is no mapping for s."]], "Parameters": [["@B_java#lang#String_E@", "String: the symbolic name to lookup"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Lookup the characters associated with this string and return it. Return", "history": "Added in API level 24", "FullName": "public abstract char[] lookup (String s)"}, "parseReference(java.lang.String,java.text.ParsePosition,int)": {"Returns": [["@B_java#lang#String_E@", "the parsed name, or null if there is no valid symbolic name at the given position."]], "Parameters": [["@B_java#lang#String_E@", "String: the text to parse for the name"], ["@B_java#text#ParsePosition_E@", "ParsePosition: on entry, the index of the first character to parse. This is the character following the SYMBOL_REF character. On exit, the index after the last parsed character. If the parse failed, pos is unchanged on exit."], ["int", "int: the index after the last character to be parsed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Parse a symbol reference name from the given string, starting at the given position. If no valid symbol reference name is found, return null and leave pos unchanged. That is, if the character at pos cannot start a name, or if pos is at or after text.length(), then return null. This indicates an isolated SYMBOL_REF character.", "history": "Added in API level 24", "FullName": "public abstract String parseReference (String text, ParsePosition pos, int limit)"}, "lookupMatcher(int)": {"Returns": [["@B_android#icu#text#UnicodeMatcher_E@", "the UnicodeMatcher object represented by the given character, or null if there is no mapping for ch."]], "Parameters": [["int", "int: a 32-bit code point from 0 to 0x10FFFF inclusive."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Lookup the UnicodeMatcher associated with the given character, and return it. Return", "history": "Added in API level 24", "FullName": "public abstract UnicodeMatcher lookupMatcher (int ch)"}}, "Inheritance": [], "ClassName": "android.icu.text.SymbolTable", "ClassDesc": "An interface that defines both lookup protocol and parsing of symbolic names. This interface is used by UnicodeSet to resolve $Variable style references that appear in set patterns. RBBI and Transliteration both independently implement this interface. A symbol table maintains two kinds of mappings. The first is between symbolic names and their values. For example, if the variable with the name \"start\" is set to the value \"alpha\" (perhaps, though not necessarily, through an expression such as \"$start=alpha\"), then the call lookup(\"start\") will return the char[] array ['a', 'l', 'p', 'h', 'a']. The second kind of mapping is between character values and UnicodeMatcher objects. This is used by RuleBasedTransliterator, which uses characters in the private use area to represent objects such as UnicodeSets. If U+E015 is mapped to the UnicodeSet [a-z], then lookupMatcher(0xE015) will return the UnicodeSet [a-z]. Finally, a symbol table defines parsing behavior for symbolic names. All symbolic names start with the SYMBOL_REF character. When a parser encounters this character, it calls parseReference() with the position immediately following the SYMBOL_REF. The symbol table parses the name, if there is one, and returns it."}