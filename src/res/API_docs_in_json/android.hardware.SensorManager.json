{"Functions": {"getDefaultSensor(int)": {"Returns": [["@B_android#hardware#Sensor_E@", "the default sensor matching the requested type if one exists and the application has the necessary permissions, or null otherwise."]], "Parameters": [["int", "int: of sensors requested"]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#getSensorList_E@", "@B_android#hardware#Sensor_E@"], "Permissions": [], "Description": "Use this method to get the default sensor for a given type. Note that the returned sensor could be a composite sensor, and its data could be averaged or filtered. If you need to access the raw sensors use @B_android#hardware#SensorManager#getSensorList_E@.", "history": "Added in API level 3", "FullName": "public Sensor getDefaultSensor (int type)"}, "unregisterListener(android.hardware.SensorListener,int)": {"Returns": [], "Parameters": [["@B_android#hardware#SensorListener_E@", "SensorListener: a SensorListener object"], ["int", "int: a bit masks of the sensors to unregister from"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is deprecated, use @B_android#hardware#SensorManager#unregisterListener_E@ instead. Unregisters a listener for the sensors with which it is registered.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public void unregisterListener (SensorListener listener, int sensors)"}, "getSensorList(int)": {"Returns": [["@B_java#util#List_E@", "a list of sensors matching the asked type."]], "Parameters": [["int", "int: of sensors requested"]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#getDefaultSensor_E@", "@B_android#hardware#Sensor_E@"], "Permissions": [], "Description": "Use this method to get the list of available sensors of a certain type. Make multiple calls to get sensors of different types or use @B_android#hardware#Sensor#TYPE_ALL_E@ to get all the sensors. NOTE: Both wake-up and non wake-up sensors matching the given type are returned. Check @B_android#hardware#Sensor#isWakeUpSensor_E@ to know the wake-up properties of the returned @B_android#hardware#Sensor_E@.", "history": "Added in API level 3", "FullName": "public List<Sensor> getSensorList (int type)"}, "registerDynamicSensorCallback(android.hardware.SensorManager.DynamicSensorCallback)": {"Returns": [], "Parameters": [["@B_android#hardware#SensorManager#DynamicSensorCallback_E@", "SensorManager.DynamicSensorCallback: An object that implements the @B_android#hardware#SensorManager#DynamicSensorCallback_E@ interface for receiving callbacks."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when callback is null."]], "SeeAlso": ["@B_android#hardware#SensorManager#registerDynamicSensorCallback_E@"], "Permissions": [], "Description": "Add a @B_android#hardware#SensorManager#DynamicSensorCallback_E@ to receive dynamic sensor connection callbacks. Repeat registration with the already registered callback object will have no additional effect.", "history": "Added in API level 24", "FullName": "public void registerDynamicSensorCallback (SensorManager.DynamicSensorCallback callback)"}, "registerListener(android.hardware.SensorListener,int)": {"Returns": [["boolean", "true if the sensor is supported and successfully enabled"]], "Parameters": [["@B_android#hardware#SensorListener_E@", "SensorListener: sensor listener object"], ["int", "int: a bit masks of the sensors to register to"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is deprecated, use @B_android#hardware#SensorManager#registerListener_E@ instead. Registers a listener for given sensors.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public boolean registerListener (SensorListener listener, int sensors)"}, "requestTriggerSensor(android.hardware.TriggerEventListener,android.hardware.Sensor)": {"Returns": [["boolean", "true if the sensor was successfully enabled."]], "Parameters": [["@B_android#hardware#TriggerEventListener_E@", "TriggerEventListener: The listener on which the @B_android#hardware#TriggerEventListener#onTrigger_E@ will be delivered."], ["@B_android#hardware#Sensor_E@", "Sensor: The sensor to be enabled."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when sensor is null or not a trigger sensor."]], "SeeAlso": [], "Permissions": [], "Description": "Requests receiving trigger events for a trigger sensor. When the sensor detects a trigger event condition, such as significant motion in the case of the @B_android#hardware#Sensor#TYPE_SIGNIFICANT_MOTION_E@, the provided trigger listener will be invoked once and then its request to receive trigger events will be canceled. To continue receiving trigger events, the application must request to receive trigger events again.", "history": "Added in API level 18", "FullName": "public boolean requestTriggerSensor (TriggerEventListener listener, Sensor sensor)"}, "getDefaultSensor(int, boolean)": {"Returns": [["@B_android#hardware#Sensor_E@", "the default sensor matching the requested type and wakeUp properties if one exists and the application has the necessary permissions, or null otherwise."]], "Parameters": [["int", "int: type of sensor requested"], ["boolean", "boolean: flag to indicate whether the Sensor is a wake-up or non wake-up sensor."]], "Throws": [], "SeeAlso": ["@B_android#hardware#Sensor#isWakeUpSensor_E@"], "Permissions": [], "Description": "Return a Sensor with the given type and wakeUp properties. If multiple sensors of this type exist, any one of them may be returned. For example, getDefaultSensor(@B_android#hardware#Sensor#TYPE_ACCELEROMETER_E@, true) returns a wake-up accelerometer sensor if it exists. getDefaultSensor(@B_android#hardware#Sensor#TYPE_PROXIMITY_E@, false) returns a non wake-up proximity sensor if it exists. getDefaultSensor(@B_android#hardware#Sensor#TYPE_PROXIMITY_E@, true) returns a wake-up proximity sensor which is the same as the Sensor returned by @B_android#hardware#SensorManager#getDefaultSensor_E@. Note: Sensors like @B_android#hardware#Sensor#TYPE_PROXIMITY_E@ and @B_android#hardware#Sensor#TYPE_SIGNIFICANT_MOTION_E@ are declared as wake-up sensors by default.", "history": "added in API level 21", "FullName": "public Sensor getDefaultSensor (int type, boolean wakeUp)"}, "flush(android.hardware.SensorEventListener)": {"Returns": [["boolean", "true if the flush is initiated successfully on all the sensors registered for this listener, false if no sensor is previously registered for this listener or flush on one of the sensors fails."]], "Parameters": [["@B_android#hardware#SensorEventListener_E@", "SensorEventListener: A @B_android#hardware#SensorEventListener_E@ object which was previously used in a registerListener call."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when listener is null."]], "SeeAlso": ["@B_android#hardware#SensorManager#registerListener_E@"], "Permissions": [], "Description": "Flushes the FIFO of all the sensors registered for this listener. If there are events in the FIFO of the sensor, they are returned as if the maxReportLantecy of the FIFO has expired. Events are returned in the usual way through the SensorEventListener. This call doesn't affect the maxReportLantecy for this sensor. This call is asynchronous and returns immediately. @B_android#hardware#SensorEventListener2#onFlushCompleted_E@ is called after all the events in the batch at the time of calling this method have been delivered successfully. If the hardware doesn't support flush, it still returns true and a trivial flush complete event is sent after the current event for all the clients registered for this sensor.", "history": "Added in API level 19", "FullName": "public boolean flush (SensorEventListener listener)"}, "getSensors()": {"Returns": [["int", "available sensors."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is deprecated, use @B_android#hardware#SensorManager#getSensorList_E@ instead", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public int getSensors ()"}, "getDynamicSensorList(int)": {"Returns": [["@B_java#util#List_E@", "a list of dynamic sensors matching the requested type."]], "Parameters": [["int", "int: of sensors requested"]], "Throws": [], "SeeAlso": ["@B_android#hardware#Sensor_E@"], "Permissions": [], "Description": "Use this method to get a list of available dynamic sensors of a certain type. Make multiple calls to get sensors of different types or use @B_android#hardware#Sensor#TYPE_ALL_E@ to get all dynamic sensors. NOTE: Both wake-up and non wake-up sensors matching the given type are returned. Check @B_android#hardware#Sensor#isWakeUpSensor_E@ to know the wake-up properties of the returned @B_android#hardware#Sensor_E@.", "history": "Added in API level 24", "FullName": "public List<Sensor> getDynamicSensorList (int type)"}, "registerListener(android.hardware.SensorEventListener,android.hardware.Sensor,int,android.os.Handler)": {"Returns": [["boolean", "true if the sensor is supported and successfully enabled."]], "Parameters": [["@B_android#hardware#SensorEventListener_E@", "SensorEventListener: A @B_android#hardware#SensorEventListener_E@ object."], ["@B_android#hardware#Sensor_E@", "Sensor: The @B_android#hardware#Sensor_E@ to register to."], ["int", "int: The rate @B_android#hardware#SensorEvent_E@ are delivered at. This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. The value must be one of @B_android#hardware#SensorManager#SENSOR_DELAY_NORMAL_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_UI_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_GAME_E@, or @B_android#hardware#SensorManager#SENSOR_DELAY_FASTEST_E@ or, the desired delay between events in microseconds. Specifying the delay in microseconds only works from Android 2.3 (API level 9) onwards. For earlier releases, you must use one of the SENSOR_DELAY_* constants."], ["@B_android#os#Handler_E@", "Handler: The @B_android#os#Handler_E@ the @B_android#hardware#SensorEvent_E@ will be delivered to."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#registerListener_E@", "@B_android#hardware#SensorManager#unregisterListener_E@"], "Permissions": [], "Description": "Registers a @B_android#hardware#SensorEventListener_E@ for the given sensor. Events are delivered in continuous mode as soon as they are available. To reduce the power consumption, applications can use @B_android#hardware#SensorManager#registerListener_E@ instead and specify a positive non-zero maximum reporting latency. Note: Don't use this method with a one shot trigger sensor such as @B_android#hardware#Sensor#TYPE_SIGNIFICANT_MOTION_E@. Use @B_android#hardware#SensorManager#requestTriggerSensor_E@ instead.", "history": "Added in API level 3", "FullName": "public boolean registerListener (SensorEventListener listener, Sensor sensor, int samplingPeriodUs, Handler handler)"}, "getOrientation(float[],float[])": {"Returns": [["float[]", "The array values passed as argument."]], "Parameters": [["float[]", "float: rotation matrix see @B_android#hardware#SensorManager#getRotationMatrix_E@."], ["float[]", "float: an array of 3 floats to hold the result."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#getRotationMatrix_E@", "@B_android#hardware#GeomagneticField_E@"], "Permissions": [], "Description": "Computes the device's orientation based on the rotation matrix. When it returns, the array values are as follows: values[0]: values[1]: values[2]: Applying these three rotations in the azimuth, pitch, roll order transforms an identity matrix to the rotation matrix passed into this method. Also, note that all three orientation angles are expressed in", "history": "Added in API level 3", "FullName": "public static float[] getOrientation (float[] R, float[] values)"}, "createDirectChannel(android.os.MemoryFile)": {"Returns": [["@B_android#hardware#SensorDirectChannel_E@", "A @B_android#hardware#SensorDirectChannel_E@ object."]], "Parameters": [["@B_android#os#MemoryFile_E@", "MemoryFile: A @B_android#os#MemoryFile_E@ shared memory object."]], "Throws": [["@B_java#lang#NullPointerException_E@", "when mem is null."], ["", "if not able to create channel."]], "SeeAlso": ["@B_android#hardware#SensorDirectChannel#close_E@"], "Permissions": [], "Description": "Create a sensor direct channel backed by shared memory wrapped in MemoryFile object. The resulting channel can be used for delivering sensor events to native code, other processes, GPU/DSP or other co-processors without CPU intervention. This is the recommanded for high performance sensor applications that use high sensor rates (e.g. greater than 200Hz) and cares about sensor event latency. Use the returned @B_android#hardware#SensorDirectChannel_E@ object to configure direct report of sensor events. After use, call @B_android#hardware#SensorDirectChannel#close_E@ to free up resource in sensor system associated with the direct channel.", "history": "Added in API level 26", "FullName": "public SensorDirectChannel createDirectChannel (MemoryFile mem)"}, "getOrientation(float[], float[])": {"Returns": [["float[]", "The array values passed as argument."]], "Parameters": [["float[]", "float: rotation matrix see @B_android#hardware#SensorManager#getRotationMatrix_E@."], ["float[]", "float: an array of 3 floats to hold the result."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#getRotationMatrix_E@", "@B_android#hardware#GeomagneticField_E@"], "Permissions": [], "Description": "Computes the device's orientation based on the rotation matrix. When it returns, the array values are as follows: values[0]: values[1]: values[2]: Applying these three rotations in the azimuth, pitch, roll order transforms an identity matrix to the rotation matrix passed into this method. Also, note that all three orientation angles are expressed in", "history": "added in API level 3", "FullName": "public static float[] getOrientation (float[] R, float[] values)"}, "getRotationMatrixFromVector(float[],float[])": {"Returns": [], "Parameters": [["float[]", "float: an array of floats in which to store the rotation matrix"], ["float[]", "float: the rotation vector to convert"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Helper function to convert a rotation vector to a rotation matrix. Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a 9 or 16 element rotation matrix in the array R. R must have length 9 or 16. If R.length == 9, the following matrix is returned:", "history": "Added in API level 9", "FullName": "public static void getRotationMatrixFromVector (float[] R, float[] rotationVector)"}, "registerDynamicSensorCallback(android.hardware.SensorManager.DynamicSensorCallback,android.os.Handler)": {"Returns": [], "Parameters": [["@B_android#hardware#SensorManager#DynamicSensorCallback_E@", "SensorManager.DynamicSensorCallback: An object that implements the @B_android#hardware#SensorManager#DynamicSensorCallback_E@ interface for receiving callbacks."], ["@B_android#os#Handler_E@", "Handler: The @B_android#os#Handler_E@ the @B_android#hardware#SensorManager#DynamicSensorCallback_E@ will be delivered to."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when callback is null."]], "SeeAlso": [], "Permissions": [], "Description": "Add a @B_android#hardware#SensorManager#DynamicSensorCallback_E@ to receive dynamic sensor connection callbacks. Repeat registration with the already registered callback object will have no additional effect.", "history": "Added in API level 24", "FullName": "public void registerDynamicSensorCallback (SensorManager.DynamicSensorCallback callback, Handler handler)"}, "registerListener(android.hardware.SensorEventListener,android.hardware.Sensor,int)": {"Returns": [["boolean", "true if the sensor is supported and successfully enabled."]], "Parameters": [["@B_android#hardware#SensorEventListener_E@", "SensorEventListener: A @B_android#hardware#SensorEventListener_E@ object."], ["@B_android#hardware#Sensor_E@", "Sensor: The @B_android#hardware#Sensor_E@ to register to."], ["int", "int: The rate @B_android#hardware#SensorEvent_E@ are delivered at. This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. The value must be one of @B_android#hardware#SensorManager#SENSOR_DELAY_NORMAL_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_UI_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_GAME_E@, or @B_android#hardware#SensorManager#SENSOR_DELAY_FASTEST_E@ or, the desired delay between events in microseconds. Specifying the delay in microseconds only works from Android 2.3 (API level 9) onwards. For earlier releases, you must use one of the SENSOR_DELAY_* constants."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#registerListener_E@", "@B_android#hardware#SensorManager#unregisterListener_E@"], "Permissions": [], "Description": "Registers a @B_android#hardware#SensorEventListener_E@ for the given sensor at the given sampling frequency. The events will be delivered to the provided SensorEventListener as soon as they are available. To reduce the power consumption, applications can use @B_android#hardware#SensorManager#registerListener_E@ instead and specify a positive non-zero maximum reporting latency. In the case of non-wake-up sensors, the events are only delivered while the Application Processor (AP) is not in suspend mode. See @B_android#hardware#Sensor#isWakeUpSensor_E@ for more details. To ensure delivery of events from non-wake-up sensors even when the screen is OFF, the application registering to the sensor must hold a partial wake-lock to keep the AP awake, otherwise some events might be lost while the AP is asleep. Note that although events might be lost while the AP is asleep, the sensor will still consume power if it is not explicitly deactivated by the application. Applications must unregister their SensorEventListeners in their activity's onPause() method to avoid consuming power while the device is inactive. See @B_android#hardware#SensorManager#registerListener_E@ for more details on hardware FIFO (queueing) capabilities and when some sensor events might be lost. In the case of wake-up sensors, each event generated by the sensor will cause the AP to wake-up, ensuring that each event can be delivered. Because of this, registering to a wake-up sensor has very significant power implications. Call @B_android#hardware#Sensor#isWakeUpSensor_E@ to check whether a sensor is a wake-up sensor. See @B_android#hardware#SensorManager#registerListener_E@ for information on how to reduce the power impact of registering to wake-up sensors. Note: Don't use this method with one-shot trigger sensors such as @B_android#hardware#Sensor#TYPE_SIGNIFICANT_MOTION_E@. Use @B_android#hardware#SensorManager#requestTriggerSensor_E@ instead. Use @B_android#hardware#Sensor#getReportingMode_E@ to obtain the reporting mode of a given sensor.", "history": "Added in API level 3", "FullName": "public boolean registerListener (SensorEventListener listener, Sensor sensor, int samplingPeriodUs)"}, "registerListener(android.hardware.SensorEventListener,android.hardware.Sensor,int,int)": {"Returns": [["boolean", "true if the sensor is supported and successfully enabled."]], "Parameters": [["@B_android#hardware#SensorEventListener_E@", "SensorEventListener: A @B_android#hardware#SensorEventListener_E@ object that will receive the sensor events. If the application is interested in receiving flush complete notifications, it should register with @B_android#hardware#SensorEventListener_E@ instead."], ["@B_android#hardware#Sensor_E@", "Sensor: The @B_android#hardware#Sensor_E@ to register to."], ["int", "int: The desired delay between two consecutive events in microseconds. This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. Can be one of @B_android#hardware#SensorManager#SENSOR_DELAY_NORMAL_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_UI_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_GAME_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_FASTEST_E@ or the delay in microseconds."], ["int", "int: Maximum time in microseconds that events can be delayed before being reported to the application. A large value allows reducing the power consumption associated with the sensor. If maxReportLatencyUs is set to zero, events are delivered as soon as they are available, which is equivalent to calling @B_android#hardware#SensorManager#registerListener_E@."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#registerListener_E@", "@B_android#hardware#SensorManager#unregisterListener_E@", "@B_android#hardware#SensorManager#flush_E@"], "Permissions": [], "Description": "Registers a @B_android#hardware#SensorEventListener_E@ for the given sensor at the given sampling frequency and the given maximum reporting latency. This function is similar to @B_android#hardware#SensorManager#registerListener_E@ but it allows events to stay temporarily in the hardware FIFO (queue) before being delivered. The events can be stored in the hardware FIFO up to maxReportLatencyUs microseconds. Once one of the events in the FIFO needs to be reported, all of the events in the FIFO are reported sequentially. This means that some events will be reported before the maximum reporting latency has elapsed. When maxReportLatencyUs is 0, the call is equivalent to a call to @B_android#hardware#SensorManager#registerListener_E@, as it requires the events to be delivered as soon as possible. When sensor.maxFifoEventCount() is 0, the sensor does not use a FIFO, so the call will also be equivalent to @B_android#hardware#SensorManager#registerListener_E@. Setting maxReportLatencyUs to a positive value allows to reduce the number of interrupts the AP (Application Processor) receives, hence reducing power consumption, as the AP can switch to a lower power state while the sensor is capturing the data. This is especially important when registering to wake-up sensors, for which each interrupt causes the AP to wake up if it was in suspend mode. See @B_android#hardware#Sensor#isWakeUpSensor_E@ for more information on wake-up sensors. Note: Don't use this method with one-shot trigger sensors such as @B_android#hardware#Sensor#TYPE_SIGNIFICANT_MOTION_E@. Use @B_android#hardware#SensorManager#requestTriggerSensor_E@ instead.", "history": "Added in API level 19", "FullName": "public boolean registerListener (SensorEventListener listener, Sensor sensor, int samplingPeriodUs, int maxReportLatencyUs)"}, "registerListener(android.hardware.SensorListener,int,int)": {"Returns": [["boolean", "true if the sensor is supported and successfully enabled"]], "Parameters": [["@B_android#hardware#SensorListener_E@", "SensorListener: sensor listener object"], ["int", "int: a bit masks of the sensors to register to"], ["int", "int: rate of events. This is only a hint to the system. events may be received faster or slower than the specified rate. Usually events are received faster. The value must be one of @B_android#hardware#SensorManager#SENSOR_DELAY_NORMAL_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_UI_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_GAME_E@, or @B_android#hardware#SensorManager#SENSOR_DELAY_FASTEST_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is deprecated, use @B_android#hardware#SensorManager#registerListener_E@ instead. Registers a SensorListener for given sensors.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public boolean registerListener (SensorListener listener, int sensors, int rate)"}, "isDynamicSensorDiscoverySupported()": {"Returns": [["boolean", "true if dynamic sensor discovery is supported, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Tell if dynamic sensor discovery feature is supported by system.", "history": "Added in API level 24", "FullName": "public boolean isDynamicSensorDiscoverySupported ()"}, "getRotationMatrixFromVector(float[], float[])": {"Returns": [], "Parameters": [["float[]", "float: an array of floats in which to store the rotation matrix"], ["float[]", "float: the rotation vector to convert"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Helper function to convert a rotation vector to a rotation matrix. Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a 9 or 16 element rotation matrix in the array R. R must have length 9 or 16. If R.length == 9, the following matrix is returned:", "history": "added in API level 9", "FullName": "public static void getRotationMatrixFromVector (float[] R, float[] rotationVector)"}, "registerListener(android.hardware.SensorEventListener,android.hardware.Sensor,int,int,android.os.Handler)": {"Returns": [["boolean", "true if the sensor is supported and successfully enabled."]], "Parameters": [["@B_android#hardware#SensorEventListener_E@", "SensorEventListener: A @B_android#hardware#SensorEventListener_E@ object that will receive the sensor events. If the application is interested in receiving flush complete notifications, it should register with @B_android#hardware#SensorEventListener_E@ instead."], ["@B_android#hardware#Sensor_E@", "Sensor: The @B_android#hardware#Sensor_E@ to register to."], ["int", "int: The desired delay between two consecutive events in microseconds. This is only a hint to the system. Events may be received faster or slower than the specified rate. Usually events are received faster. Can be one of @B_android#hardware#SensorManager#SENSOR_DELAY_NORMAL_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_UI_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_GAME_E@, @B_android#hardware#SensorManager#SENSOR_DELAY_FASTEST_E@ or the delay in microseconds."], ["int", "int: Maximum time in microseconds that events can be delayed before being reported to the application. A large value allows reducing the power consumption associated with the sensor. If maxReportLatencyUs is set to zero, events are delivered as soon as they are available, which is equivalent to calling @B_android#hardware#SensorManager#registerListener_E@."], ["@B_android#os#Handler_E@", "Handler: The @B_android#os#Handler_E@ the @B_android#hardware#SensorEvent_E@ will be delivered to."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#registerListener_E@"], "Permissions": [], "Description": "Registers a @B_android#hardware#SensorEventListener_E@ for the given sensor at the given sampling frequency and the given maximum reporting latency.", "history": "Added in API level 19", "FullName": "public boolean registerListener (SensorEventListener listener, Sensor sensor, int samplingPeriodUs, int maxReportLatencyUs, Handler handler)"}, "unregisterListener(android.hardware.SensorListener)": {"Returns": [], "Parameters": [["@B_android#hardware#SensorListener_E@", "SensorListener: a SensorListener object"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This method is deprecated, use @B_android#hardware#SensorManager#unregisterListener_E@ instead. Unregisters a listener for all sensors.", "history": "Added in API level 1 Deprecated in API level 15", "FullName": "public void unregisterListener (SensorListener listener)"}, "getQuaternionFromVector(float[],float[])": {"Returns": [], "Parameters": [["float[]", "float: an array of floats in which to store the computed quaternion"], ["float[]", "float: the rotation vector to convert"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Helper function to convert a rotation vector to a normalized quaternion. Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a normalized quaternion in the array Q. The quaternion is stored as [w, x, y, z]", "history": "Added in API level 9", "FullName": "public static void getQuaternionFromVector (float[] Q, float[] rv)"}, "getInclination(float[])": {"Returns": [["float", "The geomagnetic inclination angle in radians."]], "Parameters": [["float[]", "float: inclination matrix see @B_android#hardware#SensorManager#getRotationMatrix_E@."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#getRotationMatrix_E@", "@B_android#hardware#SensorManager#getOrientation_E@", "@B_android#hardware#GeomagneticField_E@"], "Permissions": [], "Description": "Computes the geomagnetic inclination angle in radians from the inclination matrix @B_android#hardware#SensorManager#getRotationMatrix_E@.", "history": "Added in API level 3", "FullName": "public static float getInclination (float[] I)"}, "remapCoordinateSystem(float[], int, int, float[])": {"Returns": [["boolean", "true on success. false if the input parameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length."]], "Parameters": [["float[]", "float: the rotation matrix to be transformed. Usually it is the matrix returned by @B_android#hardware#SensorManager#getRotationMatrix_E@."], ["int", "int: defines the axis of the new cooridinate system that coincide with the X axis of the original coordinate system."], ["int", "int: defines the axis of the new cooridinate system that coincide with the Y axis of the original coordinate system."], ["float[]", "float: the transformed rotation matrix. inR and outR should not be the same array."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#getRotationMatrix_E@"], "Permissions": [], "Description": "Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see @B_android#hardware#SensorManager#getOrientation_E@) in a different coordinate system. When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually @B_android#view#Display#getRotation_E@ to retrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed: remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR); Using the device as a mechanical compass when rotation is @B_android#view#Surface#ROTATION_90_E@: remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR); Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see @B_android#hardware#SensorManager#getOrientation_E@). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your @B_android#app#Activity_E@ is running in landscape mode. Since the resulting coordinate system is orthonormal, only two axes need to be specified.", "history": "added in API level 3", "FullName": "public static boolean remapCoordinateSystem (float[] inR, int X, int Y, float[] outR)"}, "getAngleChange(float[],float[],float[])": {"Returns": [], "Parameters": [["float[]", "float: an an array of floats (z, x, and y) in which the angle change (in radians) is stored"], ["float[]", "float: current rotation matrix"], ["float[]", "float: previous rotation matrix"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the intrinsic rotation around the z, x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z, x, and y angle change at indexes 0, 1, and 2 respectively. Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: If the array length is 9, then the array elements represent this matrix If the array length is 16, then the array elements represent this matrix @B_android#hardware#SensorManager#getOrientation_E@ for more detailed definition of the output.", "history": "Added in API level 9", "FullName": "public static void getAngleChange (float[] angleChange, float[] R, float[] prevR)"}, "getAngleChange(float[], float[], float[])": {"Returns": [], "Parameters": [["float[]", "float: an an array of floats (z, x, and y) in which the angle change (in radians) is stored"], ["float[]", "float: current rotation matrix"], ["float[]", "float: previous rotation matrix"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Helper function to compute the angle change between two rotation matrices. Given a current rotation matrix (R) and a previous rotation matrix (prevR) computes the intrinsic rotation around the z, x, and y axes which transforms prevR to R. outputs a 3 element vector containing the z, x, and y angle change at indexes 0, 1, and 2 respectively. Each input matrix is either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: If the array length is 9, then the array elements represent this matrix If the array length is 16, then the array elements represent this matrix @B_android#hardware#SensorManager#getOrientation_E@ for more detailed definition of the output.", "history": "added in API level 9", "FullName": "public static void getAngleChange (float[] angleChange, float[] R, float[] prevR)"}, "cancelTriggerSensor(android.hardware.TriggerEventListener,android.hardware.Sensor)": {"Returns": [["boolean", "true if successfully canceled."]], "Parameters": [["@B_android#hardware#TriggerEventListener_E@", "TriggerEventListener: The listener on which the @B_android#hardware#TriggerEventListener#onTrigger_E@ is delivered.It should be the same as the one used in @B_android#hardware#SensorManager#requestTriggerSensor_E@"], ["@B_android#hardware#Sensor_E@", "Sensor: The sensor for which the trigger request should be canceled. If null, it cancels receiving trigger for all sensors associated with the listener."]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "when sensor is a trigger sensor."]], "SeeAlso": [], "Permissions": [], "Description": "Cancels receiving trigger events for a trigger sensor. Note that a Trigger sensor will be auto disabled if @B_android#hardware#TriggerEventListener#onTrigger_E@ has triggered. This method is provided in case the user wants to explicitly cancel the request to receive trigger events.", "history": "Added in API level 18", "FullName": "public boolean cancelTriggerSensor (TriggerEventListener listener, Sensor sensor)"}, "getDefaultSensor(int,boolean)": {"Returns": [["@B_android#hardware#Sensor_E@", "the default sensor matching the requested type and wakeUp properties if one exists and the application has the necessary permissions, or null otherwise."]], "Parameters": [["int", "int: type of sensor requested"], ["boolean", "boolean: flag to indicate whether the Sensor is a wake-up or non wake-up sensor."]], "Throws": [], "SeeAlso": ["@B_android#hardware#Sensor#isWakeUpSensor_E@"], "Permissions": [], "Description": "Return a Sensor with the given type and wakeUp properties. If multiple sensors of this type exist, any one of them may be returned. For example, getDefaultSensor(@B_android#hardware#Sensor#TYPE_ACCELEROMETER_E@, true) returns a wake-up accelerometer sensor if it exists. getDefaultSensor(@B_android#hardware#Sensor#TYPE_PROXIMITY_E@, false) returns a non wake-up proximity sensor if it exists. getDefaultSensor(@B_android#hardware#Sensor#TYPE_PROXIMITY_E@, true) returns a wake-up proximity sensor which is the same as the Sensor returned by @B_android#hardware#SensorManager#getDefaultSensor_E@. Note: Sensors like @B_android#hardware#Sensor#TYPE_PROXIMITY_E@ and @B_android#hardware#Sensor#TYPE_SIGNIFICANT_MOTION_E@ are declared as wake-up sensors by default.", "history": "Added in API level 21", "FullName": "public Sensor getDefaultSensor (int type, boolean wakeUp)"}, "unregisterListener(android.hardware.SensorEventListener,android.hardware.Sensor)": {"Returns": [], "Parameters": [["@B_android#hardware#SensorEventListener_E@", "SensorEventListener: a SensorEventListener object"], ["@B_android#hardware#Sensor_E@", "Sensor: the sensor to unregister from"]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#unregisterListener_E@", "@B_android#hardware#SensorManager#registerListener_E@"], "Permissions": [], "Description": "Unregisters a listener for the sensors with which it is registered. Note: Don't use this method with a one shot trigger sensor such as @B_android#hardware#Sensor#TYPE_SIGNIFICANT_MOTION_E@. Use @B_android#hardware#SensorManager#cancelTriggerSensor_E@ instead.", "history": "Added in API level 3", "FullName": "public void unregisterListener (SensorEventListener listener, Sensor sensor)"}, "getAltitude(float,float)": {"Returns": [["float", "Altitude in meters"]], "Parameters": [["float", "float: pressure at sea level"], ["float", "float: atmospheric pressure"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Computes the Altitude in meters from the atmospheric pressure and the pressure at sea level. Typically the atmospheric pressure is read from a @B_android#hardware#Sensor#TYPE_PRESSURE_E@ sensor. The pressure at sea level must be known, usually it can be retrieved from airport databases in the vicinity. If unknown, you can use @B_android#hardware#SensorManager#PRESSURE_STANDARD_ATMOSPHERE_E@ as an approximation, but absolute altitudes won't be accurate. To calculate altitude differences, you must calculate the difference between the altitudes at both points. If you don't know the altitude as sea level, you can use @B_android#hardware#SensorManager#PRESSURE_STANDARD_ATMOSPHERE_E@ instead, which will give good results considering the range of pressure typically involved. float altitude_difference = getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point2) - getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point1);", "history": "Added in API level 9", "FullName": "public static float getAltitude (float p0, float p)"}, "createDirectChannel(android.hardware.HardwareBuffer)": {"Returns": [["@B_android#hardware#SensorDirectChannel_E@", "A @B_android#hardware#SensorDirectChannel_E@ object."]], "Parameters": [["@B_android#hardware#HardwareBuffer_E@", "HardwareBuffer: A @B_android#hardware#HardwareBuffer_E@ shared memory object."]], "Throws": [["@B_java#lang#NullPointerException_E@", "when mem is null."], ["", "if not able to create channel."]], "SeeAlso": ["@B_android#hardware#SensorDirectChannel#close_E@"], "Permissions": [], "Description": "Create a sensor direct channel backed by shared memory wrapped in HardwareBuffer object. The resulting channel can be used for delivering sensor events to native code, other processes, GPU/DSP or other co-processors without CPU intervention. This is the recommanded for high performance sensor applications that use high sensor rates (e.g. greater than 200Hz) and cares about sensor event latency. Use the returned @B_android#hardware#SensorDirectChannel_E@ object to configure direct report of sensor events. After use, call @B_android#hardware#SensorDirectChannel#close_E@ to free up resource in sensor system associated with the direct channel.", "history": "Added in API level 26", "FullName": "public SensorDirectChannel createDirectChannel (HardwareBuffer mem)"}, "remapCoordinateSystem(float[],int,int,float[])": {"Returns": [["boolean", "true on success. false if the input parameters are incorrect, for instance if X and Y define the same axis. Or if inR and outR don't have the same length."]], "Parameters": [["float[]", "float: the rotation matrix to be transformed. Usually it is the matrix returned by @B_android#hardware#SensorManager#getRotationMatrix_E@."], ["int", "int: defines the axis of the new cooridinate system that coincide with the X axis of the original coordinate system."], ["int", "int: defines the axis of the new cooridinate system that coincide with the Y axis of the original coordinate system."], ["float[]", "float: the transformed rotation matrix. inR and outR should not be the same array."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#getRotationMatrix_E@"], "Permissions": [], "Description": "Rotates the supplied rotation matrix so it is expressed in a different coordinate system. This is typically used when an application needs to compute the three orientation angles of the device (see @B_android#hardware#SensorManager#getOrientation_E@) in a different coordinate system. When the rotation matrix is used for drawing (for instance with OpenGL ES), it usually @B_android#view#Display#getRotation_E@ to retrieve the current rotation of the screen. Note that because the user is generally free to rotate their screen, you often should consider the rotation in deciding the parameters to use here. Using the camera (Y axis along the camera's axis) for an augmented reality application where the rotation angles are needed: remapCoordinateSystem(inR, AXIS_X, AXIS_Z, outR); Using the device as a mechanical compass when rotation is @B_android#view#Surface#ROTATION_90_E@: remapCoordinateSystem(inR, AXIS_Y, AXIS_MINUS_X, outR); Beware of the above example. This call is needed only to account for a rotation from its natural orientation when calculating the rotation angles (see @B_android#hardware#SensorManager#getOrientation_E@). If the rotation matrix is also used for rendering, it may not need to be transformed, for instance if your @B_android#app#Activity_E@ is running in landscape mode. Since the resulting coordinate system is orthonormal, only two axes need to be specified.", "history": "Added in API level 3", "FullName": "public static boolean remapCoordinateSystem (float[] inR, int X, int Y, float[] outR)"}, "getAltitude(float, float)": {"Returns": [["float", "Altitude in meters"]], "Parameters": [["float", "float: pressure at sea level"], ["float", "float: atmospheric pressure"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Computes the Altitude in meters from the atmospheric pressure and the pressure at sea level. Typically the atmospheric pressure is read from a @B_android#hardware#Sensor#TYPE_PRESSURE_E@ sensor. The pressure at sea level must be known, usually it can be retrieved from airport databases in the vicinity. If unknown, you can use @B_android#hardware#SensorManager#PRESSURE_STANDARD_ATMOSPHERE_E@ as an approximation, but absolute altitudes won't be accurate. To calculate altitude differences, you must calculate the difference between the altitudes at both points. If you don't know the altitude as sea level, you can use @B_android#hardware#SensorManager#PRESSURE_STANDARD_ATMOSPHERE_E@ instead, which will give good results considering the range of pressure typically involved. float altitude_difference = getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point2) - getAltitude(SensorManager.PRESSURE_STANDARD_ATMOSPHERE, pressure_at_point1);", "history": "added in API level 9", "FullName": "public static float getAltitude (float p0, float p)"}, "unregisterListener(android.hardware.SensorEventListener)": {"Returns": [], "Parameters": [["@B_android#hardware#SensorEventListener_E@", "SensorEventListener: a SensorListener object"]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#unregisterListener_E@", "@B_android#hardware#SensorManager#registerListener_E@"], "Permissions": [], "Description": "Unregisters a listener for all sensors.", "history": "Added in API level 3", "FullName": "public void unregisterListener (SensorEventListener listener)"}, "getRotationMatrix(float[],float[],float[],float[])": {"Returns": [["boolean", "true on success, false on failure (for instance, if the device is in free fall). Free fall is defined as condition when the magnitude of the gravity is less than 1/10 of the nominal value. On failure the output matrices are not modified."]], "Parameters": [["float[]", "float: is an array of 9 floats holding the rotation matrix R when this function returns. R can be null."], ["float[]", "float: is an array of 9 floats holding the rotation matrix I when this function returns. I can be null."], ["float[]", "float: is an array of 3 floats containing the gravity vector expressed in the device's coordinate. You can simply use the @B_android#hardware#SensorEvent#values_E@ returned by a @B_android#hardware#SensorEvent_E@ of a @B_android#hardware#Sensor_E@ of type @B_android#hardware#Sensor#TYPE_ACCELEROMETER_E@."], ["float[]", "float: is an array of 3 floats containing the geomagnetic vector expressed in the device's coordinate. You can simply use the @B_android#hardware#SensorEvent#values_E@ returned by a @B_android#hardware#SensorEvent_E@ of a @B_android#hardware#Sensor_E@ of type @B_android#hardware#Sensor#TYPE_MAGNETIC_FIELD_E@."]], "Throws": [], "SeeAlso": ["@B_android#hardware#SensorManager#getInclination_E@", "@B_android#hardware#SensorManager#getOrientation_E@", "@B_android#hardware#SensorManager#remapCoordinateSystem_E@"], "Permissions": [], "Description": "Computes the inclination matrix X is defined as the vector product Y is tangential to the ground at the device's current location and points towards the magnetic North Pole. Z points towards the sky and is perpendicular to the ground. By definition: [0 0 g] = [0 m 0] = @B_android#hardware#SensorManager#getInclination_E@. Each matrix is returned either as a 3x3 or 4x4 row-major matrix depending on the length of the passed array: @B_javax#microedition#khronos#opengles#GL10#glLoadMatrixf_E@. Note that because OpenGL matrices are column-major matrices you must transpose the matrix before using it. However, since the matrix is a rotation matrix, its transpose is also its inverse, conveniently, it is often the inverse of the rotation that is needed for rendering; it can therefore be used with OpenGL ES directly. Also note that the returned matrices always have this form: The inverse of each matrix can be computed easily by taking its transpose. The matrices returned by this function are meaningful only when the device is not free-falling and it is not close to the magnetic north. If the device is accelerating, or placed into a strong magnetic field, the returned matrices may be inaccurate.", "history": "Added in API level 3", "FullName": "public static boolean getRotationMatrix (float[] R, float[] I, float[] gravity, float[] geomagnetic)"}, "getQuaternionFromVector(float[], float[])": {"Returns": [], "Parameters": [["float[]", "float: an array of floats in which to store the computed quaternion"], ["float[]", "float: the rotation vector to convert"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Helper function to convert a rotation vector to a normalized quaternion. Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a normalized quaternion in the array Q. The quaternion is stored as [w, x, y, z]", "history": "added in API level 9", "FullName": "public static void getQuaternionFromVector (float[] Q, float[] rv)"}, "unregisterDynamicSensorCallback(android.hardware.SensorManager.DynamicSensorCallback)": {"Returns": [], "Parameters": [["@B_android#hardware#SensorManager#DynamicSensorCallback_E@", "SensorManager.DynamicSensorCallback: An object that implements the @B_android#hardware#SensorManager#DynamicSensorCallback_E@ interface for receiving callbacks."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Remove a @B_android#hardware#SensorManager#DynamicSensorCallback_E@ to stop sending dynamic sensor connection events to that callback.", "history": "Added in API level 24", "FullName": "public void unregisterDynamicSensorCallback (SensorManager.DynamicSensorCallback callback)"}}, "Inheritance": [], "ClassName": "android.hardware.SensorManager", "ClassDesc": "SensorManager lets you access the device's @B_android#hardware#Sensor_E@. Always make sure to disable sensors you don't need, especially when your activity is paused. Failing to do so can drain the battery in just a few hours. Note that the system will Note: Don't use this mechanism with a Trigger Sensor, have a look at @B_android#hardware#TriggerEventListener_E@. @B_android#hardware#Sensor#TYPE_SIGNIFICANT_MOTION_E@ is an example of a trigger sensor."}