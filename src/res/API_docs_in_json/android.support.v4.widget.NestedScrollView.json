{"Functions": {"executeKeyEvent(android.view.KeyEvent)": {"Returns": [["boolean", "Return true if the event was handled, else false."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to execute."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "You can call this function yourself to have the scroll view perform scrolling from a key event, just as if the event had been dispatched to it by the view hierarchy.", "history": "added in version 22.1.0", "FullName": "boolean executeKeyEvent (KeyEvent event)"}, "requestDisallowInterceptTouchEvent(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True if the child does not want the parent to intercept touch events."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called when a child does not want this parent and its ancestors to intercept touch events with @B_android#view#ViewGroup#onInterceptTouchEvent_E@. This parent should pass this call onto its parents. This parent must obey this request for the duration of the touch (that is, only clear the flag after this parent has received an up or a cancel.", "history": "", "FullName": "void requestDisallowInterceptTouchEvent (boolean disallowIntercept)"}, "getNestedScrollAxes()": {"Returns": [["int", "Flags indicating the current axes of nested scrolling"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return the current axes of nested scrolling for this ViewGroup. A ViewGroup returning something other than @B_android#view#View#SCROLL_AXIS_NONE_E@ is currently acting as a nested scrolling parent for one or more descendant views in the hierarchy.", "history": "", "FullName": "int getNestedScrollAxes ()"}, "stopNestedScroll(int)": {"Returns": [], "Parameters": [["int", "int: the type of input which cause this scroll event"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Stop a nested scroll in progress for the given input type. Calling this method when a nested scroll is not currently in progress is harmless.", "history": "added in version 26.0.0-beta2", "FullName": "void stopNestedScroll (int type)"}, "setNestedScrollingEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: true to enable nested scrolling, false to disable"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Enable or disable nested scrolling for this view. If this property is set to true the view will be permitted to initiate nested scrolling operations with a compatible parent view in the current hierarchy. If this view does not implement nested scrolling this will have no effect. Disabling nested scrolling while a nested scroll is in progress has the effect of @B_android#view#View#stopNestedScroll_E@ the nested scroll.", "history": "", "FullName": "void setNestedScrollingEnabled (boolean enabled)"}, "hasNestedScrollingParent(int)": {"Returns": [["boolean", "whether this view has a nested scrolling parent"]], "Parameters": [["int", "int: the type of input which cause this scroll event"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has a nested scrolling parent for the given input type. The presence of a nested scrolling parent indicates that this view has initiated a nested scroll and it was accepted by an ancestor view further up the view hierarchy.", "history": "added in version 26.0.0-beta2", "FullName": "boolean hasNestedScrollingParent (int type)"}, "computeScroll()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by a parent to request that a child update its values for mScrollX and mScrollY if necessary. This will typically be done if the child is animating a scroll using a @B_android#widget#Scroller_E@ object.", "history": "", "FullName": "void computeScroll ()"}, "getMaxScrollAmount()": {"Returns": [["int", "The maximum amount this scroll view will scroll in response to an arrow event."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.1.0", "FullName": "int getMaxScrollAmount ()"}, "smoothScrollBy(int, int)": {"Returns": [], "Parameters": [["int", "int: the number of pixels to scroll by on the X axis"], ["int", "int: the number of pixels to scroll by on the Y axis"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#view#View#scrollBy_E@, but scroll smoothly instead of immediately.", "history": "added in version 22.1.0", "FullName": "void smoothScrollBy (int dx, int dy)"}, "setSmoothScrollingEnabled(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: whether arrow scrolling will animate its transition"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set whether arrow scrolling will animate its transition.", "history": "added in version 22.1.0", "FullName": "void setSmoothScrollingEnabled (boolean smoothScrollingEnabled)"}, "dispatchNestedFling(float, float, boolean)": {"Returns": [["boolean", "true if the nested scrolling parent consumed or otherwise reacted to the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"], ["boolean", "boolean: true if the child consumed the fling, false otherwise"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent. This method should be used to indicate that a nested scrolling child has detected suitable conditions for a fling. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling child view would normally fling but it is at the edge of its own content, it can use this method to delegate the fling to its nested scrolling parent instead. The parent may optionally consume the fling or observe a child fling.", "history": "", "FullName": "boolean dispatchNestedFling (float velocityX, float velocityY, boolean consumed)"}, "measureChild(android.view.View, int, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: The child to measure"], ["int", "int: The width requirements for this view"], ["int", "int: The height requirements for this view"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Ask one of the children of this view to measure itself, taking into account both the MeasureSpec requirements for this view and its padding. The heavy lifting is done in getChildMeasureSpec.", "history": "", "FullName": "void measureChild (View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec)"}, "dispatchNestedPreScroll(int, int, int[], int[])": {"Returns": [["boolean", "true if the parent consumed some or all of the scroll delta"]], "Parameters": [["int", "int: Horizontal scroll distance in pixels"], ["int", "int: Vertical scroll distance in pixels"], ["int[]", "int: Output. If not null, consumed[0] will contain the consumed component of dx and consumed[1] the consumed dy."], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress before this view consumes any portion of it. Nested pre-scroll events are to nested scroll events what touch intercept is to touch. dispatchNestedPreScroll offers an opportunity for the parent view in a nested scrolling operation to consume some or all of the scroll operation before the child view consumes it.", "history": "", "FullName": "boolean dispatchNestedPreScroll (int dx, int dy, int[] consumed, int[] offsetInWindow)"}, "onNestedPreFling(android.view.View, float, float)": {"Returns": [["boolean", "true if this parent consumed the fling ahead of the target view"]], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"], ["float", "float: Horizontal velocity in pixels per second"], ["float", "float: Vertical velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested fling before the target view consumes it. This method siginfies that a nested scrolling child has detected a fling with the given velocity along each axis. Generally this means that a touch scroll has ended with a @B_android#view#VelocityTracker_E@ in the direction of scrolling that meets or exceeds the @B_android#view#ViewConfiguration#getScaledMinimumFlingVelocity_E@ along a scrollable axis. If a nested scrolling parent is consuming motion as part of a @B_android#view#ViewParent#onNestedPreScroll_E@, it may be appropriate for it to also consume the pre-fling to complete that same motion. By returning true from this method, the parent indicates that the child should not fling its own internal content as well.", "history": "", "FullName": "boolean onNestedPreFling (View target, float velocityX, float velocityY)"}, "onOverScrolled(int, int, boolean, boolean)": {"Returns": [], "Parameters": [["int", "int: New X scroll value in pixels"], ["int", "int: New Y scroll value in pixels"], ["boolean", "boolean: True if scrollX was clamped to an over-scroll boundary"], ["boolean", "boolean: True if scrollY was clamped to an over-scroll boundary"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called by @B_android#view#View#overScrollBy_E@ to respond to the results of an over-scroll operation.", "history": "", "FullName": "void onOverScrolled (int scrollX, int scrollY, boolean clampedX, boolean clampedY)"}, "computeVerticalScrollRange()": {"Returns": [["", "the total vertical range represented by the vertical scrollbar The default range is the drawing height of this view."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "The scroll range of a scroll view is the overall height of all of its children.", "history": "", "FullName": "protected int computeVerticalScrollRange ()"}, "addView(android.view.View, int)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"], ["int", "int: the position at which to add the child"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view. If no layout parameters are already set on the child, the default parameters for this ViewGroup are set on the child. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "", "FullName": "void addView (View child, int index)"}, "getTopFadingEdgeStrength()": {"Returns": [["float", "the intensity of the top fade as a float between 0.0f and 1.0f"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the strength, or intensity, of the top faded edge. The strength is a value between 0.0 (no fade) and 1.0 (full fade). The default implementation returns 0.0 or 1.0 but no value in between. Subclasses should override this method to provide a smoother fade transition when scrolling occurs.", "history": "", "FullName": "float getTopFadingEdgeStrength ()"}, "onGenericMotionEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The generic motion event being processed."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle generic motion events. Generic motion events describe joystick movements, mouse hovers, track pad touches, scroll wheel movements and other input events. The @B_android#view#MotionEvent#getSource_E@ of the motion event specifies the class of input that was received. Implementations of this method must examine the bits in the source before processing the event. The following code example shows how this is done. Generic motion events with source class @B_android#view#InputDevice#SOURCE_CLASS_POINTER_E@ are delivered to the view under the pointer. All other generic motion events are delivered to the focused view.", "history": "", "FullName": "boolean onGenericMotionEvent (MotionEvent event)"}, "dispatchNestedPreFling(float, float)": {"Returns": [["boolean", "true if a nested scrolling parent consumed the fling"]], "Parameters": [["float", "float: Horizontal fling velocity in pixels per second"], ["float", "float: Vertical fling velocity in pixels per second"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a fling to a nested scrolling parent before it is processed by this view. Nested pre-fling events are to nested fling events what touch intercept is to touch and what nested pre-scroll is to nested scroll. dispatchNestedPreFling offsets an opportunity for the parent view in a nested fling to fully consume the fling before the child view consumes it. If this method returns true, a nested parent view consumed the fling and this view should not scroll as a result. For a better user experience, only one view in a nested scrolling chain should consume the fling at a time. If a parent view consumed the fling this method will return false. Custom view implementations should account for this in two ways: If a custom view is paged and needs to settle to a fixed page-point, do not call dispatchNestedPreFling; consume the fling and settle to a valid position regardless. If a nested parent does consume the fling, this view should not scroll at all, even to settle back to a valid idle position. Views should also not offer fling velocities to nested parent views along an axis where scrolling is not currently supported; a @B_android#widget#ScrollView_E@ should not offer a horizontal fling velocity to its parents since scrolling along that axis is not permitted and carrying velocity along that motion does not make sense.", "history": "", "FullName": "boolean dispatchNestedPreFling (float velocityX, float velocityY)"}, "onSaveInstanceState()": {"Returns": [["@B_android#os#Parcelable_E@", "Returns a Parcelable object containing the view's current dynamic state, or null if there is nothing interesting to save."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to generate a representation of its internal state that can later be used to create a new instance with that same state. This state should only contain information that is not persistent or can not be reconstructed later. For example, you will never store your current position on screen because that will be computed again when a new instance of the view is placed in its view hierarchy. Some examples of things you may store here: the current cursor position in a text view (but usually not the text itself since that is stored in a content provider or other persistent storage), the currently selected item in a list view.", "history": "", "FullName": "Parcelable onSaveInstanceState ()"}, "smoothScrollTo(int, int)": {"Returns": [], "Parameters": [["int", "int: the position where to scroll on the X axis"], ["int", "int: the position where to scroll on the Y axis"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Like @B_android#support#v4#widget#NestedScrollView#scrollTo_E@, but scroll smoothly instead of immediately.", "history": "added in version 22.1.0", "FullName": "void smoothScrollTo (int x, int y)"}, "isNestedScrollingEnabled()": {"Returns": [["boolean", "true if nested scrolling is enabled"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if nested scrolling is enabled for this view. If nested scrolling is enabled and this View class implementation supports it, this view will act as a nested scrolling child view when applicable, forwarding data about the scroll operation in progress to a compatible and cooperating nested scrolling parent.", "history": "", "FullName": "boolean isNestedScrollingEnabled ()"}, "onTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to handle touch screen motion events. If this method is used to detect click actions, it is recommended that the actions be performed by implementing and calling @B_android#view#View#performClick_E@. This will ensure consistent system behavior, including: obeying click sound preferences dispatching OnClickListener calls handling @B_android#view#accessibility#AccessibilityNodeInfo#ACTION_CLICK_E@ when accessibility features are enabled", "history": "", "FullName": "boolean onTouchEvent (MotionEvent ev)"}, "draw(android.graphics.Canvas)": {"Returns": [], "Parameters": [["@B_android#graphics#Canvas_E@", "Canvas: The Canvas to which the View is rendered."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Manually render this view (and all of its children) to the given Canvas. The view must have already done a full layout before this function is called. When implementing a view, implement @B_android#view#View#onDraw_E@ instead of overriding this method. If you do need to override this method, call the superclass version.", "history": "", "FullName": "void draw (Canvas canvas)"}, "fullScroll(int)": {"Returns": [["boolean", "true if the key event is consumed by this method, false otherwise"]], "Parameters": [["int", "int: the scroll direction: @B_android#view#View#FOCUS_UP_E@ to go the top of the view or @B_android#view#View#FOCUS_DOWN_E@ to go the bottom"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handles scrolling in response to a \"home/end\" shortcut press. This method will scroll the view to the top or bottom and give the focus to the topmost/bottommost component in the new visible area. If no component is a good candidate for focus, this scrollview reclaims the focus.", "history": "added in version 22.1.0", "FullName": "boolean fullScroll (int direction)"}, "requestLayout()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Call this when something has changed which has invalidated the layout of this view. This will schedule a layout pass of the view tree. This should not be called while the view hierarchy is currently in a layout pass (@B_android#view#View#isInLayout_E@. If layout is happening, the request may be honored at the end of the current layout pass (and then layout will run again) or after the current frame is drawn and the next layout occurs. Subclasses which override this method should call the superclass method to handle possible request-during-layout errors correctly.", "history": "", "FullName": "void requestLayout ()"}, "onSizeChanged(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: Current width of this view."], ["int", "int: Current height of this view."], ["int", "int: Old width of this view."], ["int", "int: Old height of this view."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called during layout when the size of this view has changed. If you were just added to the view hierarchy, you're called with the old values of 0.", "history": "", "FullName": "void onSizeChanged (int w, int h, int oldw, int oldh)"}, "dispatchKeyEvent(android.view.KeyEvent)": {"Returns": [["boolean", "True if the event was handled, false otherwise."]], "Parameters": [["@B_android#view#KeyEvent_E@", "KeyEvent: The key event to be dispatched."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch a key event to the next view on the focus path. This path runs from the top of the view tree down to the currently focused view. If this view has focus, it will dispatch to itself. Otherwise it will dispatch the next node down the focus path. This method also fires any key listeners.", "history": "", "FullName": "boolean dispatchKeyEvent (KeyEvent event)"}, "onStopNestedScroll(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: View that initiated the nested scroll"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "React to a nested scroll operation ending. Perform cleanup after a nested scrolling operation. This method will be called when a nested scroll stops, for example when a nested touch scroll ends with a @B_android#view#MotionEvent#ACTION_UP_E@ or @B_android#view#MotionEvent#ACTION_CANCEL_E@ event. Implementations of this method should always call their superclass's implementation of this method if one is present.", "history": "", "FullName": "void onStopNestedScroll (View target)"}, "computeVerticalScrollOffset()": {"Returns": [["", "the vertical offset of the scrollbar's thumb"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Compute the vertical offset of the vertical scrollbar's thumb within the horizontal range. This value is used to compute the position of the thumb within the scrollbar's track. The range is expressed in arbitrary units that must be the same as the units used by @B_android#view#View#computeVerticalScrollRange_E@ and @B_android#view#View#computeVerticalScrollExtent_E@. The default offset is the scroll offset of this view.", "history": "", "FullName": "protected int computeVerticalScrollOffset ()"}, "onLayout(boolean, int, int, int, int)": {"Returns": [], "Parameters": [["boolean", "boolean: This is a new size or position for this view"], ["int", "int: Left position, relative to parent"], ["int", "int: Top position, relative to parent"], ["int", "int: Right position, relative to parent"], ["int", "int: Bottom position, relative to parent"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Called from layout when this view should assign a size and position to each of its children. Derived classes with children should override this method and call layout on each of their children.", "history": "", "FullName": "void onLayout (boolean changed, int l, int t, int r, int b)"}, "onMeasure(int, int)": {"Returns": [], "Parameters": [["int", "int: horizontal space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."], ["int", "int: vertical space requirements as imposed by the parent. The requirements are encoded with @B_android#view#View#MeasureSpec_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Measure the view and its content to determine the measured width and the measured height. This method is invoked by @B_android#view#View#measure_E@ and should be overridden by subclasses to provide accurate and efficient measurement of their contents. must call @B_android#view#View#setMeasuredDimension_E@ to store the measured width and height of this view. Failure to do so will trigger an IllegalStateException, thrown by @B_android#view#View#measure_E@. Calling the superclass' @B_android#view#View#onMeasure_E@ is a valid use. The base class implementation of measure defaults to the background size, unless a larger size is allowed by the MeasureSpec. Subclasses should override @B_android#view#View#onMeasure_E@ to provide better measurements of their content. If this method is overridden, it is the subclass's responsibility to make sure the measured height and width are at least the view's minimum height and width (@B_android#view#View#getSuggestedMinimumHeight_E@ and @B_android#view#View#getSuggestedMinimumWidth_E@).", "history": "", "FullName": "void onMeasure (int widthMeasureSpec, int heightMeasureSpec)"}, "isFillViewport()": {"Returns": [["boolean", "True if the content fills the viewport, false otherwise."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether this ScrollView's content is stretched to fill the viewport.", "history": "added in version 22.1.0", "FullName": "boolean isFillViewport ()"}, "arrowScroll(int)": {"Returns": [["boolean", "True if we consumed the event, false otherwise"]], "Parameters": [["int", "int: The direction corresponding to the arrow key that was pressed"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handle scrolling in response to an up or down arrow click.", "history": "added in version 22.1.0", "FullName": "boolean arrowScroll (int direction)"}, "pageScroll(int)": {"Returns": [["boolean", "true if the key event is consumed by this method, false otherwise"]], "Parameters": [["int", "int: the scroll direction: @B_android#view#View#FOCUS_UP_E@ to go one page up or @B_android#view#View#FOCUS_DOWN_E@ to go one page down"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Handles scrolling in response to a \"page up/down\" shortcut press. This method will scroll the view by one page up or down and give the focus to the topmost/bottommost component in the new visible area. If no component is a good candidate for focus, this scrollview reclaims the focus.", "history": "added in version 22.1.0", "FullName": "boolean pageScroll (int direction)"}, "shouldDelayChildPressedState()": {"Returns": [["boolean", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Return true if the pressed state should be delayed for children or descendants of this ViewGroup. Generally, this should be done for containers that can scroll, such as a List. This prevents the pressed state from appearing when the user is actually trying to scroll the content. The default implementation returns true for compatibility reasons. Subclasses that do not scroll should generally override this method and return false.", "history": "", "FullName": "boolean shouldDelayChildPressedState ()"}, "onRestoreInstanceState(android.os.Parcelable)": {"Returns": [], "Parameters": [["@B_android#os#Parcelable_E@", "Parcelable: The frozen state that had previously been returned by @B_android#support#v4#widget#NestedScrollView#onSaveInstanceState_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Hook allowing a view to re-apply a representation of its internal state that had previously been generated by @B_android#view#View#onSaveInstanceState_E@. This function will never be called with a null state.", "history": "", "FullName": "void onRestoreInstanceState (Parcelable state)"}, "scrollTo(int, int)": {"Returns": [], "Parameters": [["int", "int: the x position to scroll to"], ["int", "int: the y position to scroll to"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set the scrolled position of your view. This will cause a call to @B_android#view#View#onScrollChanged_E@ and the view will be invalidated. This version also clamps the scrolling to the bounds of our child.", "history": "", "FullName": "void scrollTo (int x, int y)"}, "isSmoothScrollingEnabled()": {"Returns": [["boolean", "Whether arrow scrolling will animate its transition."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.1.0", "FullName": "boolean isSmoothScrollingEnabled ()"}, "onScrollChanged(int, int, int, int)": {"Returns": [], "Parameters": [["int", "int: Current horizontal scroll origin."], ["int", "int: Current vertical scroll origin."], ["int", "int: Previous horizontal scroll origin."], ["int", "int: Previous vertical scroll origin."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called in response to an internal scroll in this view (i.e., the view scrolled its own contents). This is typically as a result of @B_android#view#View#scrollBy_E@ or @B_android#view#View#scrollTo_E@ having been called.", "history": "", "FullName": "void onScrollChanged (int l, int t, int oldl, int oldt)"}, "NestedScrollView(android.content.Context)": {"Returns": [], "Parameters": [["@B_android#content#Context_E@", "Context no parameter comment"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "", "history": "added in version 22.1.0", "FullName": "NestedScrollView (Context context)"}, "stopNestedScroll()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Stop a nested scroll in progress. Calling this method when a nested scroll is not currently in progress is harmless.", "history": "", "FullName": "void stopNestedScroll ()"}, "onAttachedToWindow()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "This is called when the view is attached to a window. At this point it has a Surface and will start drawing. Note that this function is guaranteed to be called before @B_android#view#View#onDraw_E@, however it may be called any time before the first onDraw -- including before or after @B_android#view#View#onMeasure_E@.", "history": "added in version 22.1.0", "FullName": "void onAttachedToWindow ()"}, "addView(android.view.View)": {"Returns": [], "Parameters": [["@B_android#view#View_E@", "View: the child view to add"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Adds a child view. If no layout parameters are already set on the child, the default parameters for this ViewGroup are set on the child. @B_android#view#View#draw_E@, @B_android#view#View#onDraw_E@, @B_android#view#ViewGroup#dispatchDraw_E@ or any related method.", "history": "", "FullName": "void addView (View child)"}, "getBottomFadingEdgeStrength()": {"Returns": [["float", "the intensity of the bottom fade as a float between 0.0f and 1.0f"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the strength, or intensity, of the bottom faded edge. The strength is a value between 0.0 (no fade) and 1.0 (full fade). The default implementation returns 0.0 or 1.0 but no value in between. Subclasses should override this method to provide a smoother fade transition when scrolling occurs.", "history": "", "FullName": "float getBottomFadingEdgeStrength ()"}, "onInterceptTouchEvent(android.view.MotionEvent)": {"Returns": [["boolean", "Return true to steal motion events from the children and have them dispatched to this ViewGroup through onTouchEvent(). The current target will receive an ACTION_CANCEL event, and no further messages will be delivered here."]], "Parameters": [["@B_android#view#MotionEvent_E@", "MotionEvent: The motion event being dispatched down the hierarchy."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Implement this method to intercept all touch screen motion events. This allows you to watch events as they are dispatched to your children, and take ownership of the current gesture at any point. Using this function takes some care, as it has a fairly complicated interaction with @B_android#view#View#onTouchEvent_E@, and using it requires implementing that method as well as this one in the correct way. Events will be received in the following order:", "history": "", "FullName": "boolean onInterceptTouchEvent (MotionEvent ev)"}, "startNestedScroll(int, int)": {"Returns": [["boolean", "true if a cooperative parent was found and nested scrolling has been enabled for the current gesture."]], "Parameters": [["int", "int: Flags consisting of a combination of @B_android#support#v4#view#ViewCompat#SCROLL_AXIS_HORIZONTAL_E@ and/or @B_android#support#v4#view#ViewCompat#SCROLL_AXIS_VERTICAL_E@."], ["int", "int: the type of input which cause this scroll event"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begin a nestable scroll operation along the given axes, for the given input type. A view starting a nested scroll promises to abide by the following contract: The view will call startNestedScroll upon initiating a scroll operation. In the case of a touch scroll type this corresponds to the initial @B_android#view#MotionEvent#ACTION_DOWN_E@. In the case of touch scrolling the nested scroll will be terminated automatically in the same manner as @B_android#view#ViewParent#requestDisallowInterceptTouchEvent_E@. In the event of programmatic scrolling the caller must explicitly call @B_android#support#v4#view#NestedScrollingChild2#stopNestedScroll_E@ to indicate the end of the nested scroll. If startNestedScroll returns true, a cooperative parent was found. If it returns false the caller may ignore the rest of this contract until the next scroll. Calling startNestedScroll while a nested scroll is already in progress will return true. At each incremental step of the scroll the caller should invoke @B_android#support#v4#view#NestedScrollingChild2#dispatchNestedPreScroll_E@ once it has calculated the requested scrolling delta. If it returns true the nested scrolling parent at least partially consumed the scroll and the caller should adjust the amount it scrolls by. After applying the remainder of the scroll delta the caller should invoke @B_android#support#v4#view#NestedScrollingChild2#dispatchNestedScroll_E@, passing both the delta consumed and the delta unconsumed. A nested scrolling parent may treat these values differently. See @B_android#support#v4#view#NestedScrollingParent2#onNestedScroll_E@.", "history": "added in version 26.0.0-beta2", "FullName": "boolean startNestedScroll (int axes, int type)"}, "hasNestedScrollingParent()": {"Returns": [["boolean", "whether this view has a nested scrolling parent"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns true if this view has a nested scrolling parent. The presence of a nested scrolling parent indicates that this view has initiated a nested scroll and it was accepted by an ancestor view further up the view hierarchy.", "history": "", "FullName": "boolean hasNestedScrollingParent ()"}, "dispatchNestedScroll(int, int, int, int, int[])": {"Returns": [["boolean", "true if the event was dispatched, false if it could not be dispatched."]], "Parameters": [["int", "int: Horizontal distance in pixels consumed by this view during this scroll step"], ["int", "int: Vertical distance in pixels consumed by this view during this scroll step"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int", "int: Horizontal scroll distance in pixels not consumed by this view"], ["int[]", "int: Optional. If not null, on return this will contain the offset in local view coordinates of this view from before this operation to after it completes. View implementations may use this to adjust expected input coordinate tracking."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Dispatch one step of a nested scroll in progress. Implementations of views that support nested scrolling should call this to report info about a scroll in progress to the current nested scrolling parent. If a nested scroll is not currently in progress or nested scrolling is not @B_android#view#View#isNestedScrollingEnabled_E@ for this view this method does nothing. Compatible View implementations should also call @B_android#view#View#dispatchNestedPreScroll_E@ before consuming a component of the scroll event themselves.", "history": "", "FullName": "boolean dispatchNestedScroll (int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int[] offsetInWindow)"}, "setFillViewport(boolean)": {"Returns": [], "Parameters": [["boolean", "boolean: True to stretch the content's height to the viewport's boundaries, false otherwise."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Set whether this ScrollView should stretch its content height to fill the viewport or not.", "history": "added in version 22.1.0", "FullName": "void setFillViewport (boolean fillViewport)"}, "fling(int)": {"Returns": [], "Parameters": [["int", "int: The initial velocity in the Y direction. Positive numbers mean that the finger/cursor is moving down the screen, which means we want to scroll towards the top."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Fling the scroll view", "history": "added in version 22.1.0", "FullName": "void fling (int velocityY)"}, "startNestedScroll(int)": {"Returns": [["boolean", "true if a cooperative parent was found and nested scrolling has been enabled for the current gesture."]], "Parameters": [["int", "int: Flags consisting of a combination of @B_android#view#View#SCROLL_AXIS_HORIZONTAL_E@ and/or @B_android#view#View#SCROLL_AXIS_VERTICAL_E@."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Begin a nestable scroll operation along the given axes. A view starting a nested scroll promises to abide by the following contract: The view will call startNestedScroll upon initiating a scroll operation. In the case of a touch scroll this corresponds to the initial @B_android#view#MotionEvent#ACTION_DOWN_E@. In the case of touch scrolling the nested scroll will be terminated automatically in the same manner as @B_android#view#ViewParent#requestDisallowInterceptTouchEvent_E@. In the event of programmatic scrolling the caller must explicitly call @B_android#view#View#stopNestedScroll_E@ to indicate the end of the nested scroll. If startNestedScroll returns true, a cooperative parent was found. If it returns false the caller may ignore the rest of this contract until the next scroll. Calling startNestedScroll while a nested scroll is already in progress will return true. At each incremental step of the scroll the caller should invoke @B_android#view#View#dispatchNestedPreScroll_E@ once it has calculated the requested scrolling delta. If it returns true the nested scrolling parent at least partially consumed the scroll and the caller should adjust the amount it scrolls by. After applying the remainder of the scroll delta the caller should invoke @B_android#view#View#dispatchNestedScroll_E@, passing both the delta consumed and the delta unconsumed. A nested scrolling parent may treat these values differently. See @B_android#view#ViewParent#onNestedScroll_E@.", "history": "", "FullName": "boolean startNestedScroll (int axes)"}}, "Inheritance": ["java.lang.Object", "https:##developer#android#com@B_android#view#View_E@", "https:##developer#android#com@B_android#view#ViewGroup_E@", "https:##developer#android#com@B_android#widget#FrameLayout_E@"], "ClassName": "android.support.v4.widget.NestedScrollView", "ClassDesc": "NestedScrollView is just like https:##developer#android#com@B_android#widget#ScrollView_E@, but it supports acting as both a nested scrolling parent and child on both new and old versions of Android. Nested scrolling is enabled by default."}