{"Functions": {"unmarkReusable()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Marks this connection as not being in a reusable state. This can be used immediately before releasing this connection to prevent it's reuse. Reasons for preventing reuse include error conditions and the evaluation of a @B_org#apache#http#ConnectionReuseStrategy_E@. @B_org#apache#http#conn#ManagedClientConnection#markReusable_E@.", "history": "Added in API level 1", "FullName": "public abstract void unmarkReusable ()"}, "getSSLSession()": {"Returns": [["", "the underlying SSL session if available, null otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Obtains the SSL session of the underlying connection, if any. If this connection is open, and the underlying socket is an @B_javax#net#ssl#SSLSocket_E@, the SSL session of that socket is obtained. This is a potentially blocking operation. @B_org#apache#http#conn#ManagedClientConnection#isSecure_E@. Plain sockets may be considered secure, for example if they are connected to a known host in the same network segment. On the other hand, SSL sockets may be considered insecure, for example depending on the chosen cipher suite.", "history": "Added in API level 1", "FullName": "public abstract SSLSession getSSLSession ()"}, "getState()": {"Returns": [["", "The state object"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the state object associated with this connection.", "history": "Added in API level 1", "FullName": "public abstract Object getState ()"}, "isMarkedReusable()": {"Returns": [["", "true if this connection is marked as being in a reusable communication state, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether this connection is in a reusable communication state. See @B_org#apache#http#conn#ManagedClientConnection#markReusable_E@ and @B_org#apache#http#conn#ManagedClientConnection#unmarkReusable_E@ for details.", "history": "Added in API level 1", "FullName": "public abstract boolean isMarkedReusable ()"}, "setState(java.lang.Object)": {"Returns": [], "Parameters": [["@B_java#lang#Object_E@", "The state object"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Assigns a state object to this connection. Connection managers may make use of the connection state when allocating persistent connections.", "history": "Added in API level 1", "FullName": "public abstract void setState (Object state)"}, "tunnelTarget(boolean, org.apache.http.params.HttpParams)": {"Returns": [], "Parameters": [["boolean", "true if the tunnel should be considered secure, false otherwise"], ["@B_org#apache#http#params#HttpParams_E@", "the parameters for tunnelling this connection"]], "Throws": [["@B_java#io#IOException_E@", "in case of a problem"]], "SeeAlso": [], "Permissions": [], "Description": "Indicates that a tunnel to the target has been established. The route is the one previously passed to @B_org#apache#http#conn#ManagedClientConnection#open_E@. Subsequently, @B_org#apache#http#conn#ManagedClientConnection#layerProtocol_E@ can be called to layer the TLS/SSL protocol on top of the tunnelled connection.", "history": "Added in API level 1", "FullName": "public abstract void tunnelTarget (boolean secure, HttpParams params)"}, "getRoute()": {"Returns": [["", "the route established so far, or null if not connected"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Obtains the current route of this connection.", "history": "Added in API level 1", "FullName": "public abstract HttpRoute getRoute ()"}, "setIdleDuration(long, java.util.concurrent.TimeUnit)": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the duration that this connection can remain idle before it is reused. The connection should not be used again if this time elapses. The idle duration must be reset after each request sent over this connection. The elapsed time starts counting when the connection is released, which is typically after the headers (and any response body, if present) is fully consumed.", "history": "Added in API level 1", "FullName": "public abstract void setIdleDuration (long duration, TimeUnit unit)"}, "open(org.apache.http.conn.routing.HttpRoute, org.apache.http.protocol.HttpContext, org.apache.http.params.HttpParams)": {"Returns": [], "Parameters": [["@B_org#apache#http#conn#routing#HttpRoute_E@", "the route along which to open. It will be opened to the first proxy if present, or directly to the target."], ["@B_org#apache#http#protocol#HttpContext_E@", "the context for opening this connection"], ["@B_org#apache#http#params#HttpParams_E@", "the parameters for opening this connection"]], "Throws": [["@B_java#io#IOException_E@", "in case of a problem"]], "SeeAlso": [], "Permissions": [], "Description": "Opens this connection according to the given route.", "history": "Added in API level 1", "FullName": "public abstract void open (HttpRoute route, HttpContext context, HttpParams params)"}, "markReusable()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Marks this connection as being in a reusable communication state. The checkpoints for reuseable communication states (in the absence of pipelining) are before sending a request and after receiving the response in it's entirety. The connection will automatically clear the checkpoint when used for communication. A call to this method indicates that the next checkpoint has been reached. A reusable communication state is necessary but not sufficient for the connection to be reused. A @B_org#apache#http#conn#ManagedClientConnection#getRoute_E@ mismatch, the connection being closed, or other circumstances might prevent reuse.", "history": "Added in API level 1", "FullName": "public abstract void markReusable ()"}, "tunnelProxy(org.apache.http.HttpHost, boolean, org.apache.http.params.HttpParams)": {"Returns": [], "Parameters": [["@B_org#apache#http#HttpHost_E@", "the proxy to which the tunnel was established. This is not the proxy through which the tunnel was established, but the new end point of the tunnel. The tunnel does not yet reach to the target, use @B_org#apache#http#conn#ManagedClientConnection#tunnelTarget_E@ to indicate an end-to-end tunnel."], ["boolean", "true if the connection should be considered secure, false otherwise"], ["@B_org#apache#http#params#HttpParams_E@", "the parameters for tunnelling this connection"]], "Throws": [["@B_java#io#IOException_E@", "in case of a problem"]], "SeeAlso": [], "Permissions": [], "Description": "Indicates that a tunnel to an intermediate proxy has been established. This is used exclusively for so-called @B_org#apache#http#conn#ManagedClientConnection#tunnelTarget_E@.", "history": "Added in API level 1", "FullName": "public abstract void tunnelProxy (HttpHost next, boolean secure, HttpParams params)"}, "layerProtocol(org.apache.http.protocol.HttpContext, org.apache.http.params.HttpParams)": {"Returns": [], "Parameters": [["@B_org#apache#http#protocol#HttpContext_E@", "the context for layering on top of this connection"], ["@B_org#apache#http#params#HttpParams_E@", "the parameters for layering on top of this connection"]], "Throws": [["@B_java#io#IOException_E@", "in case of a problem"]], "SeeAlso": [], "Permissions": [], "Description": "Layers a new protocol on top of a @B_org#apache#http#conn#ManagedClientConnection#tunnelTarget_E@ connection. This is typically used to create a TLS/SSL connection through a proxy. The route is the one previously passed to @B_org#apache#http#conn#ManagedClientConnection#open_E@. It is not guaranteed that the layered connection is @B_org#apache#http#conn#ManagedClientConnection#isSecure_E@.", "history": "Added in API level 1", "FullName": "public abstract void layerProtocol (HttpContext context, HttpParams params)"}, "isSecure()": {"Returns": [["", "true if this connection is secure, false otherwise"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Indicates whether this connection is secure. The return value is well-defined only while the connection is open. It may change even while the connection is open.", "history": "Added in API level 1", "FullName": "public abstract boolean isSecure ()"}}, "Inheritance": [], "ClassName": "org.apache.http.conn.ManagedClientConnection", "ClassDesc": "Please use @B_java#net#URL#openConnection_E@ instead. Please visit A client-side connection with advanced connection logic. Instances are typically obtained from a connection manager."}