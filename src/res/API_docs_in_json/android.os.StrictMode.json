{"Functions": {"allowThreadDiskWrites()": {"Returns": [["@B_android#os#StrictMode#ThreadPolicy_E@", "the old policy, to be passed to @B_android#os#StrictMode#setThreadPolicy_E@ to restore the policy at the end of a block"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "A convenience wrapper that takes the current @B_android#os#StrictMode#ThreadPolicy_E@ from @B_android#os#StrictMode#getThreadPolicy_E@, modifies it to permit both disk reads & writes, and sets the new policy with @B_android#os#StrictMode#setThreadPolicy_E@, returning the old policy so you can restore it at the end of a block.", "history": "Added in API level 9", "FullName": "public static StrictMode.ThreadPolicy allowThreadDiskWrites ()"}, "setThreadPolicy(android.os.StrictMode.ThreadPolicy)": {"Returns": [], "Parameters": [["@B_android#os#StrictMode#ThreadPolicy_E@", "StrictMode.ThreadPolicy: the policy to put into place"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the policy for what actions on the current thread should be detected, as well as the penalty if such actions occur. Internally this sets a thread-local variable which is propagated across cross-process IPC calls, meaning you can catch violations when a system service or another process accesses the disk or network on your behalf.", "history": "Added in API level 9", "FullName": "public static void setThreadPolicy (StrictMode.ThreadPolicy policy)"}, "setVmPolicy(android.os.StrictMode.VmPolicy)": {"Returns": [], "Parameters": [["@B_android#os#StrictMode#VmPolicy_E@", "StrictMode.VmPolicy: the policy to put into place"]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Sets the policy for what actions in the VM process (on any thread) should be detected, as well as the penalty if such actions occur.", "history": "Added in API level 9", "FullName": "public static void setVmPolicy (StrictMode.VmPolicy policy)"}, "enableDefaults()": {"Returns": [], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Enable the recommended StrictMode defaults, with violations just being logged. This catches disk and network access on the main thread, as well as leaked SQLite cursors and unclosed resources. This is simply a wrapper around @B_android#os#StrictMode#setVmPolicy_E@ and @B_android#os#StrictMode#setThreadPolicy_E@.", "history": "Added in API level 9", "FullName": "public static void enableDefaults ()"}, "allowThreadDiskReads()": {"Returns": [["@B_android#os#StrictMode#ThreadPolicy_E@", "the old policy, to be passed to setThreadPolicy to restore the policy."]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "A convenience wrapper that takes the current @B_android#os#StrictMode#ThreadPolicy_E@ from @B_android#os#StrictMode#getThreadPolicy_E@, modifies it to permit disk reads, and sets the new policy with @B_android#os#StrictMode#setThreadPolicy_E@, returning the old policy so you can restore it at the end of a block.", "history": "Added in API level 9", "FullName": "public static StrictMode.ThreadPolicy allowThreadDiskReads ()"}, "getThreadPolicy()": {"Returns": [["@B_android#os#StrictMode#ThreadPolicy_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Returns the current thread's policy.", "history": "Added in API level 9", "FullName": "public static StrictMode.ThreadPolicy getThreadPolicy ()"}, "noteSlowCall(java.lang.String)": {"Returns": [], "Parameters": [["@B_java#lang#String_E@", "String: a short string for the exception stack trace that's built if when this fires."]], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "For code to note that it's slow. This is a no-op unless the current thread's @B_android#os#StrictMode#ThreadPolicy_E@ has @B_android#os#StrictMode#ThreadPolicy#Builder#detectCustomSlowCalls_E@ enabled.", "history": "Added in API level 11", "FullName": "public static void noteSlowCall (String name)"}, "getVmPolicy()": {"Returns": [["@B_android#os#StrictMode#VmPolicy_E@", "no returns description in source"]], "Parameters": [], "Throws": [], "SeeAlso": [], "Permissions": [], "Description": "Gets the current VM policy.", "history": "Added in API level 9", "FullName": "public static StrictMode.VmPolicy getVmPolicy ()"}}, "Inheritance": [], "ClassName": "android.os.StrictMode", "ClassDesc": "StrictMode is a developer tool which detects things you might be doing by accident and brings them to your attention so you can fix them. StrictMode is most commonly used to catch accidental disk or network access on the application's main thread, where UI operations are received and animations take place. Keeping disk and network operations off the main thread makes for much smoother, more responsive applications. By keeping your application's main thread responsive, you also prevent Note that even though an Android device's disk is often on flash memory, many devices run a filesystem on top of that memory with very limited concurrency. It's often the case that almost all disk accesses are fast, but may in individual cases be dramatically slower when certain I/O is happening in the background from other processes. If possible, it's best to assume that such things are not fast. Example code to enable from early in your @B_android#app#Application_E@, @B_android#app#Activity_E@, or other application component's @B_android#app#Application#onCreate_E@ method: You can decide what should happen when a violation is detected. For example, using @B_android#os#StrictMode#ThreadPolicy#Builder#penaltyLog_E@ you can watch the output of adb logcat while you use your application to see the violations as they happen. If you find violations that you feel are problematic, there are a variety of tools to help solve them: threads, @B_android#os#Handler_E@, @B_android#os#AsyncTask_E@, @B_android#app#IntentService_E@, etc. But don't feel compelled to fix everything that StrictMode finds. In particular, many cases of disk access are often necessary during the normal activity lifecycle. Use StrictMode to find things you did by accident. Network requests on the UI thread are almost always a problem, though. StrictMode is not a security mechanism and is not guaranteed to find all disk or network accesses. While it does propagate its state across process boundaries when doing @B_android#os#Binder_E@ calls, it's still ultimately a best effort mechanism. Notably, disk or network access from JNI calls won't necessarily trigger it. Future versions of Android may catch more (or fewer) operations, so you should never leave StrictMode enabled in applications distributed on Google Play."}