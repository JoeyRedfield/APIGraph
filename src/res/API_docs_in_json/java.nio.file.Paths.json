{"Functions": {"get(java.lang.String,java.lang.String...)": {"Returns": [["@B_java#nio#file#Path_E@", "the resulting Path"]], "Parameters": [["@B_java#lang#String_E@", "String: the path string or initial part of the path string"], ["@B_java#lang#String_E@", "String: additional strings to be joined to form the path string"]], "Throws": [["@B_java#nio#file#InvalidPathException_E@", "if the path string cannot be converted to a Path"]], "SeeAlso": ["@B_java#nio#file#FileSystem#getPath_E@"], "Permissions": [], "Description": "Converts a path string, or a sequence of strings that when joined form a path string, to a Path. If more does not specify any elements then the value of the first parameter is the path string to convert. If more specifies one or more elements then each non-empty string, including first, is considered to be a sequence of name elements (see @B_java#nio#file#Path_E@) and is joined to form a path string. The details as to how the Strings are joined is provider specific but typically they will be joined using the @B_java#nio#file#FileSystem#getSeparator_E@ as the separator. For example, if the name separator is \"/\" and getPath(\"/foo\",\"bar\",\"gus\") is invoked, then the path string \"/foo/bar/gus\" is converted to a Path. A Path representing an empty path is returned if first is the empty string and more does not contain any non-empty strings. The Path is obtained by invoking the @B_java#nio#file#FileSystem#getPath_E@ method of the @B_java#nio#file#FileSystems#getDefault_E@ @B_java#nio#file#FileSystem_E@. Note that while this method is very convenient, using it will imply an assumed reference to the default FileSystem and limit the utility of the calling code. Hence it should not be used in library code intended for flexible reuse. A more flexible alternative is to use an existing Path instance as an anchor, such as:", "history": "Added in API level 26", "FullName": "public static Path get (String first, String... more)"}, "get(java.lang.String, java.lang.String...)": {"Returns": [["@B_java#nio#file#Path_E@", "the resulting Path"]], "Parameters": [["@B_java#lang#String_E@", "String: the path string or initial part of the path string"], ["@B_java#lang#String_E@", "String: additional strings to be joined to form the path string"]], "Throws": [["@B_java#nio#file#InvalidPathException_E@", "if the path string cannot be converted to a Path"]], "SeeAlso": ["@B_java#nio#file#FileSystem#getPath_E@"], "Permissions": [], "Description": "Converts a path string, or a sequence of strings that when joined form a path string, to a Path. If more does not specify any elements then the value of the first parameter is the path string to convert. If more specifies one or more elements then each non-empty string, including first, is considered to be a sequence of name elements (see @B_java#nio#file#Path_E@) and is joined to form a path string. The details as to how the Strings are joined is provider specific but typically they will be joined using the @B_java#nio#file#FileSystem#getSeparator_E@ as the separator. For example, if the name separator is \"/\" and getPath(\"/foo\",\"bar\",\"gus\") is invoked, then the path string \"/foo/bar/gus\" is converted to a Path. A Path representing an empty path is returned if first is the empty string and more does not contain any non-empty strings. The Path is obtained by invoking the @B_java#nio#file#FileSystem#getPath_E@ method of the @B_java#nio#file#FileSystems#getDefault_E@ @B_java#nio#file#FileSystem_E@. Note that while this method is very convenient, using it will imply an assumed reference to the default FileSystem and limit the utility of the calling code. Hence it should not be used in library code intended for flexible reuse. A more flexible alternative is to use an existing Path instance as an anchor, such as:", "history": "added in API level 26", "FullName": "public static Path get (String first, String... more)"}, "get(java.net.URI)": {"Returns": [["@B_java#nio#file#Path_E@", "the resulting Path"]], "Parameters": [["@B_java#net#URI_E@", "URI: the URI to convert"]], "Throws": [["@B_java#lang#IllegalArgumentException_E@", "if preconditions on the uri parameter do not hold. The format of the URI is provider specific."], ["@B_java#nio#file#FileSystemNotFoundException_E@", "The file system, identified by the URI, does not exist and cannot be created automatically, or the provider identified by the URI's scheme component is not installed"], ["@B_java#lang#SecurityException_E@", "if a security manager is installed and it denies an unspecified permission to access the file system"]], "SeeAlso": [], "Permissions": [], "Description": "Converts the given URI to a @B_java#nio#file#Path_E@ object. This method iterates over the @B_java#nio#file#spi#FileSystemProvider#installedProviders_E@ providers to locate the provider that is identified by the URI @B_java#net#URI#getScheme_E@ of the given URI. URI schemes are compared without regard to case. If the provider is found then its @B_java#nio#file#spi#FileSystemProvider#getPath_E@ method is invoked to convert the URI. In the case of the default provider, identified by the URI scheme \"file\", the given URI has a non-empty path component, and undefined query and fragment components. Whether the authority component may be present is platform specific. The returned Path is associated with the @B_java#nio#file#FileSystems#getDefault_E@ file system. The default provider provides a similar round-trip guarantee to the @B_java#io#File_E@ class. For a given Path Path, the URI, and the new Path are all created in (possibly different invocations of) the same Java virtual machine. Whether other providers make any guarantees is provider specific and therefore unspecified.", "history": "Added in API level 26", "FullName": "public static Path get (URI uri)"}}, "Inheritance": [], "ClassName": "java.nio.file.Paths", "ClassDesc": "This class consists exclusively of static methods that return a @B_java#nio#file#Path_E@ by converting a path string or @B_java#net#URI_E@."}